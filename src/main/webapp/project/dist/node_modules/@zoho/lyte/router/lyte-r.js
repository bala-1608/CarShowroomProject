/*Polyfills for functions not available in other browsers. */

/*Polyfill for Node.after
//Not supported out of the box in IE and Edge. 
//from: https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/after()/after().md */
(function (arr) {
  arr.forEach(function (item) {
    if (item.hasOwnProperty('after')) {
      return;
    }
    Object.defineProperty(item, 'after', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function after() {
        var argArr = Array.prototype.slice.call(arguments),
          docFrag = document.createDocumentFragment();
        
        argArr.forEach(function (argItem) {
          var isNode = argItem instanceof Node;
          docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
        });
        
        this.parentNode.insertBefore(docFrag, this.nextSibling);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);


/*Polyfill for replaceWith. 
//Not supported out of the box for IE and Edge. */
function ReplaceWith(Ele) {
    var parent = this.parentNode,
        i = arguments.length,
        firstIsNode = +(parent && typeof Ele === 'object');
    if (!parent){
        return;
    } 
    
    while (i-- > firstIsNode){
      if (parent && typeof arguments[i] !== 'object'){
        arguments[i] = document.createTextNode(arguments[i]);
      } if (!parent && arguments[i].parentNode){
        arguments[i].parentNode.removeChild(arguments[i]);
        continue;
      }
      parent.insertBefore(this.previousSibling, arguments[i]);
    }
    if (firstIsNode){
        parent.replaceChild(this, Ele);
    } 
}
if (!Element.prototype.replaceWith){
    Element.prototype.replaceWith = ReplaceWith;
}
if (!CharacterData.prototype.replaceWith){
    CharacterData.prototype.replaceWith = ReplaceWith;
}
if (!DocumentType.prototype.replaceWith) {
    DocumentType.prototype.replaceWith = ReplaceWith;
}

/*Polyfill for startsWith
//Not supported out of the box for  IE */
if(!String.prototype.startsWith) {
      String.prototype.startsWith = function(searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
    };
}

/*Polyfill for endsWith
//Not supported out of the box for  IE */
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(search, this_len) {
    if (this_len === undefined || this_len > this.length) {
      this_len = this.length;
    }
    return this.substring(this_len - search.length, this_len) === search;
  };
}


let _Lyte = {
  version : "3.7.0-BETA1",
    $ : {
        consoleTime : []
    },
    registeredMixins : {},
    registeredServices : {},
    requiredServices : {},
    toBeInjectedServices : {},
    _registeredComponents : {},
    _keywords : {
      "component" : ["init", "didConnect", "didDestroy", "constructor", "onError", "actions", "methods", "data"],
      "adapter" : ["namespace", "actionNamespace", "host", "withCredentials", "buildURL", "methodForRequest", "headersForRequest", "reloadRecord", "reloadRecord", "reloadAll", "processRequest", "parseResponse", "parseRequest", "super"],
      "serializer" : ["normalize", "normalizeResponse", "serialize", "serializeKey", "deserializeKey", "extractMeta", "payloadKey", "serializeRecord", "normalizeRecord", "super"],
      "route" : ["getDependencies", "getResources", "beforeModel", "model", "afterModel", "redirect", "renderTemplate", "afterRender", "beforeExit", "didDestroy", "queryParams", "title", "routeName", "component", "parent", "currentModel", "forceFetch", "setTitle", "setQueryParams", "getQueryParams", "setDynamicParam", "getDynamicParam", "removeFromCache", "refresh", "transitionTo", "replaceWith","actions"],
      "is" : function(key, scope){
        var arr = ["component", "adapter", "serializer", "route"];
        if(scope){
          arr = [scope];
        }
        var len = arr.length;
        for(var i=0;i<len;i++){
          var keyArr = this[arr[i]];
          if(keyArr){
            var res = keyArr.indexOf(key);
            if(res != -1){
              return true;
            }
          }
        }
        return false;
      }
    },
    Mixin : {},
    Service : {},
    debug : false,
    performance : false,
    toBeRegistered : [],
    browser : {},
    registeredCustomComponent : {},
    Globals : {}
  };
  if(window.isLyteWidgetParent) {
    _widgetLyte = _Lyte;
    _Lyte.isWidgetBuild = true;
    window.__lyteConfig.isWidgetBuild = true; 
  } else {
    Lyte = _Lyte;
  }
class IdleTaskScheduler{
  constructor(obj){
    this.idleCallback = this.idleCallback.bind(this);
    this.timeout = 50;
    this.chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    this.tasks = new Map();
    this.idleCallbackRequested = false;
    this.delayInit = false;
    this.useRequestIdleCallback = true;
    this.priorityQueue = [];
    this.processTime = {};
    this.perf = false;
    if(obj!= undefined){      
      if(obj.useRequestIdleCallback !== undefined){
        this.useRequestIdleCallback = obj.useRequestIdleCallback;
      }
      if(obj.delayInit !== undefined){
          this.delayInit = obj.delayInit;
      }
      if(obj.timeout !== undefined){
        this.timeout = obj.timeout;			
      }
      if(obj.priorityQueue !== undefined){
        this.priorityQueue = obj.priorityQueue;
      }
      if(obj.perf !== undefined){
        this.perf = obj.perf;
      }
    }
  }
  isGenerator(obj) {
    return (
        obj !== null &&
        typeof obj === "object" &&
        typeof obj.next === "function" &&
        typeof obj[Symbol.iterator] === "function"
    );
  }
  init(obj){
    if(this.delayInit == true){
      if(obj !== undefined){ 
        if(obj.useRequestIdleCallback !== undefined){
          this.useRequestIdleCallback = obj.useRequestIdleCallback;
        }
        if(obj.timeout !== undefined){
          this.timeout = obj.timeout;
        }
        if(obj.perf !== undefined){
          this.perf = obj.perf;
        }
      }
      this.delayInit = false;
      this.tasksScheduler();
    } 
  }
  getUniqueKey(len){
    var result;
    while(result == undefined || this.tasks.has(result)){
        result = undefined;
        result = this.generateUniqueKey(len);
    }
    return result;
  }
  generateUniqueKey(length){
    let result = '', clen = this.chars.length;
    for (let i = 0; i < length; i++) {
        result += this.chars.charAt(Math.floor(Math.random() * clen));
    }
    return result;
  }
  enqueueTask(handler, data, id){
    if(!id){
        id = this.getUniqueKey(6);
    }
    if(this.tasks.has(id)){
        console.error("Task with id-"+id+" is alreaded queued for execution.");
        return; 
    }
    this.tasks.set(id, {handler: handler, data: data});
    this.tasksScheduler();
    return id;
  }
  deleteTask(id){
    if(id){
        var val = this.tasks.get(id);
        this.tasks.delete(id);
        if(this.priorityQueue.length){
          var ind = this.priorityQueue.indexOf(id);
          if(ind != -1){
            this.priorityQueue.splice(ind, 1);
          }
        }
        return val;
    }
  }
  getPriorityQObj(){
    var id, i=0, pObj;
    if(this.priorityQueue.length){
      var len =this.priorityQueue.length;
      while(i<len){
        id = this.priorityQueue[i];
        if(this.tasks.has(id)){
          pObj = this.tasks.get(id);
          break;
        }
        i++;
      }
      if(pObj){
        return {id:id, obj:pObj, ind:i};
      }
    }
    return false;   
  }
  dequeueTask(id){
    if(id){
        var val = this.tasks.get(id);
        // console.log("dequeud-",id);
        this.tasks.delete(id);
        return val;
    }
    else if(this.tasks.size || this.priorityQueue.length){
      var pqObj = this.getPriorityQObj(), gnxt, gval, obj, isPriority = false, ind;
      if(pqObj !== false){
        id = pqObj.id;
        obj = pqObj.obj;
        ind = pqObj.ind;
        isPriority = true;
      }
      else{
        if(!this.tasks.size){
          return;
        }
        var val = this.tasks.entries().next().value;
        id = val[0]
        obj = val[1];
      }
      // console.log("dequeud-",id);
      this.currentTask = {id:id, handler: obj.handler};
      Lyte.extendEventListeners(this.currentTask);
      if(this.isGenerator(obj.handler)){
        gnxt = obj.handler.next();
        if(gnxt.done == false){
          gval = gnxt.value;
          if(typeof gval == "function"){
            return gval;
          }
        }
        else{
          this.currentTask.triggerEvent("done", id);
          if(isPriority){
            this.priorityQueue.splice(ind,1);
          }
          this.tasks.delete(id);
          return this.dequeueTask();
        }
      }
      else{
        this.currentTask.triggerEvent("done", id);
        if(isPriority){
          this.priorityQueue.splice(ind,1);
        }
        this.tasks.delete(id);
      }
      return obj;
    }
  }
  tasksScheduler(){
    if(this.delayInit == false){
      if(this.tasks.size){
        if(this.idleCallbackRequested == false){
          if('requestIdleCallback' in window && this.useRequestIdleCallback){
              this.idleCallbackRequested = true;
              requestIdleCallback(this.idleCallback);
          }   
          else{
              this.requestIdleCallback(this.idleCallback);
          }
        }
      }
      else{
        if('cancelIdleCallback' in window && this.useRequestIdleCallback){
          cancelIdleCallback(this.idleCallback);
        }
      }
    }
  }
  idleCallback(deadline){
    var task, i=0, remTime = deadline.timeRemaining();
    while(remTime>0 && this.tasks.size){
      task = this.dequeueTask();
      if(this.perf){
        var p1 = performance.now();
      }
      if(typeof task == "function"){
            // setTimeout(function(){
                task();
            // },1);
      }
      if(typeof task == "object"){
        // setTimeout(function(){
        var data = task.data || [];
        if(typeof task.handler == "function"){
          task.handler(...data);	
        }
        // },1);
      }
      if(this.perf){
        var p2 = performance.now();
        var id = this.currentTask.id;
        this.processTime[id] = (this.processTime.hasOwnProperty(id) ? this.processTime[id] : 0) + (p2-p1);
      }
      remTime = deadline.timeRemaining();
    }
    this.idleCallbackRequested = false;
    this.tasksScheduler();
  }
  requestIdleCallback(callback){
    var self = this;
    setTimeout(function(){
      setTimeout(function(){
        var startTime = Date.now();
        callback({
          timeRemaining: function(){
            var diffTime = Date.now() - startTime;
            if(diffTime > self.timeout){
                return 0;
            }
            return self.timeout-diffTime;
          }
        });
      }, 1);
    }, 50);
  }
}  
(function(Lyte){
  var userAgent = Lyte.$.userAgent = window.userAgent = navigator.userAgent;
  var singletonServices = new Map();
    //temporary fix for IE 11
  if (userAgent.match(/rv:11\.0/) && navigator.userAgent.match(/Trident/)) {
    Lyte.browser.ie = true;
    window.action = function () {
      return;
    };
  }
  if (userAgent.match('Edge')) {
    var s = createElement("div");
    s.innerHTML = "<template><div>c</div></template>";
    if (s.querySelector("template").childNodes.length) {
      Lyte.browser.ie = true;
    } else {
      Lyte.browser.edge = true;
    }
    s.remove();
  }


Lyte.Globals.set = function(scope,value){
  Lyte.Component.set(Lyte.__gl,scope,value);    
};

Lyte.Globals.get = function(scope){
  return Lyte.Component._get(Lyte.__gl, scope);
};

Object.defineProperty(Lyte.Service, "__Lyte__", {
  value: Lyte
});
Object.defineProperty(Lyte.Mixin, "__Lyte__", {
  value: Lyte
});
Object.defineProperty(Lyte.$, "__Lyte__", {
  value: Lyte
});
Lyte.Mixin.__Lyte__.requiredMixins = {};
Lyte.oldProxy = (typeof $Lt != "undefined") && $Lt.oldProxy ? $Lt.oldProxy : undefined;  
  
  Lyte.$.assetsDiv = document.createElement("div");
  Lyte.$.assetsDiv.setAttribute("id", "lyteAssetsDiv");
  Lyte.assetsDivContainer = document.head;

  Lyte.$.widgetWrapper = document.createElement("shadow-wrapper");
  Lyte.$.widgetWrapper.attachShadow({"mode":"open"});//af
  Lyte.$.widgetWrapper.setAttribute("id", "widgetWrapperDiv");
  
  Lyte.domContentLoaded = function(callback) {
    if(document.readyState === "complete" || document.readyState === "interactive") { 
      callback();
    } else {
      window.addEventListener('DOMContentLoaded', function() {
        callback();
      });
    }
  }
  
  Lyte.createApplication = function(name, obj){
      if(obj.init){
          obj.init.apply(Lyte);
      }
  }
  
  Lyte.registerErrorCodes = function(obj) {
    Object.assign(Lyte.errorCodes, obj);
  }
  
  Lyte.establishObserverBindings  = function(observers,fromStore,properties,model) {
    var scope = this;
    var watchProps = model && fromStore ? model._fldGrps.JsonPathWatch : scope.constructor._deepWatchProperties;
    if(fromStore){
      scope = fromStore;      
    }
    for(var i=0;i<observers.length;i++) {
      var props = observers[i].properties;
      var obsAttr = {},obsDuplicate=false;
      var Jpath={}
        for(var j=0;j<props.length;j++) {
            var actProp;
            var isArrayObserver = false;
            if(typeof props[j] == "string"){
              if(props[j].search(/^\$\./g)!=-1){
         
                var JsonPath = props[j];
      
                var CmpPropertyPath = JsonPath.match(/[^\$.][^\.]*/g)[0]
                if(CmpPropertyPath.search(/\[[0-9*]\]/g)!=-1){
                  CmpPropertyPath = CmpPropertyPath.split(/\[[0-9*]\]/g)[0];
                }
                if(watchProps[CmpPropertyPath]==undefined){
                  watchProps[CmpPropertyPath]=[];
                }
      
                if(Jpath[CmpPropertyPath] == undefined){
                  Jpath[CmpPropertyPath]=[];
                }
                
                var JSONPATH ;
                var reg = "^\\$\\."+CmpPropertyPath+"\\.?"
                reg = new RegExp(reg);
                JSONPATH = props[j].replace(reg,"$.")
                if(!watchProps[CmpPropertyPath].includes(JSONPATH)){
                  watchProps[CmpPropertyPath].push(JSONPATH)
                }
                
                if(!Jpath[CmpPropertyPath].includes(JSONPATH)){
                  Jpath[CmpPropertyPath].push(JSONPATH)
                }
      
      
                CmpPropertyPath =CmpPropertyPath+".*";
                if(!obsAttr.hasOwnProperty(CmpPropertyPath)){
                  actProp= Lyte.getProperty.call(this,CmpPropertyPath,fromStore,properties)
                  obsAttr[CmpPropertyPath]=true;
                  obsDuplicate = false;
                }
                else{
                  obsDuplicate = true;
                }
              }
              else if(props[j].indexOf('.[]') !== -1) {
                  isArrayObserver = true;
                  actProp = Lyte.getProperty.call(this,props[j].substring(0, props[j].indexOf('.[]')),fromStore,properties);
              } else {
              if(props[j].indexOf('.*') !== -1) {
                var prop = props[j].split(".")[0];
                var isDeepObs = (!fromStore && this.component.__data[prop] && this.component.__data[prop].watch) || (fromStore && model && model.fieldList && model.fieldList[prop] && model.fieldList[prop].watch) ? true : false;
                if(!isDeepObs){
                  continue;
                }
              } 
                actProp = Lyte.getProperty.call(this,props[j],fromStore,properties);
              }
              if(!obsDuplicate){
                if(!actProp._observers) {
                  Object.defineProperty(actProp, '_observers', {
                      value : new Set(),
                      enumerable: false, 
                      writable: true,
                      configurable: true
                  });
                }
              actProp._observers.add({callee : scope, observer: observers[i], isArrayObserver : isArrayObserver});
              }
          }else{
            Lyte.warn("ERR27",JSON.stringify(props[j]),observers[i].fnName,this.tagName);
          }
        }
        observers[i].Jpath  = Jpath;
        obsAttr={};
    }
  }
  
  Lyte.getProperty = function(key,fromStore,properties) {
      let arr = key.match(/([^[\].]+|\[\])/g);
      let property = this;
      if(fromStore){
          property = properties;
          if(!properties[arr[0]]){
              properties[arr[0]] = {};
          }
          property = properties[arr[0]];
      }
      else {                      
          if(!property._properties[arr[0]]) {
              property._properties[arr[0]] = {};
          } 
          property = property._properties[arr[0]];
      }
  
      Object.defineProperty(property, '_path', {enumerable: false, value : arr[0]});
      for(let i=1;i<arr.length;i++) {
        if (arr[i].startsWith("'") || arr[i].startsWith('"')) {
          arr[i] = arr[i].substring(1, arr[i].length -1);
        }
          if(!property[arr[i]]) {
              property[arr[i]] = {};
              Object.defineProperty(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
          }
          property = property[arr[i]];
      }
      return property;
  }
  
  Lyte.getErrorMessage = function(code) {
    var args = Array.from(arguments).slice(1);
    if(Lyte.errorCodes[code]) {
        return Lyte.errorCodes[code].replace(/{(\d+)}/g, function(t, i) {
            return args[i]
        });
    } else {
        return code;
    }
  }
  
  Lyte.error = function () {
    var errorObj = arguments[0],
    parse = errorObj.stack;
    errorObj = parse ? errorObj : Error(Lyte.getErrorMessage.apply(Lyte, arguments));
    if (Lyte.onerror) {
        Lyte.onerror.call(this, errorObj,arguments[1]);
    }
    Lyte.triggerEvent("error", errorObj,arguments[1]);
    var safari = errorObj.stack && errorObj.stack.indexOf(errorObj.message) == -1
    if (parse && !safari) {
        errorObj = JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj)));
    }
    if(arguments[1]) {
        console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message,arguments[1]);
    } else {
        console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message);    
    }
    
  };
  
  Lyte.warn = function () {
    var errorObj = arguments[0];
    errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : Error(Lyte.getErrorMessage.apply(Lyte, arguments));
    console.warn(errorObj.stack ? (errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace("Error: ", "") : errorObj) : errorObj.message);
  };
  
  var requiredMixins  = {};
  var fnProto = Function.prototype;
	if(!fnProto.on){
		fnProto.on = function(){
			Lyte.warn("'.on()' method with the argument '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "callBack", "value": this.type === "observer" ? this.value : this, "properties": arguments, "observes": this.type === "observer" ? this : undefined };
		};
	}
	if(!fnProto.observes){
		fnProto.observes = function(){
			Lyte.warn("'.observes()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "observer", "value": this, "properties": arguments, "on": Lyte._onObj, "lyteOn": Lyte._onObj };
		};
	}
	if(!fnProto.computed){
		fnProto.computed = function(){
			Lyte.warn("'.computed()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "computed", "value": this, "properties": arguments };
		};
	}
  Lyte._onObj = function(){
    return {"type": "callBack", "value":(this.type === "observer") ? this.value:this , "properties":arguments, "observes":(this.type === "observer" ? this: undefined)}
  }
  Lyte._observesObj = function() {
      return {"type" : "observer", "value" : this, "properties" : arguments, "on": Lyte._onObj, "lyteOn" : Lyte._onObj}
  }
  Lyte._computedObj = function() {
      return {"type" : "computed", "value" : this, "properties" : arguments}
  }
  Lyte._preRegister = function(){
    Lyte._actualFnProtoOn = Function.prototype.on;
    Lyte._actualFnProtoObserves = Function.prototype.observes;
    Lyte._actualFnProtoComputed = Function.prototype.computed;
    let fnProto = Function.prototype;
    fnProto.on = fnProto.lyteOn = Lyte._onObj;
    fnProto.observes = fnProto.lyteObserves = Lyte._observesObj;
    fnProto.computed = fnProto.lyteComputed = Lyte._computedObj;
  }
  Lyte._postRegister = function(){
    let fnProto = Function.prototype;
    fnProto.on = Lyte._actualFnProtoOn;
    fnProto.observes = Lyte._actualFnProtoObserves;
    fnProto.computed = Lyte._actualFnProtoComputed;
  }
  Object.defineProperty(Lyte.Mixin,"register",{
    get : function(){
        Lyte._preRegister();
        return Lyte.registerMixinWrapper;
    }
    , "enumerable" : true})
  Lyte.registerMixinWrapper = function(){
    try{
      Lyte.registerMixin.apply(Lyte, arguments);
      Lyte._postRegister();
    }catch(e){
      Lyte._postRegister();
    }
  }
  Lyte.registerMixin = function (name, mixin) {
    Lyte.registeredMixins[name] = mixin;
    var req;
    if(req = requiredMixins[name]) {
      for(var key in req) {
        Lyte.$.requiredMixins[key](mixin, req[key],key);
      }
    }
  };
  
  Lyte.Mixin.get = function(name) {
  return Lyte.registeredMixins[name];
  }
  
  Lyte.$.instantiateService = function(name, data){
    var service = Lyte.registeredServices[name];
    if(service.singleton == true){
      if(singletonServices.has(name)){
        return singletonServices.get(name);
      }
      else{
        var ins = new service(data);
        singletonServices.set(name, ins);
        return ins;
      }
    }
    else{
      return new service(data);
    }
  }
  
  Lyte.Service.register = function (name, service, isSingleton) {
    if(Lyte.registeredServices.hasOwnProperty(name)){
      Lyte.warn('Service -'+name+' is already registered');
      return;
    }
    if(!Lyte._keywords.is(name)){
      var data = service, 
      req;
      if(isSingleton){
        data.singleton = isSingleton;
      }
      Lyte.registeredServices[name] = data;
      var serv = Lyte.requiredServices[name];
      if(serv && serv.size) {
        serv.forEach(function(obj) {
          var toSend = data;
          if(obj.isGlobal){
            toSend = Lyte.__gS[obj.key] = Lyte.__gS[obj.key] || Lyte.$.instantiateService(name, obj.data);
          }
          obj.cB(toSend, obj.key, obj.name, name);
        });
      }
      return data;
    }
    else{
      Lyte.warn('Service name-'+name+' should not be a keyword used in Lyte');
    }
  };

  Lyte.Service.getInjected = function(key){
    if(Lyte.__gS.hasOwnProperty(key)){
      return Lyte.__gS[key];
    }
  }
  
  
  // Lyte.Service.get = function(name) {
  //   return Lyte.registeredServices[name];
  // }
  
  Lyte.$.requiredServices = function (key, serviceName, cB, type, name, isGlobal, data) {
		var reqServ = Lyte.requiredServices[serviceName];
		var req = reqServ ? reqServ : Lyte.requiredServices[serviceName] = new Map();
    var id = Lyte.$.genMapId(req);
    req.set(id, { key: key, cB: cB, type: type, name: name, serviceName:serviceName, isGlobal:isGlobal, data:data });
    return serviceName+"-"+id;
	};

  
  Lyte.$.lazyRegisterService = function(service,obj){
    var scope = obj.scope, name = obj.name , callback = scope[obj.type][name];
    if(callback){
      callback[obj.key] = service;
    }
  };
  
  Lyte.$.injectServices = {}; 
  Object.defineProperty(Lyte, "__gS", {
    value : {}
  });
	Lyte.injectServices = function (data) {
		var serv = {};
    if(!Array.isArray(data)){
      data = [data];
    }
		data.forEach(function (itm) {
			if (itm && typeof itm == 'object') {
				var key = itm.as, service = itm.service, args = itm.data;
				if (!Lyte._keywords.is(key)) {
					if (!Lyte.toBeInjectedServices.hasOwnProperty(key)) {
						Lyte.toBeInjectedServices[key] = service;
						serv[key] = {service:service, data:args};
						if(Lyte.registeredServices[service]){
							Lyte.__gS[key] = Lyte.$.instantiateService(service, args);
						}
					} else {
						Lyte.warn("A service has already been injected in the key named, ", key);
					}
				} else {
					Lyte.warn("Service cannot be used in any keywords of Lyte.");
				}
			} else if (typeof itm == "string") {
				if (!Lyte.toBeInjectedServices.hasOwnProperty(itm)) {
					Lyte.toBeInjectedServices[itm] = itm;
					serv[itm] = {service:itm};
					if(Lyte.registeredServices[itm]){
						Lyte.__gS[itm] = Lyte.$.instantiateService(itm);
					}
				} else {
					Lyte.warn("A service has already been injected in the key named, ", itm);
				}
			}
      else{
        Lyte.warn("Invalid data passed to injectServices", itm);
      }
		});
		var mdlObj = Lyte.$.injectServices;
		for (var mKey in mdlObj) {
			for (var key in serv) {
				mdlObj[mKey](key, serv[key].service, mKey, Lyte.__gS[key],undefined,serv[key].data);
			}
		}
	};

  Lyte.$.genMapId = function(map){
    var id = Math.floor(Math.random()*10000000000 + 1);
    while(map.get(id)){
        id = Math.floor(Math.random()*10000000000 + 1)
    }
    return id.toString();
  }

  Lyte.$.toRemoveFromRequiredServices = function(str){
    var arr = str.split("-"), id = arr[arr.length-1], idLen = id.length, servName = str.substr(0,str.length - (idLen+1));
    var reqArr = Lyte.requiredServices[servName];
    if(reqArr){
      reqArr.delete(id);
    }
  }


	Lyte.toBeUsedServices = function (obj) {
		// var serviceToBeUsed = obj.callback ? Object.assign({}, Lyte.toBeInjectedServices) : {};
		var serviceToBeUsed = {};
		var arr = obj.services;
		if (arr) {
			arr.forEach(function (service) {
				if (typeof service == "string") {
					serviceToBeUsed[service] = service;
				} else if (service && typeof service == "object") {
					var key = service.as, serv = service.service;
					if (!Lyte._keywords.is(key, obj.type)) {
						serviceToBeUsed[key] = serv;
					} else {
						Lyte.warn("Service cannot be used in any keywords of Lyte.");
					}
				}
			});
		}
		return serviceToBeUsed;
	};

	Lyte.extendService = function (arg) {
		var servObj = Lyte.toBeUsedServices(arg),
		    name;
		for (var serv in servObj) {
			name = servObj[serv];
			// var scp = arg.isGlobal && Lyte.__gS.hasOwnProperty(serv) : Lyte.registeredServices; 
			if ((arg.isGlobal && Lyte.__gS.hasOwnProperty(serv)) || (!arg.isGlobal && Lyte.registeredServices.hasOwnProperty(name))) {
				var ins = arg.ins,
				    service = arg.isGlobal ? Lyte.__gS[serv] : Lyte.$.instantiateService(name);
				if (!Array.isArray(ins)) {
					ins = [arg.ins];
				}
				ins.forEach(function (insObj) {
					insObj[serv] = arg.isGlobal ? Lyte.__gS[serv] : Lyte.$.instantiateService(name);
				});
			} else{
				Lyte.$.requiredServices(serv, name, arg.callback, arg.type, arg.name, arg.isGlobal, arg.data);
			}
		}
	};
  
  Lyte.$.requiredMixins = function(mixin,dir,type) {
  var req = requiredMixins[mixin] ? requiredMixins[mixin] : (requiredMixins[mixin] = {});
  if(!req[type]) {
    req[type] = [dir];
  } else {
    req[type].push(dir);  
  }
  }
  
  Lyte.Mixin.exists = function (name) {
  if (!Lyte.registeredMixins[name]) {
    // Lyte.error('Mixin used before being registered.');
    return false;
  }
  return true;
  };
  
  Lyte.log = function (text, src, color) {
  if (Lyte.debug) {
      if(color) {
          console.log("%c" + text,'color:' + color);
      } else {
        console.log(text);      
      }
  }
  };
  
  Lyte.time = function(fn) {
  if(Lyte.performance) {
    var index;
    if((index = Lyte.$.consoleTime.indexOf(fn)) != -1) {
      Lyte.$.consoleTime.splice(index,1);
      console.timeEnd(fn);
    } else {
      Lyte.$.consoleTime.push(fn)
      console.time(fn);
    }
  }
  }
  /* disable async function */
  Lyte.isRecord = function(object){
  if(object && object.$ && object.$.hasOwnProperty("isModified")) {
    return true;
  }
  return false;
  }
  
  Lyte.isComponent = function(object) {
  if(object && object.$node && object.__data) {
    return true;
  }
  return false;
  }
  
  
  /* --------- lyte router v2 changes starts---- */
  Lyte.$.reqFiles = {};
  
  Lyte.injectResources = function (files, every, completed, options) {
    var successFiles = [],
        errorFiles = [];
    every = every || function () {};
    completed = completed || function () {};
    return new Promise(function (resolve, reject) {
      processRequirements(files, function () {
        if (options && options.defer) {
          options.defer({
            injectJS: injectJS,
            files: files,
            errorFiles: errorFiles
          });
          resolve();
        } else {
          injectJS(files, function () {
            completed(successFiles, errorFiles);
            if (errorFiles.length) {
              reject(successFiles, errorFiles);
            } else {
              resolve(successFiles, errorFiles);
            }
          });
        }
      }.bind(this));
    });
  
    function injectJS(files, resolve, execFiles) {
      var len;
      execFiles = execFiles || [];
      if (!files) {
        resolve(successFiles, errorFiles);
      } else {
        if (!Array.isArray(files)) {
          files = [files];
        }
        if (!files.length) {
          resolve(successFiles, errorFiles);
        }
        len = -files.length;
        files.forEach(function (file) {
          if (typeof file == "string") {
            var type = getFileExtn(file);
            if (type && (type == ".js" || type == ".css") && execFiles.indexOf(file) == -1) {
              execFiles.push(file);
              createScript(file, function () {
                loaded();
              });
            } else {
              loaded();
            }
          } else if (Array.isArray(file)) {
            injectJS(file,function () {
              loaded();
            })
          } else {
            len--;
            injectJS(file.parent, function() {
              injectJS(file.child,function() {
                  loaded();
              })
              loaded();
          })
          }
        });
      }
  
      function loaded() {
        len++;
        if (len == 0) {
          resolve(successFiles, errorFiles);
        }
      }
    }
  
    function createScript(file, resolve) {
      var ev = Lyte.injectResources.respObj[file];
      if(ev && (!Lyte.injectResources.availableTags[file] || Lyte.injectResources.availableTags[file].tag.getAttribute("rel") == "preload")) {
        var type = getFileExtn(file),
        tag;
        if(type == ".js") {
          tag = document.createElement('script');
          tag.setAttribute('type', "text/javascript");
          tag.setAttribute('src', file);
        } else if(type == ".css") {
          tag = document.createElement('link');
          tag.setAttribute('type', "text/css");
          tag.setAttribute('rel', "stylesheet");
          tag.setAttribute('href', file);
        }
        ev.getAttributeNames().forEach(function (attr) {
          if (["href", "as", "rel"].indexOf(attr) == -1) {
            tag.setAttribute(attr, ev.getAttribute(attr));
          }
        });
        tag.onerror = tag.onload = function (event) {
          if (event.type == "error") {
            errorFiles.push(event);
          } else {
            successFiles.push(event);
          }
          delete Lyte.injectResources.respObj[file];
          Lyte.injectResources.availableTags[file].tag.remove();
          Lyte.injectResources.availableTags[file] = { tag: tag, event : event, type : event.type == "error" ? "error" : "load"  };
          resolve();
          tag.onerror = tag.onload = undefined;
        };
        Lyte.$.assetsDiv.appendChild(tag);
      } else {
        var t = Lyte.injectResources.availableTags[file];
        if(t.type == "error") {
          errorFiles.push(t.event)
        } else {
          successFiles.push(t.event);
        }
        resolve();
      }
    }
  
    function processRequirements(files, resolve) {
      var len;
      if (!files) {
        resolve();
      } else {
        if (!Array.isArray(files)) {
          files = [files];
        }
        if (!files.length) {
          resolve();
        }
        len = -files.length;
        files.forEach(function (file) {
          if (typeof file == "string") {
            requestFile(file, Lyte.injectResources.availableTags[file], function () {
              loaded();
            });
          } else if (Array.isArray(file)) {
            new Promise(function (r) {
              processRequirements(file, r);
            }).then(function () {
              loaded();
            });
          } else {
            len--;
            new Promise(function (r) {
              processRequirements(file.parent, r);
            }).then(function () {
              loaded();
            });
            new Promise(function (r) {
              processRequirements(file.child, r);
            }).then(function () {
              loaded();
            });
          }
        });
      }
  
      function loaded() {
        len++;
        if (len == 0) {
          resolve();
        }
      }
  
      function requestFile(file, cached, resolve) {
        if (Lyte.$.reqFiles[file]) {
          Lyte.$.reqFiles[file].push(resolve);
        } else {
          Lyte.$.reqFiles[file] = [resolve];
          if (cached && cached.event.type != "error") {
            if (Lyte.removeFromCache.arr.indexOf(file) != -1) {
              Lyte.removeFromCache.arr.splice(Lyte.removeFromCache.arr.indexOf(file), 1);
            }
            fileLoaded.call(cached.tag, file, cached.event, true);
            resolve();
          } else {
            makeRequest(file, function (event) {
              Lyte.injectResources.respObj[file] = this;
              Lyte.$.reqFiles[file].forEach(function (resolve) {
                resolve();
              });
              // filesObj[file] = this;
              fileLoaded.call(this, file, event);
              every.call(this, event);
            });
          }
        }
      }
  
      function fileLoaded(file, event, cached) {
        delete Lyte.$.reqFiles[file];
        if (!cached) {
          if (Lyte.injectResources.availableTags[file]) {
            Lyte.injectResources.availableTags[file].tag.remove();
            delete Lyte.injectResources.respObj[file];
          }
          Lyte.injectResources.availableTags[file] = { tag: this, event: event, type: event.type};
        }
      }
    }
  
    function makeRequest(file, callBack) {
      var tag,
      ev = every.internal || {},
      type = getFileExtn(file);
      ev.file = file;
      if (type == null) {
        Lyte.error('Type of file is not specified in injectResources.');
        return;
      }
      tag = document.createElement('link');
      tag.setAttribute('href', file);
      ev.tag = tag;
      if (type == '.css') {
        tag.setAttribute('as', "style");
      } else {
        tag.setAttribute('as', "script");
      }
      tag.setAttribute('rel', "preload");
      tag.onerror = tag.onload = function (event) {
        callBack.call(this, event);
        this.onerror = this.onload = undefined;
      };
      Lyte.triggerEvent("onBeforeInject", ev);
      Lyte.$.assetsDiv.appendChild(tag);
    };
  };

   function getFileExtn(file) {
    return file.match(/\.[a-zA-Z]+(?=\?|$)/);
  }
  
  Lyte.injectResources.availableTags = [];
  Lyte.injectResources.respObj = [];


  function getFileExtn(file) {
    return file.match(/\.[a-zA-Z]+(?=\?|$)/);
  }
  
  Lyte.$.replaceOldInjectResource = function() {
    Lyte.injectResources = function (files, every, completed) {
      var successFiles = [],
      errorFiles = []; 
      every = every || function() {};
      completed = completed || function() {};
      return new Promise(function(resolve) {
        processRequirements(files, resolve);   
      }).then(function() {
        completed(successFiles,errorFiles);  
      });
    
      function processRequirements(files, resolve) {
        var len;
        if(!files) {
          resolve();
        } else {
          if(!Array.isArray(files)) {
            files = [files];
          }
          if(!files.length) {
            resolve();
          }
          len = -(files.length);
          files.forEach(function(file) {
            if(typeof file == "string"){
              requestFile(file, Lyte.injectResources.availableTags[file], function() {
                loaded();
              });  
            } else if(Array.isArray(file)) {
              new Promise(function(r){
                processRequirements(file, r);
              }).then(function(){
                loaded();
              })
            } else {
              new Promise(function(r){
                processRequirements(file.parent, r);
              }).then(function(){
                new Promise(function(r1){
                  processRequirements(file.child, r1)
                }).then(function(){
                  loaded();
                })
              })
            }
          })
        }
    
        function loaded() {
          len++;
          if(len == 0) {
            resolve();
          }
        }
        
        function requestFile(file,cached,resolve) {
          if(Lyte.$.reqFiles[file]) {
            Lyte.$.reqFiles[file].push(resolve)
          } else {
            Lyte.$.reqFiles[file] = [resolve];
            if(cached && cached.event.type != "error") {
              if(Lyte.removeFromCache.arr.indexOf(file) != -1) {
                Lyte.removeFromCache.arr.splice(Lyte.removeFromCache.arr.indexOf(file),1);
              }
              fileLoaded.call(cached.tag,cached.event,true);
              resolve();
            } else {
              makeRequest(file,
                function(event) {
                  Lyte.$.reqFiles[file].forEach(function(resolve) {
                    resolve();
                  });
                  fileLoaded.call(this,event);
                  every.call(this,event);
                }
              );
            }
          }
        }
    
        function fileLoaded(event,cached) {
          var file = this.getAttribute('src') || this.getAttribute('href');
          delete Lyte.$.reqFiles[file];
          if(!cached) {
            if(Lyte.injectResources.availableTags[file]) {
              Lyte.injectResources.availableTags[file].tag.remove();
            }
            this.onerror = this.onload = undefined;
            Lyte.injectResources.availableTags[file] = {tag : this, event : {type : event.type}};
          }
        }
      }
    
      function makeRequest(file,callBack) {
        var tags = { ".js": 'script', ".css" : 'link' },
        type = getFileExtn(file);
        tag = document.createElement(tags[type]);
        if (!type) {
          Lyte.error('Type of file is not specified in injectResources.');
          return;
        } else if (type == '.css') {
          tag.setAttribute('href', file);
          tag.setAttribute('type', "text/css");
          tag.setAttribute('rel', "stylesheet");
        } else {
          tag.setAttribute('src', file);
        }
        tag.onerror = tag.onload = function (event) {
          if(event.type == "error") {
            errorFiles.push(event);  
          } else {
            successFiles.push(event);
          }
          if(callBack) {
            callBack.call(this,event);
          }
        };
        var ev = every.internal || {};
        ev.file = file;
        ev.tag = tag;
        Lyte.triggerEvent("onBeforeInject", ev);
        Lyte.$.assetsDiv.appendChild(tag);
      };
    };
  
    Lyte.injectResources.availableTags = [];
    Lyte.injectResources.respObj = [];
  }
  
  Lyte.removeFromCache = function (arr) {
    Lyte.removeFromCache.assign(arr);
    if (Lyte.removeFromCache.arr.length) {
      Lyte.removeFromCache.arr.forEach(function (file) {
        if (Lyte.injectResources.availableTags[file]) {
          Lyte.injectResources.availableTags[file].tag.remove();
          delete Lyte.injectResources.availableTags[file];
          delete Lyte.injectResources.respObj[file];
        }
      });
      Lyte.removeFromCache.arr = [];
    }
  };
  
  Lyte.removeFromCache.arr = [];
  
  Lyte.removeFromCache.assign = function (arr) {
    arr = arr == "*" ? Object.keys(Lyte.injectResources.availableTags) : Array.isArray(arr) ? arr : [arr];
    Lyte.removeFromCache.arr = Lyte.removeFromCache.arr.concat(arr);
    return;
  };

    Lyte.$.prefetchSupport = false;
    try {
        if(!Lyte.browser.ie) {
          var link = document.createElement('link');
          Lyte.$.prefetchSupport = link.relList.supports('prefetch') && link.relList.supports('preload');
        }
    } catch(e) {
    }
    if(!Lyte.$.prefetchSupport) {
        console.log("Prefetch is not supported. Falling back to old implementation")
        Lyte.$.replaceOldInjectResource();
    }
  
  /* --------- lyte router v2 changes ends ---- */
  
  Lyte.checkProperty = function(property, dataVal, key, fieldVal,field, record, type, name ,init){
    var exts = "extends";
    switch(property){
      case "type" : 
      if (Lyte.Transform.hasOwnProperty(fieldVal) && dataVal !== undefined && dataVal !== null) {
        var _fld = Lyte.Transform[fieldVal], _ret = true;
        if (Array.isArray(dataVal)) {
          if (Lyte.Transform[fieldVal][exts] != "array") {
            return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
          }
          if(_fld.hasOwnProperty("items")){
            _ret = Lyte.checkProperty("items", dataVal, key, _fld.items);
    
          }
        }else if(typeof dataVal === "object" && Lyte.Transform[fieldVal][exts] == "object" && _fld.hasOwnProperty("properties")){
          _ret = Lyte.checkProperty("properties", dataVal, key, _fld.properties);
        } 
        else if (Lyte.Transform[fieldVal][exts] != typeof dataVal) {
          return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
        }
        if(_ret !== true){
          return _ret;
        }
      }
        else if(dataVal !== undefined && dataVal !== null){
          if(Array.isArray(dataVal)){
             if(fieldVal != "array"){
                return {code : "ERR03", message : Lyte.errorCodes.ERR03, expected : fieldVal};
             }
          }
          else if(fieldVal != (typeof dataVal)){
            return {code : "ERR03", message : Lyte.errorCodes.ERR03, expected : fieldVal};
          }
        }
        break;
      case "mandatory":
          let validateFlag = fieldVal;
          if(typeof fieldVal == "object"){
            if(init && fieldVal.skipValidationOnInit == true){
              validateFlag = false;
            }
          }
          if (validateFlag && (dataVal == undefined || dataVal == null || dataVal === "")) {
            return { code: "ERR02", message: Lyte.errorCodes.ERR02 };
          }
          break;
      case "maximum" :
        if((typeof dataVal == "number") && dataVal > fieldVal){
          return {code : "ERR04", message : Lyte.errorCodes.ERR04, expected : fieldVal};
        }
        break;
      case "minimum" :
        if((typeof dataVal == "number") && dataVal < fieldVal){
          return {code : "ERR05", message : Lyte.errorCodes.ERR05, expected : fieldVal};
        }
        break;
      case "maxLength" :
      case "maxItems" :
        if(dataVal && dataVal.length > fieldVal){
          return {code : "ERR06", message : Lyte.errorCodes.ERR06, expected : fieldVal};
        }
        break;
      case "minLength" :
      case "minItems" :
        if(dataVal && dataVal.length < fieldVal){
          return {code : "ERR07", message : Lyte.errorCodes.ERR07, expected : fieldVal};
        }
        break;
      case "pattern" :
        if( typeof dataVal == "string" && !(new RegExp(fieldVal).test(dataVal))){
          return {code : "ERR08", message : Lyte.errorCodes.ERR08, expected : fieldVal};
        }
        break;
      case "uniqueItems" :{
        if(Array.isArray(dataVal) && fieldVal){
          var newArr = [];
          for(var i=0; i<dataVal.length; i++){
            var val = dataVal[i];
            if(newArr.indexOf(val) != -1){
              return {code : "ERR09", message : Lyte.errorCodes.ERR09};
            }
            newArr.push(val);
          }         
        }
        break;        
      }
      case "constant" :
        if(Array.isArray(dataVal)){
          var resp = dataVal.length==fieldVal.length && dataVal.every(function(v,i) { return v === fieldVal[i]});
          if(!resp){
            return {code : "ERR10", message : Lyte.errorCodes.ERR10, expected : fieldVal};
          }
        }
        else if(typeof dataVal == "object"){
          var resp = store.adapter.$.compareObjects(dataVal, fieldVal);
          if(!resp){
            return {code : "ERR10", message : Lyte.errorCodes.ERR10, expected : fieldVal};
          }
        }
        else if(dataVal && dataVal != fieldVal){
          return {code : "ERR10", message : Lyte.errorCodes.ERR10, expected : fieldVal};
        }
        break;
      case "items" :{
        if (Array.isArray(dataVal)) {
          for (var i = 0; i < dataVal.length; i++) {
            if(!(fieldVal.any && Array.isArray(fieldVal))){
              fieldVal = [fieldVal];
            }
            var fldLen = fieldVal.length, _ret = true;
            for(var j=0; j<fldLen; j++){
              var _fld = fieldVal[j];
              for (var property in _fld) {
              var resp = Lyte.checkProperty(property, dataVal[i], i, _fld[property], _fld);
              if (resp !== true) {
                if(_ret === true){
                resp.path = resp.path ? i + "." + resp.path : resp.path;
                _ret = resp;
                }
                break;
              }
              }
            }
            if(_ret !== true){
              return _ret;
            }
            }
        }
        break;        
      }
      case "properties" :
        if (typeof dataVal == "object" && !Array.isArray(dataVal)) {
					for (var key in dataVal) {
						if(fieldVal.hasOwnProperty(key)){
						  var fld = fieldVal[key];
						  if(!(fld.any && Array.isArray(fld))){
							  fld = [fld];
						  }
						  var fldLen = fld.length, _ret = true;
						  for(var i=0; i<fldLen; i++){
							var _fld = fld[i];
							for (var property in _fld) {
							  var resp = Lyte.checkProperty(property, dataVal[key], key, _fld[property], _fld);
							  if (resp != true) {
								if(_ret === true){
								resp.path = resp.path ? key + "." + resp.path : key.toString();
								_ret = resp;
								}
								break;
							  }
							}
						  }
						  if(_ret !== true){
							return _ret;
						  }
						}
						// else if(field.exact){
						// 	return { code : "ERR29", message: Lyte.errorCodes.ERR29, property: key };
						// }
					} 
				}
        break;
      case "validation" :{
        var resp =  Lyte.customValidator[fieldVal].apply(record, [key, dataVal, name]);
        if(resp != true){
          return resp;
        }
        break;
      }
      case "instanceof":{
        if(typeof dataVal === "object" && !Array.isArray(dataVal) && !(dataVal instanceof fieldVal)){
          return { code: "ERR30", message: Lyte.errorCodes.ERR30, property: key, instanceof: fieldVal};
        }
      }        
    }
    return true;
    }

    Lyte.checkNestedProp = function(id,path,dtype,wobj,object,property,value,check,fromStore){
      if (Lyte.Transform[dtype.type]){
        dtype = Lyte.Transform[dtype.type];
        dtype.type = dtype.extends;
      }
      if(path.length!=0){
          if(dtype.type == 'array'){
              if(dtype.items && !isNaN(path[0]) && typeof(dtype.items)=='object'){
                path= path.slice(1);
                Lyte.checkNestedProp(id,path,dtype.items,wobj,object,property,value,check,fromStore)
              }
          }
          else if( dtype.type == "object"){
              if(dtype.properties && dtype.properties.hasOwnProperty(path[0])){
                var k = path[0];
                path = path.slice(1);
                Lyte.checkNestedProp(id,path,dtype.properties[k],wobj,object,property,value,check,fromStore);
              }
          }
      }
      else {
        var err;
        if (dtype && (dtype.properties || dtype.items) && !check.hasOwnProperty("warn")) {
          var component = {};component.__data = {};
          if (dtype.properties) {
            component.__data[property] = dtype.properties[property];
        } else if (dtype.items && wobj.index) {
            component.__data[wobj.index] = dtype;
        } else {
            component.__data[property] = dtype.items;
        }
          var cp = Lyte.validate(object, property, value, component);
          var errKey = wobj.attr ? wobj.attr : wobj.key,_path = wobj.path.split(".");
          var PathWay = wobj.index == undefined && property? wobj.path+(wobj.path!="" ?".":"")+property : wobj.index !=undefined ? wobj.path+(wobj.path!="" ?".":"")+wobj.index : wobj.path;
          if (cp && (typeof cp === 'undefined' ? 'undefined' : typeof(cp)) == "object" && cp.code) {
              cp.value = value;
              cp.path = wobj.path !=""?wobj.path:property;
              if(wobj.isRec && fromStore && wobj.key ==  undefined && wobj.path!=""){
                  errKey = wobj.path.split(".")[0]
                  _path.shift();
                  _path = (_path.length == 1 && _path[0] == property) ? [] : _path;
              }
              // wobj.Error ? true : wobj.Error = {}
              wobj.Error && wobj.Error[errKey] ? wobj.Error[errKey].code && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : wobj.Error[errKey].nested = {} : wobj.Error[errKey] = { nested: {} };
              wobj.Error[errKey].code = "ERR34"
              wobj.Error[errKey].message = Lyte.errorCodes.ERR34;
              err = wobj.Error[errKey].nested;
              wobj._cmpErr[errKey] ? true : wobj._cmpErr[errKey]={};
              wobj._cmpErr[errKey].code = "ERR34";
              wobj._cmpErr[errKey].message = Lyte.errorCodes.ERR34;
              var cmpErrPath = wobj._cmpErr[errKey].path ? wobj._cmpErr[errKey].path : [] ;
              if(wobj.path !=""){
                  _path.forEach(function (k) {
                      if (err && !err[k]) {
                          err = err[k] = {};
                      } else {
                          err = err[k];
                      }
                  });
              }
              wobj.index != undefined ? err[wobj.index] = cp : err[property] = cp;
              if(!cmpErrPath.includes(PathWay)){
                cmpErrPath.push(PathWay)
              }
              wobj._cmpErr[errKey].path = cmpErrPath;
          } else{
              if(wobj.isRec && fromStore && wobj.key ==  undefined){
                  errKey = wobj.path.split(".")[0]
                  _path.shift();
                  _path = (_path.length == 1 && _path[0] == property) ? [property] : _path;
              }
              err = wobj.Error[errKey] && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : undefined;
              var cmpErr = wobj._cmpErr[errKey] || undefined;
              if(cmpErr && cmpErr.path && cmpErr.path.includes(PathWay)){
                var ind = cmpErr.path.indexOf(PathWay)
                cmpErr.path.splice(ind,1)
              }
              //var p = object.$.error[property];
              if(err){
                  var key = wobj.index || property; 
                  var flag = true,
                  p = PathWay.split(".");
                  p.forEach(function (r) {
                      if (err[r] && err[r].code) {
                          delete err[r];
                          if(err && Object.keys(err).length == 0){
                              flag = true;
                          }
                          else{
                              flag = false;
                          }
                      }
                      else{
                        err = err[r]
                      }
                  });
                  if (flag == true && wobj.Error[errKey] && wobj._cmpErr[errKey]) {
                      delete wobj.Error[errKey];
                      delete wobj._cmpErr[errKey]
                  }
              }
    
          }
          if((check.value && check.value.hasOwnProperty("code") && cp.code) || !check.value){
              check.value = cp;
          }
      }
    }
      wobj.index && delete wobj.index; 
    }
  
  Lyte.types = ["string", "object", "number", "boolean", "array"];
  
  Lyte.attr = function(type, opts){
  var obj = {};
  obj.type = type;
  if(opts == undefined){
    opts = {};
  }
  if(Lyte.types.indexOf(type) == -1 && !Lyte.Transform.hasOwnProperty(type)){
    throw new Error("Not a valid field type - "+type);
  }
  Object.assign(obj,opts);
  return obj;
  }
  
  window.prop = Lyte.attr;
  Lyte.defineRelation = function(name,type,opts){
  var relation = {type : "relation", relType : type, relatedTo : name};
  if(opts){
    relation.opts = opts;
  }
  return relation;
  }
  
  Lyte.belongsTo = function(name,opts){
  return this.defineRelation(name,"belongsTo",opts);
  }
  
  Lyte.hasMany = function(name,opts){
  return this.defineRelation(name,"hasMany",opts);
  }

  
  Lyte.Transform = {};
  
  Lyte.customValidator = {};
  
  Lyte.registerDataType = function(fieldTypeName, properties){
  var exts = "extends";
  if(this.Transform.hasOwnProperty(fieldTypeName)){
    Lyte.warn("Custom Field Type - "+fieldTypeName+" -  already exists.");
    return;
  }
  if(properties[exts] == undefined || Lyte.types.indexOf(properties[exts]) == -1){
    Lyte.error("Not a valid field type - "+properties[exts]);
    return;
  }
  this.Transform[fieldTypeName] = properties;
  }
  
  Lyte.registerValidator = function(customValidatorName, func){
  if(this.customValidator.hasOwnProperty(customValidatorName)){
    Lyte.warn("Custom Validator with name - "+customValidatorName+" - already exists");
    return;
  }
  this.customValidator[customValidatorName] = func;
  }
  
  Lyte.patterns = {
  email : /^([A-Za-z0-9._%\-'+/]+@[A-Za-z0-9.-]+\.[a-zA-Z]{2,22})$/,
  url : /(^(ht|f)tp(s?):\/\/[0-9a-zA-Z][-.\w]*(:[0-9])*(\/?)([a-zA-Z0-9\-.?,:'/\\+=&amp;%$#_[\]@!()*;~]*)?$)/,
  ampm : /^(AM|PM|am|pm)$/,
  hour : /^(0?[0-9]|1[0-9]|2[0-4])$/,
  minute : /^(0?[0-9]|[1-5][0-9]|60)$/,
  boolean : /^(true|false|TRUE|FALSE)$/,
  alphaNumeric : /([a-zA-Z0-9])+/,
  alphabetsOnly : /([a-zA-Z])+/,
  numeric : /([0-9])+/,
  phoneNo : /^[0-9a-zA-Z+.()\-;\s]+$/
  }

  Lyte.validate = function (object, key, value, component, init) {
		var definition = component.__data[key];
		var isError = false;
		var type = definition ? definition.type : undefined;
		var _def = definition;
		if(_def){
		  if(!(_def.any && Array.isArray(_def))){
			  _def = [_def];
		  }
		  var defLen = _def.length, _ret = true;
		  for(var i=0; i<defLen; i++){
			  var _d = _def[i];
			  for (var defKey in _d) {
				  isError = Lyte.checkProperty(defKey, value, key, _d[defKey], _d, object, type, undefined, init);
				  if (isError !== true) {
					  if(_ret === true){
						  _ret = isError;
					  }
				  }
			  }
		  }
		  if(_ret !== true){
			  return _ret;
		  }
		}
		return false;
	  };
    
  
  Lyte.registerPattern = function(patternName, pattern){
  this.patterns[patternName] = pattern;
  }
  
  Lyte.errorCodes = {
    ERR01 : "Primary key cannot be modified", ERR02 : "Mandatory field cannot be empty", ERR03 : "Type of value does not match the specified data type", ERR04 : "Value is greater than the maximum value allowed",
    ERR05 : "Value is less than the minimum value allowed", ERR06 : "Length of string/array is greater than the maximum limit allowed", ERR07 : "Length of string/array is less than the minimum limit allowed",
    ERR08 : "String does not match the specified pattern", ERR09 : "Values in array are not unique", ERR10 : "Value is not equal to the specified constant", ERR11 : "Model of related field is not defined",
    ERR12 : "Model of backward relation is not defined", ERR13 : "Record not found", ERR14 : "Model does not match the related field model", ERR15 : "Error in creating a record as a relation",
    ERR16 : "Record with primary key already exists", ERR17 : "Value cannot be changed because record has been deleted", ERR18 : "Action not defined", ERR19 : "Model not defined",
    ERR20 : "Key not specified", ERR21 : "'belongsTo' relationship expects a single object/id", ERR22 : "Type not specified for polymorphic relation", ERR23: "Primary Key value not present", ERR24: "Error while relating record", ERR25: "Backward relation not present", ERR26: "Primary key value cannot be undefined or null",
    ERR27 : "Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'",
    ERR28 : "Unloaded record cannot be saved",
    ERR29: "Property not defined in the object",
    ERR30:"Error in variables declaration for Query",ERR31: "Query not registered for the Model",
    ERR32: "Property not defined in the object",
    ERR33: "Property's value is not an instanceof the mentioned class",
    ERR34: "Type definition for nested properties / items does not match with the value" ,
    ERR35: "A datatype mismatch has occurred for custom DataType '{0}'"
  }
  
  Lyte.registeredGlobalEvents = Lyte.__lyteRegisteredEvents = {};
  Lyte.__lyteRegisteredEventsGlobal = {}
  Lyte.triggerEvent = function(obj) {
    var args;
    var actArgs;
    var eventObjectPath;
    if(typeof obj == "object" && obj.global) {
      actArgs = obj.args;
      args = Array.prototype.slice.call(actArgs, 1);
      eventName = actArgs[0];
      eventObjectPath = "__lyteRegisteredEventsGlobal";
    } else {
      args = Array.prototype.slice.call(arguments, 1);
      eventName = arguments[0];
      eventObjectPath = "__lyteRegisteredEvents";
    }
     var stopEvent = false;
     var s = this[eventObjectPath][eventName];
       if(!s) {
         s = this[eventObjectPath][eventName] = {"listeners" : []};
       } else {
         for(var i=0;i<s.listeners.length;i++) {
           var func = s.listeners[i];
           if(func) {
              var ret = func.apply(this, args);
              if(ret === false) {
                stopEvent = true;
                break;
              }
           }
         }
       }
       var customEvent = new CustomEvent(eventName, {"detail" : args});
       if(!stopEvent) {
        document.dispatchEvent(customEvent); 
       } 
   }
  Lyte.triggerGlobalEvent = function() {
    return Lyte.triggerEvent({"global" : true, "args" : Array.from(arguments)});
  }
  
   Lyte.addEventListener = function(eventName, func, options) {
     if(typeof func !== "function") {
         Lyte.error("Second parameter to Lyte.Component.addGlobalEventListener() must be a function");
         return;
     }
     var eventObjectPath = options && options.global ? "__lyteRegisteredEventsGlobal" : "__lyteRegisteredEvents";
     var s = this[eventObjectPath][eventName];
     if(!s) {
       s = this[eventObjectPath][eventName] = {"listeners" : []};
     }
     var d = s.listeners.push(func);
     return eventName + "-" + (d - 1);
    }
    
    Lyte.removeEventListener = function(id, options) {
      let lastIndex;
     if(!id || (lastIndex = id.lastIndexOf("-")) == -1) {
       Lyte.error("listener unique id not specified / invalid");
       return;
     }
     var globalId  = id.split("-");
     if(options){
      var globalId  = id.split("-");
      var eventObjectPath = options && options.global ? "__lyteRegisteredEventsGlobal" : "__lyteRegisteredEvents";
      var s = this[eventObjectPath][globalId[0]];
      if(!s || !s.listeners[globalId[1]]) {
          Lyte.error("No such listener registered");
          return;
      }
      s.listeners[globalId[1]] = null;
     }else{
      var eventName = id.substring(0,lastIndex);
      var eventId = id.substring(lastIndex + 1);
      var s = this.__lyteRegisteredEvents[eventName];
      if(!s || !s.listeners[eventId]) {
          Lyte.error("No such listener registered");
          return;
      }
      s.listeners[eventId] = null;
     }
    }
  
  
  Lyte.extendEventListeners = function(scp){
    if(scp && typeof scp == "object" && !scp.hasOwnProperty("__lyteRegisteredEvents")){
        Object.defineProperties(scp, {
            __lyteRegisteredEvents : {
                value : {}
            },
            addEventListener : {
                value : Lyte.addEventListener
            },
            removeEventListener : {
                value : Lyte.removeEventListener
            },
            triggerEvent : {
                value : Lyte.triggerEvent
            }
        });
    }
  }
  
  Lyte.deepCopyObject = function( obj )  {
  var targetVal = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
  var current, copies = [{source : obj, target : targetVal}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];
  var cloneObject = copies[0].target, targetReferences = [cloneObject];
  while(current = copies.shift()){
    keys = Object.keys(current.source);
    for(propertyIndex = 0; propertyIndex < keys.length; propertyIndex++){
        descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
        if(!descriptor){
            continue;
        }
        if(!descriptor.value || typeof descriptor.value != "object"){
            Object.defineProperty(current.target, keys[propertyIndex], descriptor);
            continue;
        }
        nextSource = descriptor.value;
        descriptor.value = Array.isArray(nextSource) ? [] : nextSource instanceof Set ? new Set() : Object.create(Object.getPrototypeOf(nextSource));
        indexOf = sourceReferences.indexOf(nextSource);
        if(indexOf != -1){
            descriptor.value = targetReferences[indexOf];
            Object.defineProperty(current.target, keys[propertyIndex], descriptor);
            continue;
        }
        sourceReferences.push(nextSource);
        targetReferences.push(descriptor.value);
        Object.defineProperty(current.target, keys[propertyIndex], descriptor);
        copies.push({source : nextSource, target : descriptor.value});
    }
    if(Lyte.isRecord(current.source)){
      Object.defineProperty(current.target, "$", {
        value: {}
      });
      current.target.$.isNew = current.source.$.isNew;
      current.target.$.isModified = current.source.$.isModified;
      current.target.$.isDeleted = current.source.$.isDeleted;
      current.target.$.pK = current.source.$.pK;
      current.target.$._attributes = current.source.$._attributes;
      current.target.$.isCloned = true;
      current.target.$.model = { _name : current.source.$.model._name };
      if(current.source.$.hasOwnProperty("deepNest")){
        current.target.$.deepNest = current.source.$.deepNest;
      }
      if(current.source.$.hasOwnProperty("partialType")){
        current.target.$.partialType = current.source.$.partialType;
      }
    }
    if(Array.isArray(current.source)){
      if(current.source.partial){
        Object.defineProperty(current.target, "partial", {
          value: current.source.partial
        });
      }
    }
  }
  return cloneObject;
  }
  
  Lyte.nestScpId = 1;
  Lyte.nestScp = {};
  Lyte.__nestRef__ = {};
  // Lyte.__nestScp__ = {};
  Lyte.__nestScp__ = new Map();
  // Lyte.__nestScp1__ = new Map();
  Lyte.establishObjectBinding = function (data, attr, fromStore, update,storeRecord,watch) {
    var model, fld, nestObj;
    var checkAttrs=data.__component__ && data.__component__.component.__data?data.__component__.component.__data[attr]:undefined;
    if (fromStore) {
      if(data && !data.$ && data._scp){
        var keys = Array.from(data._scp.keys());
        keys.forEach(function(id){
            var recObj = Lyte.nestScp[id];
            model = store.modelFor(recObj.model);
        })
      }else{
        model = data.$.model;
      }
       fld = model && model.fieldList && model.fieldList.hasOwnProperty(attr)? model.fieldList[attr] : {};
       var _checkDtype = false;
       if(fld){
        var _dtype = Lyte.Transform[fld.type];
        if(_dtype && (_dtype.hasOwnProperty("properties") || _dtype.hasOwnProperty("items"))){
          _checkDtype = true;
        }
       }
        if (fld && (fld.type !== "relation" && fld.watch) || _checkDtype){
            checkAttrs=fld;
        }
      else{
         if(data._scp){
            var keys = Array.from(data._scp.keys());
             keys.forEach(function (id) {
               var _mpObj = data._scp.get(id), 
               mpObj = _mpObj.paths;
               var _dtype = Lyte.nestScp[id] || undefined;
               watch = _dtype && _dtype["watch"]?_dtype["watch"]:watch;
                 for (var key in mpObj) {
                     var path = key ? key.split(".") : [];
                     path.push(attr);
                     Lyte.bindObj(data, attr, id, path, new Map(),undefined,checkAttrs,watch,true);
                 }
            });
         }
        return;
      }
    }
    if (update && data._scp && data._scp.size) {
        var keys = Array.from(data._scp.keys());
        keys.forEach(function (id) {
          var _mpObj = data._scp.get(id), 
          mpObj = _mpObj.paths;
          var _dtype = Lyte.nestScp[id] || undefined;
          watch = _dtype && _dtype["watch"]?_dtype["watch"]:watch;
            for (var key in mpObj) {
                var path = key ? key.split(".") : [];
                path.push(attr);
                Lyte.bindObj(data, attr, id, path, new Map(),undefined,checkAttrs,watch,true);
            }
        });
    }
    var customDtype = false;
    if (checkAttrs && Lyte.Transform[checkAttrs.type]) {
      var dtype = Lyte.Transform[checkAttrs.type];
      if(dtype.hasOwnProperty("properties") || dtype.hasOwnProperty("items")){
        checkAttrs = Lyte.Transform[checkAttrs.type];
        customDtype = true;
      }
    }
    if ((!fromStore || fld.watch || fld.properties || fld.items || watch || customDtype) && data[attr]) {
      var _scpObj, kmpKey;
        if (data && data.__component__) {
            data.__component__.__scpObj || Object.defineProperty(data.__component__, "__scpObj", {
                value: {}
            });
            kmpKey = data.__component__;
            _scpObj = data.__component__.__scpObj;
        } else if (Lyte.isRecord(data)) {
            data.$.__scpObj || Object.defineProperty(data.$, "__scpObj", {
                value: {}
            });
            kmpKey = data;
            _scpObj = data.$.__scpObj;
        }
        var obj = _scpObj,
        id;
        if (_scpObj) {
            var __nestScp1Set__ = false, __nestScp2Set__ = false;
            if (fromStore) {
                if(data[attr] && !Lyte.__nestScp__.has(data[attr])){
                    nestObj = { model: model._name, attr: attr, pK: data.$.pK , Error : {} };
                    __nestScp1Set__ = true;
                }
                else{
                  // var kmp = Lyte.__nestScp__[kid] = Lyte.__nestScp__[kid] || new Map();
                  // data ? kmp.set(data, true) : undefined;
                  var __nId = Lyte.__nestScp__.get(data[attr])
                  var refMp = Lyte.__nestRef__[__nId] = Lyte.__nestRef__[__nId] || new Map();
                  var refMpId = Lyte.$.genMapId(refMp);
                  refMp.set(refMpId, true);
                  Lyte.setRecBindMap(Lyte.nestScp[__nId], {model:model._name, attr: attr, pK: data.$.pK , Error : {}});
                  obj[attr] = __nId+"_"+refMpId;
                }
            } else {
              if(data[attr] && !Lyte.__nestScp__.has(data[attr])){
                var ErrMap = [],cmpDataKeys = {};
                cmpDataKeys.key=attr;
                cmpDataKeys.dtype = data.__component__.component.__data[attr];
                cmpDataKeys._cmpErr = data.errors;
                cmpDataKeys.Error={};
                ErrMap.push(cmpDataKeys);
                nestObj = { data: data[attr], PropsInfo : ErrMap };
                if(cmpDataKeys.dtype.watch){
                  nestObj.watch = true;
                }
                __nestScp2Set__ = true;
              }
              else{
                  var __nId = Lyte.__nestScp__.get(data[attr])
                  var scope = Lyte.nestScp[__nId];
                  if(scope){
                    if(!scope.PropsInfo){
                      scope.PropsInfo = [];
                    }
                    var errMp = scope.PropsInfo;
                    var cmpDataKeys = {};
                    cmpDataKeys.key=attr;
                    cmpDataKeys.Error = {};
                    cmpDataKeys._cmpErr = data.errors;
                    cmpDataKeys.dtype = data.__component__.component.__data[attr];
                    if(cmpDataKeys.dtype.watch){
                      scope.watch = true;
                    }
                    errMp.push(cmpDataKeys);
                  }
                  var refMp = Lyte.__nestRef__[__nId] = Lyte.__nestRef__[__nId] || new Map();
                  var refMpId = Lyte.$.genMapId(refMp);
                  refMp.set(refMpId, true);
                  obj[attr] = __nId+"_"+refMpId;
              }
          }
          if(nestObj){
            var nestScpId = Lyte.nestScpId++;
            var refMp = Lyte.__nestRef__[nestScpId] = Lyte.__nestRef__[nestScpId] || new Map();
            var refMpId = Lyte.$.genMapId(refMp);
            refMp.set(refMpId, true);
            // var kmp = Lyte.__nestScp__[nestScpId] = Lyte.__nestScp__[nestScpId] || new Map();
            // kmp.set(kmpKey, true);
            Lyte.__nestScp__.set(data[attr], nestScpId);
            if(__nestScp1Set__){
                Lyte.nestScp[nestScpId] = {};
                Lyte.setRecBindMap(Lyte.nestScp[nestScpId], nestObj);
                Lyte.nestScp[nestScpId].Error = nestObj.Error
                //     Lyte.setRecBindMap(model._name, attr, data.$.pK, nestScpId); 
            }
            if(__nestScp2Set__){   
                Lyte.nestScp[nestScpId] = nestObj;                 
            //     Lyte.__nestScp2__.set(data[attr], nestScpId);
            }
            Lyte.nestScp[nestScpId]._data = data[attr];
            obj[attr] = obj[attr] || nestScpId+"_"+refMpId;
            var path = [];
            // fromStore ? path.push(attr) : undefined;
            Lyte.bindObj(data, attr, nestScpId, path, new Map(), undefined, checkAttrs,watch);
          }
      }
  }
};

Lyte.removeNestScp2Bind = function(mp, mdlObj){
var mp = mp.model;
if (mp.has(mdlObj.model)) {
    var mp1 = mp.get(mdlObj.model);
    if (mp1.has(mdlObj.pK)) {
        var mp2 = mp1.get(mdlObj.pK);
        if (mp2.has(mdlObj.attr)) {
            mp2.delete(mdlObj.attr);
        }
        !mp2.size ? mp1.delete(mdlObj.pK) : undefined; 
    }
    !mp1.size ? mp.delete(mdlObj.model) : undefined;
}
}

Lyte.setRecBindMap = function(obj, nestObj){
var mp = obj.model = obj.model || new Map(), modelName = nestObj.model, pK = nestObj.pK, attr = nestObj.attr;
if(modelName && !mp.has(modelName)){
    mp.set(modelName, new Map());
}
mp = mp.get(modelName);
if(pK && !mp.has(pK)){
    mp.set(pK, new Map());
}
mp = mp.get(pK);
if(attr && !mp.has(attr)){
  mp.set(attr, true);
}
}
  

Lyte.bindObj = function (data, key, id, path, mp, check, checkAttrs,watch,ignoreCyclicDelete) {
  mp = mp || new Map();
var value = key != undefined ? data[key] : data;
var cyclic = false;
if(!ignoreCyclicDelete && !path.length && Lyte.__nestScp__.get(data) === id){
  delete Lyte.nestScp[id].cyclic;
}
if (path.length > 1 && value && Lyte.nestScp[id] && Lyte.nestScp[id].hasOwnProperty("data") && Lyte.nestScp[id].data === value) {
  if(mp.get(value)){
    cyclic = true;
  }
    else{
       try{ 
          JSON.stringify(value);
       }
       catch(exp){
           cyclic = true;
       }
   }
  if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
    Lyte.estObjScp(value, id, path, cyclic);
  }
  return;
}
var attrs,nestedSCP;
if(checkAttrs){
	if((checkAttrs.hasOwnProperty("items")||checkAttrs.hasOwnProperty("properties"))){
		attrs=checkAttrs.items || checkAttrs.properties;
    nestedSCP = true;
	}
	else if(watch == undefined && checkAttrs.watch == true){
		watch = checkAttrs.watch 
	}
}
attrs=watch?undefined:attrs;
if (Array.isArray(value)) {
  if (!mp.get(value)) {
    mp.set(value, true);
    value.forEach(function (val, idx) {
      path.push(idx);
      if(watch || (checkAttrs && checkAttrs.hasOwnProperty("items") && typeof(checkAttrs.items) == "object" )){
        Lyte.bindObj(value, idx, id, path, mp,undefined,attrs,watch);
      }
      path.pop();
    });
  } else {
    cyclic = true;
  }
  if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
    var _establish;
    if(Array.isArray(watch)){
      _establish = Lyte.checkEstablishingSCP(value,path,watch)
    }
    if(_establish || (typeof watch =="boolean" && watch ) || nestedSCP){
        Lyte.estObjScp(value, id, path, cyclic);
    }
  }
} else if (value && typeof(value) == "object") {
  var cyclic = false;
  if (!mp.get(value)) {
    mp.set(value, true);
    for (var str in value) {
      path.push(str);
      if(watch || (attrs && attrs.hasOwnProperty(str))){
        Lyte.bindObj(value, str, id, path, mp,undefined,attrs?attrs[str]:undefined,watch);
      }
      path.pop();
    }
  } else {
    cyclic = true;
  }
  if(Lyte.checkAndAddBind(value, id, path, cyclic)) {
    var _establish;
    if(Array.isArray(watch)){
      _establish = Lyte.checkEstablishingSCP(value,path,watch)
    }
    if(_establish || (typeof watch =="boolean" && watch ) || nestedSCP ){
      Lyte.estObjScp(value, id, path, cyclic);
    }
  }
}
};

  Lyte.checkAndAddBind = function(value, id, path, cyclic){
      if(!value._scp || !value._scp.size){
          return true;
      }
      if(value._scp.size){
        if(value._scp.has(id)){
            var _obj = value._scp.get(id);
            var obj = _obj.paths;
            if(obj.hasOwnProperty(path.join("."))){
              if(cyclic){
                Lyte.nestScp[id].cyclic = true;
              }                      
              return false;
            }
        }
      }
      return true;
  }   

  Lyte.estObjScp = function(value, id, path, cyclic){
    if(!value._scp){
      Object.defineProperty(value, "_scp", {
        value : new Map(),
        enumerable : false,
        configurable : true
      });
    }
    var mp = value._scp;
    if(!mp.has(id)){
      mp.set(id, {});
    }
    var obj = mp.get(id),
    path = path ? path.join(".") : path;
    var pathObj = obj.paths = obj.paths || {};
    pathObj[path] = true;
    var nestObj = Lyte.nestScp[id];
    if(!nestObj.cyclic && cyclic == true){
      nestObj.cyclic = true;
    }
  }
  
  Lyte.cmpObjs = function (obj1, obj2){
      if(Object.keys(obj1).length !== Object.keys(obj2).length){
          return false;
      }
      for(var key in obj1){
          if(!obj2.hasOwnProperty(key)){
              return false;
          }
          var ret = Lyte.cmpData(obj1[key], obj2[key]);
          if(ret == false){
              return false;
          }
      }
      return true;
  }	
  
  
  Lyte.cmpData = function(data1, data2){
    if(Array.isArray(data1)){
      if((!Array.isArray(data2)) || data1.length !== data2.length){
        return false;
      }
      if(data1 === data2){
        return true;
      }
      var len = data1.length, ret;
      for(var i=0;i <len; i++){
        ret = Lyte.cmpData(data1[i], data2[i]);
        if(ret == false){
          return false;
        }
      }
    }
    else if(data1 && data2 && typeof data1 == "object" && typeof data2 == "object"){
      if(data1 === data2){
        return true;
      }
      return Lyte.cmpObjs(data1,data2);
    }
    // else if(Lyte && Lyte.isRecord(data1) && Lyte.isRecord(data2)){
    //   if( (data1.$.model._name !== data1.$.model._name) || (Lyte.getpKVal(data1) !== Lyte.getpKVal(data2)) ){
    //     return false;
    //   }
    // }
    else if(data1 !== data2){
      return false;
    }
    return true;
  }

  Lyte.nestScpRmPath = function(obj, path){
    if(obj && obj.paths){
        obj = obj.paths;
        for(var key in obj){
            if(key.startsWith(path+".")){
                delete obj[key];
            }
        }
    }
  }
  
  Lyte.nestScpRemove = function(data, id, path){
    var mp = data._scp;
    if(mp && mp.size){
        if(path){
          Lyte.nestScpRmPath(mp.get(id), path);
          var _obj = mp.get(id); 
          var obj = _obj ? _obj.paths : undefined;
          if(obj && !Object.keys(obj).length){
              mp.delete(id);
          }  
        }
        else{
            mp.delete(id);
        }
        if(!mp.size){
          delete data._scp;
        }
    }
  }
  
  Lyte.rmNestScp = function(value, id, mp, data, path){
    if (Array.isArray(value)) {
        if (!mp.get(value)) {
            mp.set(value, true);
            value.forEach(function (val, idx) {
                Lyte.rmNestScp(val, id, mp, undefined, path);
            });
        }
        Lyte.nestScpRemove(value, id, path);
    } else if (value && typeof(value) == "object") {
        if (!mp.get(value)) {
            mp.set(value, true);
            for (var str in value) {
                Lyte.rmNestScp(value[str], id, mp, undefined, path);
            }
        }
        Lyte.nestScpRemove(value, id, path);
    }
  }

Lyte.removeNestScp = function (value, id, mpId, path, context, mp, data, recObj) {
  mp = mp || new Map();
  id = Number.parseInt(id);
  var obj = Lyte.nestScp[id], kmp = Lyte.__nestRef__[id];
  if(recObj && obj.model){
    Lyte.removeNestScp2Bind(obj, recObj);
  }
  if(context){
      if(kmp && kmp.has(mpId)){
          kmp.delete(mpId);
      }
      if(!kmp || (kmp && !kmp.size)){
          delete Lyte.__nestRef__[id];
          if(Lyte.__nestScp__.has(value)){
              Lyte.__nestScp__.delete(value);
          }
          Lyte.rmNestScp(value, id, mp, true, path);
          if(!data){
              delete Lyte.nestScp[id];
          }
      }
  }
  else{
    Lyte.rmNestScp(value, id, mp, true, path);
  }
};

  
  Lyte.resolvePromises = function(promises) {
  if(typeof promises == "string" || promises instanceof Promise) {
      return promises;
  } else {
    if(Array.isArray(promises)) {
      return promiseArray(promises);
    } else if(typeof promises == "object") {
      return promiseHash(promises);
    }    
  }
  
  function promiseHash(promiseObj) {
    var actPromKeys = [],
    promises = [],
    promiseKeys = Object.keys(promiseObj);
    promiseKeys.forEach(function(key) {
        var value = promiseObj[key];
      if(value instanceof Promise || (value && !Array.isArray(value) && typeof value == "object" && typeof value.then == "function")) {
        actPromKeys.push(key)
        promises.push(value);
      }
    });
    if(!promises.length) {
      return Promise.resolve(promiseObj);
    } else {
       var obj = {},promise = new Promise(function(resolve,reject) {
          Promise.all(promises).then(function(data) {
            promiseKeys.forEach(function(promiseKey) {
              if(actPromKeys.indexOf(promiseKey) != -1) {
                obj[promiseKey] = data[actPromKeys.indexOf(promiseKey)]
              } else {
                obj[promiseKey] = promiseObj[promiseKey];
              }
            });
          resolve(obj);
        },function(err) {
          reject(err);
          Lyte.error('Error on resolve promises',err);
        });
      });   
     return promise;
    }
  }
  
  function promiseArray(promiseArray) {
    var array = [],
    hasPromise = false;
    promiseArray.every(function(item,i) {
        if(item instanceof Promise || (item && !Array.isArray(item) && typeof item == "object" && typeof item.then == "function")) { 
            hasPromise = true;
            return false;
        }
        return true
    });
    if(!hasPromise) {
        return Promise.resolve(promiseArray);
    }
    var promise = new Promise(function(resolve,reject) {
      Promise.all(promiseArray).then(function(data) {
        promiseArray.forEach(function(key,index){
          array[index] = data[index];
        });
        resolve(array);
      },function(err) {
        reject(err);
        Lyte.error('Error on resolve promises',err);
      });
    });   
   return promise;
  }
  };
  function domContentLoaded1() {
    Lyte.assetsDivContainer.appendChild(Lyte.$.assetsDiv);
  }
  
  if(document.readyState === "complete" || document.readyState === "interactive") {
    domContentLoaded1();
  } else {
    document.addEventListener("DOMContentLoaded", function(e){
        domContentLoaded1();
    },true);
  };
  
  
    var XHRSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = function(){
        var event = window.event;  
        var type, target = event ? event.target : undefined; 
        if(Lyte.getConfig("stateHandling")){
            if(event){
                type = event.type;
                /^(click|dblclick)$/.test(type) && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false" ? addStateToMap(type,target,this) : undefined;
            }
            else{
                var router = Lyte && Lyte.Router ? Lyte.Router.getRouteInstance() : undefined;
                if(router){
                    var currentAction = router.transition ? router.transition.ev : undefined;
                    if(currentAction && currentAction.target && currentAction.target.getAttribute && currentAction.target.getAttribute("lyte-state-handling") != "false"){
                        var mp = Lyte.__transXHRMap = Lyte.__transXHRMap || new Map();
                        mp.set(router.transition, {currentAction : currentAction, XHR:this});
                        addStateToMap(currentAction.type, currentAction.target, this);
                    }
                }
            }
        }
        XHRSend.apply(this, arguments);
    }
    
    Lyte.addEventListener("transitionStart",function(obj){
      var trans = obj.nextTrans;
      if(trans && obj.prevTrans){
          if(window.event && /^(click|dblclick)$/.test(window.event.type)){
              trans.ev = window.event;
              if(obj.prevTrans.ev){
                delete obj.prevTrans.ev;
              }
          }
          else if((obj.prevTrans.state == 409 || obj.prevTrans.state == 308) && obj.prevTrans.ev){
              trans.ev = obj.prevTrans.ev;
              delete obj.prevTrans.ev;
          }
          
      }
    });
    
    Lyte.addEventListener("afterRouteTransition", function(obj){
        if(obj && obj.trans){
            var mp = Lyte.__transXHRMap, removeEv = false;
            if(obj.trans.state == 409 || obj.trans.state == 308){
                var ev1 = window.event, ev2 = obj.trans.ev;
                if(!ev1 || (ev1 && ev2 && ev1 != ev2 && ev1.target == ev2.target && ev1.type == ev2.type)){
                    obj.trans.nested = true;
                }
                else{
                  removeEv = true;
                }
                if(mp){
                    var mpObj = mp.get(obj.trans);
                    if(mpObj){
                        removeStateFromMap(mpObj.XHR, mpObj.currentAction.type, mpObj.currentAction.target);
                        mp.delete(obj.trans);
                    }
                }
            }
            else if(obj.trans.state == 200){
                mp ? mp.delete(obj.trans) : undefined;
                removeEv = true;
            }
            if(removeEv){
              obj.trans.ev ? delete obj.trans.ev : undefined;
            }
        }
    });
    
    Lyte.addEventListener("beforeRouteTransition", function(obj){
        if(obj && obj.prevTrans && obj.prevTrans.nested){
            obj.trans.ev = obj.prevTrans.ev;
            delete obj.prevTrans.ev;
            obj.trans.fromPrevTrans = true; // temp check
        }
    });
    
    function addStateToMap(event, target, XHR, stateName){
        var mp = Lyte.__nodeXHRMap = Lyte.__nodeXHRMap || new Map();
        var nodeMap = mp.get(target);
        if(!nodeMap){
            mp.set(target, new Map());
        }
        nodeMap = mp.get(target);
        var sr = target.lyteState = target.lyteState || [], type = stateName || XHR;
        if(sr.indexOf(type) == -1){
            sr.push(type);
        }
        target.setAttribute("lyte-state", "");
        var evMap = nodeMap.get(event);
        if(!evMap){
            nodeMap.set(event, []);
            evMap = nodeMap.get(event);
        }
        if(stateName){
            evMap.push({state:stateName});
            return {target: target, event: event};        
        }
        else{
            evMap.push({isXHR:true, xhr:XHR});
            var callback = function(arg){
                if(XHR.readyState == 4){
                    removeStateFromMap(XHR, event, target);
                    XHR.removeEventListener("readystatechange", callback);
                }
            }
            XHR.addEventListener("readystatechange", callback);
        }
    }
    function removeStateFromMap(type, event, target){
        var mp = Lyte.__nodeXHRMap; 
        var nodeMap = mp.get(target);
        if(!nodeMap){
            return;
        }
        var evMap = nodeMap.get(event);
        if(!evMap){
            return;
        }
        if(evMap){
            var arr = evMap;
            var ind = -1;
            arr.every(function(itm, idx){
                if((itm && itm.isXHR && itm.xhr == type)|| (typeof type == "string" && itm.state == type)){
                    ind = idx;
                    return false;
                }
                return true;
            });
            if(ind != -1){
                arr.splice(ind,1);
                var sind = target.lyteState.indexOf(type);
                target.lyteState.splice(sind, 1);
                if(!arr.length){
                    nodeMap.delete(event);
                    var tyInd = target && Array.isArray(target.lyteState) ? target.lyteState.indexOf(type) : -1; 
                    tyInd != -1 ? target.lyteState.splice(tyInd, 1) : undefined;
                    if(target && target.lyteState && target.lyteState.length == 0){
                        target.lyteState = null;
                        target.removeAttribute("lyte-state");
                    } 
                }
                if(!nodeMap.size){
                    mp.delete(target);
                }
            }
        }
    }
    
    Lyte.setState = function(str){
        if(!str){
            console.error("Please provide a state name");
        }
        var evnt = window.event;
        if(/^(click|dblclick)$/.test(evnt.type)){
            var target = evnt.target;
            if(Lyte.getConfig("stateHandling") == true &&  target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false"){
                var state = target.getAttribute("lyte-state");
                if(!state){
                    var mp = Lyte.__stateMap = Lyte.__stateMap || new Map();
                    var mpobj = mp.get(str);
                    if(!mpobj){
                        var obj = addStateToMap(evnt.type, target, undefined, str);
                        mp.set(str, obj);
                    }
                    else{
                        console.error("There is already a open state by the name",str);
                    }
                }
            }        
        }
    }
    
    Lyte.removeState = function(str){
        if(!str){
            console.error("Please provide a state name");
        }
        var mp = Lyte.__stateMap;
        if(mp){
            var obj = mp.get(str);
            if(obj){
                mp.delete(str);
                removeStateFromMap(str, obj.event, obj.target);
            }
        }
    }
    Lyte.setConfig = function(key, value, cons){
        if(key == "mutable"){
          if(value == true){
            Lyte.__gl = Lyte.mut(Lyte.__gl__);
          }
          else if(value == false){
            Lyte.__gl = Lyte.__gl__;            
          }
        }
        var configObj = Lyte.__config = Lyte.__config || {};
        if(cons){
          Object.defineProperty(configObj, key, {
            value: value
          })
        }
        else{
          configObj[key] = value;
        }
    }
    /*disable async function*/
    Lyte.getConfig = function(key){
        var configObj = Lyte.__config;
        if(configObj){
            return configObj[key];
        }
    }
    Lyte.establishWatchScope=function(watchProps,model){
      var scope = this,object;
      for (var v in watchProps){
        var property = v;
        var watch = watchProps[v]
        if(scope.component && scope.component.__data && scope.component.__data[property]){
          object = scope.getData(property);
          watch = scope.component.__data[property].watch ? true : watch;
          if(typeof object == "object"){
            Lyte.establishObjectBinding(scope.component.data,v,false,undefined,undefined,watch)
          }
          var dataDef = scope.component.__data;
          if( Lyte.nestScp[Lyte.__nestScp__.get(object)]){
            // nestScp[__nestScp__.get(object)].dtype.watch = watch;
            dataDef[v].watch = watch;        
          }
        }
        else{
          if(model){
            var fieldList = model.fieldList;
            if(fieldList[v] && fieldList[v].watch == undefined){
              fieldList[v].watch = watch ;
              model._fldGrps.watch[v] = fieldList[v];
            }
          }
        }
      }
    }

    Lyte.checkEstablishingSCP = function(value,path,watch){
      if(Array.isArray(watch)){
          var _path ='';
          _path = path.join(".")
          if(Lyte.checkWatchPath(_path,watch,true) && typeof value != "object"){
              return true
          }
          var _key = Object.keys(value);
          for(var i_scp =0 ; i_scp<_key.length ; i_scp++){
              var spiePath = _key[i_scp];
             var finalaUth =  _path == ""?spiePath : _path+"."+spiePath;
              if(Lyte.checkWatchPath(finalaUth,watch,true)){
                  return true
              }
          }
      }
    }
    Lyte.checkWatchPath=function(actualPath,watchArr,establishBind){
      if(typeof watchArr == "boolean" && watchArr === true){
          return true
      }
      else if(Array.isArray(watchArr)){
          for(var i_watch=0; i_watch < watchArr.length ; i_watch++){
              var path = watchArr[i_watch];
              path =path.replace(/ /g,"");
              path = path.replace(/\$\.\./g,"..");
              path = path.replace(/\$\./g,"")
              var weirdPath = path.search(/\.\./g) != -1 || path.search(/\[|\\]|\{|\}/g)!=-1 ? true : false || path.includes("*");
              if(actualPath == path){
                  return true;
              }
              else if (weirdPath){
                  if(establishBind){
                    if(path.search(/\.\./) != -1 ){
                      path = path.replace(/\.\.\S+/g,"..*")
                      if(path == "..*"){
                        return true;
                      }
                    } 
                  }
                  path = path.search(/\[/) == 0? path.replace("[",""):path;
                  path = path.search(/\.\.\[/)==0 ? path.replace("..[",".."):path
                  path = path.replace(/\.*\[/g,".");
                  path = path.replace(/\]/g,"");
                  var _watchPath = Lyte.checkWeirdPath(path,actualPath);
                  if(_watchPath){
                      return true
                  }
              }
          }
      }
    }
    Lyte.checkWeirdPath=function(watchPath,actualPath){
      if(actualPath == watchPath){
          return true;
      }
      else if(watchPath.includes("..") || watchPath.includes("*")) {
          var cmpPath = watchPath;
          cmpPath = cmpPath.replace(/\*/g, "$$")
          cmpPath = cmpPath.replace(/\.\./g,"::")
          // cmpPath = cmpPath.replace("[","\\[")
          cmpPath = cmpPath.replace(/\./g,"\\.")
          cmpPath=cmpPath.replace(/\:\:/g,"\\.?.*\\.?");
          cmpPath=cmpPath.replace(/\$/g,".*");
          var _wildCard = watchPath.split(".")
          var _wClenght = _wildCard.length;
          if(_wildCard[_wClenght-2] == "" && _wildCard[_wClenght-1]!="*"){
            cmpPath = cmpPath+"$";
          }
          var regularExp = new RegExp(cmpPath);
          if(regularExp.test(actualPath)){
              return true;
          }
          return false;
      }
    }

    var ignoreMut = false;
    Lyte.ignoreMut = function(method){
        ignoreMut = true;
        method();
        ignoreMut = false;
    }    
    
    /*disable async function*/
    var wkMap = new WeakMap();
    /*disable async function*/
    Lyte.mut = function mut(data){
        if(data && data.__ltPrx__){
            return data;
        }
        if(data && wkMap.has(data)){
            return wkMap.get(data);
        }
        if(!data || (data && (data.constructor.name !== "Object" && data.constructor.name !== "Record") && !Array.isArray(data) && !data.__ltPrx__)){
          return data;
      }
        let prxVal =  new Proxy(data, {
          set:function(target, prop, value){
            if(!Array.isArray(target)){
                Lyte.Component.set(target, prop, value);
            }else{
                target[prop] = value;
            }
            return true;
          },
          get:function(target, prop){
            if(prop === "__ltPrx__"){
                return true;
            }
            if(prop === "__target__"){
                return target;
            }
            var value = target[prop];
            if(value && value.__ltPrx__){
                return value;
            }
            if(value && wkMap.has(value)){
                return wkMap.get(value);
            }
            var descriptor = Object.getOwnPropertyDescriptor(target, prop);
            if(value && (value.constructor.name === "Object" || Array.isArray(value) || value && value.$ && value.$.hasOwnProperty("isModified")) && !value.__ltPrx__ && descriptor && descriptor.configurable){
                // path = path || [];
                // path.push(prop);
                // if(Array.isArray(value) && value.model && value.key){
                //     var hmPrx = value.record.$.__hmPrx = value.record.$.__hmPrx || {};
                //     var retVal;
                //     if(!hmPrx[value.key]){
                //         retVal = hmPrx[value.key] = Lyte.mut(value)
                //     }
                //     else{
                //         retVal = hmPrx[value.key]
                //     }
                //     return retVal;
                // }
                let prxVal = Lyte.mut(value);
                wkMap.set(value, prxVal);
                // Object.defineProperty(value, "__mcln__", { value: prxVal});
                return prxVal;
            }
            return value;
          }
        });
        wkMap.set(data, prxVal);
        // Object.defineProperty(data, "__mcln__", { value: prxVal});
        return prxVal;
    
    }
    /*disable async function*/
    Lyte.immut = function immut(data, mp){
        var mp = mp || new WeakMap(), nData;
        if(data && Array.isArray(data)){
            nData = Array.from(data);
        }
        else if(data && typeof data == "object"){
            nData = Object.assign({}, data);
        }
        mp.get(data, nData);
        return new Proxy(data, {
            get:function(data, prop){
                var _obj = mp.get(data), val;
                val = _obj[prop];
                if(val && typeof val == "object" && !mp.has(val)){
                    return Lyte.immut(val, mp);
                }
                return val;
            },
            set:function(data, prop, value){
                var _obj = mp.get(obj);
                // _obj[prop] = value;
                
                Lyte.Component.set(_obj, prop, value);
                return true;
            }
        })
    }
    // Lyte.mut = function mut(data){
    //     if(data && data.__ltPrx__){
    //         return data;
    //     }
    //     if(data && data.__mcln__){
    //         return data.__mcln__;
    //     }
    //     if(!data || (data && !data.constructor.name === "Object" && !Array.isArray(data)) && !value.__ltPrx__){
    //         return data;
    //     }
    //     // parent = parent || data;
    //     let prxVal =  new Proxy(data, {
    //         set:function(target, prop, value){
    //             if(!Array.isArray(target)){
    //                 Lyte.Component.set(target, prop, value);
    //             }else{
    //                 target[prop] = value;
    //             }
    //             return true;
    //         },
    //         get: function(target, prop){
    //             if(prop === "__mcln__"){
    //                 debugger
    //                 return target[prop];
    //             }
    //             if(prop === "__ltPrx__"){
    //                 return true;
    //             }
    //             if(prop === "__target__"){
    //                 return target;
    //             }
    //             var value = target[prop];
    //             if(value && value.__mcln__){
    //                 return value.__mcln__;
    //             }
    //             var descriptor = Object.getOwnPropertyDescriptor(target, prop);
    //             if((value && value.$ && value.$.hasOwnProperty("isModified") && value.$.getProxy)){
    //                 let prxVal = value.$.getProxy();
    //                 return prxVal;
    //             }
    //             else if(value && (value.constructor.name === "Object" || Array.isArray(value)) && !value.__ltPrx__ && descriptor && descriptor.configurable){
    //                 // path = path || [];
    //                 // path.push(prop);
    //                 if(Array.isArray(value) && value.model && value.key){
    //                     var hmPrx = value.record.$.__hmPrx = value.record.$.__hmPrx || {};
    //                     var retVal;
    //                     if(!hmPrx[value.key]){
    //                         retVal = hmPrx[value.key] = Lyte.mut(value)
    //                     }
    //                     else{
    //                         retVal = hmPrx[value.key]
    //                     }
    //                     return retVal;
    //                 }
    //                 let prxVal = Lyte.mut(value);
    //                 Object.defineProperty(value, "__mcln__", { value: prxVal});
    //                 return prxVal;
    //             }
    //             return value;
    //         }
    //     });
    //     Object.defineProperty(data, "__mcln__", { value: prxVal});
    //     return prxVal;
    // }
    Object.defineProperty(Lyte, "__gl__", {
      value: {}
    });
    Lyte.__gl = Lyte.__gl__;
})(_Lyte);
;(function(window) { //latest
	function Router(routes) {
	  /*-----------string declaration starts------------*/
		var functionStr = "function",
		routeStr = "route",
		TransitionStr = "Transition",
		pendingStr = "pending",
		completedStr = "completed",
		abortedStr = "aborted",
		TransitionAbortedStr = TransitionStr+" "+abortedStr+".",
		TransitionResumedStr = TransitionStr+" resumed.",
		TransitionPausedStr = TransitionStr+" paused.",
		TransitionComletedStr = TransitionStr+" "+completedStr+".",
		parseRouteMappingStr = "parseRouteMapping",
		constructRunLoopStr = "constructRunLoop",
		RouteTransitionStr = "Route"+TransitionStr,
		getDependenciesStr = "getDependencies",
		getResourcesStr = "getResources",
		beforeStr = "before",
		afterStr = "after",
		beforeModelStr = beforeStr+"Model",
		modelStr = "model",
		afterModelStr = afterStr+"Model",
		redirectStr = "redirect",
		renderTemplateStr = "renderTemplate",
		afterRenderStr = afterStr+"Render",
		beforeExitStr = beforeStr+"Exit",
		didDestroyStr = "didDestroy",
		willTransitionStr = "will"+TransitionStr,
		didTransitionStr = "did"+TransitionStr,
		onErrorStr = "onError",
		beforeLoadStr = "beforeLoad",
		onBeforeLoadStr = "onBeforeLoad",
		beforeRouteTransitionStr = beforeStr+"Route"+TransitionStr,
		afterRouteTransitionStr = afterStr+"Route"+TransitionStr,
		beforeTemplateDestroyStr = beforeStr+"TemplateDestroy",
		resourcesStr = "resources",
		dependenciesStr = "dependencies",
		ltPropStr = "lt-prop",
		pReplace = ltPropStr+"-replace",
		startHFromStr = "start-from",
		pStartFrom = ltPropStr+"-"+startHFromStr,
		pRoute = ltPropStr+"-"+routeStr,
		pFragment = ltPropStr+"-fragment",
		pDp = ltPropStr+"-dp",
		pQp = ltPropStr+"-qp",
		pTd = ltPropStr+"-td",
		pTrans = ltPropStr+"-trans",
		refreshHRouteStr = "refresh-"+routeStr,
		pRefreshRoute = ltPropStr+"-"+refreshHRouteStr,
		linktoStr = "link-to",
		LINKTOStr = "LINK-TO",
		stateChangeStr = "stateChange",
		dependencyRequestLog = 'Requesting files in '+getDependenciesStr+' will stall execution of route till download completes. Please validate files '+beforeStr+' requesting.',
		renderTemplateWarning = renderTemplateStr+" hook should return either component or HTML. Rendering of HTML directly into the DOM within the "+renderTemplateStr+" hook is deprecated.",
		addRoutesWarning = "addRoutes function will be deprecated from next version",
		ltPropWarning = "Error while parsing ltProp in "+linktoStr,
		/*-----------string declaration ends------------*/
		fontColor = 'MediumOrchid',
		newTransInfo,
		newTransInfoClone,
		newTransInfoTimer,
		t = Lyte.time,
		log = Lyte.log,
		parse = JSON.parse,
		LR = this,
		d = document,
		dloc = d.location,
		config = {
			routeHash : {},
			urlCache : {},
			stickyRoutes : {},
			allLinks : {},
			activeLinkTags : []
		},
		trans,
		prevTrans,
		newTrans,
		visibleTrans,
		historyObj,
		initialLoad = true,
		allowHistoryChange = false,
		historyLength = getMeta() ? getMeta().index : 0,
		fromHistoryGo = false,
		routeParser,
		processedDispatch,
		Processed,
		
		emptyFn = function() {},
		run = {},
		reqestedType = {
			getResources : resourcesStr,
			getDependencies : dependenciesStr
		};

		run[getDependenciesStr] = 
		run[getResourcesStr] = function(hook,index) {
			var routeInstance = this.routes[index],
			fnType = hook == getDependenciesStr ? "loadDependencies" : "loadResources",
			callback = this.R[index][hook];
			routeInstance.__lp[reqestedType[hook]+'Loaded'] = true;
			if(callback && validateTransition(this)) {
				var require = callHookWithoutPromise.call(this,callback,this.routes[index],hook,index,params(index));
				if(require && require instanceof Promise) {
					return require;
				}
				routeInstance.__lp[reqestedType[hook]] = require;
				routeInstance.__lp[reqestedType[hook]+'Loaded'] = !require || !(require.length || typeof require == "object")
				if(require) {
					if(hook == getDependenciesStr) {
						console.warn(dependencyRequestLog);
					}
					routeInstance.__lp[fnType] = function() {
						routeInstance.__lp[fnType] = pendingStr;
					}
					getRequirements.call(this,{reqType : reqestedType[hook],r : routeInstance,  index : index});
				}
			}
			return callHookWithPromise();
		};

		run[beforeModelStr] = 
		run[modelStr] = 
		run[afterModelStr] = function(hook,index) {
			var routeInstance = this.routes[index],
			callback = this.R[index][hook],
			args = [this.R[index][hook],routeInstance,params(index)];
			if(hook == afterModelStr) {
				args.splice(2,0,routeInstance.currentModel);
			}
			if(callback) {
				callback.then = {success : setDataIns, failure : setDataIns};
				function setDataIns(data) {
					routeInstance.$[hook] = data;
					if(hook == modelStr) {
						routeInstance.currentModel = data;
					}
					delete callback.then;
				}
			}
			return callHookWithPromise.apply(this,args);
		};

		run[redirectStr] = function(hook,index) {
			var routeInstance = this.routes[index],
			args = [this.R[index][hook],routeInstance,params(index)];
			args.splice(2,0,routeInstance.currentModel);
			return callHookWithPromise.apply(this,args);
		};

		run[onErrorStr] = function(hook,index,err,state,options) {
			setPendingResume.call(trans,trans.prom);
			trans._trans.triggerEvent(onErrorStr,{error : err,hook : hook});
			var errIns = this.routes[index];
			for(; index >= 0 && !this.aborted && this.paused; index--) {
				var instance = this.routes[index];
				log(onErrorStr+" of "+ instance.routeName,routeStr,fontColor);
				if(callAction.call(this,onErrorStr,index,[err,this._trans,params(index),hook]) == false) {
					break;
				}  
			}
			consoleErrorFromCallback(err,hook,errIns.routeName,state,options);
		};

		run[willTransitionStr] = function(hook,index) {
			if(callAction.call(prevTrans,hook,index,[trans._trans]) == false) {
				removeHook(trans.runLoop.previous,hook);
			}
			return callHookWithPromise();
		};

		run[beforeRouteTransitionStr] = function() {
			if(validateTransition(this)) {
				var pt;
				if(pt = prevTrans && prevTrans._trans) {
					delete pt.abort;
					delete pt.pause;
				}
				var obj = {
					prevTrans : pt,
					trans : trans._trans,
					history : LR.history
				};
				LR[beforeRouteTransitionStr](obj.prevTrans, obj.trans , obj.history);
				trans._trans.triggerEvent(beforeRouteTransitionStr,obj);
				Lyte.triggerEvent(beforeRouteTransitionStr, obj);
			}
			return callHookWithPromise();	
		};

		run[afterRouteTransitionStr] = function(_trans) {
			LR[afterRouteTransitionStr](_trans);
			trans._trans.triggerEvent(afterRouteTransitionStr, {trans : _trans});
			Lyte.triggerEvent(afterRouteTransitionStr, {trans : _trans});
		};

		run[beforeLoadStr] = function(hook,index) {
			var route = this.routes[index],
			loadingTemplate = callHookWithoutPromise.call(this,this.R[index][hook],this.routes[index],hook,index,params(index)),
			outlet;
			if(loadingTemplate && loadingTemplate.outlet && (outlet = getOutlet(loadingTemplate.outlet,route.parent))) {
				if(outlet.childNodes[0]) {
					triggerTemplateDestroy({outlet,route},false);
				}
				if(loadingTemplate.component) {
					var component = d.createElement(loadingTemplate.component);
					setDataInComponent.call(this,component,loadingTemplate.data,routeInstance,hook,index);
					outlet.innerHTML = '';
					outlet.appendChild(routeInstance.component = component);
				} else if(renderTemplate.html) {
					routeInstance.component = undefined;
					outlet.innerHTML = renderTemplate.html;
					var scripts = outlet.getElementsByTagName('script');
					if(scripts.length) {
						scriptExecution(Array.from(scripts),outlet);
					}
				}
			}
			return callHookWithPromise();
		};

		run[onBeforeLoadStr] = function() {
			return new Promise(function(resolve,reject) {
				for(var len = trans.matched.route.length, i=1; i <= len && validateTransition(trans); i++) {
					var l = len-i;
					if(trans.R[l].actions && trans.R[l].actions.onBeforeLoad) {
						console.log(onBeforeLoadStr +' action is depricated. Use beforeLoad callback');
					}
					if((callAction.call(trans,onBeforeLoadStr,l,[params(l)]) == false) || (i == len)) {
						resolve();
						break;
					}
				}
			});
		};

		run[afterRenderStr] =
		run[didTransitionStr] = function(hook,index) {
			return new Promise(function(resolve, reject) {
				var st = setTimeout(function() {
					if(hook == afterRenderStr) {
						var routeInstance = this.routes[index];
						routeInstance.__ltp.rendered =  true;
						callHookWithPromise.call(this,this.R[index][hook],routeInstance,routeInstance.currentModel,params(index),routeInstance.component)
						.then(function(data) {
							if(!trans.routes[index+1]) {
								trans._trans.triggerEvent(afterRenderStr);
							}
							resolve(data);
						}, function(data) {
							reject(data);
						});
					} else {
						run.removeTemplate.call(this);
						if(callAction.call(this,hook,index,[params(index),trans._trans]) == false) {
							removeHook(trans.runLoop.current,hook);
							index = 0;
						}
						resolve();
						if(index == 0) {
							transitionCompleted({state : 200});
						}
					}
				}.bind(this,hook,index),0);
				this.fns.push(st);          
			}.bind(this));
		};

		run[beforeExitStr] = function(hook,index) {
			var prevTransRouteInstance = prevTrans.routes[index],
			callback = prevTrans.R[index][hook];
			return callHookWithPromise.call(this,callback,prevTransRouteInstance,prevTransRouteInstance.currentModel,params(index,prevTrans));
		};

		run[renderTemplateStr] = function(hook,index) {
			var routeInstance = this.routes[index],
			r = this.R[index];
			if(r[hook]) {
				run.removeTemplate.call(this);
				var renderTemplate = callHookWithoutPromise.call(this,r[hook],routeInstance,hook,index,routeInstance.currentModel,params(index));
				if(validateTransition(this)) {
					if(renderTemplate && (routeInstance.outletName = renderTemplate.outlet)) {
						var data = routeInstance.currentModel,
						outlet;
						if(routeInstance.outlet = outlet = getOutlet(renderTemplate.outlet,routeInstance.parent)) {
							var  obj = {
								outlet : renderTemplate.outlet,
								route : routeInstance
							};
							if(renderTemplate.component) {
								if(routeInstance.component && !renderTemplate.reRender && (routeInstance.component.tagName.toLocaleLowerCase() == renderTemplate.component) && routeInstance.outlet == outlet && outlet.contains(routeInstance.component)) {
									setDataInComponent.call(this,routeInstance.component,data,routeInstance,hook,index);
								} else {
									triggerTemplateDestroy(obj,false);
									var component = d.createElement(renderTemplate.component);
									component._route = routeInstance.__lp.objPath;
									setDataInComponent.call(this,component,data,routeInstance,hook,index);
									outlet.innerHTML = '';
									outlet.appendChild(routeInstance.component = component);
								}
							} else if(renderTemplate.html) {
								routeInstance.component = undefined;
								triggerTemplateDestroy(obj,false);
								outlet.innerHTML = renderTemplate.html;
								var scripts = outlet.getElementsByTagName('script');
								if(scripts.length) {
									scriptExecution(Array.from(scripts),outlet);
								}
							}
						}
					} else {
						Lyte.warn(renderTemplateWarning);
					}
				}  
			} else if(validateTransition(this) && this.runLoop.templateToRemove && this.R.length == index+1) {
				run.removeTemplate.call(this);
			}
			return callHookWithPromise();
		};

		function setDataInComponent(component,data,routeInstance,hook,index) {
			if(data) {
				if(typeof data == "object" && !Array.isArray(data)) {
				component.setData(data);
				} else {
					processError.call(this,{stopTrans : true, err :Error(getError(203)).stack,instance :routeInstance,hook : hook,index : index});
				}   
			}
		}
		
		function getOutlet(outlet,parent) {
			var _outlet;
			if(parent) {
				_outlet =  parent.outlet ? parent.outlet.querySelector(outlet) : undefined;
				if(!_outlet) {
				return getOutlet(outlet,parent.parent);
				}
			} else if(!(_outlet = d.querySelector(outlet))) {
				consoleError(428,outlet);
			}
			return _outlet;
		}

		function scriptExecution(scriptNode) {
			for(var i=0,currentScript;currentScript = scriptNode[i];i++) {
				var parent = currentScript.parentNode,
				s = d.createElement("script");
				for(var j = 0,attributes;attributes = currentScript.attributes[j]; j++) {
				s.setAttribute(attributes.name, attributes.value);
				}
				s.innerHTML = currentScript.innerHTML;
				parent.appendChild(s);
				parent.removeChild(currentScript);
			}
		}
		
		run.removeTemplate = function() {
			var arr = this.runLoop.templateToRemove;
			if(!this.cleared) {
				if(prevTrans && arr) {
				templateDelete(arr);
				}
				this.cleared = true;
				if(visibleTrans != this) {
					visibleTrans = this;
				}
				delete this.runLoop.templateToRemove;
				Lyte.removeFromCache();
			}
		};

		function params(index,t) {
			t = t || trans;
			var routeInstance = t.routes[index];
			return {
				queryParams : routeInstance.__ltp.queryParams, 
				dynamicParam : routeInstance.__ltp.dynamicParam
			};
		}

		function validateTransition(trans) {
			return !trans.aborted && !trans.paused;
		}
		
		function addToHistory(obj) {
			var type = obj.replace ? "replaceState" : "pushState",
			url = config.history ? _delimit(shiftBaseURL(obj.url, true)) : '#' + (config.slashAfterHash ? _delimit(obj.url) : (obj.url[0] == "/" && obj.url.length > 1 ? obj.url.substring(1,obj.url.length) : obj.url));
			obj.title = obj.title || d.title;
			/* support for windows, undefined is appended to url */
			var args = [obj.state, obj.title];
			if(url) {
				args.push(url);
			}
			window.history[type].apply(history, args);
		}

		function getMeta() {
			return history.state && history.state.meta;
		}

		function getData() {
			return history.state && history.state.data;
		}

		function getHistoryState(obj) {
			/* 
				state data which needs to be pushed to history. 
				- Matched object is added to process url directly with history back and forward.
				- Index is used to detect browser back or forward.
			*/

			return {
				meta : {
					matched : obj.matched,
					url : obj.url,
					index : obj.fromHistory ? (getMeta() ? getMeta().index : historyLength) : ((obj.replace && getMeta()) ? getMeta().index : (historyLength = historyLength+1))
				},
				data : obj.data
			};
		}

		function getHistoryObj(obj) {
			/* parses history state to history object. */
			if(!LR.history) {
				historyRegistration();
			}
			LR.history.index = obj.state.meta.index;
			LR.history.fromHistory = obj.fromHistory ? (prevTrans ? (prevTrans.stateObj.meta.index < trans.stateObj.meta.index ? 'forward' : 'back') : 'reload') : false;
			allowHistoryChange = true;
			LR.history.state = getData() || {};
			LR.history.initial = initialLoad;
			return LR.history;
		}

		this.configureDefaults = function(options) {
			options = options || {};
			config.history = options.history == "html5";
			config.baseURL = options.baseURL;
			config.slashAfterHash = options.slashAfterHash == undefined ? true : options.slashAfterHash;
			config.deferInit = options.deferInit || false;
			config.preserveUrlOnBrowserNavigation = options.preserveUrlOnBrowserNavigation;
			config.linkActiveClass = options.hasOwnProperty("linkActiveClass") ? options.linkActiveClass : "";
			config.cipher = options.cipher;
			config.queryParamOptions = {
				sticky : options.queryParamOptions && options.queryParamOptions.hasOwnProperty('sticky') ?  options.queryParamOptions.sticky : true
			};
			if(!Lyte.$.prefetchSupport || options.execRouteRequirementsOnDemand == false) {
				Lyte.$.replaceOldInjectResource && Lyte.$.replaceOldInjectResource();
				config.execRouteRequirementsOnDemand = false;
			} else {
				config.execRouteRequirementsOnDemand = true;
			}
			
			this.__lp.config = config;
		}; 

		this.__lp = {
			version : "3.2.7",
			pendingReg : [],
			getDefinition : function(arr,def) {
				if(arr == "*") {
				return config.routes;
				} else {
				def = def || config.routes;
				def = _getObj(arr,def);
				return def && def.__lp && def.__lp.def || undefined;  
				}
			}
		};

		this.configureRoutes = function (map) {
			if(!this.__lp.config) {
				this.configureDefaults();
			}
			parseRouteMapping.call(this, map);
			for(var i = 0,l = this.__lp.pendingReg.length; i < l; i++) {
				registerRoute.apply({},this.__lp.pendingReg[i]);
			}
			this.__lp.pendingReg = [];
			Lyte.domContentLoaded(init);
			this.__lp.routesConfigured = true;
		};

		function init () {
			if(!config.deferInit && LR.init) {
				LR.init();
			}  
		}

		this.init = function(r) {
			delete this.init;
			this.popstate = function(onChangeEvent) {
			   var goValue,
			   url;
			   if(config.preserveUrlOnBrowserNavigation) {
				   if(fromHistoryGo) {
					   fromHistoryGo = false;
					   return;
				   }
				   if(getMeta() && prevTrans && (prevTrans.stateObj.meta.index != getMeta().index)) {
					   fromHistoryGo = true
					   url = getUrlFromMeta(onChangeEvent)
					   goValue = prevTrans.stateObj.meta.index - getMeta().index;
					   history.go(goValue);
				   }
			   }
			   url = url || getUrlFromMeta(onChangeEvent)
			   historyObj = {
				   fromHistory : true,
				   url : url,
				   goValue : goValue
			   };
			   if(onChangeEvent && history.state) {
				   historyObj.data = history.state;
			   }
			   if(trans && !trans.aborted) {
					console.log("aborting from dispatch")
				   trans.abort({state : 308, iAbort : true});
			   }
			   dispatch(url);
		   }
			 window.addEventListener('popstate', this.popstate);
			if(config.history) {
				this.popstate();
			} else {
				historyObj = {
					fromHistory : true,
					url : getLocation()
				};
				dispatch(historyObj.url);
			}
			linkToRegistration();
			return this;
		};

		function getUrlFromMeta(onChangeEvent) {
			var url;
			if(!(getMeta() && (url = getMeta().url))) {
				if(config.history) {
					url = getLocation();
				} else {
					var newURL = onChangeEvent && onChangeEvent.newURL || dloc.hash;
					url = checkForEmptyPath(newURL.replace(/.*#/, ''));
				}  
			}
			return url;
		}
		
		this.beforeScroll = this[beforeRouteTransitionStr] = this[afterRouteTransitionStr] = emptyFn;

		function setRouteDef(dir, value) {
			var cache = config.routes,
			len = dir.length,
			dirLen = len - 1;
			for(var i = 0, key; i < len; i++) {
				key = dir[i];
				if (dirLen === i) {
					var obj = cache[key];
					if (obj && obj.__lp) {
						obj.__lp.def = value;
					} else if (obj) {
						obj.__lp = { def: value };
					} else {
						cache[key] = { __lp: { def: value } };
					}
				} else if (!cache[key]) {
					cache[key] = {};
				}
				cache = cache[key];
			}
		}

	
		function linkToRegistration() {
			class LinkTo extends HTMLElement {
				static get observedAttributes() {
					return [pRoute, pDp, pFragment, pQp, ltPropStr, 'lt-prop-class', 'lt-prop-data-tabindex', 'lt-prop-data-tabindex', 'lt-prop-tabindex','lt-prop-aria-label', 'lt-prop-aria-attributes','lt-prop-id', 'lt-prop-rel', 'lt-prop-title', 'lt-prop-style', 'lt-prop-target'];
				}
				attributeChangedCallback(attr, oldValue, newValue) {
					if(this.matched && this.hasAttribute("lyte-rendered")) {
						let aTag = this.getElementsByTagName('A')[0];
						//If attr is ltProp
						if(aTag) {
							if(attr === ltPropStr) {
								this.handleLtProp();
								if(!this.hasAttribute("lt-prop-custom")) {
									this.setCustomAttributes(aTag, true);
								}
								this.constructHref(aTag);
							} else if(/^(lt-prop-route|lt-prop-fragment|lt-prop-dp|lt-prop-qp)$/.test(attr)) {
								//if it is a route transition attribute
								this.getMatchedObject();
								this.constructHref(aTag, attr, oldValue, newValue);
							} else if(!this.hasAttribute('lt-prop-custom')) {
								//for rest of the attributes
								aTag.setAttribute(attr.substring(8), newValue);
							}
						}
					}
				}

				connectedCallback() {
					this.ltProp = this.ltProp || {};
					this.handleLtProp();
					if(this.hasAttribute("lyte-rendered")) {
						if(this.getElementsByTagName('A')[0] && !this.matched) {
							this.getMatchedObject();
						}
						return;
					} 
					var isCustom = this.hasAttribute("lt-prop-custom") || this.ltProp.custom,
					aTag;
					if(isCustom) {
						if(aTag = this.getElementsByTagName('A')[0]) {
							this.getMatchedObject();
							this.constructHref(aTag);
						}
					} else {
						aTag = d.createElement("a");
						while(this.childNodes[0]) {
							aTag.appendChild(this.childNodes[0]);
						}
						this.setCustomAttributes(aTag);
						this.getMatchedObject();
						this.constructHref(aTag);
						this.appendChild(aTag);
					}
					if(Lyte.Component) {
						this._linkToEventId = Lyte.Component.addLyteEventListener(this, "click", function(event) {
							linkToEventListener(event, this);
						}, this);
					} else {
						this.addEventListener("click", linkToEventListener);
					}
					this.setAttribute("lyte-rendered", "");
				}

				modifyLinkToTagsInRoute(remove) {
					var strRoute = Array.isArray(this.matched.route) ? this.matched.route.join('.') : this.matched.route,
					allLinks = config.allLinks[strRoute];
					if(remove) {
						if(allLinks) {
							let pos = allLinks.indexOf(this);
							if(pos != -1) {
								allLinks.splice(pos,1);
							}
						}
					} else {
						if(allLinks) {
							allLinks.push(this);
						} else {
							config.allLinks[strRoute] = [this];
						}
					}
					if(config.stickyRoutes[strRoute]) {
						let routesObj = config.routes,
						routes;
						if(remove) {
							if(this.matched) {
								routes = remove;
							} else {
								return;
							}
						} else {
							routes = this.matched.route;
						}
						if(!routes) {
							return;
						} 
						routes = Array.isArray(routes) ? routes : dotSerperator(routes);
						for(var i = 0,l = routes.length,r; i < l; i++) {
							r = routes[i];
							routesObj =  _getObj(r,routesObj);
							if(!routesObj || !routesObj.__lp) {
								consoleError(422,routes,i);
								return false;
							}
							var def = routesObj.__lp.def.__lp;
							if(remove) {
								let pos = def.stickyLinks.indexOf(this);
								if(pos !== -1) {
									def.stickyLinks.splice(pos,1);
								}
							} else if(def.qpdef) {
								def.stickyLinks.push(this);  
							}
						}
					}
				}

				disconnectedCallback() {
					let m = this.modifyLinkToTagsInRoute.bind(this);
					if(!Lyte.Component.shouldIgnoreDisconnect()) {
						if(this.matched && this.matched.route) {
							m(this.matched.route);
						}
						if(this._linkToEventId) {
							Lyte.Component.removeLyteEventListener(this, this._linkToEventId);
						}
					}
				}
				
				handleLtProp() {
					var ltProp = this.getAttribute(ltPropStr);
					if(ltProp) {
						try{
							this.ltProp = parse(ltProp);
						} catch(e) {
							Lyte.warn(ltPropWarning);
						}
					}
				}

				setCustomAttributes(linkTag, onlyLtProp) {
					for(let key in this.ltProp) {
						if(/^(id|class|style|target)$/.test(key)) {
							linkTag.setAttribute(key, this.ltProp[key]);
						}
					}
					if(!onlyLtProp) {
						for(let i=0,attr,attrName; attr = this.attributes[i]; i++) {
							if((attrName = attr.nodeName) !== ltPropStr && /^(lt-prop-id|lt-prop-rel|lt-prop-class|lt-prop-style|lt-prop-target|lt-prop-tabindex|lt-prop-aria-label|lt-prop-aria-attributes)$/.test(attrName)) {
								linkTag.setAttribute(attrName.substring(8), attr.nodeValue);
							}
						}
					}
				}

				constructHref(linkTag, attr, oldValue) {
					var href,
					m = this.modifyLinkToTagsInRoute.bind(this);
					if(href = LR.getURL.call(this,this.matched)) {
						linkTag.setAttribute("href", href); 
						if(attr === pRoute) {
							m(oldValue);
							m();
						} else {
							m();
						}
					}
				}
			}

			LinkTo.prototype.getMatchedObject = function() {
				var matched = this.matched || {},
				ga = this.getAttribute.bind(this),
				dynamicParams = ga(pDp) || this.ltProp.dp || [],
				queryParams = ga(pQp) || this.ltProp.qp || {};
				if(!(dynamicParams instanceof Array)) {
					try {
						dynamicParams = parse(dynamicParams);  
					} catch(e) {
						consoleError(498,"dynamicParams",this.outerHTML);
						return;
					}
				}
				if(!(queryParams instanceof Object)) {
					try{
						queryParams = parse(queryParams);
						if(Array.isArray(queryParams)) {
							consoleError(498,"queryParams",this.outerHTML);
							return;
						}
					} catch(e) {
						consoleError(498,"queryParams",this.outerHTML);
						return;
					}
				}
				matched.route = ga(pRoute) || this.ltProp.route;
				matched.fragment = ga(pFragment) || this.ltProp.fragment;
				matched.dynamicParams = dynamicParams || [];
				matched.queryParams = queryParams || {};
				matched.refreshRoute = ga(pRefreshRoute) != undefined ? ga(pRefreshRoute) : this.ltProp[refreshHRouteStr];
				matched.refreshRoute = (matched.refreshRoute == "" || matched.refreshRoute == 'true') ? matched.route : matched.refreshRoute;
				matched.startFrom = ga(pStartFrom) || this.ltProp[startHFromStr];
				return this.matched = matched;
			};
			customElements.define(linktoStr, LinkTo);
		}
	
		function linkToEventListener(event, linkTo) {
			if(event.button == 2 || event.defaultPrevented) {
				return;
			}
			var targetElem = linkTo || event.currentTarget;
			if(targetElem.children[0].tagName === "A" && (event.ctrlKey == true || event.metaKey == true || event.which == 2 || (targetElem.children[0].hasAttribute("target") && targetElem.children[0].getAttribute("target") !== "_self")) ) {
				return;  
			}
			event.preventDefault();
			if(!targetElem.matched) {
				targetElem.getMatchedObject();
			}
			var matched = Object.assign({},targetElem.matched);
			matched.route = Array.isArray(matched.route) ? matched.route.join('.') : matched.route;
			var replace = targetElem.ltProp.replace  || targetElem.hasAttribute(pReplace),
			transitionInstance = LR[replace && replace != "false" ? "replaceWith" : "transitionTo"](targetElem.matched);
			var transObj = {},
			transProp;
			if(transProp = targetElem.getAttribute(pTrans)) {
				try{
					transObj = parse(transProp);  
				} catch(e) {
					consoleError(498, pTrans, linkTo.outerHTML);
				}
			}
			let transitionData = targetElem.getAttribute(pTd);
			if(transitionData = (transitionData || transObj.data)) {
				if(typeof transitionData === "string") {
					try {
						transitionData = parse(transitionData);
					} catch(e) {
						consoleError(498, pTd , linkTo.outerHTML);
					}
				}
				transObj.data = transitionData;
			}
			for(var key in transObj) {
				transitionInstance[key] = transObj[key];
			}
		}
	
		this.checkIfSameRoute = function(transInfo1, transInfo2) {
			if(transInfo1.route == transInfo2.route && transInfo1.fragment == transInfo2.fragment && transInfo1.dynamicParams.length === transInfo2.dynamicParams.length && _compareObj(transInfo1.queryParams,transInfo2.queryParams)) {
				return checkIfSameDp(transInfo1.dynamicParams, transInfo2.dynamicParams)
			}
			return false;
		};

		function checkIfSameDp(dp1, dp2) {
			if(dp1.length) {
				for(var i = 0,dp; dp = dp1[i]; i++) {
					if(dp != dp2[i]){
						return false;
					}
				}
			}
			return true;
		}

		function convertMatchedObjToRouteInfo(matched) {
			var info = {
				route : matched.route.join("."),
				fragment : matched.fragment,
				dynamicParams : matched.dynamicParams.filter(_arrayClean),
				queryParams : matched.queryParams

			};
			return info;
		}
	
		this.addRoutes = function(map, route) { 
			var clr = setInterval(function() {
				if(Lyte.Router.__lp.routesConfigured) {
					clearInterval(clr);
					Lyte.warn(addRoutesWarning);
					var routeArr = route ? route.split(".") : [],
					routes = _getObj(routeArr, config.routes);
					if(!routes) {
						console.error(route+" is not specified in router map.");
						return;
					}
					Object.assign(routes,parseRouteMapping.call(routeParser,map));
				}
			},0);
		};
	
		function dotSerperator(str) {
			return str.split('.').filter(function(s) {return s != "";});
		}
		
		function _arrayClean(e) {
			return e != undefined;
		}
	
		function parseRouteMapping(map) {
			t(parseRouteMappingStr);
			var routesObj = config.routes ? config.routes : (config.routes = {}),
			mapObj = {}, 
			pathStringArr = [], 
			routeStringArr = [];
			routeParser = {
			route : function(routeName,obj,nestedFn) {
				if(typeof obj == "object") {
				if(!obj.path) {
					obj.path = _delimit(routeName);
				} else {
					if(_presence(obj.path,"?")) {
					var split = obj.path.split('?');
					obj.defQP = frameQueryParams(split[1]);
					obj.path = split[0] || "/";
					}  
				}
				if(obj.queryParams) {
					obj.defQP = obj.queryParams;
				}
				} else {
				if(typeof obj == functionStr) {
					nestedFn = obj;
				}
				obj = {path : _delimit(routeName)};  
				}
				mapObj = _getObj(pathStringArr,config.routeHash)[obj.path] = {__lp : {}};
				if(obj.path == '/') {
				pathStringArr.push('/');
				} else {
				var trimedPath = obj.path;
				if(dynamicRouteCheck(trimedPath) || wildcardRouteCheck(trimedPath)) {
					_splitPath(trimedPath).every(function(seg,index,arr) {
					if(dynamicRouteCheck(seg) || wildcardRouteCheck(seg)) {
						var dkey;
						if(dynamicRouteCheck(seg)) {
						dkey = seg.replace(":","");
						} else  {
						dkey = seg.replace("*","");
						obj.wildcard = mapObj.__lp.wildcard = true;
						obj.sufix = mapObj.__lp.sufix = [];
						for(var i = index+1,j; j = arr[i]; i++) {
							mapObj.__lp.sufix.push(j);
						}
						}
						obj.dkey = mapObj.__lp.dkey = dkey;
						obj.dIndex = mapObj.__lp.dIndex = index;
						return false;
					}
					return true;
					});
				} 
				pathStringArr.push(trimedPath);
				}
				var routes = _getObj(routeStringArr,routesObj) || routesObj;
				routeStringArr.push(routeName);
				mapObj.__lp.route = Array.from(routeStringArr);
				routes[routeName] ? (Object.assign(routes[routeName].__lp,obj)) : (routes[routeName] = {__lp : obj});
				if(nestedFn) {
				nestedFn.call(this,{});
				}
				routeStringArr.pop();
				pathStringArr.pop();
			}
			};
			map.call(routeParser,{});
			t(parseRouteMappingStr);
			return routesObj;
		}
	
		this.replaceWith = function() {
			var args = normalizeMatchedObj.call(this,normalizeTransitionParams.apply(this,arguments));
			if(args) {
			args.matched.replace = true;
			return routeTransition(args);   
			}
		};
	
		this.transitionTo = function() {
			var processed;
			if(processed = normalizeMatchedObj.call(this,normalizeTransitionParams.apply(this,arguments))) {
			return routeTransition(processed);  
			}
		};
	
		this.getURL = function (matched) {
			if(matched) {
				if(!matched.route) {
					matched = normalizeTransitionParams.apply(this,arguments)
				} else if(!matched.queryParams) {
					matched.queryParams = {}
				}
				var url,
				l,
				linkTo = this.tagName == LINKTOStr,
				cache = config.urlCache,
				matchedCache,
				sticky = config.queryParamOptions.sticky;
				if(!sticky && (matchedCache = cache[Array.isArray(matched.route) ? matched.route.join('.') : matched.route])) {
					url = matchedCache.url;
					if(l = matched.dynamicParams && matched.dynamicParams.length) {
						for(var i = 0; i < l; i++) {
							url = url.replace('<<dp>>',matched.dynamicParams[i]);	
						}
					} else if(url.indexOf('<<dp>>') != -1) {
						consoleError(499,matched.route,linkTo ? this : undefined);
					}
					for(var key in matchedCache.defQP) {
						if(!matched.queryParams[key] && matchedCache.defQP[key]) {
							matched.queryParams[key] = matchedCache.defQP[key];
						}
					}
					url = appendQueryParamsAndFrag(url,matched);
				} else {
					if(linkTo) {
						url = constructURLFromRoute.apply(this,arguments);
					} else {
						url = constructURLFromRoute.call(this,matched);
					}
				}
				if(url) {
					url = config.history ? shiftBaseURL(url, true) : '#'+url;
					return url;
				}
			}
		};
	
		this.getRoute = function(url) {
			var matched = traverse(shiftBaseURL(url),true);
			if(matched) {
			matched.dynamicParams = matched.dynamicParams.filter(_arrayClean);
			matched.route = matched.route.join('.');
			}
			return matched;  
		};
	
		function routeTransition(processed) {
			if(LR.init) {
				consoleError(405);
				return 
			}
			var matched = processed.matched,
			currRoute;
			processed.currRoute = currRoute = matched.route.join('.');
			matched.refreshRoute && currRoute == prevTrans.info.route;
			newTransInfo = {
				replace : matched.replace || (matched.refreshRoute && LR.checkIfSameRoute(convertMatchedObjToRouteInfo(processed.matched),convertMatchedObjToRouteInfo(prevTrans.matched)) ? true :  matched.replace),
				title : trans ? trans.title : d.title,
				fromHistory : false
			};
			var url = dispatchTransition(processed);
			if(url && newTrans) {
				log('Transitioning to '+currRoute+' '+url,routeStr);
				return newTrans._trans;  
			} else {
				log('Transition failed')
				return {};
			}
		}
	
		function getLocation() { 
			if(config.history) {
				var path = checkForEmptyPath(dloc.pathname + dloc.search + (dloc.hash || ""));
				path = shiftBaseURL(path);
				return _delimit(path);  
			} else {
				return _delimit(checkForEmptyPath(dloc.hash.replace('#','')));
			}
		}
	
		function checkForEmptyPath(path) {
			if(!path) {
				path = '/'
			}
			return path;
		}
	
		function shiftBaseURL(path,append) {
			var baseURL;
			if((baseURL = config.baseURL) && path) {
			baseURL = _delimit(baseURL);
			if(path.indexOf(baseURL) == 0 && !append) {
				return path.replace(baseURL,'');
			} else if(append && path.indexOf(baseURL) != 0) {
				return baseURL+path;
			} 
			} 
			return path;
		}
	
		function constructURLFromRoute(matched) {
			if(matched && matched.route) {
				var strRoute;
				if(!Array.isArray(matched.route)) {
					matched.route = dotSerperator(strRoute = matched.route);
				} else {
					strRoute = matched.route.join('.')
				}
				matched.queryParams = matched.queryParams || {};
				matched.dynamicParams = matched.dynamicParams || [];
				matched.refreshModel = false;
				var url,
				sameRoute = !!trans,
				dynamicPos = matched.dynamicParams.length != matched.route.length,
				dynamicParamPos = 0,
				linkTo = this.tagName == LINKTOStr,
				routeObj = config.routes,
				templateUrl = url = '',
				defQPTemp = {},
				route;
				for(var i = 0, l = matched.route.length; i < l; i++) {
					route = matched.route[i];
					if(sameRoute && trans.matched.route[i] != route) {
						sameRoute = false;
					}
					routeObj = _getObj(route,routeObj);
					if(!routeObj && !routeObj.__lp && routeObj.__lp.path) {
						consoleError(422,matched.route,i);
						return false;
					}
					var def = routeObj.__lp.def;
					if(!def && !linkTo) {
						consoleError(422,matched.route,i);
					}
					var path = routeObj.__lp.path,
					defaultQP;
					if(!def || !def.__lp) {
						if(defaultQP = routeObj.__lp.defQP) {
							for(var key in defaultQP) {
								if(matched.queryParams && !matched.queryParams.hasOwnProperty(key)) {
									matched.queryParams[key] = defaultQP[key];
								} 
							}
						}
					} else if(def.queryParams) {
						defaultQP = routeObj.__lp.defQP;
						var qpdef = def.__lp.qpdef;
						for(var key in qpdef) {
							if(!matched.queryParams.hasOwnProperty(key)) {
								if(sameRoute && qpdef[key].sticky) {
									matched.queryParams[key] = trans.routes[i].__ltp.queryParams[key];
								} else if(defaultQP && defaultQP.hasOwnProperty(key)) {
									defQPTemp[key] = matched.queryParams[key] = defaultQP[key];
								}
							}
							if(constructURLFromRoute.caller.name != "pathProcessor" && qpdef[key].cipher && config.cipher.encryptor) {
								matched.queryParams[key] = config.cipher.encryptor(matched.queryParams[key]);
							}
							if(!linkTo && !matched.refreshModel && qpdef[key].refreshModel) {
								matched.refreshModel = true;
							}
						}
					}
					if(routeObj.__lp.dkey) {
						var dynamicPathSplit = _splitPath(path),
						dynamicPathSplitTemp = _splitPath(path),
						pos = dynamicPos ? dynamicParamPos : i;
						if(!matched.dynamicParams || !matched.dynamicParams[pos]) {
						consoleError(499,route,linkTo ? this : undefined);
						return false;   
						} else {
							dynamicPathSplit[routeObj.__lp.dIndex] = encodeURI(matched.dynamicParams[pos]);
							dynamicPathSplitTemp[routeObj.__lp.dIndex] = _delimit('<<dp>>');
							templateUrl += _delimit(dynamicPathSplitTemp.join('/')); 
							url += _delimit(dynamicPathSplit.join('/')); 
							dynamicParamPos++;
						} 
					} else {
						templateUrl += _delimit(path);
						url += _delimit(path);
					}
				}
				if(!config.stickyRoutes[strRoute]) {
					config.urlCache[strRoute] = {url : validateURL(templateUrl), defQP : defQPTemp};
				}
				return appendQueryParamsAndFrag(url,matched);
			}
		}
		
		function appendQueryParamsAndFrag(url,matched) {
			url = url[url.length-1] == '/' && url.length != 1 ? url.slice(0,-1) : url;
			if(matched.queryParams) {
				var ques = true;
				for(var key in matched.queryParams) {
					if(matched.queryParams[key] != undefined) {
						if(ques) {
							url += '?';
							ques = false
						} else {
							url += '&';
						}
						url+= key+'='+encodeURIComponent(matched.queryParams[key]);  
					}
				}
			}
			if(config.history && matched.fragment) {
			url = url+"#"+matched.fragment;
			}
			return validateURL(url);
		}
	
		function historyRegistration() {
			LR.history = new History();
			function History() {
			return this;
			}
	
			Object.defineProperty(History.prototype, 'state', {
			get : function() {
				return getData();
			},
			set : function(data) {
				if(allowHistoryChange) {
				allowHistoryChange = false;
				} else {
				Lyte.warn('setting on data will not be pushed to history. If needed, use `LR.history.replaceState`.');
				}
				return data;
			}
			});
	
			History.prototype.replaceState = function() {
				stateChange.apply(Array.from(arguments).push(true));
			};
	
			History.prototype.pushState = function() {
				stateChange.apply(Array.from(arguments));
			};
	
			function stateChange(data,title,url,replace) {
				if(!replace) {
					getMeta().index++;
				}
				addToHistory({
					state : {
						meta : getMeta(),
						data : data
					},
					title: title, 
					url: url
				});
			}
		}  
	
		var invokeRunLoop;
		function dispatch(path, processed, data) {
			t(RouteTransitionStr);
			if(path && config.baseURL && d.location.pathname.indexOf(config.baseURL) == -1) {
				consoleError(400);
				return;
			}
			processed = processed || (!initialLoad && getMeta() && getMeta().matched && getMeta().url == getLocation() ? normalizeMatchedObj(getMeta().matched) : traverse(path));
			if(processed && processed.matched.route.length) {
			clearTimeout(invokeRunLoop);
			processed.prevTrans = processed.prevTrans || Lyte.Router.__lp.prevTrans;
			processed.path = processed.path || path;
			processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched,processed.R);
			invoke(Processed = processed);
			Lyte.triggerEvent("transitionStart", {prevTrans : prevTrans && prevTrans._trans, nextTrans : newTrans._trans});
			invokeRunLoop = setTimeout(function() {
				Processed = undefined;
				if(trans && trans.state == 102 && newTrans && LR.checkIfSameRoute(newTrans.info,trans.info) && !trans.aborted && JSON.stringify(trans._data) == JSON.stringify(newTrans._trans.data)) {
					if(trans.iPause == true) {
						trans.resume();    
					}
					return;
				} else if(trans && trans.state == 102) {
					trans.abort({state : 409}); 
				}
				trans = newTrans;
				trans._data = trans._trans.data ? Lyte.deepCopyObject(trans._trans.data) : undefined;
				processed.previous = true;
				trans.transComp = processed.transComp;
				// trans.transComp = processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched,processed.R);
				trans.runLoop = constructRunLoop(processedDispatch = processed);
				if(trans._trans.data) {
					newTransInfo.data = trans._trans.data;
				}
				newTransInfo.state = trans.stateObj = getHistoryState({
					replace : newTransInfo.replace,
					data : newTransInfo.data,
					url : trans.url,
					matched : trans.matched,
					fromHistory : newTransInfo.fromHistory
				});
				getHistoryObj(newTransInfo);
				trans.run();
			},0);
			} 
		}
	
		function getTransitionDiffernce(prevTrans, matched, R) {
			var like = true,
			similar = true,
			rendered = [],
			common = [],
			unRendered = [],
			templateToRemove,
			currRoute = matched.route.join('.'),
			r,
			tar = "";   
	
			if(prevTrans) {
				var prevMatched = prevTrans.matched,
				route,
				startFrom = matched.refreshRoute && currRoute == prevTrans.info.route ?  matched.refreshRoute : matched.startFrom;
				for(var i = 0, l = matched.route.length; i < l; i++) {
					route = matched.route[i];
					tar = tar + (tar ? "." : "") + route;
					if(similar && route == prevMatched.route[i] && (!startFrom || tar != startFrom)) {
						r = R ? R[i] : LR.__lp.getDefinition(route.slice(0,i));
						if(like && compareRoute(r,i,prevMatched,matched)) {
							common.push(route);
							if(prevTrans.routes[i].__ltp.rendered) {
								rendered.push(route);  
							} else {
								// like = false; dont change this code. It is commented for decideTransition function
								unRendered.push(route);  
							}
						} else {
							like = false;
							unRendered.push(route);
						}
					} else {
						similar = false;
						if(templateToRemove == undefined && prevTrans.routes[i] && prevTrans.routes[i].__ltp.rendered && prevTrans.routes[i].outlet) {
							templateToRemove = i;
						}
						unRendered.push(route);
					}
				}
				if(prevMatched.route.length > matched.route.length) {
					var index = matched.route.length;
					if(templateToRemove == undefined && prevTrans.routes[index].__ltp.rendered /* && prevTrans.routes[i].outlet */) {
						templateToRemove = index;
					}
				}
			} else {
				unRendered = unRendered.concat(matched.route);
			}
			return {
			rendered : rendered,
			unRendered : unRendered,
			common : common,
			templateToRemove : templateToRemove
			};
		}
	
		function compareRoute(r,index,prevMatched,matched) {
			var same = true,
			routeObj = _getObj(r.__lp.objPath,config.routes);
			if(!r.queryParams && !routeObj.__lp.dkey) {
				return true;
			}
			if(routeObj.__lp.dkey && prevMatched.dynamicParams[index] != matched.dynamicParams[index]) {
				return false;
			} else if(r.queryParams && matched.refreshModel) {
				r.queryParams.every(function(key) {
					if(same && r.__lp.qpdef[key].refreshModel && (matched.queryParams || prevMatched.queryParams) && matched.queryParams[key] != prevMatched.queryParams[key]) {
					return same = false;
					} else {
					return true;
					} 
				});
			}
			return same;
		}
	
		var basicHooks = [beforeModelStr,modelStr,afterModelStr,redirectStr,renderTemplateStr,afterRenderStr];
		function constructRunLoop(processed) {
			t(constructRunLoopStr);
			var transComp = processed.transComp,
			runLoop = [],
			forceFetch = {},
			beforeLoad = [],
			req = [],
			b4Exit = [],
			willTransit = [],
			didTransit = [];
	
			if (processed.previous) {
				var b4RouteTrans = [{hook : beforeRouteTransitionStr}];
				if(prevTrans) {
					for(var i = prevTrans.matched.route.length-1,r;r = prevTrans.matched.route[i]; i--) {
						var r1 = trans.matched._routes[i];
						if(!r1 || (r1.join('.') != prevTrans.matched._routes[i].join('.'))) {
							b4Exit.push({hook : beforeExitStr, index : i});
						}
						willTransit.push({hook : willTransitionStr, index : i});
					}
					t(constructRunLoopStr);
					return {previous : willTransit.concat(b4RouteTrans).concat(b4Exit) ,current : b4Exit};
				}
				t(constructRunLoopStr);
				return {previous : b4RouteTrans};
			}
			if(transComp.rendered && transComp.rendered.length) {
				transComp.rendered.forEach(function(hook,index) {
					trans.routes[index].__ltp.rendered = true;
					runLoop.push({hook : redirectStr,index : index});
					didTransit.push({hook : didTransitionStr,index : trans.matched.route.length-index-1});
				});
			}
			if(transComp.unRendered && transComp.unRendered.length) {
				// beforeLoad.push({hook : beforeLoadStr, index : transComp.rendered.length});
				transComp.unRendered.forEach(function(hook,orgIndex) {
					var index = transComp.rendered.length+orgIndex;
					if(!transComp.redirected || (transComp.redirected && transComp.redirected.index != index)) {
						beforeLoad.push({hook : beforeLoadStr, index});
						req = req.concat([{hook : getDependenciesStr, index},{hook : getResourcesStr, index }]);
					}
					var routeInstance = trans.routes[index];
					if(typeof routeInstance.forceFetch == functionStr ? callHookWithoutPromise.call(this,routeInstance.forceFetch,routeInstance,"forceFetch",index,params(index)) : routeInstance.forceFetch) {
						forceFetch[index] = [
							{hook : beforeModelStr, index : index},
							{hook : modelStr, index : index},
							{hook : afterModelStr, index : index}
						];
						newTrans.routes[index].__ltp.fetchStatus = pendingStr;
						[redirectStr,renderTemplateStr,afterRenderStr].forEach(function(h) {
							runLoop.push({hook : h,index : index});
							if(h == renderTemplateStr && transComp.unRendered[orgIndex+1]) {
								runLoop.push({hook : beforeLoadStr,index : index+1});
							}
						});
					} else {
						basicHooks.forEach(function(h) {
							if(transComp.redirected && transComp.redirected.index == index && h != redirectStr) {
								if([beforeModelStr,modelStr,afterModelStr].indexOf(h) == -1) {
									runLoop.push({hook : h,index : index});
								}
								if(h == renderTemplateStr && transComp.unRendered[orgIndex+1]) {
									runLoop.push({hook : beforeLoadStr,index : index+1});
								}
							} else {
								runLoop.push({hook : h,index : index});
								if(h == renderTemplateStr && transComp.unRendered[orgIndex+1]) {
									runLoop.push({hook : beforeLoadStr,index : index+1});
								}
							}
						});  
					}
					didTransit.push({hook : didTransitionStr,index : trans.matched.route.length-index-1});
				});
			}
			
			runLoop = {
				previous : [],
				current : [{hook : onBeforeLoadStr}].concat(beforeLoad).concat(req.concat(runLoop).concat(didTransit)),
				forceFetch : forceFetch
			};
			runLoop.templateToRemove = (prevTrans && prevTrans.runLoop.templateToRemove) ? prevTrans.runLoop.templateToRemove : [];
			if(transComp.templateToRemove != undefined) {
			runLoop.templateToRemove.push({index : transComp.templateToRemove, routes : visibleTrans.routes});
			}
			t(constructRunLoopStr);
			return runLoop;
		}
	
		function invoke(processed) {
			newTrans = new Transition(processed);
			newTrans._processed = processed
			newTrans.url = processed.path;
			newTrans.runLoop = {};
			newTrans._trans = limitTransition(newTrans);
			Lyte.extendEventListeners(newTrans._trans);
			newTrans.routes = initRoute(processed);
			if(historyObj) {
				newTransInfo = historyObj;
				newTransInfo.url = processed.path;
				newTrans._trans.data = getData() || {};
				newTransInfo.replace = true;
				historyObj = undefined;
			} else if(newTrans._trans.data) {
				LR.history.replaceState(newTrans._trans.data);
			}
		}
	
		function _getObj(arr,obj) {
			if(!obj) {
			return;
			} else if(!arr) {
			return obj;
			} else if(!Array.isArray(arr) && typeof arr == 'string') {
			arr = dotSerperator(arr);
			}
			arr.every(function(key)  {
			if(obj && obj[key]) {
				obj = obj[key];
				return true;
			}
			return obj = false;
			});
			return obj;
		}
	
		function abortRunningPromises(trans) {
			if(trans.runningProm) {
				trans.runningProm.reject(abortedStr);  
			}
			if(trans.fRunningProm) {
				trans.fRunningProm.reject(abortedStr);   
			}
		}
	
		var transId = 0;
		function Transition(processed) {
			this.transId = transId = transId+1;
			this.matched = processed.matched;
			this.target = processed.matched.target;
			this.fns = [];
			this.pending = {
				dependencies : new Set(),
				resources : new Set(),
				forceFetch : new Set()
			};
			this.info = {
				route : processed.matched.target,
				queryParams : processed.matched.queryParams,
				dynamicParams : processed.matched.dynamicParams.filter(_arrayClean)
			};
			if(processed.matched.fragment) {
				this.info.fragment = processed.matched.fragment;
			}
			this.R = processed.R;
			this.running = this.aborted = this.paused = false;
			this.abort = function(obj) {
				if(newTransInfo && newTransInfo.goValue) {
					fromHistoryGo = false;
				}
				this.abort = emptyFn;
				abortRunningPromises(this);
				this.aborted = true;
				if(!obj) {
					obj = {state : 308};
				} 
				if(this.running) {
					log(TransitionAbortedStr,routeStr);
				}
				// if(this.running && newTransInfo && !newTransInfo.replace) {
				// 	historyLength--;
				// }
				if(!obj.iAbort) {
					delete this.runLoop.templateToRemove;
					// if(prevTrans && prevTrans.url != getLocation() && this.state == 201) {
					// if(prevTrans && visibleTrans && prevTrans.url != getLocation() && trans != visibleTrans) {
						// fromHistoryGo = true;
						// if(getMeta() && getMeta().index != undefined && getMeta().index+1 == history.length) {
						// 	history.go(1);
						// } else {
						// 	history.go(-1);
						// }
					// }  
				}
				transitionCompleted(obj);
			}.bind(this);
			this.pause = function (obj) {
			log(TransitionPausedStr, routeStr);
			if (obj && obj.iPause) {
				this.iPause = true;
			} else {
				this.iPause = false;
				this.state = this._trans.state = 307;
				this._trans.triggerEvent(stateChangeStr,this.state);
			}
			this.paused = trans.prom || true;
			this.resume = this._trans.resume = function (t) {
				t = t || this;
				if (t.prom != t.eProm) {
					if (!t.pendingResume) {
						t.pendingResume = t.resume;
						delete t._trans.resume;
						delete t.resume;
					}
					return;
				}
				delete t._trans.resume;
				delete t.resume;
				log(TransitionResumedStr, routeStr);
				if (t.paused) {
					var state,
					prom = t.prom;
					if(t.paused != true) {
						state = t.paused.state;
					}
					if (t.runLoop[state]) {
						if(state == "forceFetch") {
							var newProm = t.runLoop.forceFetch[prom.index];
							if(newProm[0] && prom.hook == newProm[0].hook) {
								newProm.splice(0, 1);
							}
						} else if(t.runLoop[state][0] && t.runLoop[state][0].hook == t.paused.hook && t.runLoop[state][0].index == t.paused.index) {
							removeHook(t.runLoop[state], t.paused.hook, t.paused.index);
						}
					}
					t.iPause = t.paused = false;
					t.state = t._trans.state = 102;
					this._trans.triggerEvent(stateChangeStr,t.state);
					if(this.forceFetchRunning) {
						if(t.runLoop.forceFetch[prom.index][0]) {
							t.run(t.runLoop.forceFetch[prom.index][0]);
						} else {
							t.routes[prom.index].__ltp.fetchStatus = completedStr;
							if (t.pending.waitingForFF != undefined && t.pending.waitingForFF == prom.index) {
								delete t.pending.waitingForFF;
								t.run();
							}
						}
					} else {
						if(state && state == "forceFetch" && !t.runLoop.forceFetch[prom.index][0]) {
							t.routes[prom.index].__ltp.fetchStatus = completedStr;
						} 
						t.run();  
					}
				}
			}.bind(this);
			return this._trans;
			}.bind(this);
		}

		function debugLog() {
			if(Lyte.debug) {
				console.log.apply(this,Array.from(arguments));
			}
		}
		
		function getRequirements(object) {
			/* download files that are returned from getResources and getDependencies */
			var every = function() {};
			every.internal = {};
			var r = object.r,
			reqType = object.reqType,
			index = object.index,
			ins = r.__lp,
			hook = every.internal.hook = trans.prom.hook;
			every.internal.route = ins.objPath;
			debugLog(reqType+' before inject',this.transId,ins.objPath);
			Lyte.injectResources(ins[reqType],every,function(successFiles,errorFiles) {
				if(!config.execRouteRequirementsOnDemand) {			
					if(!trans.aborted || (ins.objPath == this.routes[index].__lp.objPath && (trans.transComp.redirected && index <= trans.transComp.common.length-1) || (Processed && Processed.transComp.redirected && index <= Processed.transComp.common.length - 1))) {
						if(trans.aborted) {
							trans = !LR.__lp.trans.aborted ? !LR.__lp.trans.aborted : newTrans;
							ins = trans.routes[index].__lp;
						}
						var fnType = hook == getDependenciesStr ? "loadDependencies" : "loadResources";
						var errorType = hook == getDependenciesStr ? "errorDependencies" : "errorResources";
						if(trans.pending[reqType].has(index)) {
							ins = trans.routes[index].__lp;
							ins[reqType+'Loaded'] = true;
							delete ins[fnType];
							trans.pending[reqType].delete(index);
							if(!errorFiles.length) {
								debugLog(reqType+' inject completed','success',trans.transId,ins.objPath);
								if(trans.pending.forceFetch.has(index)) {
									trans.pending.forceFetch.delete(index);
									nestedForcedPromises.call(trans, trans.runLoop.forceFetch , trans.fRunningProm.resolve ,trans.runLoop.forceFetch[index][0]);
								} else {
									nestedPromises.call(trans,trans.runLoop,"current",trans.runningProm.resolve);
								}
							} else {
								debugLog(reqType+' inject completed','failure',trans.transId);
								if(!trans.paused) {
									trans.pause({iPause : true});  
								}
								run[onErrorStr].call(trans,hook,index, (r.__lp[errorType] = errorFiles), 424);  
							}
						} else {
							trans.routes[index].__lp[fnType] = function() {
								if(errorFiles.length) {
										debugLog(reqType+' inject completed','failure',trans.transId,this.objPath);
										trans.routes[index].__lp[reqType+'Loaded'] = true;
										delete trans.routes[index].__lp[fnType];
										// ins[reqType+'Loaded'] = true;
										// delete this[fnType];
										if(!trans.paused) {
											trans.pause({iPause : true});  
										}
										run[onErrorStr].call(trans,hook,index, (r.__lp[errorType] = errorFiles), 424); 
										return false;
								} else {
									trans.routes[index].__lp[reqType+'Loaded'] = true;
									delete trans.routes[index].__lp[fnType];
									// this[reqType+'Loaded'] = true;
									// delete this[fnType];
								}
							}
						}
						// if(!errorFiles.length) {
						// 	ins[reqType+'Loaded'] = true;
						// 	delete ins[fnType];
						// 	debugLog(reqType+' inject completed','success',trans.transId)
						// 	var pos = trans.pending[reqType].indexOf(index);
						// 	if(pos != -1) {
						// 		delete trans.pending[reqType].splice(pos,1);
						// 		if(trans.pending.forceFetch != undefined && trans.pending.forceFetch == index) {
						// 			delete trans.pending.forceFetch;
						// 			nestedForcedPromises.call(trans, trans.runLoop.forceFetch , trans.fRunningProm.resolve ,trans.runLoop.forceFetch[index][0]);
						// 		}
						// 		nestedPromises.call(trans,trans.runLoop,"current",trans.runningProm.resolve);
						// 	}
						// } else {
						// 	ins[fnType] = function() {
						// 		debugLog(reqType+' inject completed','failure',trans.transId);
						// 		ins[reqType+'Loaded'] = true;
						// 		delete ins[fnType];
						// 		if(!trans.paused) {
						// 			trans.pause({iPause : true});  
						// 		}
						// 		run[onErrorStr].call(trans,hook,index, (r.__lp[errorType] = errorFiles), 424);  
						// 	}
						// }
					}
				}
			}.bind(trans),{
				defer : function(opt) {
					var trans = this;
					console.log("fromDefer",ins,trans.routes[index].__lp,newTrans)
					function setTrans() {
						if(this.aborted) {
							if(newTrans && ins.objPath == (newTrans.routes[index] && newTrans.routes[index].__lp.objPath)) {
								if(newTrans._processed.transComp.redirected && index <= newTrans._processed.transComp.common.length - 1) {
									trans = newTrans;
									ins = trans.routes[index].__lp;
									return true;
								} else if(this != trans){
									return true;
								} else {
									return false;
								}
							} else {
								return false;
							}
						} else {
							return true;
						}
					}

					if(ins.objPath == trans.routes[index].__lp.objPath) {
						if(!setTrans.call(this)) {
							return;
						}
						var injectJS = opt.injectJS,
						files = opt.files,
						// errorFiles = opt.errorFiles,
						fnType = hook == getDependenciesStr ? "loadDependencies" : "loadResources",
						errorType = hook == getDependenciesStr ? "errorDependencies" : "errorResources",
						completed = function(errorFiles) {
							/* completed callback */
							if(!setTrans.call(this)) {
								return;
							}
							var _trans = trans;
							_trans.routes[index].__lp[reqType+'Loaded'] = true;
							if(!errorFiles.length) {
								debugLog(reqType+' inject completed','success',_trans.transId,ins.objPath)
								if(_trans.pending[reqType].has(index)) {
									_trans.pending[reqType].delete(index);
									if(_trans.pending.forceFetch.has(index)) {
										_trans.pending.forceFetch.delete(index);
										nestedForcedPromises.call(_trans, _trans.runLoop.forceFetch , _trans.fRunningProm.resolve ,_trans.runLoop.forceFetch[index][0]);
									} else {
										nestedPromises.call(_trans,_trans.runLoop,"current",_trans.runningProm.resolve);
									}
								}
							} else {
								debugLog(reqType+' inject completed','failure',_trans.transId,ins.objPath);
								if(!_trans.paused) {
									_trans.pause({iPause : true});  
								}
								run[onErrorStr].call(_trans,hook,index, (r.__lp[errorType] = errorFiles), 424);  
							}
						}.bind(this);
						if(ins[fnType] == 'pending') {
							if(!setTrans.call(this)) {
								return;
							}
							injectJS(files, function(successFiles,errorFiles) {
								debugLog(reqType+' after inject',trans.transId,this.objPath);
								// delete this[fnType];
								delete trans.routes[index].__lp[fnType];
								completed(errorFiles);
							});
						} else {
							ins[fnType] = function() {
								injectJS(files, function(successFiles,errorFiles) {
									if(!setTrans.call(this)) {
										return;
									}
									debugLog(reqType+' after inject',trans.transId,this.objPath);
									delete trans.routes[index].__lp[fnType];
									completed(errorFiles);
								}.bind(trans));
							};
						}
						// }
					}
				}.bind(trans)
			});
		}

		var requirements = {
			get : function(ins,type) {
				var status = ins.__lp[type+'Loaded'] == true;
				var fnType = type == dependenciesStr ? "loadDependencies" : "loadResources";
				if(!ins.__lp[fnType] || typeof ins.__lp[fnType] != 'function' || status) {
					return status;
				} else {
					var err = ins.__lp[fnType]();
					return err == false ? false : ins.__lp[type+'Loaded'] == true;
				}
			}
		};
	
		function templateDelete(arr) {
		/* clears outlet, from parent to child */
			for(var i = 0,l = arr.length,obj; i < l; i++) {
				obj = arr[i];
				for (var inst, j = obj.routes.length - 1; j >= obj.index; j--) {
					inst = obj.routes[j];
					// delete inst.__lp.rendered;  
					if (inst.outlet) {
						triggerTemplateDestroy({outlet : inst.outletName, route : inst},true)
						inst.outlet.innerHTML = "";
						if(!trans.routes[j] || trans.routes[j].__lp.objPath != inst.__lp.objPath) {
							callDidDestroy.call(this,inst,j,obj);
						}
					}
				}
			}
		}
		
		function triggerTemplateDestroy(obj, bool) {
			// if(!obj.route.__lp.triggeredTemplateDestroy) {
				Lyte.triggerEvent(beforeTemplateDestroyStr,obj);
				// obj.route.__lp.triggeredTemplateDestroy = bool;
			// }
		}

		function callDidDestroy(inst,index,obj) {
			log(didDestroyStr+" of "+ inst.routeName,routeStr,fontColor);
			callHookWithoutPromise.call(this,inst.didDestroy,inst,didDestroyStr,index,inst.currentModel,params(index,obj));
		} 
	
		var stoppableHooks = [getDependenciesStr,getResourcesStr,beforeModelStr,modelStr,afterModelStr]; 
		// error in these hooks should pause transition and call onerror action
		function errorStoppableHook(hook) {
			return _presence(stoppableHooks,hook);
		}
	
		function callHookWithPromise(callback,instance) {
			/* executes route hooks which will returns promise */
			if(callback) { 
				var args = arguments,
				resp,
				t = trans,
				prom = trans.prom,
				hook = prom.hook,
				index = prom.index,
				stopTrans = errorStoppableHook(hook),
				self = this;
				return new Promise(function(resolve,reject) {
					try {
						var result = callback.apply(instance,Array.from(args).slice(2));
						if(stopTrans && result) {
							result = Lyte.resolvePromises(result);
						}
						resp = Promise.resolve(result);
					} catch(err) {
						processError.call(self,{hook : hook, index : index,stopTrans : stopTrans, err : err,instance : instance, promise : {resolve : resolve, reject : reject}});
						return;
					}
					resp.then(function(data) {
						if(prom.state != "previous" && trans._trans != instance.transition) {
							reject("old transition's promise rejected")
						} else {
							resolve(data);
							callback.then && callback.then.success.apply(this,arguments);
						}
					},function(err) {
						t.prom = prom;
						reject(err)
						callback.then && callback.then.failure.apply(this,arguments)
						processError.call(self,{hook : hook, index : index,stopTrans : stopTrans,err : err,instance : instance, PR : true});

					});  
				});
			} else {
				return Promise.resolve();
			}
		}
	
		function callHookWithoutPromise(callback,instance,hook,index) {
			/* executes route hooks which wont return promise  */
			if(callback) {
				var stopTrans = errorStoppableHook(hook);
				try {
					return callback.apply(instance,Array.from(arguments).slice(4));
				} catch(err) {
					processError.call(this,{hook : hook, index : index, stopTrans : stopTrans,err : err,instance : instance});
					return;
				}  
			}
		}
	
		function callAction(hook,index,args) {
			/* executes route's actions  */
			var action,
			routeInstance = this.routes[index];
			if(routeInstance.actions && (action = routeInstance.actions[hook])) {
			try {
				if(action.apply(routeInstance,args) == false) {
				return false;
				}
			} catch(e) {
				consoleErrorFromCallback(e,hook,routeInstance.routeName);
				return false;
			} 
			}
		}

		function consoleErrorFromCallback(err,hook,routeName,state,options) {
			if(typeof err == "string" || (typeof err == "object" && err.stack && !err.$)) {
				if(!err.stack) {
					err = Error(err);
				}
				err.$ = true;
				var internalErr = getError(state || 420,hook,routeName);
				err.stack = err.stack.replace(err.message,err.message = err.message+"\n\t"+internalErr);
				consoleError(err);
			} else {
				consoleError(state,hook,routeName,err,options && options.PR);
			}
		}
	
		function processError(options) {
			/* handles error in hooks */
			var instance = options.instance,
			stopTrans = options.stopTrans,
			err = options.err,
			hook = options.hook,
			index = options.index;
			if(stopTrans) {
				trans.pause();
				run[onErrorStr].call(this,hook,index,err,420,options);
			} else {
				consoleErrorFromCallback(err,hook,instance.routeName);
				// if(_presence([willTransitionStr,didTransitionStr,beforeExitStr,redirectStr],hook)) {
					if(options.promise) {
						options.promise.resolve();
					}
				// } else {
					// trans.abort({state : 4, iAbort : true});
				// }
			}  
		}
	
		function runLoopPromise(fn,fnName,loop,success,failure) {
			success = success || emptyFn;
			failure = failure || function(error) {
				if(error != abortedStr) {
					consoleError(error);
				}
			};
			new Promise(function(resolve,reject) {
				if(fnName == "nestedForcedPromises" ) {
					this.fRunningProm = {resolve : resolve, reject : reject};
					fn.call(this,this.runLoop.forceFetch,resolve);
				} else {
					this.runningProm = {resolve : resolve, reject : reject};
					fn.call(this,this.runLoop,loop,resolve);  
				}
			}.bind(this)).then(success,failure);
		}
	
		Transition.prototype.run = function (pausedForcedProm) {
			if(pausedForcedProm) {
			nestedForcedPromises.call(this, this.runLoop.forceFetch , this.fRunningProm.resolve ,pausedForcedProm);
			return;
			}
			processRunLoop.call(this);
			d.title = this.title = this.routes[this.routes.length-1].title || d.title;
		};
	
		function processRunLoop() {
			runLoopPromise.call(this,nestedPromises,"nestedPromises",'previous',function() {
			if(processedDispatch && !trans.running && !trans.aborted ) {
				trans.state = trans._trans.state = 102;
				trans._trans.triggerEvent(stateChangeStr,trans.state);
				if(newTransInfo) {
					if(config.preserveUrlOnBrowserNavigation) {
						if(newTransInfo.fromHistory && !!newTransInfo.goValue) {
							fromHistoryGo = true;
							history.go(-(newTransInfo.goValue));
						}
						newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
						newTransInfoClone = Lyte.deepCopyObject(newTransInfo);
						trans.stateObj = newTransInfo.state;
						var newTransInfoTimer = setInterval(function() {
							if(!newTransInfoClone) {
								clearInterval(newTransInfoTimer);
								return;
							}
							if(!fromHistoryGo) {
								clearInterval(newTransInfoTimer);
								addToHistory(newTransInfoClone);
								newTransInfoClone = undefined;
								
							}
						},0)
					} else {
						newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
						addToHistory(newTransInfo);
						trans.stateObj = newTransInfo.state;
					}
				}
				LR.__lp.trans = trans;            
				processedDispatch.previous = false;
				trans.runLoop = constructRunLoop(processedDispatch);
				setParamsInInst(processedDispatch, trans.info);
				processedDispatch = newTransInfo = undefined;
				trans.running = true;
			}
			runLoopPromise.call(this,nestedPromises,"nestedPromises",'current');
			}.bind(this));
		}
	
		function setPendingResume(promise) {
			trans.eProm = promise;
			if (this.pendingResume) {
			var resume = this.pendingResume;
			delete this.pendingResume;
			resume();
			}
		}
	
		function nestedForcedPromises(forcedLoop, resolve, promise) {
			if (validateTransition(this) && forcedLoop) {
				if(!promise) {
					for(var key in forcedLoop) {
						var routeLoop = forcedLoop[key],
						p = routeLoop[0];
						if(p) {
							if(!p.running) {
								nestedForcedPromises.call(this, forcedLoop, resolve,p);    
							}
						}
					}
					return;
				}
				var r = this.R[promise.index],
				routeInstance = this.routes[promise.index];
				promise.state = "forceFetch";
				trans.prom = promise;
				if (promise.hook == beforeModelStr && !requirements.get(routeInstance, dependenciesStr)) {
					this.pending.dependencies.add(promise.index);
					this.pending.forceFetch.add(promise.index)
					return;
					// var fn = r.__lp.loadDependencies;
					// r.__lp.loadDependencies = 'pending';
					// if(fn) {
					// 	fn();
					// 	// delete r.__lp.loadDependencies;
					// }
					// if(r.__lp.loadDependencies) {
					// 	this.pausedRunloop = true;
					// 	return;
					// }
				}
				logCallbacks(promise);
				forcedLoop[promise.index][0].running = true;
				forcedLoop[promise.index].splice(0, 1);
				run[promise.hook].call(this, promise.hook, promise.index).then(function (data) {
					setPendingResume.call(trans, trans.prom);
					if(promise.hook == afterModelStr) {
						routeInstance.__ltp.fetchStatus = completedStr;
						if (this.pending.waitingForFF != undefined && this.pending.waitingForFF == promise.index) {
							delete this.pending.waitingForFF;
							nestedPromises.call(this,this.runLoop,"current",this.runningProm.resolve);
						}
					} else if(promise.hook == modelStr) {
						if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == afterModelStr) {
							nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
						}
					} else {
						if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == modelStr) {
							nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
						}
					}
				}.bind(this),function() {debugger;});
			} else {
				this.forceFetchRunning = false;
			}
		}
	
		function logCallbacks(promise) {
			if(Lyte.debug) {
				var hook = promise.hook,
				index = promise.index;
				if([beforeRouteTransitionStr, onBeforeLoadStr].indexOf(promise.hook) != -1) {
					log(hook,routeStr,fontColor);
					return;  
				}
				var route = promise.state == "previous" ? prevTrans.R[index] : trans.R[index];
				log(hook +' of route '+route.routeName,routeStr,fontColor);    
			}
		}
	
		function nestedPromises(loop,state,resolve) {
			if(validateTransition(this)) {
				var runLoop = loop[state];
				if(runLoop && runLoop.length) {
					var promise = runLoop[0],
					r = this.R[promise.index],
					routeInstance = this.routes[promise.index];
					var cond;
					if(promise.hook == beforeModelStr) {
						cond = requirements.get(routeInstance,dependenciesStr);
					}
					if(promise.hook == beforeModelStr && !cond) {
						this.pending.dependencies.add(promise.index);
						return;
						// this.pending.dependencies.push(promise.index);
						// var fn = r.__lp.loadDependencies;
						// r.__lp.loadDependencies = 'pending';
						// if(fn) {
						// 	fn();
						// 	// delete r.__lp.loadDependencies
						// } 
						// if(r.__lp.loadDependencies) {
						// 	this.pausedRunloop = true;
						// 	return;
						// }
					} else if(promise.hook == renderTemplateStr && !requirements.get(routeInstance,resourcesStr)) {
						this.pending.resources.add(promise.index);
						return;
						// this.pending.resources.push(promise.index);
						// var fn = r.__lp.loadResources;
						// r.__lp.loadResources = 'pending';
						// if(fn) {
						// 	fn();
						// 	// delete r.__lp.loadResources
						// } 
						// if(r.__lp.loadResources) {
						// 	this.pausedRunloop = true;
						// 	return;
						// }
					} else if(promise.hook == redirectStr && r.forceFetch && routeInstance.__ltp.fetchStatus == pendingStr) {
						if(!this.forceFetchRunning) {
							this.forceFetchRunning = true;
							runLoopPromise.call(this,nestedForcedPromises,"nestedForcedPromises");
						}
						this.pending.waitingForFF = promise.index;
						return;
					} else {
						promise.state = state;
						trans.prom = promise;
						logCallbacks(promise);
						t(promise.hook+promise.index);
						run[promise.hook].call(this,promise.hook,promise.index).then(function(data) {
							setPendingResume.call(trans,trans.prom);
							t(promise.hook+promise.index);
							if(this.runningProm.resolve == resolve) {
							removeHook(loop[state],promise.hook,promise.index);
							nestedPromises.call(this,loop,state,resolve);  
							}
						}.bind(this));
					}
				} else if(resolve) {
					resolve();
				}
			} else if(this.paused && this.runningProm) {
				this.runningProm.reject(abortedStr);  
			}
		}
	
		function removeHook(loop,hook,index) {
			for(var i = 0,obj;obj = loop[i]; i++) {
				if(obj.hook == hook) {
					if(index != undefined) {
						if(index == obj.index) {
							loop.splice(i,1);
							break;
						}
					} else {
						loop.splice(i,1);
						i--;
					}
				}
			}
		}
	
		function frameQueryParams(url) {
			if(url) {
				var qp = {},
				split,
				params = _presence(url,"?") ? url.split("?")[1] : url;
				params = _presence(params,"&") ? params.split(/&/g) : [params];
				for(var i = 0,l = params.length; i < l; i++) {
					qp[(split = params[i].split('='))[0]] = split[1] ? decodeURIComponent(split[1]) : split[1];
				}
				return qp;
			} 
		}
	
		function frameDynamicParams(url,matched) {
			var routesObj = config.routes,
			dynamicParam,
			fdp,
			framedDP = [],
			urlSplit = _splitPath(url.split('?')[0]);
			for(var i = 0,l = matched.route.length,r; i < l; i++) {
				r = matched.route[i];
				routesObj = _getObj([r],routesObj);
				var routeObj =  routesObj.__lp;
				if(routeObj.wildcard) {
					if(routeObj.sufix.length) {
					var dp = urlSplit.slice(0,urlSplit.indexOf(routeObj.sufix[0]));
					fdp = decodeURI(dp.join('/'));
					_pop(dp.concat(routeObj.sufix),urlSplit);
					} else {
					fdp = decodeURI(urlSplit.join('/'));
					}
				} else if(routeObj.dkey) {
					dynamicParam = urlSplit[routeObj.dIndex];
					_pop(_splitPath(routeObj.path),urlSplit);
					fdp = decodeURI(dynamicParam);
				} else {
					_pop(_splitPath(routeObj.path),urlSplit);
					fdp = undefined;
				}
				framedDP.push(fdp);
			};
			return framedDP;
		}
		
	
		function _pop(path,urlSplit) {
			for(var i = 0,l = path.length; i < l; i++) {
				urlSplit.shift();
			};
		}
	
		function _presence(str,char) {
			return str.indexOf(char) != -1;
		}
	
		function transitionCompleted(obj) {
			/* called after a atransition is completed or aborted*/
			if(trans.running) {
				if(trans == newTrans) {
					newTrans = undefined;  
				}
				if(newTransInfoClone) {
					clearInterval(newTransInfoTimer);
					addToHistory(newTransInfoClone);
					newTransInfoClone = undefined;
				}
				setActiveClassForLink(trans.info)
				for(var i = 0,l = trans.fns.length; i < l; i++) {
					clearTimeout(trans.fns[i]);
				};
				trans.pendingResume = undefined;
				trans.running = false;
				trans.state = trans._trans.state = obj.state;
				trans._trans.triggerEvent(stateChangeStr,trans.state);
				if(initialLoad || trans.state == 200) {
					LR.__lp.prevTrans = prevTrans =  trans;
					t(RouteTransitionStr);
					log(TransitionComletedStr,routeStr);
					if(config.history && trans.info.fragment) {
						var elem;
						if((elem = d.getElementById(trans._trans.info.fragment)) && elem.scrollIntoView && (LR.beforeScroll(trans._trans) != false)) {
							elem.scrollIntoView();
						}
					}
					run[afterRouteTransitionStr](trans._trans);
				} else if(obj.iAbort || visibleTrans == trans) {
					LR.__lp.prevTrans = prevTrans = trans;
					if (trans.state && trans.state != 201) {
					run[afterRouteTransitionStr](trans._trans);
					}
				} else {
					if (trans.state && trans.state != 201) {
						run[afterRouteTransitionStr](trans._trans);
					}
					LR.__lp.trans = trans = prevTrans;  
				}
				if(initialLoad) {
					initialLoad = false;
				}
			} else if(prevTrans){
				LR.__lp.trans = trans = prevTrans;
			}
		}
	
		function _delimit(seg) {
			return seg[0] == "/" ? seg : "/"+seg;
		}
	
		function _splitPath(path) {
			return path.match(/[^/?]+/g) || [];
		}
	
		function validateURL(url) {
			url = url.replace(/\/\//g,'/');
			url = url.replace(/\/\?/g,'?');
			return url;
		}
	
		function getError() {
			var args = arguments,
			error;
			switch(args[0]) {
				case 400 :
					error = args[1] ? "url '"+args[1]+"' is not defined in router." : "Base path of url is not specified.";
					break;
				case 405 :
					error = "Method not allowed before router initialization.";
					break;
				case 422 :
					error = "There is no route definition for the route "+(args[1].splice(0,args[2]+1).join('.'))+".";
					break;
				case 424 : 
					error = "File not loaded in "+args[1]+ " of route "+args[2]+".\n"+args[3][0].target.outerHTML;
					break;
				case 498: 
					error = "Invalid argument " + args[1] + (args[2] ? " provided in "+args[2] : ".");
					break;
				case 499 : 
					error = args[1] ? ("Dynamic params for the route "+args[1]+" is not provided" + (args[2] && args[2].outerHTML  ? " in "+args[2].outerHTML : ".")) : "Transition tried without arguments.";
					break;
				case 420 : 
					error = (args[3]? "Promise rejected" : "Error")+" in "+args[1]+" of route "+args[2]+".";
					break;
				case 428 : 
					error = "There is no outlet named "+args[1]+".";
					break;
				case 203 :
					error =  "Data provided for component is not valid.";
					break;
			}
			return 'LR '+args[0]+': '+error;
		}
	
		function consoleError() {
			Lyte.error(arguments[0].stack ? arguments[0] : getError.apply(this,arguments),arguments[3]);
		}
	
		function traverse(path,get) {
			if(!path) {
				consoleError(400,'');
				return;
			}
			var selectedPaths = [],
			fragment;
			if(config.history) {
				var fragSplit = path.split('#');
				if(fragment = fragSplit[1]) {
					path = fragSplit[0];
				}
			}
			var pathSplit = path.split('?');
			path = decodeURI(pathSplit[0]);
			if(path == '/') {
				if(_getObj(['/'],config.routeHash)) {
					selectedPaths.push([path]);  
				} else {
					consoleError(400,path);
					return;
				}
			} else {
				var params = pathSplit[1],
				pathSplitArr = _splitPath(path);
				var pathLevel = 0,
				pathArrLevel = [0],
				exactMatch,
				matchedPath = [];
				matchedPath.dynamicParams = [];
				findPossibleMatch(config.routeHash);
	
				function findPossibleMatch(mapObj) {
					for(var mapPath in mapObj) {
					if(!exactMatch) {
						var pathObj = mapObj[mapPath],
						innerLevel;
						if(mapPath != "__lp") {
						var mapPathSplit = _splitPath(mapPath);
						if(mapPathSplit) {
							if((innerLevel = checkArrayMatch(mapPathSplit,pathSplitArr,pathLevel,pathObj,matchedPath)) !== false) {
							pathArrLevel.push(innerLevel);
							pathLevel = pathArrLevel[pathArrLevel.length-1];
							if(pathSplitArr.length == pathLevel) {
								var path = Array.from(matchedPath.concat(mapPath));
								if(pathObj["/"]) {
								path = path.concat('/');
								}
								selectedPaths.push(path);
								if(pathObj.__lp.wildcard || pathObj.__lp.dkey) {
								pathArrLevel.pop();
								pathLevel = pathArrLevel[pathArrLevel.length-1];
								} else {
								if(!/[:*]/.test(path.join(''))) {
									exactMatch = path;  
								}
								return;  
								}
							} else {
								var innerRoutes = Object.keys(pathObj);
								matchedPath.push(mapPath);
								if(pathSplitArr[pathLevel]) {
								if(pathObj.__lp.wildcard && !pathObj.__lp.sufix.length && innerRoutes.length == 1) {
									var wildcard= Array.from(matchedPath);
									if(pathObj["/"]) {
									wildcard = wildcard.concat('/');
									}
									selectedPaths.push(wildcard);
								} else if(innerRoutes.length > 1) {
									findPossibleMatch(pathObj);    
								}
								} 
								matchedPath.pop();
								pathArrLevel.pop();
								pathLevel = pathArrLevel[pathArrLevel.length-1];
							}
							}
						}
						}
					}
					}
				}
			}
			if(exactMatch) {
				return pathProcessor(get,exactMatch,path,params,fragment);
			} else if(selectedPaths.length == 1) {
				return pathProcessor(get,selectedPaths[0],path,params,fragment);
			} else if(selectedPaths.length) {
				return pathProcessor(get,getBestMatch(getStaticMatches(selectedPaths),selectedPaths),path,params,fragment);
	
				function getBestMatch(staticMatches, selectedPaths, position) {
					position = position || 0;
					var traversedStaticMatch = traversedStaticMatch || traverseArray(staticMatches),
					maxStaticSeg = Math.max(...traversedStaticMatch[position]),
					duplicatePos;
					while(duplicatePos = checkForArrayDuplicates(traversedStaticMatch[position], maxStaticSeg, selectedPaths, staticMatches)) {
						position = position+1;
						var newSelectedPaths = [],
						newStaticMatches = [];
						for(var i = 0,l = duplicatePos.length; i < l; i++) {
							newSelectedPaths.push(selectedPaths[i]);
							newStaticMatches.push(staticMatches[i]);
						}
						var newSelectedPathsFiltered = [],
						newStaticMatchesFiltered = [];
						for(var i = 0,l = newStaticMatches.length; i < l; i++) {
							if(newStaticMatches[i][position] != undefined) {
								newSelectedPathsFiltered.push(newSelectedPaths[i]);
								newStaticMatchesFiltered.push(newStaticMatches[i]);
							}
						}
						if(!newSelectedPathsFiltered.length) {
							return newSelectedPaths[0];
						} else if(newSelectedPathsFiltered.length == 1) {
							return newSelectedPathsFiltered[0];
						}
						return getBestMatch(newStaticMatchesFiltered, newSelectedPathsFiltered, position);
					}
					return selectedPaths[traversedStaticMatch[position].indexOf(maxStaticSeg)];
				}
	
				function getStaticMatches(selectedPaths) {
					var staticSegmentsInMatch = [];
					for(var i = 0,l = selectedPaths.length; i < l; i++) {
						var arr = Array.from(selectedPaths[i]),
						staticPath = 0,
						result = [];
						if(arr[0] == "/") {
							arr.shift();
						}
						if(arr[arr.length-1] == "/") {
							arr.pop();
						}
						var counter = -1;
						arr.every(function(seg,i) {
							var noWildcard = true;
							_splitPath(seg).every(function(innerSeg,j) {
							counter++;
							if(innerSeg == pathSplitArr[counter]) {
								staticPath++;
								if(arr.length == i+1){
								result.push(staticPath);
								}
								return true;
							} else if(innerSeg.indexOf(':') != -1) {
								result.push(staticPath);
								staticPath = 0;
								return true;
							} else {
								if(innerSeg.indexOf('*') != -1) {
								noWildcard = false;
								}
								result.push(staticPath);
								return false;
							}
							});  
							return noWildcard;
						});
						staticSegmentsInMatch.push(result);
					}
					return staticSegmentsInMatch;
				}
			} else {
				consoleError(400,path);
			}
		}
	
		function checkArrayMatch(arr1,arr2,l,pathObj,matchedPath) {
			if(!(pathObj.__lp.wildcard || pathObj.__lp.dkey)) {
			var prevObj;
			if(prevObj = _getObj(matchedPath,config.routeHash).__lp) {
				if(prevObj.wildcard) {
				var pathArr = arr2.slice(l);
				if(!(l += pathArr.indexOf(arr1[0]))) {
					return false;
				}  
				}
			}
			}
			for(var i = 0,a1;a1 = arr1[i]; i++,l++) {
			if(a1 != arr2[l] && !dynamicRouteCheck(a1)) {
				if(wildcardRouteCheck(a1)) {
				if(pathObj.__lp.sufix.length) {
					l = arr2.indexOf(pathObj.__lp.sufix[0])-1; 
				}
				} else if(arr1[l] == '/') {
				l--;
				} else {
				return false;  
				}
			}
			}
			return l;
		}
	
		function checkForArrayDuplicates(arr, value, selectedPaths, staticMatches) {
			var pos = [];
			for(var i = 0,l = arr.length;i < l; i++) {
				if(arr[i] == value) {
					pos.push(i);
				}
			}
			return pos.length == 1 ? false : pos;
		}
	
		function traverseArray(arr) {
			var res = [],
			maxArrLen = 0;
			for(var i = 0,l = arr.length; i < l; i++) {
				var a = arr[i];
				maxArrLen = a.length > maxArrLen ? a.length : maxArrLen;
			}
			for(var i=0,a ;a = arr[i]; i++) {
				for(var j=0; j<maxArrLen; j++) {
					res[j] = res[j] || [];    
					res[j][i] = a[j];
				} 
			}
			return res;
		}
	
		function pathProcessor(get,selectedPath,path,params,fragment) {
			var newURL,
			orgMatched,
			newMatched,
			matched = {
			route : _getObj(selectedPath,config.routeHash).__lp.route,
			queryParams : params ? frameQueryParams(params) : {}
			};
			if(config.history) {
				matched.fragment = fragment;
			}
			matched.dynamicParams = frameDynamicParams(path,matched);
			if(get) {return matched;}
			matched.dpProcessed = true;
			var transInfo = normalizeMatchedObj(matched);
			if(transInfo != false) {
				orgMatched = Lyte.deepCopyObject(transInfo.matched);
				newMatched = Lyte.deepCopyObject(transInfo.matched);
				if(!transInfo.matched.hasOwnProperty('refreshModel')) {
					constructURLFromRoute(transInfo.matched);
				}
				newURL = constructURLFromRoute(newMatched);
				if(!_compareObj(newMatched.queryParams,orgMatched.queryParams)) {
					addToHistory({replace : true,state : window.history.state,url : newURL,fromHistory : true});
					transInfo.path = newURL;
				}  
			}
			return transInfo;
		}
	
		function setParamsInInst(processed, transInfo) {
			if(config.linkActiveClass) {
				config.activeLinkTags.forEach(function(tag) {
					tag.classList.remove(config.linkActiveClass);
				});
			}
			config.activeLinkTags = [];
			var R,
			r,
			matched = processed.matched;
			try {
				function linkTagPush(tag) {
					if(tag.getAttribute('lt-prop-route') == matched.target && activeLinkTags.indexOf(tag) == -1) {
						activeLinkTags.push(tag);
					}
				}
				function pushQP(key) {
					r.__ltp.queryParams[key] = R.__lp.qpdef[key].cipher && config.cipher.decryptor ? config.cipher.decryptor(matched.queryParams[key]) : matched.queryParams[key];
				}
				for(var i = 0,l = trans.R.length; i < l; i++) {
					R = trans.R[i];
					r = trans.routes[i];
					if(R.queryParams) {
						R.queryParams.forEach(pushQP);
					}
					r.__ltp.dynamicParam = matched.dynamicParams[i];
					if(i+1 == l) {
						R.__lp.linkTags.forEach(linkTagPush);
					}
				}
				setActiveClassForLink(transInfo )
			} catch(e) {
				consoleError(e);
			}
			return;
		}

		function setActiveClassForLink(transInfo) {
			if(config.linkActiveClass && config.allLinks[transInfo.route]) {
				config.allLinks[transInfo.route].forEach(function(tag) {
					var tagDp = tag.getAttribute(pDp)
					if(checkIfSameDp(transInfo.dynamicParams,(tagDp ? JSON.parse(tagDp) : []))) {
						tag.classList.add(config.linkActiveClass);
						config.activeLinkTags.push(tag);
						var aTag = tag.getElementsByTagName('A')[0]
						if(aTag) {
							aTag.setAttribute("href", LR.getURL(tag.getMatchedObject())); 
						}
					}
				});
			}
		}
	
		function assignMixin(options,fns,dir,lazyload) {
			if(options && options.mixins) {
			if(!Array.isArray(options.mixins)) {
				options.mixins = [options.mixins];
			}
			options.mixins.forEach(function(mixin) {
				if(Lyte.registeredMixins[mixin]) {
					mixin = Lyte.registeredMixins[mixin];
					if(lazyload) {
						var prevTransRouteInstance = LR.getRouteInstance(dir,prevTrans),
						transRouteInstance = LR.getRouteInstance(dir,trans),
						newTransInstance = newTrans && LR.getRouteInstance(dir,newTrans);
						if(prevTransRouteInstance || transRouteInstance) {
							prevTransRouteInstance = prevTransRouteInstance ||  {};
							transRouteInstance = transRouteInstance ||  {};
							setMixinPropInDefandIns(mixin,fns,prevTransRouteInstance,transRouteInstance,newTransInstance);
						} else {
						setMixinPropInDef(mixin,fns);
						}
					} else {
						setMixinPropInDef(mixin,fns);
					}
				} else if(!lazyload) {
					Lyte.$.requiredMixins(mixin,dir,"router");
				}
			});
			}
		}

		// function setServicePropInDef(dir) {
		// 	var prevTransRouteInstance = LR.getRouteInstance(dir,prevTrans),
		// 	transRouteInstance = LR.getRouteInstance(dir,trans);
		// 	if(prevTransRouteInstance) {
		// 		Lyte.extendService({services : serv, type:"route", name : dir, ins: prevTransRouteInstance});
		// 	}
		// 	if(transRouteInstance) {
		// 		Lyte.extendService({services : serv, type:"route", name : dir, ins: transRouteInstance});	
		// 	}
		// }
	
		Lyte.$.requiredMixins.router = function(mixin,dir) {
			dir.forEach(function(d) {
			var fns = LR.__lp.getDefinition(d);
			if(mixin && fns) {
				assignMixin(fns.__lp.options,fns,d,true);  
			}
			});
		};

		Lyte.$.injectServices.router = function(key, name, type, ins, cIns, data) {
			var obj = {};
			obj.as = key;
			obj.service = name;
			// Lyte.extendService({services : [obj], type:"route", ins: arr});
			includeServices({services : [obj]},undefined,undefined,getDefinitionArr(),true,data)
		}

		function includeServices(options,fns,dir,def,isGlobal,data) {
			if(options && options.services){
				var toBeUsed = [], laterToBeUsed = [];
				options.services.forEach(function(itm){
					if(typeof itm == "string"){
						toBeUsed.push(itm);
					}
					else if(itm && typeof itm == "object"){
						if( isGlobal || !itm.scope || (itm.scope && itm.scope == "static")){
							toBeUsed.push(itm);
						}
						else{
							laterToBeUsed.push(itm);
						}
					}
				});
			}
			if(toBeUsed && toBeUsed.length){
				assignService(toBeUsed,fns,dir,def,isGlobal,data);
			}
			if(laterToBeUsed && laterToBeUsed.length){
				var arr = getFnsAndIns(dir,fns);
				arr.forEach(function(itm){
					if(itm && itm.__lp){
						itm.__lp.toBeUsed = laterToBeUsed;
					}
				});
			}
		}

		function assignService(servArr,fns,dir,def,isGlobal,data){
			var arr = getFnsAndIns(dir,fns);
			Lyte.extendService({services : servArr || [], type:"route", ins: def || arr, isGlobal:isGlobal, data:data, callback : function(serv, key, aName, serName){
				var obj = {};
				obj.as = key;
				obj.service = serName;
				Lyte.extendService({services : [obj], type:"route", isGlobal:isGlobal, ins: dir ? getFnsAndIns(dir,fns) : getDefinitionArr()});
			}});
		}

		function getFnsAndIns(dir,fns) {
			var arr = [fns],
			ins;
			[prevTrans, newTrans,trans].forEach(function(t) {
				if(t && (ins = LR.getRouteInstance(dir,t))) {
					arr.push(ins)	
				}
			}); 
			// var prevTransRouteInstance = LR.getRouteInstance(dir,prevTrans),
			// transRouteInstance = LR.getRouteInstance(dir,trans);
			// if(prevTransRouteInstance) {
			// 	arr.push(prevTransRouteInstance)
			// }
			// if(transRouteInstance) {
			// 	arr.push(transRouteInstance)
			// }
			return arr;
		}

		function getDefinitionArr(def,arr) {
			var parent = !def;
			def = def || config.routes;
			arr = arr || [];
			for(var key in def) {
				if(key == "__lp") {
					if(def.__lp.def) {
						arr.push(def.__lp.def);
					}
				} else {
					getDefinitionArr(def[key],arr);
				}
			}
			if(parent) {
				if(prevTrans && prevTrans != trans) {
					arr = arr.concat(prevTrans.routes)
				}
				if(trans) {
					arr = arr.concat(trans.routes)
				}
				return arr;
			}
		}
	
		function setMixinPropInDef(mixin,fns) {
			for(var key in mixin) {
				if(key == "actions") {
					fns.actions = Object.assign(fns.actions || {}, mixin.actions);
				} else if(key == "queryParams") {
					fns[key] = Lyte.deepCopyObject(mixin[key]);
				} else {
					fns[key] = mixin[key];  
				}
			} 
		}
	
		function setMixinPropInDefandIns(mixin,fns,prev,curr,newTrans) {
			for(var key in mixin) {
				if(key == "actions") {
					if(!fns.actions) {
						curr.actions = prev.actions = fns.actions = {};
					}
					prev.actions = curr.actions = Object.assign(fns.actions,mixin.actions);
					if(newTrans) {
						newTrans.actions = prev.actions
					}
				} else {
					prev[key] = curr[key] = fns[key] = mixin[key];  
					if(newTrans) {
						newTrans[key] = prev[key];
					}
				}
			} 
		}

		this.registerRoute = function() {
			if(config.routes) {
				registerRoute.apply({},arguments);
			} else {
				this.__lp.pendingReg.push(arguments);
			}
		};
		
		function registerRoute(dir,fns,options) {
			assignMixin(options,fns,dir);
			fns.__lp = {
				options : options,
				objPath : dir.replace(/\//g,'.'),
				stickyLinks : [],
				linkTags : []
			};
			includeServices(options,fns,dir);
			if(Lyte.toBeInjectedServices){
				var tbServ = Lyte.toBeInjectedServices, arr = [];
				for(var key in tbServ){
					arr.push({as:key, service: tbServ[key]});
				}
				includeServices({services:arr},fns,dir, undefined,true);
			}

			var sticky = config.queryParamOptions.sticky;
			if(fns.queryParams) {
				fns.__lp.qpdef = {};
				fns.queryParams.forEach(function(qp,i) {
					if(typeof qp == "string") {
					fns.__lp.qpdef[qp] = {
						sticky : sticky,
						refreshModel : true
					};
					if(config.stickyRoutes[dir] == undefined && sticky) {
						config.stickyRoutes[dir] = sticky
					}
				} else if(typeof qp == "object") {
					for(var key in qp) {
						fns.__lp.qpdef[key] = {
							cipher : qp[key].cipher,
							sticky : qp[key].hasOwnProperty('sticky') ? qp[key].sticky : sticky,
							refreshModel : qp[key].hasOwnProperty('refreshModel') ? qp[key].refreshModel : true
						};
						if(!config.stickyRoutes[dir] && fns.__lp.qpdef[key].sticky) {
							config.stickyRoutes[dir] = true
						}
					}
					fns.queryParams[i] = key;
					}
				});  
			}
			dir = dotSerperator(dir);
			fns.routeName = dir[dir.length -1];
			setRouteDef(dir,fns);
		}
	
		var transPredefined = ['runLoop','running','paused','R','routes',abortedStr,'prom','run',pendingStr,'matched','fns'];
	
		function limitTransition(int) {
			var _trans = new transition(int);
			int.state = _trans.state = 201;
			return _trans;
		}
	
		function dummy() {
			/*
			Dont delete this function.
			This one is to avoid function to be merged during minification.
			*/
			var _trans = new transition(int);
		}
	
		function transition(int) {
			for(var prop in int) {
			if(transPredefined.indexOf(prop) == -1) {
				if(prop == 'info') {
				this.info = Lyte.deepCopyObject(int[prop]);
				} else {
				this[prop] = int[prop];
				}
			}
			}
		}
	
		function dynamicRouteCheck(route) {
			return _presence(route,":");
		}
	
		function wildcardRouteCheck(route) {
			return _presence(route,"*");
		}
		
		function _compareObj(obj1,obj2) {
			var obj1keys = Object.keys(obj1),
			obj2keys = Object.keys(obj2);
			if(obj1keys.length != obj2keys.length) {
			return false;
			} else {
			for(var key in obj1) {
				if(obj1[key] != obj2[key]) {
				return false;
				}
			}
			return true;
			}
		}
	
		this.getRouteInstance = function(routeName,t) {
			var newTrans;
			if(LR && !LR.init && (newTrans = (t || (LR.__lp && LR.__lp.trans) || trans)) && newTrans.routes) {
				var routeLen = newTrans.routes.length;
				if(!routeName) {
					return newTrans.routes[routeLen-1];
				} else if(routeName == "*") {
					return newTrans.routes;
				} else {
					var reqRouteLen = routeName.split('.').length-1,
					reqRoute = newTrans.routes[reqRouteLen];
					return reqRoute && reqRoute.__lp.objPath == routeName ? reqRoute : undefined;
				}
			}
		};

		function normalizeTransitionParams(obj) {
			// To normalize argument for transition, returns matched obj from obj or native tranisitionTo argument.
			var params;
			if(typeof obj == "object") {
			params = obj;
			} else {
			params = {
				queryParams : {},
				dynamicParams : []
			};
			Array.from(arguments).forEach(function(arg,index) {
				if(Array.isArray(arg)) {
					consoleError(498,JSON.stringify(arg));
					return;
				} else {
				if(index == 0) {
					params.route = arg;
				} else if(arg && typeof arg == "object") {
					params.queryParams = Lyte.deepCopyObject(arg);
				} else {
					params.dynamicParams.push(arg);
				}  
				}
			});
			}
			return params;
		}
	
		function normalizeMatchedObj(obj) {
			// To construct dynamic params array.
			if(obj.route) {
				var routesObj = config.routes,
				matched,
				def,
				R = [],
				errorCheck = function(route,i) {
					routesObj = _getObj(route,routesObj);
					if(!routesObj) {
						throw Error(getError(400,matched.target));
					}
					if(!(def = routesObj.__lp.def)) {
						throw Error(getError(422,matched.route,i));
					}
					R.push(def)
				};
				if(obj._routes) {
					matched = obj;
				} else {
					var matched = {
						route : Array.isArray(obj.route) ? obj.route : dotSerperator(obj.route),
						queryParams : obj.queryParams || {},
						dynamicParams : [],
						fragment : obj.fragment,
						target : "",
						refreshRoute : obj.refreshRoute,
						startFrom : obj.startFrom,
						_routes : []
					};
					if(obj.dynamicParams) {
						if(obj.dpProcessed) {
							matched.dynamicParams = Array.from(obj.dynamicParams);
						} else {
							var dynamicParams =  Array.from(obj.dynamicParams);
						}
					}
				}
				try {
					matched.route.forEach(obj._routes ? errorCheck : function(route,i) {
						matched.target = matched.target ? matched.target+'.'+route : route;
						matched._routes.push(dotSerperator(matched.target));
						errorCheck(route,i)
						if(dynamicParams) {
							matched.dynamicParams.push(routesObj.__lp.dkey ? dynamicParams.shift() : undefined);
						}
					});
					if(dynamicParams && dynamicParams.length) {
						Lyte.error('Extra dynamic params found. Provide exact numbers dynamic params required for the transition '+ JSON.stringify(dynamicParams));
					}
				} catch(e) {
					consoleError(e);
					return false;
				}
				return { 
					matched : matched,
					R : R
				};
			} else {
				if(this.tagName == LINKTOStr) {
					consoleError(498,pRoute,this.outerHTML);
				} else {
					consoleError(499);  
				}
			}
		}
	
		function initRoute(processed) {
			var routeObj,
			matched = processed.matched,
			routes = [],
			refMatch = processed.prevTrans,
			similarRoute = true;
	
			for(var i=0,route; route = matched.route[i];i++) {
				routeObj = LR.__lp.getDefinition(newTrans.matched._routes[i]);
				if(!routeObj) {return false;}
				if(refMatch && similarRoute && refMatch.matched && refMatch.matched.route[i] == route) {
					routes.push(new Route(routes, routeObj,i,processed,refMatch.routes[i]));
				} else {
					routes[i] = new Route(routes, routeObj,i,processed);
					similarRoute = false;
				}
			}
			refMatch = undefined;
			return routes;
		}
	
		var routePredefined = [getDependenciesStr,getResourcesStr,beforeModelStr,modelStr,afterModelStr,redirectStr,renderTemplateStr,afterRenderStr,beforeExitStr],
		Route = function(routes, fns,index,processed,prevInstance)  {
			var self = this;
			var src = prevInstance || fns;
			for(var key in src) {
				if(prevInstance || !_presence(routePredefined,key)) {
					if(key == "__lp") {
						this.__lp = Lyte.deepCopyObject(src.__lp);
					} else {
						this[key] = src[key];
					}
				} 
			}
			if(processed.transComp && !processed.transComp.rendered[index] && processed.transComp.redirected && processed.transComp.redirected.index < index) {
				delete this.__lp.loadDependencies;
				delete this.__lp.loadResources;
				this.$ = {};
				delete this.currentModel;
			} 
			this.__ltp = {
				queryParams : {}
			};
			if(this.__lp && this.__lp.toBeUsed && this.__lp.toBeUsed.length){
				var self = this;
				Lyte.extendService({services : this.__lp.toBeUsed || [], type:"route", ins: this, callback : function(serv, key, aName, serName){
					var obj = {};
					obj.key = key;
					obj.service = serName;
					Lyte.extendService({services : [obj], type:"route", ins: self});
				}});
			}
			this.transition = newTrans._trans;
			this.parent = routes[index-1];
			if(!prevInstance) {
				this.$ = {};
				if(this.init) {this.init();}
				this.throwEvent = typeof Lyte.Component !== "undefined" && Lyte.Component.throwEvent;
			}
			this.replaceWith = LR.replaceWith;
			this.transitionTo = LR.transitionTo;
			this.removeFromCache = function(arr) {
				Lyte.removeFromCache.assign(arr);
			};
			this.refresh = function(obj) {
				var refreshFrom = dotSerperator(this.__lp.objPath).length-1,
				route = Array.from(trans.matched.route),
				processed = {
					matched : trans.matched,
					R : trans.R,
					transComp : {
						unRendered : route.splice(refreshFrom),
						rendered : route
					}
				};
				trans.abort({state : 308, iAbort : true});
				newTransInfo = {replace : true,data : trans.data,fromHistory : false,url : trans.url};
				dispatch(trans.url,processed);
				if(obj && obj.refreshTemplate) {
					for(var i = refreshFrom,r; r = newTrans.routes[i]; i++) {
						delete r.component;
					}
				}
				return newTrans._trans;
			};
			this.setTitle = function(title) {
				d.title = this.title = title;
			};
			this.getQueryParams = function() {
				return this.__ltp.queryParams || {};
			};
			this.getDynamicParam = function() {
				return this.__ltp.dynamicParam;
			};
			Object.defineProperty(self,'$lg', {
				value : Lyte.__gl
			});
			this.getRouteInstance = function(routeName) {
				return LR.getRouteInstance(routeName);
			};
			this.setDynamicParam = function(value) {
				if(value && this.__ltp.dynamicParam && this.__ltp.dynamicParam != value) {
					var dynamicParams = Array.from(trans.matched.dynamicParams);
					dynamicParams.splice(this.__lp.objPath.split(".").length-1, 1, value);
					return paramChangeTrans(cloneMatchedObj(trans.matched,{dynamicParams : dynamicParams}));
				}
				return trans._trans;
			};
			function paramChangeTrans(matched) {
				var url = constructURLFromRoute(matched),
				processed = {
					matched : matched,
					R : trans.R
				};
				newTransInfo = {
					data: trans.data,
					url: url,
					fromHistory: false
				};
				dispatch(url, decideTransition(processed));
				return newTrans._trans;
				}
				this.setQueryParams = function(key,value,options)  {
				var obj = {},
				refresh;
				if(typeof key == "object") {
					obj = key;
					options = value;
				} else {
					obj[key] = value;
				}
				if(typeof options == "object") {
					refresh = options.refresh;
				}
				refresh = options;
				var matched = cloneMatchedObj(trans.matched,{queryParams : Object.assign({},trans.matched.queryParams,obj)});
				if(!_compareObj(trans.matched.queryParams,matched.queryParams)) {
					matched.refreshModel = matched.refreshModel == undefined ? refresh : matched.refreshModel;
					return paramChangeTrans(matched);
				}
				return trans._trans;
			};
		};
	
		function cloneMatchedObj(matched, data) {
			var obj = Object.assign({},matched);
			obj.route = data.route || Array.from(matched.route);
			obj.dynamicParams = data.dynamicParams || Array.from(matched.dynamicParams);
			obj.queryParams = data.queryParams || Object.assign(matched.queryParams);
			return obj;
		}
	
		function dispatchTransition(processed) {
			// processed = setParamsInDef(newMatch);
			var url = constructURLFromRoute(processed.matched);
			if(url) {
				processed.path = newTransInfo.url = url;
				dispatch(url,decideTransition(processed));
			}
			return url;
		}
	
		var allHooks = [getDependenciesStr,getResourcesStr,beforeModelStr,modelStr,afterModelStr,redirectStr,renderTemplateStr,afterRenderStr];
		function decideTransition(processed) {
			/* determines which transition to consider as previous transition */
			if(trans) {
				if(trans.running) {
					var matched = processed.matched;
					if(trans.state == 102 && trans.prom && trans.prom.hook == redirectStr) {
						var transComp = getTransitionDiffernce(trans,matched,processed.R),
						transitioningRoute = allHooks.indexOf(trans.prom.hook) <= 5 ? trans.prom.index : trans.prom.index+1,
						visibleTransComparison = getTransitionDiffernce(visibleTrans,matched,processed.R);
						if(transComp.common.length < visibleTransComparison.common.length) {
							if(transComp.rendered.length < visibleTransComparison.rendered.length) {
								processed.prevTrans = visibleTrans;
								if(trans.runLoop.templateToRemove.length) {
									trans.runLoop.templateToRemove.pop();
								}
							}
							transComp = visibleTransComparison;
							if(trans.prom.index <= visibleTransComparison.common.length -1) {
								transComp.redirected = trans.prom;
							}
						} else if(transComp.common.length-1 >= transitioningRoute) {
							if(trans.prom.index <= transComp.common.length -1) {
								processed.prevTrans = trans;
								transComp.redirected = trans.prom;
							}
						}  
					}
					var info = {
						route : matched.target,
						queryParams : matched.queryParams,
						dynamicParams : matched.dynamicParams.filter(_arrayClean)
					};
					if(LR.checkIfSameRoute(trans.info,info) && !trans.aborted) {
						trans.pause({iPause : true});  
					} else {
						trans.abort({state : 409, iAbort : true});
					}
					processed.transComp = transComp;
				} else if(trans && !trans.aborted) {
					trans.abort({state : 409, iAbort : true});
				}
			}
			return processed;
		}

		// function getRequirements(object) {
		// 	/* download files that are returned from getResources and getDependencies */
		// 	var every = function() {};
		// 	every.internal = {};
		// 	var reqType = object.reqType,
		// 	r = object.r,
		// 	index = object.index,
		// 	hook = every.internal.hook = trans.prom.hook,
		// 	errorType = reqType == dependenciesStr ? "errorDependencies" : "errorResources",
		// 	self = this;
		// 	every.internal.route = r.__lp.objPath;
		// 	Lyte.injectResources(
		// 	r.__lp[reqType],
		// 	every,
		// 	function(successFiles,errorFiles) {
		// 		/* completed callback */
		// 		r.__lp[reqType+'Loaded'] = true;
		// 		if(!errorFiles.length) {
		// 			var pending;
		// 			if(trans.pending && (pending = trans.pending[reqType]) != undefined && pending == index) {
		// 				delete trans.pending[reqType];
		// 				if((pending = trans.pending.forceFetch) != undefined && pending == index && trans.forceFetchRunning) {
		// 					delete trans.pending.forceFetch;
		// 					nestedForcedPromises.call(trans, trans.runLoop.forceFetch , trans.fRunningProm.resolve ,trans.runLoop.forceFetch[index][0]);
		// 				}
		// 				nestedPromises.call(trans,trans.runLoop,"current",trans.runningProm.resolve);
		// 			}
		// 		} else {
		// 			if(!self.aborted) {
		// 				if(!self.paused) {
		// 					self.pause({iPause : true});  
		// 				}
		// 				run[onErrorStr].call(self,hook,index, (r.__lp[errorType] = errorFiles), 424);  
		// 		}
		// 		}         
		// 	}
		// 	);
		// }
		
		// function nestedPromises(loop,state,resolve) {
		// 	if(validateTransition(this)) {
		// 	var runLoop = loop[state];
		// 	if(runLoop && runLoop.length) {
		// 		var promise = runLoop[0],
		// 		r = this.R[promise.index],
		// 		routeInstance = this.routes[promise.index];
		// 		if(promise.hook == beforeModelStr && !requirements.get(r,dependenciesStr)) {
		// 		this.pending[dependenciesStr] = promise.index;
		// 		return;
		// 		} else if(promise.hook == renderTemplateStr && !requirements.get(r,resourcesStr)) {
		// 		this.pending[resourcesStr] = promise.index;
		// 		return;
		// 		} else if(promise.hook == redirectStr && r.forceFetch && routeInstance.__lp.fetchStatus == pendingStr) {
		// 		if(!this.forceFetchRunning) {
		// 			this.forceFetchRunning = true;
		// 			runLoopPromise.call(this,nestedForcedPromises,"nestedForcedPromises");
		// 		}
		// 		this.pending.forceFetch = promise.index;
		// 		return;
		// 		} else {
		// 		promise.state = state;
		// 		trans.prom = promise;
		// 		logCallbacks(promise);
		// 		t(promise.hook+promise.index);
		// 		run[promise.hook].call(this,promise.hook,promise.index).then(function(data) {
		// 			setPendingResume.call(trans,trans.prom);
		// 			t(promise.hook+promise.index);
		// 			// if(promise.hook == modelStr) {
		// 			// 	routeInstance.currentModel = data;
		// 			// }
		// 			if(this.runningProm.resolve == resolve) {
		// 			removeHook(loop[state],promise.hook,promise.index);
		// 			nestedPromises.call(this,loop,state,resolve);  
		// 			}
		// 		}.bind(this));
		// 		}
		// 	} else if(resolve) {
		// 		resolve();
		// 	}
		// 	} else if(this.paused && this.runningProm) {
		// 	this.runningProm.reject(abortedStr);  
		// 	}
		// }

		// function nestedForcedPromises(forcedLoop, resolve, promise) {
		// 	if (validateTransition(this) && forcedLoop) {
		// 		if(!promise) {
		// 			for(var key in forcedLoop) {
		// 			var routeLoop = forcedLoop[key],
		// 			p = routeLoop[0];
		// 			if(p) {
		// 				if(requirements.get(this.R[p.index],dependenciesStr)) {
		// 				if(!routeLoop[0].running) {
		// 					nestedForcedPromises.call(this, forcedLoop, resolve,routeLoop[0]);    
		// 				}
		// 				} else {
		// 				this.pending[dependenciesStr] = p.index;
		// 				} 
		// 			}
		// 			}
		// 			return;
		// 		}
		// 		var r = this.R[promise.index],
		// 		routeInstance = this.routes[promise.index];
		// 		promise.state = "forceFetch";
		// 		trans.prom = promise;
		// 		if (promise.hook == beforeModelStr && !requirements.get(routeInstance, dependenciesStr)) {
		// 			this.pending[dependenciesStr] = promise.index;
		// 			return;
		// 		}
		// 		logCallbacks(promise);
		// 		forcedLoop[promise.index][0].running = true;
		// 		forcedLoop[promise.index].splice(0, 1);
		// 		run[promise.hook].call(this, promise.hook, promise.index).then(function (data) {
		// 			setPendingResume.call(trans, trans.prom);
		// 			if(promise.hook == afterModelStr) {
		// 				routeInstance.__lp.fetchStatus = completedStr;
		// 				if (this.pending.forceFetch != undefined && this.pending.forceFetch == promise.index) {
		// 				delete this.pending.forceFetch;
		// 				nestedPromises.call(this,this.runLoop,"current",this.runningProm.resolve);
		// 				}
		// 			} else if(promise.hook == modelStr) {
		// 				routeInstance.currentModel = data;
		// 				if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == afterModelStr) {
		// 					nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
		// 				}
		// 			} else {
		// 				if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == modelStr) {
		// 					nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
		// 				}
		// 			}
		// 		}.bind(this));
		// 	} else {
		// 	this.forceFetchRunning = false;
		// 	}
		// }

		return this;
	}
	Lyte.Router = new Router();
})(window);
 
 Lyte.developmentVariables =  { production :undefined}