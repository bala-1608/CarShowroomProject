(()=>{var e={238:()=>{window.DOMPurifyCopy=window.DOMPurify?window.DOMPurify:void 0},508:function(e){e.exports=function(){"use strict";function e(e,t,n,r,o,i,a){if(r||!(t in e))return Object.defineProperty&&function(){try{return Object.defineProperty({},"x",{}),1}catch(e){return}}()?(o=!0===o,i=!0===i,a=!0===a,Object.defineProperty(e,t,{value:n,writable:o,configurable:i,enumerable:a})):(e[t]=n,e)}function t(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var n=(function(e,n){n&&t(e.prototype,n)}(r,[{key:"debug",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&this.level===this.LEVELS.DEBUG){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).debug.apply(e,n.concat([performance.now()]))}}},{key:"info",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.INFO)){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).log.apply(e,n.concat([performance.now()]))}}},{key:"warn",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.WARN)){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).warn.apply(e,n.concat([performance.now()]))}}},{key:"error",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.ERROR)){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).error.apply(e,n.concat([performance.now()]))}}}]),r);function r(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,r),this.LEVELS={NONE:-1,DEBUG:0,INFO:1,WARN:2,ERROR:3},e===this.LEVELS.NONE||e===this.LEVELS.DEBUG||e===this.LEVELS.INFO||e===this.LEVELS.WARN||e===this.LEVELS.ERROR?this.level=e:this.level=this.LEVELS.ERROR}var o=window&&window.ZWAF?window.ZWAF:{version:"7.0.0"},i=new n;o.defineProperty||(o.defineProperty=e),o.logger||(o.logger=i),o["7_0_0"]||(o["7_0_0"]={version:"7.0.0",defineProperty:e,logger:i});var a=!1;function l(e,t){if(e instanceof Object)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t(n,e[n])}function c(e,t){var n;(n=Array.prototype.splice).call.apply(n,[e,e.length,0].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(t)))}function u(e,t){if(!e||e.constructor===Object)return e;for(var n={},r=0;r<e.length;r++){var o=e[r];n[o[t]]=o}return n}function s(e){if(e&&e.constructor===String)return e.toLowerCase();if(e.constructor===Array)for(var t=0;t<e.length;t++)e[t]=s(e[t]);return e}function d(e,t,n,r){if(Array.isArray(e))for(var o=0,i=e.length;o<i;o++)f(e,t,o,n);else for(var a in e)r&&-1!==r.indexOf(a)||f(e,t,a,n);return t}function f(e,t,n,r){var o;r?(o=e[n],Array.isArray(o)?(t[n]||(t[n]=[]),d(o,t[n],r)):o instanceof Object?(t[n]||(t[n]={}),d(o,t[n],r)):t[n]=o):t[n]=e[n]}function p(e,t,n){var r=2<arguments.length&&void 0!==n?n:{};if(r=Object.assign({path:"/",SameSite:"lax","max-age":864e7},r),encodeURIComponent){var o,i=encodeURIComponent(e)+"="+encodeURIComponent(t);for(o in r){i+="; "+o;var a=r[o];!0!==a&&(i+="="+a)}document.cookie=i}}function m(e,t){p(e,"",{path:1<arguments.length&&void 0!==t?t:"/","max-age":-1})}n={log:function(){if(window&&window.console&&window.console.log&&window.navigator&&window.navigator.userAgent&&!a){var e=window.navigator.userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\/)/i);if(a=!0,e&&e[0].search(/trident|msie/i)<0)return window.console.log("%cSTOP!","color:red;font-size:xx-large;font-weight:bold;"),void window.console.log("%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details","font-size:large;");window.console.log("STOP!\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details")}}},"7.0.0"!==o.version||o.Console||o.defineProperty(o,"Console",n,!0,!1,!1,!0),o["7_0_0"].Console||o.defineProperty(o["7_0_0"],"Console",n,!0,!1,!1,!0),["_zcsr_tmp","com_chat_owner","com_avcliq_owner","wms.agent"].some((function(e){return!!function(e){e+="=";var t=document.cookie,n=void 0;return t.split("; ").forEach((function(t){if(void 0===n){var r=void 0;try{decodeURIComponent&&(r=decodeURIComponent(t))}catch(e){r=t,ZWAF&&ZWAF.logger&&ZWAF.logger.warn&&ZWAF.logger.warn("Error while trying to decode Cookie value!")}0===r.indexOf(e)&&(n=r.substring(e.length))}})),n}(e)}))&&o&&o["7_0_0"]&&o["7_0_0"].Console&&o["7_0_0"].Console.log();var A="_zwaf_ua";i={init:function(){m(A);var e=!!window.ulaa,t=navigator&&navigator.brave&&"function"==typeof navigator.brave.isBrave;e?p(A,"Ulaa"):t?p(A,"Brave"):window&&window.addEventListener("load",(function(){window.setTimeout((function(){window.getComputedStyle(window.document.documentElement).getPropertyValue("--arc-palette-background")&&p(A,"Arc")}),1e3)}))},disable:function(){m(A)}},"7.0.0"!==o.version||o.UAIdentification||o.defineProperty(o,"UAIdentification",i,!0,!1,!1,!0),o["7_0_0"].UAIdentification||o.defineProperty(o["7_0_0"],"UAIdentification",i,!0,!1,!1,!0),o&&o["7_0_0"]&&o["7_0_0"].UAIdentification&&o["7_0_0"].UAIdentification.init();var E,T=Object.hasOwnProperty,h=Object.setPrototypeOf,_=Object.isFrozen,g=Object.getPrototypeOf,N=Object.getOwnPropertyDescriptor,v=Object.freeze,y=(n=Object.seal,Object.create),S=(i="undefined"!=typeof Reflect&&Reflect,(S=i.apply)||function(e,t,n){return e.apply(t,n)}),O=(v=v||function(e){return e},n=n||function(e){return e},(O=i.construct)||function(e,t){return new(Function.prototype.bind.apply(e,[null].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(t))))}),L=F(Array.prototype.forEach),R=F(Array.prototype.pop),w=F(Array.prototype.push),b=F(String.prototype.toLowerCase),I=F(String.prototype.toString),D=F(String.prototype.match),C=F(String.prototype.replace),P=F(String.prototype.indexOf),U=F(String.prototype.trim),x=F(RegExp.prototype.test),k=(E=TypeError,function(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return O(E,t)});function M(e){return"number"==typeof e&&isNaN(e)}function F(e){return function(t){for(var n=arguments.length,r=Array(1<n?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];return S(e,t,r)}}function G(e,t,n){n=n||b,h&&h(e,null);for(var r=t.length;r--;){var o,i=t[r];"string"!=typeof i||(o=n(i))!==i&&(_(t)||(t[r]=o),i=o),e[i]=!0}return e}function B(e){var t=y(null),n=void 0;for(n in e)!0===S(T,e,[n])&&(t[n]=e[n]);return t}function H(e,t){for(;null!==e;){var n=N(e,t);if(n){if(n.get)return F(n.get);if("function"==typeof n.value)return F(n.value)}e=g(e)}return function(e){return null}}var V=v(["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dialog","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"]),W=v(["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","view","vkern"]),z=v(["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]),j=v(["animate","color-profile","cursor","discard","fedropshadow","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignobject","hatch","hatchpath","mesh","meshgradient","meshpatch","meshrow","missing-glyph","script","set","solidcolor","unknown","use"]),X=v(["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmultiscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mspace","msqrt","mstyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover"]),q=v(["maction","maligngroup","malignmark","mlongdiv","mscarries","mscarry","msgroup","mstack","msline","msrow","semantics","annotation","annotation-xml","mprescripts","none"]),Y=v(["#text"]),Z=v(["accept","action","align","alt","autocapitalize","autocomplete","autopictureinpicture","autoplay","background","bgcolor","border","capture","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","controls","controlslist","coords","crossorigin","datetime","decoding","default","dir","disabled","disablepictureinpicture","disableremoteplayback","download","draggable","enctype","enterkeyhint","face","for","headers","height","hidden","high","href","hreflang","id","inputmode","integrity","ismap","kind","label","lang","list","loading","loop","low","max","maxlength","media","method","min","minlength","multiple","muted","name","nonce","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","playsinline","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","translate","type","usemap","valign","value","width","xmlns","slot"]),K=v(["accent-height","accumulate","additive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clippathunits","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","filterunits","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","primitiveunits","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","startoffset","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","systemlanguage","tabindex","targetx","targety","transform","transform-origin","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","version","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"]),Q=v(["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","encoding","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"]),$=v(["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]),J=n(/\{\{[\w\W]*|[\w\W]*\}\}/gm),ee=n(/<%[\w\W]*|[\w\W]*%>/gm),te=n(/\${[\w\W]*}/gm),ne=n(/^data-[\-\w.\u00B7-\uFFFF]/),re=n(/^aria-[\-\w]+$/),oe=n(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),ie=n(/^(?:\w+script|data):/i),ae=n(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),le=n(/^html$/i),ce=n(/^[a-z][.\w]*(-[.\w]+)+$/i),ue="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function se(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}var de=(i=function e(t){function n(t){return e(t)}var r=0<arguments.length&&void 0!==t?t:"undefined"==typeof window?null:window;if(n.version="2.5.4",n.removed=[],!r||!r.document||9!==r.document.nodeType)return n.isSupported=!1,n;var o=r.document,i=r.document,a=r.DocumentFragment,l=r.HTMLTemplateElement,c=r.Node,u=r.Element,s=r.NodeFilter,d=void 0===(t=r.NamedNodeMap)?r.NamedNodeMap||r.MozNamedAttrMap:t,f=r.HTMLFormElement,p=r.DOMParser,m=r.trustedTypes,A=H(t=u.prototype,"cloneNode"),E=H(t,"nextSibling"),T=H(t,"childNodes"),h=H(t,"parentNode");"function"!=typeof l||(de=i.createElement("template")).content&&de.content.ownerDocument&&(i=de.content.ownerDocument);var _=function(e,t){if("object"!==(void 0===e?"undefined":ue(e))||"function"!=typeof e.createPolicy)return null;var n=null,r="data-tt-policy-suffix";n="dompurify"+((n=t.currentScript&&t.currentScript.hasAttribute(r)?t.currentScript.getAttribute(r):n)?"#"+n:"");try{return e.createPolicy(n,{createHTML:function(e){return e},createScriptURL:function(e){return e}})}catch(e){return null}}(m,o),g=_?_.createHTML(""):"",N=(de=i).implementation,y=de.createNodeIterator,S=de.createDocumentFragment,O=de.getElementsByTagName,F=o.importNode,de={};try{de=B(i).documentMode?i.documentMode:{}}catch(t){}var fe={};function pe(e){return e instanceof RegExp||e instanceof Function}function me(e){dt&&dt===e||(e=B(e=e&&"object"===(void 0===e?"undefined":ue(e))?e:{}),ct=-1===ut.indexOf(e.PARSER_MEDIA_TYPE)?"text/html":e.PARSER_MEDIA_TYPE,st="application/xhtml+xml"===ct?I:b,Oe="ALLOWED_TAGS"in e?G({},e.ALLOWED_TAGS,st):Le,we="ALLOWED_ATTR"in e?G({},e.ALLOWED_ATTR,st):be,at="ALLOWED_NAMESPACES"in e?G({},e.ALLOWED_NAMESPACES,I):lt,Je="ADD_URI_SAFE_ATTR"in e?G(B(et),e.ADD_URI_SAFE_ATTR,st):et,Qe="ADD_DATA_URI_TAGS"in e?G(B($e),e.ADD_DATA_URI_TAGS,st):$e,Ze="FORBID_CONTENTS"in e?G({},e.FORBID_CONTENTS,st):Ke,De="FORBID_TAGS"in e?G({},e.FORBID_TAGS,st):{},Ce="FORBID_ATTR"in e?G({},e.FORBID_ATTR,st):{},Ae="USE_PROFILES"in e&&e.USE_PROFILES,Pe=!1!==e.ALLOW_ARIA_ATTR,Ue=!1!==e.ALLOW_DATA_ATTR,xe=e.ALLOW_UNKNOWN_PROTOCOLS||!1,ke=!1!==e.ALLOW_SELF_CLOSE_IN_ATTR,Me=e.SAFE_FOR_TEMPLATES||!1,Fe=!1!==e.SAFE_FOR_XML,Ge=e.WHOLE_DOCUMENT||!1,Ve=e.RETURN_DOM||!1,We=e.RETURN_DOM_FRAGMENT||!1,ze=e.RETURN_TRUSTED_TYPE||!1,Re=!1!==e.DONT_TRIM,He=e.FORCE_BODY||!1,je=!1!==e.SANITIZE_DOM,Xe=e.SANITIZE_NAMED_PROPS||!1,qe=!1!==e.KEEP_CONTENT,Ye=e.IN_PLACE||!1,Se=e.ALLOWED_URI_REGEXP||Se,ot=e.NAMESPACE||rt,Ie=e.CUSTOM_ELEMENT_HANDLING||{},e.CUSTOM_ELEMENT_HANDLING&&pe(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck)&&(Ie.tagNameCheck=e.CUSTOM_ELEMENT_HANDLING.tagNameCheck),e.CUSTOM_ELEMENT_HANDLING&&pe(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)&&(Ie.attributeNameCheck=e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),e.CUSTOM_ELEMENT_HANDLING&&"boolean"==typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(Ie.allowCustomizedBuiltInElements=e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),Me&&(Ue=!1),We&&(Ve=!0),Ae&&(Oe=G({},[].concat(se(Y))),we=[],!0===Ae.html&&(G(Oe,V),G(we,Z)),!0===Ae.svg&&(G(Oe,W),G(we,K),G(we,$)),!0===Ae.svgFilters&&(G(Oe,z),G(we,K),G(we,$)),!0===Ae.mathMl&&(G(Oe,X),G(we,Q),G(we,$))),e.ADD_TAGS&&G(Oe=Oe===Le?B(Oe):Oe,e.ADD_TAGS,st),e.ADD_ATTR&&G(we=we===be?B(we):we,e.ADD_ATTR,st),e.ADD_URI_SAFE_ATTR&&G(Je,e.ADD_URI_SAFE_ATTR,st),e.FORBID_CONTENTS&&G(Ze=Ze===Ke?B(Ze):Ze,e.FORBID_CONTENTS,st),qe&&(Oe["#text"]=!0),Ge&&G(Oe,["html","head","body"]),Oe.table&&(G(Oe,["tbody"]),delete De.tbody),v&&v(e),dt=e)}n.isSupported="function"==typeof h&&N&&void 0!==N.createHTMLDocument&&9!==de;var Ae,Ee=J,Te=ee,he=te,_e=ne,ge=re,Ne=ie,ve=ae,ye=ce,Se=oe,Oe=null,Le=G({},[].concat(se(V),se(W),se(z),se(X),se(Y))),Re=!0,we=null,be=G({},[].concat(se(Z),se(K),se(Q),se($))),Ie=Object.seal(Object.create(null,{tagNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},attributeNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},allowCustomizedBuiltInElements:{writable:!0,configurable:!1,enumerable:!0,value:!1}})),De=null,Ce=null,Pe=!0,Ue=!0,xe=!1,ke=!0,Me=!1,Fe=!0,Ge=!1,Be=!1,He=!1,Ve=!1,We=!1,ze=!1,je=!0,Xe=!1,qe=!0,Ye=!1,Ze=null,Ke=G({},["annotation-xml","audio","colgroup","desc","foreignobject","head","iframe","math","mi","mn","mo","ms","mtext","noembed","noframes","noscript","plaintext","script","style","svg","template","thead","title","video","xmp"]),Qe=null,$e=G({},["audio","video","img","source","image","track"]),Je=null,et=G({},["alt","class","for","id","label","name","pattern","placeholder","role","summary","title","value","style","xmlns"]),tt="http://www.w3.org/1998/Math/MathML",nt="http://www.w3.org/2000/svg",rt="http://www.w3.org/1999/xhtml",ot=rt,it=!1,at=null,lt=G({},[tt,nt,rt],I),ct=void 0,ut=["application/xhtml+xml","text/html"],st=void 0,dt=null,ft=i.createElement("form"),pt=G({},["mi","mo","mn","ms","mtext"]),mt=G({},["foreignobject","annotation-xml"]),At=G({},["title","style","font","a","script"]),Et=G({},W);G(Et,z),G(Et,j);var Tt=G({},X);function ht(e){w(n.removed,{element:e});try{e.parentNode.removeChild(e)}catch(t){try{e.outerHTML=g}catch(t){e.remove()}}}function _t(e,t){try{w(n.removed,{attribute:t.getAttributeNode(e),from:t})}catch(e){w(n.removed,{attribute:null,from:t})}if(t.removeAttribute(e),"is"===e&&!we[e])if(Ve||We)try{ht(t)}catch(e){}else try{t.setAttribute(e,"")}catch(e){}}function gt(e){var t=void 0,n=void 0;He?e="<remove></remove>"+e:n=(r=D(e,/^[\r\n\t ]+/))&&r[0],"application/xhtml+xml"===ct&&ot===rt&&(e='<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>'+e+"</body></html>");var r=_?_.createHTML(e):e;if(ot===rt)try{t=(new p).parseFromString(r,ct)}catch(e){}if(!t||!t.documentElement){t=N.createDocument(ot,"template",null);try{t.documentElement.innerHTML=it?g:r}catch(e){}}return r=t.body||t.documentElement,e&&n&&r.insertBefore(i.createTextNode(n),r.childNodes[0]||null),ot===rt?O.call(t,Ge?"html":"body")[0]:Ge?t.documentElement:r}function Nt(e){return y.call(e.ownerDocument||e,e,s.SHOW_ELEMENT|s.SHOW_COMMENT|s.SHOW_TEXT|s.SHOW_PROCESSING_INSTRUCTION|s.SHOW_CDATA_SECTION,null,!1)}function vt(e){return e instanceof f&&(void 0!==e.__depth&&"number"!=typeof e.__depth||void 0!==e.__removalCount&&"number"!=typeof e.__removalCount||"string"!=typeof e.nodeName||"string"!=typeof e.textContent||"function"!=typeof e.removeChild||!(e.attributes instanceof d)||"function"!=typeof e.removeAttribute||"function"!=typeof e.setAttribute||"string"!=typeof e.namespaceURI||"function"!=typeof e.insertBefore||"function"!=typeof e.hasChildNodes)}function yt(e){return"object"===(void 0===c?"undefined":ue(c))?e instanceof c:e&&"object"===(void 0===e?"undefined":ue(e))&&"number"==typeof e.nodeType&&"string"==typeof e.nodeName}function St(e,t,r){fe[e]&&L(fe[e],(function(e){e.call(n,t,r,dt)}))}function Ot(e){var t;if(St("beforeSanitizeElements",e,null),vt(e))return ht(e),1;if(x(/[\u0080-\uFFFF]/,e.nodeName))return ht(e),1;var r=st(e.nodeName);if(St("uponSanitizeElement",e,{tagName:r,allowedTags:Oe}),e.hasChildNodes()&&!yt(e.firstElementChild)&&(!yt(e.content)||!yt(e.content.firstElementChild))&&x(/<[/\w]/g,e.innerHTML)&&x(/<[/\w]/g,e.textContent))return ht(e),1;if("select"===r&&x(/<template/i,e.innerHTML))return ht(e),1;if(7===e.nodeType)return ht(e),1;if(Fe&&8===e.nodeType&&x(/<[/\w]/g,e.data))return ht(e),1;if(Oe[r]&&!De[r])return e instanceof u&&!function(e){var t=h(e);t&&t.tagName||(t={namespaceURI:ot,tagName:"template"});var n=b(e.tagName),r=b(t.tagName);return at[e.namespaceURI]&&(e.namespaceURI===nt?t.namespaceURI===rt?"svg"===n:t.namespaceURI===tt?"svg"===n&&("annotation-xml"===r||pt[r]):Boolean(Et[n]):e.namespaceURI===tt?t.namespaceURI===rt?"math"===n:t.namespaceURI===nt?"math"===n&&mt[r]:Boolean(Tt[n]):e.namespaceURI===rt?(t.namespaceURI!==nt||mt[r])&&(t.namespaceURI!==tt||pt[r])&&!Tt[n]&&(At[n]||!Et[n]):"application/xhtml+xml"===ct&&at[e.namespaceURI])}(e)||("noscript"===r||"noembed"===r||"noframes"===r)&&x(/<\/no(script|embed|frames)/i,e.innerHTML)?(ht(e),1):(Me&&3===e.nodeType&&(t=e.textContent,t=C(t,Ee," "),t=C(t,Te," "),t=C(t,he," "),e.textContent!==t&&(w(n.removed,{element:e.cloneNode()}),e.textContent=t)),St("afterSanitizeElements",e,null),0);if(!De[r]&&bt(r)){if(Ie.tagNameCheck instanceof RegExp&&x(Ie.tagNameCheck,r))return;if(Ie.tagNameCheck instanceof Function&&Ie.tagNameCheck(r))return}if(qe&&!Ze[r]){var o=h(e)||e.parentNode,i=T(e)||e.childNodes;if(i&&o)for(var a=i.length-1;0<=a;--a){var l=A(i[a],!0);l.__removalCount=(e.__removalCount||0)+1,o.insertBefore(l,E(e))}}return ht(e),1}function Lt(e,t,n){if(je&&("id"===t||"name"===t)&&(n in i||n in ft||"__depth"===n||"__removalCount"===n))return!1;if((!Ue||Ce[t]||!x(_e,t))&&(!Pe||!x(ge,t)))if(!we[t]||Ce[t]){if(!(bt(e)&&(Ie.tagNameCheck instanceof RegExp&&x(Ie.tagNameCheck,e)||Ie.tagNameCheck instanceof Function&&Ie.tagNameCheck(e))&&(Ie.attributeNameCheck instanceof RegExp&&x(Ie.attributeNameCheck,t)||Ie.attributeNameCheck instanceof Function&&Ie.attributeNameCheck(t))||"is"===t&&Ie.allowCustomizedBuiltInElements&&(Ie.tagNameCheck instanceof RegExp&&x(Ie.tagNameCheck,n)||Ie.tagNameCheck instanceof Function&&Ie.tagNameCheck(n))))return!1}else if(!Je[t]&&!x(Se,C(n,ve,""))&&("src"!==t&&"xlink:href"!==t&&"href"!==t||"script"===e||0!==P(n,"data:")||!Qe[e])&&(!xe||x(Ne,C(n,ve,"")))&&n)return!1;return!0}function Rt(e){var t,r=void 0,o=void 0,i=void 0;St("beforeSanitizeAttributes",e,null);var a=e.attributes;if(a){var l={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:we,nodeName:e.nodeName.toLowerCase()};for(i=a.length;i--;){var c=(r=a[i]).name,u=r.namespaceURI;if(o="value"===c?r.value:U(r.value),Re&&(o=r.value),t=st(c),l.attrName=t,l.attrValue=o,l.keepAttr=!0,l.keepElement=!0,l.forceKeepAttr=void 0,St("uponSanitizeAttribute",e,l),!l.keepElement)return 1;if(o=l.attrValue,!l.forceKeepAttr&&(_t(c,e),l.keepAttr))if(ke||!x(/\/>/i,o))if(Fe&&x(/((--!?|])>)|<\/(style|title)/i,o))_t(c,e);else{Me&&(o=C(o,Ee," "),o=C(o,Te," "),o=C(o,he," "));var s=e.nodeName.toLowerCase();if(Lt(s,t,o)){if(!Xe||"id"!==t&&"name"!==t||(_t(c,e),o="user-content-"+o),_&&"object"===(void 0===m?"undefined":ue(m))&&"function"==typeof m.getAttributeType&&!u)switch(m.getAttributeType(s,t)){case"TrustedHTML":o=_.createHTML(o);break;case"TrustedScriptURL":o=_.createScriptURL(o)}try{u?e.setAttributeNS(u,c,o):e.setAttribute(c,o),vt(e)?ht(e):R(n.removed)}catch(e){}}}else _t(c,e)}return St("afterSanitizeAttributes",e,null),0}}function wt(e){var t,n=void 0,r=Nt(e);for(St("beforeSanitizeShadowDOM",e,null);n=r.nextNode();)St("uponSanitizeShadowNode",n,null),Ot(n)||(t=h(n),1===n.nodeType&&(t&&t.__depth?n.__depth=(n.__removalCount||0)+t.__depth+1:n.__depth=1),(255<=n.__depth||M(n.__depth))&&ht(n),n.content instanceof a&&(n.content.__depth=n.__depth,wt(n.content)),Rt(n)&&ht(n));St("afterSanitizeShadowDOM",e,null)}G(Tt,q);var bt=function(e){return"annotation-xml"!==e&&D(e,ye)};return n.sanitize=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},i=void 0,l=void 0,u=void 0,s=void 0;if("string"!=typeof(e=(it=!e)?"\x3c!--\x3e":e)&&!yt(e)){if("function"!=typeof e.toString)throw k("toString is not a function");if("string"!=typeof(e=e.toString()))throw k("dirty is not a string, aborting")}if(!n.isSupported){if("object"===ue(r.toStaticHTML)||"function"==typeof r.toStaticHTML){if("string"==typeof e)return r.toStaticHTML(e);if(yt(e))return r.toStaticHTML(e.outerHTML)}return e}if(Be||me(t),n.removed=[],Ye="string"!=typeof e&&Ye){if(e.nodeName&&(t=st(e.nodeName),!Oe[t]||De[t]))throw k("root node is forbidden and cannot be sanitized in-place")}else if(e instanceof c)1===(t=(i=gt("\x3c!----\x3e")).ownerDocument.importNode(e,!0)).nodeType&&"BODY"===t.nodeName||"HTML"===t.nodeName?i=t:i.appendChild(t);else{if(!Ve&&!Me&&!Ge&&-1===e.indexOf("<"))return _&&ze?_.createHTML(e):e;if(!(i=gt(e)))return Ve?null:ze?g:""}i&&He&&ht(i.firstChild);for(var d,f=Nt(Ye?e:i);l=f.nextNode();)3===l.nodeType&&l===u||Ot(l)||(d=h(l),1===l.nodeType&&(d&&d.__depth?l.__depth=(l.__removalCount||0)+d.__depth+1:l.__depth=1),(255<=l.__depth||M(l.__depth))&&ht(l),l.content instanceof a&&(l.content.__depth=l.__depth,wt(l.content)),Rt(l)?ht(l):u=l);if(u=null,Ye)return e;if(Ve){if(We)for(s=S.call(i.ownerDocument);i.firstChild;)s.appendChild(i.firstChild);else s=i;return we.shadowroot||we.shadowrootmod?F.call(o,s,!0):s}return e=Ge?i.outerHTML:i.innerHTML,Ge&&Oe["!doctype"]&&i.ownerDocument&&i.ownerDocument.doctype&&i.ownerDocument.doctype.name&&x(le,i.ownerDocument.doctype.name)&&(e="<!DOCTYPE "+i.ownerDocument.doctype.name+">\n"+e),Me&&(e=C(e,Ee," "),e=C(e,Te," "),e=C(e,he," ")),_&&ze?_.createHTML(e):e},n.setConfig=function(e){me(e),Be=!0},n.clearConfig=function(){dt=null,Be=!1},n.isValidAttribute=function(e,t,n){return dt||me({}),Lt(e=b(e),t=b(t),n)},n.addHook=function(e,t){"function"==typeof t&&(fe[e]=fe[e]||[],w(fe[e],t))},n.removeHook=function(e){if(fe[e])return R(fe[e])},n.removeHooks=function(e){fe[e]&&(fe[e]=[])},n.removeAllHooks=function(){fe={}},n}(),(Object.seal||function(e){return e})(/\$\{[A-Z._]+?\}/i));function fe(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}var pe=Object.freeze;return(n={FORCE_BODY:!0,ALLOWED_URI_REGEXP:!1,REUSE_CONFIG:!1,REMOVE_ONEVENTS:!0,EXTENDS:["GLOBAL_TAGS","GLOBAL_ATTR","FORBID_TAGS","FORBID_ATTR","TAG_RULES","GLOBAL_ATTR_RULES","GLOBAL_APPEND_ATTR","ADD_DATA_URI_TAGS","ADD_URI_SAFE_ATTR"],ALLOWED_STYLE:"NONE",STYLE_RULES:{FORBID_PROPS:[],FORBID_CSSRULES:[],UNSAFE_PROP_RULES:{}}}).GLOBAL_TAGS="a|abbr|acronym|address|area|article|aside|audio|b|bdi|bdo|big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|content|data|datalist|dd|decorator|del|details|dfn|dir|div|dl|dt|element|em|fieldset|figcaption|figure|font|footer|form|h1|h2|h3|h4|h5|h6|head|header|hgroup|hr|html|i|img|input|ins|kbd|label|legend|li|main|map|mark|marquee|menu|menuitem|meter|nav|nobr|ol|optgroup|option|output|p|pre|progress|q|rp|rt|ruby|s|samp|section|select|shadow|small|source|spacer|span|strike|strong|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr|#text".split("|"),n.GLOBAL_ATTR="accept|action|align|alt|autocomplete|background|bgcolor|border|cellpadding|cellspacing|checked|cite|class|clear|color|cols|colspan|coords|datetime|default|dir|disabled|download|enctype|face|for|headers|height|hidden|high|href|hreflang|id|ismap|label|lang|list|loop|low|max|maxlength|media|method|min|multiple|name|noshade|novalidate|nowrap|open|optimum|pattern|placeholder|poster|preload|pubdate|radiogroup|readonly|rel|required|rev|reversed|role|rows|rowspan|spellcheck|scope|selected|shape|size|span|srclang|start|src|step|summary|tabindex|title|target|type|usemap|valign|value|width|xmlns|sandbox".split("|"),n.FORBID_TAGS=[],n.FORBID_ATTR=[],n.GLOBAL_ATTR_RULES={},n.GLOBAL_APPEND_ATTR={},n.ADD_DATA_URI_TAGS=[],n.ADD_URI_SAFE_ATTR=[],n.TAG_RULES={a:{APPEND_ATTR:{rel:{ATTR_NAME:"rel",APPEND_ATTR_VALUE:"noopener noreferrer",SIBLING_CONDITIONS:[{ATTR_NAME:"target",CONDITIONS:[{IS_MANDATORY:"true",CONTAINS:"_blank"}]}]}}}},n.TAG_SPECIFIC_ATTRS={},i=function e(t,n){var r="GLOBAL_TAGS",o="GLOBAL_ATTR",i="GLOBAL_ATTRIBUTES",a="FORBID_TAGS",f="FORBID_ATTR",p="TAG_RULES",m="STYLE_RULES",A="GLOBAL_ATTR_RULES",E="GLOBAL_APPEND_ATTR",T="ADD_DATA_URI_TAGS",h="ADD_URI_SAFE_ATTR",_="REMOVE_ONEVENTS",g=["ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","SAFE_FOR_TEMPLATES","WHOLE_DOCUMENT","RETURN_DOM","RETURN_DOM_FRAGMENT","IN_PLACE","DONT_TRIM","FORCE_BODY","SANITIZE_DOM","KEEP_CONTENT","ALLOWED_URI_REGEXP"],N=[];c(N,g),c(N,["EXTENDS",_,"ALLOWED_STYLE"]);var v={iframe:{ATTR_RULES:{sandbox:{FALLBACK_VALUE:"allow-popups allow-forms allow-scripts allow-same-origin",CONDITIONS:[{NOT_CONTAINS:["allow-top-navigation","allow-popups-to-escape-sandbox"]}]}},APPEND_ATTR:{sandbox:{APPEND_ATTR_VALUE:"allow-popups allow-forms allow-scripts allow-same-origin"}}},embed:{ATTR_RULES:{type:{CONDITIONS:[{EQUAL:"application/pdf",FALLBACK_VALUE:"application/pdf"}]}},APPEND_ATTR:{type:{APPEND_ATTR_VALUE:"application/pdf"},typemustmatch:{APPEND_ATTR_VALUE:"true"}}},object:{ATTR_RULES:{type:{CONDITIONS:[{EQUAL:"application/pdf",FALLBACK_VALUE:"application/pdf"}]}},APPEND_ATTR:{type:{APPEND_ATTR_VALUE:"application/pdf"},typemustmatch:{APPEND_ATTR_VALUE:"true"}}}},y=void 0,S=void 0,O=void 0,L=t.GLOBAL_TAGS,R=t.GLOBAL_ATTR,w=t.FORBID_TAGS,b=t.FORBID_ATTR,I=t.TAG_RULES,D=t.STYLE_RULES,C=t.GLOBAL_ATTR_RULES,P=t.GLOBAL_APPEND_ATTR,U=t.TAG_SPECIFIC_ATTRS,x=D.FORBID_PROPS,k=D.FORBID_CSSRULES,M=D.UNSAFE_PROP_RULES,F=x&&0!==x.length||k&&0!==k.length;function G(e,t,n){if(e.constructor===String){if(t.CASE_SENSITIVE||(e=e.toLowerCase()),t.DONT_TRIM||(e=e.trim()),t.MAX_LENGTH&&e.length>t.MAX_LENGTH)return!1;if(t.MIN_LENGTH&&e.length<t.MIN_LENGTH)return!1;if(t.REGEX&&t.REGEX.constructor===RegExp&&-1===e.search(t.REGEX))return!1;if(t.REGEX&&t.REGEX.constructor===String&&(new RegExp(t.REGEX),-1===e.search(t.REGEX)))return!1;if(t.REGEX&&t.REGEX.constructor===Array)for(var r=0;r<t.REGEX.length;r++)if(-1===e.search(t.REGEX[r]))return!1;if(t.VALIDATOR&&t.VALIDATOR.HANDLER&&!t.VALIDATOR.HANDLER(e,t.VALIDATOR.CONFIG,n))return!1;if(void 0!==t.STARTS_WITH&&0!==e.indexOf(t.STARTS_WITH))return!1;if(void 0!==t.ENDS_WITH&&e.lastIndexOf(t.ENDS_WITH)!==e.length-t.ENDS_WITH.length)return!1;if(t.CONTAINS&&t.CONTAINS.constructor===String&&-1===e.indexOf(t.CONTAINS))return!1;if(t.CONTAINS&&t.CONTAINS.constructor===Array)for(var o=0;o<t.CONTAINS.length;o++)if(-1===e.indexOf(t.CONTAINS[o]))return!1;if(t.NOT_CONTAINS&&t.NOT_CONTAINS.constructor===String&&-1<e.indexOf(t.NOT_CONTAINS))return!1;if(t.NOT_CONTAINS&&t.NOT_CONTAINS.constructor===Array)for(var i=0;i<t.NOT_CONTAINS.length;i++)if(-1<e.indexOf(t.NOT_CONTAINS[i]))return!1;if(void 0!==t.EQUAL&&e!=t.EQUAL)return!1;if(void 0!==t.NOT_EQUAL&&e==t.NOT_EQUAL)return!1}if(t.LIST&&-1===t.LIST.indexOf(e))return!1;if("INTEGER"===t.TYPE||"FLOAT"===t.TYPE){n=void 0;try{n="INTEGER"===t.TYPE?window.parseInt(e,10):window.parseFloat(e)}catch(e){return!1}if(window.isNaN(n))return!1;if(void 0!==t.GREATER_THAN&&n<=t.GREATER_THAN)return!1;if(void 0!==t.GREATER_THAN_OR_EQUAL&&n<t.GREATER_THAN_OR_EQUAL)return!1;if(void 0!==t.LESSER_THAN&&n>=t.LESSER_THAN)return!1;if(void 0!==t.LESSER_THAN_OR_EQUAL&&n>t.LESSER_THAN_OR_EQUAL)return!1;if(void 0!==t.EQUAL&&n!==t.EQUAL)return!1;if(void 0!==t.NOT_EQUAL&&n===t.NOT_EQUAL)return!1}return!0}function B(e,t,n){var r=!0;if(!t||!t.CONDITIONS||0===t.CONDITIONS.length)return{isValid:r,rule:t};n=t.ATTR_NAME||n;for(var o,i,a,l,c=0;c<t.CONDITIONS.length;c++){var u=t.CONDITIONS[c];if(o=e,i=n,void 0,l=!1!==(a=u).IS_MANDATORY,r=i&&!o.hasAttribute(i.toLowerCase())?a.IS_FORBIDDEN||!l:!a.IS_FORBIDDEN&&G(o=null==(o=o.getAttribute(i.toLowerCase()))?"":o,a,i),r=u.NEGATION?!r:r){if(u.NEXT)return B(e,u.NEXT,n);break}}return{isValid:r,rule:t}}function H(e){l(e,(function(t,n){if(n&&n.constructor===String&&(0<x.length&&-1<x.indexOf(t)&&(e[t]="",y=!0),M[t]))for(var r=M[t],o=0;o<r.CONDITIONS.length;o++)if(G(n,r.CONDITIONS[o],t))return e[t]=void 0===r.FALLBACK_VALUE?"":r.FALLBACK_VALUE,y=!0,0}))}function V(e){if(e&&(e.CONDITIONS&&0<e.CONDITIONS.length&&(e.CONDITIONS=function(e){if(!e)return e;for(var t=0;t<e.length;t++)e[t]=function(e){if(!e||e&&e.CASE_SENSITIVE)return e;for(var t=["STARTS_WITH","ENDS_WITH","CONTAINS","EQUAL","NOT_EQUAL","LIST"],n=0;n<t.length;n++){var r=t[n];e[r]&&(e[r]=s(e[r]))}return e.NEXT&&V(e.NEXT),e}(e[t]);return e}(e.CONDITIONS)),e.SIBLING_CONDITIONS&&0<e.SIBLING_CONDITIONS.length))for(var t=0;t<e.SIBLING_CONDITIONS.length;t++)V(e.SIBLING_CONDITIONS[t])}function W(_){return e(_=function(e){if(!e||e.constructor!==Object)return d(t,e={},!0),e;e[p]||(e[p]={}),e[A]||(e[A]={}),e[E]||(e[E]={}),e[T]||(e[T]=[]),e[h]||(e[h]=[]),e[r]||(e[r]=[]),e[o]||(e[o]=[]),e[i]||(e[i]=[]),e[a]||(e[a]=[]),e[f]||(e[f]=[]),e[m]||(e[m]={}),e[m].FORBID_CSSRULES||(e[m].FORBID_CSSRULES=[]),e[m].FORBID_PROPS||(e[m].FORBID_PROPS=[]),e[m].UNSAFE_PROP_RULES||(e[m].UNSAFE_PROP_RULES={}),e.TAG_SPECIFIC_ATTRS={};for(var n=0;n<N.length;n++){var _=N[n];void 0===e[_]&&(e[_]=t[_])}e[p]=u(e[p],"NAME"),e[A]=u(e[A],"ATTR_NAME"),e[E]=u(e[E],"APPEND_ATTR_NAME");var g=e,v=g.TAG_RULES,y=g.TAG_SPECIFIC_ATTRS,S=g.STYLE_RULES,O=g.GLOBAL_ATTR,L=g.GLOBAL_ATTRIBUTES,w=g.GLOBAL_ATTR_RULES,b=g.GLOBAL_APPEND_ATTR,D=g.EXTENDS,C=S.FORBID_CSSRULES,P=S.FORBID_PROPS,F=S.UNSAFE_PROP_RULES;l(b,(function(e,t){V(t)})),l(w,(function(e,t){V(t)}));for(var G=function(n){var i,u,s=D[n];switch(s){case o:var _=[];c(_,R),l(U,(function(e){-1<(e=_.indexOf(e))&&_.splice(e,1)})),c(O,L),c(O,_);break;case r:case a:case f:case T:case h:c(e[s],t[s]);break;case p:i=v,(u=I)&&u.constructor===Object&&l(u,(function(e,t){e in i?(void 0===i[e].APPEND_ATTR&&(i[e].APPEND_ATTR=t.APPEND_ATTR),void 0===i[e].ATTR_RULES&&(i[e].ATTR_RULES=t.ATTR_RULES)):i[e]=t}));break;case E:case A:l(t[s],(function(n){e[s][n]||(e[s][n]={},d(t[s][n],e[s][n],!0))}));break;case m:P.push.apply(P,fe(x)),C.push.apply(C,fe(k)),l(M,(function(e){F[e]||(F[e]={},d(M[e],F[e],!0))}))}},B=0;B<D.length;B++)G(B);return l(w,(function(e){-1===O.indexOf(e)&&(O.push(e),y[e]&&y[e].constructor===Array||(y[e]=[]),-1===y[e].indexOf("*")&&y[e].push("*"))})),l(v,(function(e,t){e=s(e),t.APPEND_ATTR||(t.APPEND_ATTR={}),t.APPEND_ATTR=u(t.APPEND_ATTR,"APPEND_ATTR_NAME"),l(t.APPEND_ATTR,(function(e,t){V(t)})),t.ATTR_RULES||(t.ATTR_RULES={}),t.ATTR_RULES=u(t.ATTR_RULES,"ATTR_NAME"),l(t.ATTR_RULES,(function(t,n){V(n),t=s(t),(-1===O.indexOf(t)||y[t]&&0<y[t].length)&&(-1===O.indexOf(t)&&O.push(t),y[t]&&y[t].constructor===Array||(y[t]=[]),-1===y[t].indexOf(e)&&y[t].push(e))}))})),delete e.USE_PROFILES,e}(_),n(window))}return F||l(M,(function(){F=!0})),W.sanitize=function(e,r){return r=function(e){if(!e||e.constructor!==Object)return t;var n={};return l(t,(function(t,r){t in e&&-1!==g.indexOf(t)&&(!0===e[t]||!1===e[t]||e[t]&&e[t].constructor===RegExp)?n[t]=e[t]:n[t]=r})),n.SAFE_FOR_TEMPLATES&&(n.ALLOW_DATA_ATTR=!1),n.RETURN_DOM_FRAGMENT&&(n.RETURN_DOM=!0),n.KEEP_CONTENT&&n.GLOBAL_TAGS.push("#text"),n.ADD_TAGS&&delete n.ADD_TAGS,n.ADD_ATTR&&delete n.ADD_ATTR,n}(r),e=n.sanitize(e,r),(r=W.removed).splice.apply(r,[0,W.removed.length].concat(fe(n.removed))),e},c(w,["script"]),c(b,[]),D=t.ALLOWED_STYLE,n.removeAllHooks(),y=!1,-1===w.indexOf("style")&&w.push("style"),-1===b.indexOf("style")&&b.push("style"),"INLINE"!==D&&"ALL"!==D||(b.splice(b.indexOf("style"),1),-1===R.indexOf("style")&&R.push("style"),F&&n.addHook("uponSanitizeAttribute",(function(e,t){var n,r;"style"===t.attrName&&(e.ownerDocument.baseURI||((r=(n=window.document).createElement("base")).href=n.baseURI,e.ownerDocument.head.appendChild(r)),y=!1,H(e.style),0!==(r=e.style.cssText).length?t.attrValue=y?r:e.getAttribute("style"):t.keepAttr=!1)}))),"INTERNAL"!==D&&"ALL"!==D||(w.splice(w.indexOf("style"),1),-1===L.indexOf("style")&&L.push("style"),F&&n.addHook("uponSanitizeElement",(function(e,t){var n;"style"===t.tagName&&null!==e.sheet&&(n=e.sheet.cssRules,y=!1,function e(t,n){for(var r=t.length-1;0<=r;r--){var o=t[r];0<k.length&&-1<k.indexOf(o.type)?(n.deleteRule(r),y=!0):1===o.type&&o.selectorText||8===o.type&&o.keyText?o.style&&H(o.style):4!==o.type&&7!==o.type&&12!==o.type||!o.cssRules||e(o.cssRules,o)}}(n,e.sheet),y&&(function(e,t){for(var n=t.length-1;0<=n;n--)1!==t[n].type&&3!==t[n].type&&4!==t[n].type&&7!==t[n].type&&12!==t[n].type||e.push(t[n].cssText)}(t=[],n),e.textContent=t.join("\n")))}))),(C||I)&&(S={},l(v,(function(e,t){S[e]={},l(t.ATTR_RULES,(function(t,n){return S[e][t]=n}))})),l(S,(function(e,t){l(C,(function(t,n){return S[e][t]=n}))})),l(I,(function(e,t){S[e]||(S[e]={}),l(t.ATTR_RULES,(function(t,n){return S[e][t]=n}))})),n.addHook("uponSanitizeAttribute",(function(e,t){var n,r,o=S[t.nodeName]&&S[t.nodeName][t.attrName]||C&&C[t.attrName];o&&(r=(n=B(e,o,t.attrName)).isValid,(o=n.rule)&&o.FORCE_KEEP_ATTR&&(t.forceKeepAttr=!0),r||(n=e,r=t,"REMOVE_ELEMENT"!==(e=o).ACTION?void 0!==e.FALLBACK_VALUE?(t=e.FALLBACK_VALUE,(o=de.exec(e.FALLBACK_VALUE))&&(n=n.getAttribute(e.ATTR_NAME),"${ZWAF.URL_COMPONENT}"===o[0]&&(n=window.encodeURIComponent(n)),t=e.FALLBACK_VALUE.replace(o[0],n)),ie.test(t.replace(ae,""))?r.keepAttr=!1:r.attrValue=t):r.keepAttr=!1:r.keepElement=!1))}))),(P||I)&&(O={},l(v,(function(e,t){O[e]={},l(t.APPEND_ATTR,(function(t,n){return O[e][t]=n}))})),l(O,(function(e,t){l(C,(function(t,n){return O[e][t]=n}))})),l(I,(function(e,t){O[e]||(O[e]={}),l(t.APPEND_ATTR,(function(t,n){return O[e][t]=n}))})),n.addHook("afterSanitizeAttributes",(function(e){var t,n=e.nodeName.toLowerCase(),r={};l(P,(function(e,t){return r[e]=t})),l(O[n],(function(e,t){return r[e]=t})),t=e,l(r,(function(e,n){if(!t.hasAttribute(e.toLowerCase()))if(n.SIBLING_CONDITIONS&&0!=n.SIBLING_CONDITIONS.length)for(var r=0;r<n.SIBLING_CONDITIONS.length;r++){var o=(i=B(t,n.SIBLING_CONDITIONS[r])).isValid,i=i.rule;if(o)return i=(void 0!==i.APPEND_ATTR_VALUE?i:n).APPEND_ATTR_VALUE,t.setAttribute(e,i),0}else t.setAttribute(e,n.APPEND_ATTR_VALUE)}))}))),t[_]&&n.addHook("uponSanitizeAttribute",(function(e,t){0===t.attrName.indexOf("on")&&(t.keepAttr=!1)})),U&&n.addHook("uponSanitizeAttribute",(function(e,t){U[t.attrName]&&-1===U[t.attrName].indexOf(t.nodeName)&&-1===U[t.attrName].indexOf("*")&&(t.keepAttr=!1)})),t.ALLOWED_TAGS=L,t.ALLOWED_ATTR=R,t.GLOBAL_ATTRIBUTES=R,t&&!t.REUSE_CONFIG&&pe&&pe(t),W.isSupported=n.isSupported,W.version=n.version,W.removed=[],W}(n,i),pe&&pe(i),delete window.DOMPurify,"7.0.0"!==o.version||o.HTMLPurifier||o.defineProperty(o,"HTMLPurifier",i,!0,!1,!1,!0),o["7_0_0"].HTMLPurifier||o.defineProperty(o["7_0_0"],"HTMLPurifier",i,!0,!1,!1,!0),o}()},587:function(e){e.exports=function(){"use strict";function e(e,t,n,r,o,i,a){if(r||!(t in e))return Object.defineProperty&&function(){try{return Object.defineProperty({},"x",{}),1}catch(e){return}}()?(o=!0===o,i=!0===i,a=!0===a,Object.defineProperty(e,t,{value:n,writable:o,configurable:i,enumerable:a})):(e[t]=n,e)}var t,n,r=(r=String.prototype.codePointAt)||function(e){if(null===this)throw new TypeError(" ");var t=String(this),n=t.length,r=e?Number(e):0;if(!((r=window.isNan(r)?0:r)<0||n<=r)){var o=t.charCodeAt(r);return e=void 0,55296<=o&&o<=56319&&r+1<n&&56320<=(e=t.charCodeAt(r+1))&&e<=57343?1024*(o-55296)+e-56320+65536:o}},o=String.fromCodePoint;function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}o||(t=String.fromCharCode,n=Math.floor,o=function(){for(var e=[],r=arguments.length,o=Array(r),i=0;i<r;i++)o[i]=arguments[i];var a=o.length,l=-1;if(!a)return"";for(var c="";++l<a;){var u=Number(o[l]);if(!isFinite(u)||u<0||1114111<u||n(u)!==u)throw new RangeError("Invalid code point: "+u);u<=65535?e.push(u):(u-=65536,e.push(55296+(u>>10),u%1024+56320)),(l+1===a||16384<e.length)&&(c+=t.apply(void 0,e),e.length=0)}return c});var a=(function(e,t){t&&i(e.prototype,t)}(l,[{key:"debug",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&this.level===this.LEVELS.DEBUG){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).debug.apply(e,n.concat([performance.now()]))}}},{key:"info",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.INFO)){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).log.apply(e,n.concat([performance.now()]))}}},{key:"warn",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.WARN)){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).warn.apply(e,n.concat([performance.now()]))}}},{key:"error",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.ERROR)){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).error.apply(e,n.concat([performance.now()]))}}}]),l);function l(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),this.LEVELS={NONE:-1,DEBUG:0,INFO:1,WARN:2,ERROR:3},e===this.LEVELS.NONE||e===this.LEVELS.DEBUG||e===this.LEVELS.INFO||e===this.LEVELS.WARN||e===this.LEVELS.ERROR?this.level=e:this.level=this.LEVELS.ERROR}var c=window&&window.ZWAF?window.ZWAF:{version:"7.0.0"},u=new a;c.defineProperty||(c.defineProperty=e),c.logger||(c.logger=u),c["7_0_0"]||(c["7_0_0"]={version:"7.0.0",defineProperty:e,logger:u});var s=!1;function d(e,t,n){var r=2<arguments.length&&void 0!==n?n:{};if(r=Object.assign({path:"/",SameSite:"lax","max-age":864e7},r),encodeURIComponent){var o,i=encodeURIComponent(e)+"="+encodeURIComponent(t);for(o in r){i+="; "+o;var a=r[o];!0!==a&&(i+="="+a)}document.cookie=i}}function f(e,t){d(e,"",{path:1<arguments.length&&void 0!==t?t:"/","max-age":-1})}a={log:function(){if(window&&window.console&&window.console.log&&window.navigator&&window.navigator.userAgent&&!s){var e=window.navigator.userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\/)/i);if(s=!0,e&&e[0].search(/trident|msie/i)<0)return window.console.log("%cSTOP!","color:red;font-size:xx-large;font-weight:bold;"),void window.console.log("%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details","font-size:large;");window.console.log("STOP!\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details")}}},u=Array.prototype.indexOf||function(e){if(null==this)throw new TypeError(" ");var t={},n=t.length>>>0;if(0==n)return-1;var r=0;if(0<(arguments.length<=1?0:arguments.length-1)&&(r=Number(arguments.length<=2?void 0:arguments[2]),isNaN(r)?r=0:0!==r&&r!==1/0&&r!==-1/0&&(r=(0<r||-1)*Math.floor(Math.abs(r)))),n<=r)return-1;for(var o=0<=r?r:Math.max(n-Math.abs(r),0);o<n;o++)if(o in t&&t.charAt(o)===e)return o;return-1},"7.0.0"!==c.version||c.Console||c.defineProperty(c,"Console",a,!0,!1,!1,!0),c["7_0_0"].Console||c.defineProperty(c["7_0_0"],"Console",a,!0,!1,!1,!0),["_zcsr_tmp","com_chat_owner","com_avcliq_owner","wms.agent"].some((function(e){return!!function(e){e+="=";var t=document.cookie,n=void 0;return t.split("; ").forEach((function(t){if(void 0===n){var r=void 0;try{decodeURIComponent&&(r=decodeURIComponent(t))}catch(e){r=t,ZWAF&&ZWAF.logger&&ZWAF.logger.warn&&ZWAF.logger.warn("Error while trying to decode Cookie value!")}0===r.indexOf(e)&&(n=r.substring(e.length))}})),n}(e)}))&&c&&c["7_0_0"]&&c["7_0_0"].Console&&c["7_0_0"].Console.log(),a={arrayIndexOf:u},Object.freeze&&Object.freeze(a),"7.0.0"!==c.version||c.util||c.defineProperty(c,"util",a,!0,!1,!1,!0),c["7_0_0"].util||c.defineProperty(c["7_0_0"],"util",a,!0,!1,!1,!0);var p="_zwaf_ua";function m(e){for(var t=[],n=0;n<e.length;n++)t.push(e[n].charCodeAt(0));return t}u={init:function(){f(p);var e=!!window.ulaa,t=navigator&&navigator.brave&&"function"==typeof navigator.brave.isBrave;e?d(p,"Ulaa"):t?d(p,"Brave"):window&&window.addEventListener("load",(function(){window.setTimeout((function(){window.getComputedStyle(window.document.documentElement).getPropertyValue("--arc-palette-background")&&d(p,"Arc")}),1e3)}))},disable:function(){f(p)}},"7.0.0"!==c.version||c.UAIdentification||c.defineProperty(c,"UAIdentification",u,!0,!1,!1,!0),c["7_0_0"].UAIdentification||c.defineProperty(c["7_0_0"],"UAIdentification",u,!0,!1,!1,!0),c&&c["7_0_0"]&&c["7_0_0"].UAIdentification&&c["7_0_0"].UAIdentification.init(),u={};for(var A=a.arrayIndexOf,E={HTML:m([",",".","-","_"," "]),HTMLATTR:m([",",".","-","_"]),CSS:m([]),JAVASCRIPT:m([",",".","_"])},T={},h=(h="34=&quot|38=&amp|60=&lt|62=&gt|160=&nbsp|161=&iexcl|162=&cent|163=&pound|164=&curren|165=&yen|166=&brvbar|167=&sect|168=&uml|169=&copy|170=&ordf|171=&laquo|172=&not|173=&shy|174=&reg|175=&macr|176=&deg|177=&plusmn|178=&sup2|179=&sup3|180=&acute|181=&micro|182=&para|183=&middot|184=&cedil|185=&sup1|186=&ordm|187=&raquo|188=&frac14|189=&frac12|190=&frac34|191=&iquest|192=&Agrave|193=&Aacute|194=&Acirc|195=&Atilde|196=&Auml|197=&Aring|198=&AElig|199=&Ccedil|200=&Egrave|201=&Eacute|202=&Ecirc|203=&Euml|204=&Igrave|205=&Iacute|206=&Icirc|207=&Iuml|208=&ETH|209=&Ntilde|210=&Ograve|211=&Oacute|212=&Ocirc|213=&Otilde|214=&Ouml|215=&times|216=&Oslash|217=&Ugrave|218=&Uacute|219=&Ucirc|220=&Uuml|221=&Yacute|222=&THORN|223=&szlig|224=&agrave|225=&aacute|226=&acirc|227=&atilde|228=&auml|229=&aring|230=&aelig|231=&ccedil|232=&egrave|233=&eacute|234=&ecirc|235=&euml|236=&igrave|237=&iacute|238=&icirc|239=&iuml|240=&eth|241=&ntilde|242=&ograve|243=&oacute|244=&ocirc|245=&otilde|246=&ouml|247=&divide|248=&oslash|249=&ugrave|250=&uacute|251=&ucirc|252=&uuml|253=&yacute|254=&thorn|255=&yuml|338=&OElig|339=&oelig|352=&Scaron|353=&scaron|376=&Yuml|402=&fnof|710=&circ|732=&tilde|913=&Alpha|914=&Beta|915=&Gamma|916=&Delta|917=&Epsilon|918=&Zeta|919=&Eta|920=&Theta|921=&Iota|922=&Kappa|923=&Lambda|924=&Mu|925=&Nu|926=&Xi|927=&Omicron|928=&Pi|929=&Rho|931=&Sigma|932=&Tau|933=&Upsilon|934=&Phi|935=&Chi|936=&Psi|937=&Omega|945=&alpha|946=&beta|947=&gamma|948=&delta|949=&epsilon|950=&zeta|951=&eta|952=&theta|953=&iota|954=&kappa|955=&lambda|956=&mu|957=&nu|958=&xi|959=&omicron|960=&pi|961=&rho|962=&sigmaf|963=&sigma|964=&tau|965=&upsilon|966=&phi|967=&chi|968=&psi|969=&omega|977=&thetasym|978=&upsih|982=&piv|8194=&ensp|8195=&emsp|8201=&thinsp|8204=&zwnj|8205=&zwj|8206=&lrm|8207=&rlm|8211=&ndash|8212=&mdash|8216=&lsquo|8217=&rsquo|8218=&sbquo|8220=&ldquo|8221=&rdquo|8222=&bdquo|8224=&dagger|8225=&Dagger|8226=&bull|8230=&hellip|8240=&permil|8242=&prime|8243=&Prime|8249=&lsaquo|8250=&rsaquo|8254=&oline|8260=&frasl|8364=&euro|8465=&image|8472=&weierp|8476=&real|8482=&trade|8501=&alefsym|8592=&larr|8593=&uarr|8594=&rarr|8595=&darr|8596=&harr|8629=&crarr|8656=&lArr|8657=&uArr|8658=&rArr|8659=&dArr|8660=&hArr|8704=&forall|8706=&part|8707=&exist|8709=&empty|8711=&nabla|8712=&isin|8713=&notin|8715=&ni|8719=&prod|8721=&sum|8722=&minus|8727=&lowast|8730=&radic|8733=&prop|8734=&infin|8736=&ang|8743=&and|8744=&or|8745=&cap|8746=&cup|8747=&int|8756=&there4|8764=&sim|8773=&cong|8776=&asymp|8800=&ne|8801=&equiv|8804=&le|8805=&ge|8834=&sub|8835=&sup|8836=&nsub|8838=&sube|8839=&supe|8853=&oplus|8855=&otimes|8869=&perp|8901=&sdot|8968=&lceil|8969=&rceil|8970=&lfloor|8971=&rfloor|10216=&lang|10217=&rang|9674=&loz|9824=&spades|9827=&clubs|9829=&hearts|9830=&diams").split("|"),_=0;_<h.length;_++){var g=h[_].split("=");T[g[0]]=g[1]}for(var N=[],v=0;v<255;v++)N[v]=48<=v&&v<=57||65<=v&&v<=90||97<=v&&v<=122?null:v.toString(16);function y(e){return e<256?N[e]:e.toString(16)}function S(e,t){return-1!==A.call(e,t)||null===(e=y(t))?o(t):t<=31&&9!=t&&10!=t&&13!=t||127<=t&&t<=159||32===t?"&#x20;":void 0!==(t=T[t])?t+";":"&#x"+e+";"}function O(e,t){return-1!==A.call(e,t)||null===y(t)?String.fromCharCode(t):(e=t.toString(16),t<256?"\\x"+"00".substr(e.length)+e.toUpperCase():"\\u"+"0000".substr(e.length)+e.toUpperCase())}function L(e,t){return-1!==A.call(e,t)||null===(e=y(t))?o(t):"\\"+e+" "}function R(e,t,n,o){if(null==t||"string"!=typeof t)return t;for(var i,a="",l=0;l<t.length;l++)o?(a+=n(e,i=r.call(t,l),o),65535<i&&l++):a+=n(e,t.charCodeAt(l));return a}return u.encodeForHTML=function(e){return R(E.HTML,e,S,!0)},u.encodeForHTMLAttribute=function(e){return R(E.HTMLATTR,e,S,!0)},u.encodeForJavaScript=function(e){return R(E.JAVASCRIPT,e,O,!1)},u.encodeForCSS=function(e){return R(E.CSS,e,L,!0)},Object.freeze&&Object.freeze(u),"7.0.0"!==c.version||c.Encoder||c.defineProperty(c,"Encoder",u,!0,!1,!1,!0),c["7_0_0"].Encoder||c.defineProperty(c["7_0_0"],"Encoder",u,!0,!1,!1,!0),c}()},887:()=>{window.DOMPurifyCopy&&(window.DOMPurify=window.DOMPurifyCopy,window.DOMPurifyCopy=void 0)}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var i=t[r]={exports:{}};return e[r].call(i.exports,i,i.exports,n),i.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";n(238);var e=n(508),t=n.n(e);window.ZWAF=t(),n(887),n(587),window.ZSEC=window.ZWAF})()})();/*Polyfills for functions not available in other browsers. */

/*Polyfill for Node.after
//Not supported out of the box in IE and Edge. 
//from: https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/after()/after().md */
(function (arr) {
  arr.forEach(function (item) {
    if (item.hasOwnProperty('after')) {
      return;
    }
    Object.defineProperty(item, 'after', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function after() {
        var argArr = Array.prototype.slice.call(arguments),
          docFrag = document.createDocumentFragment();
        
        argArr.forEach(function (argItem) {
          var isNode = argItem instanceof Node;
          docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
        });
        
        this.parentNode.insertBefore(docFrag, this.nextSibling);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);


/*Polyfill for replaceWith. 
//Not supported out of the box for IE and Edge. */
function ReplaceWith(Ele) {
    var parent = this.parentNode,
        i = arguments.length,
        firstIsNode = +(parent && typeof Ele === 'object');
    if (!parent){
        return;
    } 
    
    while (i-- > firstIsNode){
      if (parent && typeof arguments[i] !== 'object'){
        arguments[i] = document.createTextNode(arguments[i]);
      } if (!parent && arguments[i].parentNode){
        arguments[i].parentNode.removeChild(arguments[i]);
        continue;
      }
      parent.insertBefore(this.previousSibling, arguments[i]);
    }
    if (firstIsNode){
        parent.replaceChild(this, Ele);
    } 
}
if (!Element.prototype.replaceWith){
    Element.prototype.replaceWith = ReplaceWith;
}
if (!CharacterData.prototype.replaceWith){
    CharacterData.prototype.replaceWith = ReplaceWith;
}
if (!DocumentType.prototype.replaceWith) {
    DocumentType.prototype.replaceWith = ReplaceWith;
}

/*Polyfill for startsWith
//Not supported out of the box for  IE */
if(!String.prototype.startsWith) {
      String.prototype.startsWith = function(searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
    };
}

/*Polyfill for endsWith
//Not supported out of the box for  IE */
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(search, this_len) {
    if (this_len === undefined || this_len > this.length) {
      this_len = this.length;
    }
    return this.substring(this_len - search.length, this_len) === search;
  };
}


let _Lyte = {
  version : "3.7.0-BETA1",
    $ : {
        consoleTime : []
    },
    registeredMixins : {},
    registeredServices : {},
    requiredServices : {},
    toBeInjectedServices : {},
    _registeredComponents : {},
    _keywords : {
      "component" : ["init", "didConnect", "didDestroy", "constructor", "onError", "actions", "methods", "data"],
      "adapter" : ["namespace", "actionNamespace", "host", "withCredentials", "buildURL", "methodForRequest", "headersForRequest", "reloadRecord", "reloadRecord", "reloadAll", "processRequest", "parseResponse", "parseRequest", "super"],
      "serializer" : ["normalize", "normalizeResponse", "serialize", "serializeKey", "deserializeKey", "extractMeta", "payloadKey", "serializeRecord", "normalizeRecord", "super"],
      "route" : ["getDependencies", "getResources", "beforeModel", "model", "afterModel", "redirect", "renderTemplate", "afterRender", "beforeExit", "didDestroy", "queryParams", "title", "routeName", "component", "parent", "currentModel", "forceFetch", "setTitle", "setQueryParams", "getQueryParams", "setDynamicParam", "getDynamicParam", "removeFromCache", "refresh", "transitionTo", "replaceWith","actions"],
      "is" : function(key, scope){
        var arr = ["component", "adapter", "serializer", "route"];
        if(scope){
          arr = [scope];
        }
        var len = arr.length;
        for(var i=0;i<len;i++){
          var keyArr = this[arr[i]];
          if(keyArr){
            var res = keyArr.indexOf(key);
            if(res != -1){
              return true;
            }
          }
        }
        return false;
      }
    },
    Mixin : {},
    Service : {},
    debug : false,
    performance : false,
    toBeRegistered : [],
    browser : {},
    registeredCustomComponent : {},
    Globals : {}
  };
  if(window.isLyteWidgetParent) {
    _widgetLyte = _Lyte;
    _Lyte.isWidgetBuild = true;
    window.__lyteConfig.isWidgetBuild = true; 
  } else {
    Lyte = _Lyte;
  }
class IdleTaskScheduler{
  constructor(obj){
    this.idleCallback = this.idleCallback.bind(this);
    this.timeout = 50;
    this.chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    this.tasks = new Map();
    this.idleCallbackRequested = false;
    this.delayInit = false;
    this.useRequestIdleCallback = true;
    this.priorityQueue = [];
    this.processTime = {};
    this.perf = false;
    if(obj!= undefined){      
      if(obj.useRequestIdleCallback !== undefined){
        this.useRequestIdleCallback = obj.useRequestIdleCallback;
      }
      if(obj.delayInit !== undefined){
          this.delayInit = obj.delayInit;
      }
      if(obj.timeout !== undefined){
        this.timeout = obj.timeout;			
      }
      if(obj.priorityQueue !== undefined){
        this.priorityQueue = obj.priorityQueue;
      }
      if(obj.perf !== undefined){
        this.perf = obj.perf;
      }
    }
  }
  isGenerator(obj) {
    return (
        obj !== null &&
        typeof obj === "object" &&
        typeof obj.next === "function" &&
        typeof obj[Symbol.iterator] === "function"
    );
  }
  init(obj){
    if(this.delayInit == true){
      if(obj !== undefined){ 
        if(obj.useRequestIdleCallback !== undefined){
          this.useRequestIdleCallback = obj.useRequestIdleCallback;
        }
        if(obj.timeout !== undefined){
          this.timeout = obj.timeout;
        }
        if(obj.perf !== undefined){
          this.perf = obj.perf;
        }
      }
      this.delayInit = false;
      this.tasksScheduler();
    } 
  }
  getUniqueKey(len){
    var result;
    while(result == undefined || this.tasks.has(result)){
        result = undefined;
        result = this.generateUniqueKey(len);
    }
    return result;
  }
  generateUniqueKey(length){
    let result = '', clen = this.chars.length;
    for (let i = 0; i < length; i++) {
        result += this.chars.charAt(Math.floor(Math.random() * clen));
    }
    return result;
  }
  enqueueTask(handler, data, id){
    if(!id){
        id = this.getUniqueKey(6);
    }
    if(this.tasks.has(id)){
        console.error("Task with id-"+id+" is alreaded queued for execution.");
        return; 
    }
    this.tasks.set(id, {handler: handler, data: data});
    this.tasksScheduler();
    return id;
  }
  deleteTask(id){
    if(id){
        var val = this.tasks.get(id);
        this.tasks.delete(id);
        if(this.priorityQueue.length){
          var ind = this.priorityQueue.indexOf(id);
          if(ind != -1){
            this.priorityQueue.splice(ind, 1);
          }
        }
        return val;
    }
  }
  getPriorityQObj(){
    var id, i=0, pObj;
    if(this.priorityQueue.length){
      var len =this.priorityQueue.length;
      while(i<len){
        id = this.priorityQueue[i];
        if(this.tasks.has(id)){
          pObj = this.tasks.get(id);
          break;
        }
        i++;
      }
      if(pObj){
        return {id:id, obj:pObj, ind:i};
      }
    }
    return false;   
  }
  dequeueTask(id){
    if(id){
        var val = this.tasks.get(id);
        // console.log("dequeud-",id);
        this.tasks.delete(id);
        return val;
    }
    else if(this.tasks.size || this.priorityQueue.length){
      var pqObj = this.getPriorityQObj(), gnxt, gval, obj, isPriority = false, ind;
      if(pqObj !== false){
        id = pqObj.id;
        obj = pqObj.obj;
        ind = pqObj.ind;
        isPriority = true;
      }
      else{
        if(!this.tasks.size){
          return;
        }
        var val = this.tasks.entries().next().value;
        id = val[0]
        obj = val[1];
      }
      // console.log("dequeud-",id);
      this.currentTask = {id:id, handler: obj.handler};
      Lyte.extendEventListeners(this.currentTask);
      if(this.isGenerator(obj.handler)){
        gnxt = obj.handler.next();
        if(gnxt.done == false){
          gval = gnxt.value;
          if(typeof gval == "function"){
            return gval;
          }
        }
        else{
          this.currentTask.triggerEvent("done", id);
          if(isPriority){
            this.priorityQueue.splice(ind,1);
          }
          this.tasks.delete(id);
          return this.dequeueTask();
        }
      }
      else{
        this.currentTask.triggerEvent("done", id);
        if(isPriority){
          this.priorityQueue.splice(ind,1);
        }
        this.tasks.delete(id);
      }
      return obj;
    }
  }
  tasksScheduler(){
    if(this.delayInit == false){
      if(this.tasks.size){
        if(this.idleCallbackRequested == false){
          if('requestIdleCallback' in window && this.useRequestIdleCallback){
              this.idleCallbackRequested = true;
              requestIdleCallback(this.idleCallback);
          }   
          else{
              this.requestIdleCallback(this.idleCallback);
          }
        }
      }
      else{
        if('cancelIdleCallback' in window && this.useRequestIdleCallback){
          cancelIdleCallback(this.idleCallback);
        }
      }
    }
  }
  idleCallback(deadline){
    var task, i=0, remTime = deadline.timeRemaining();
    while(remTime>0 && this.tasks.size){
      task = this.dequeueTask();
      if(this.perf){
        var p1 = performance.now();
      }
      if(typeof task == "function"){
            // setTimeout(function(){
                task();
            // },1);
      }
      if(typeof task == "object"){
        // setTimeout(function(){
        var data = task.data || [];
        if(typeof task.handler == "function"){
          task.handler(...data);	
        }
        // },1);
      }
      if(this.perf){
        var p2 = performance.now();
        var id = this.currentTask.id;
        this.processTime[id] = (this.processTime.hasOwnProperty(id) ? this.processTime[id] : 0) + (p2-p1);
      }
      remTime = deadline.timeRemaining();
    }
    this.idleCallbackRequested = false;
    this.tasksScheduler();
  }
  requestIdleCallback(callback){
    var self = this;
    setTimeout(function(){
      setTimeout(function(){
        var startTime = Date.now();
        callback({
          timeRemaining: function(){
            var diffTime = Date.now() - startTime;
            if(diffTime > self.timeout){
                return 0;
            }
            return self.timeout-diffTime;
          }
        });
      }, 1);
    }, 50);
  }
}  
(function(Lyte){
  var userAgent = Lyte.$.userAgent = window.userAgent = navigator.userAgent;
  var singletonServices = new Map();
    //temporary fix for IE 11
  if (userAgent.match(/rv:11\.0/) && navigator.userAgent.match(/Trident/)) {
    Lyte.browser.ie = true;
    window.action = function () {
      return;
    };
  }
  if (userAgent.match('Edge')) {
    var s = createElement("div");
    s.innerHTML = "<template><div>c</div></template>";
    if (s.querySelector("template").childNodes.length) {
      Lyte.browser.ie = true;
    } else {
      Lyte.browser.edge = true;
    }
    s.remove();
  }


Lyte.Globals.set = function(scope,value){
  Lyte.Component.set(Lyte.__gl,scope,value);    
};

Lyte.Globals.get = function(scope){
  return Lyte.Component._get(Lyte.__gl, scope);
};

Object.defineProperty(Lyte.Service, "__Lyte__", {
  value: Lyte
});
Object.defineProperty(Lyte.Mixin, "__Lyte__", {
  value: Lyte
});
Object.defineProperty(Lyte.$, "__Lyte__", {
  value: Lyte
});
Lyte.Mixin.__Lyte__.requiredMixins = {};
Lyte.oldProxy = (typeof $Lt != "undefined") && $Lt.oldProxy ? $Lt.oldProxy : undefined;  
  
  Lyte.$.assetsDiv = document.createElement("div");
  Lyte.$.assetsDiv.setAttribute("id", "lyteAssetsDiv");
  Lyte.assetsDivContainer = document.head;

  Lyte.$.widgetWrapper = document.createElement("shadow-wrapper");
  Lyte.$.widgetWrapper.attachShadow({"mode":"open"});//af
  Lyte.$.widgetWrapper.setAttribute("id", "widgetWrapperDiv");
  
  Lyte.domContentLoaded = function(callback) {
    if(document.readyState === "complete" || document.readyState === "interactive") { 
      callback();
    } else {
      window.addEventListener('DOMContentLoaded', function() {
        callback();
      });
    }
  }
  
  Lyte.createApplication = function(name, obj){
      if(obj.init){
          obj.init.apply(Lyte);
      }
  }
  
  Lyte.registerErrorCodes = function(obj) {
    Object.assign(Lyte.errorCodes, obj);
  }
  
  Lyte.establishObserverBindings  = function(observers,fromStore,properties,model) {
    var scope = this;
    var watchProps = model && fromStore ? model._fldGrps.JsonPathWatch : scope.constructor._deepWatchProperties;
    if(fromStore){
      scope = fromStore;      
    }
    for(var i=0;i<observers.length;i++) {
      var props = observers[i].properties;
      var obsAttr = {},obsDuplicate=false;
      var Jpath={}
        for(var j=0;j<props.length;j++) {
            var actProp;
            var isArrayObserver = false;
            if(typeof props[j] == "string"){
              if(props[j].search(/^\$\./g)!=-1){
         
                var JsonPath = props[j];
      
                var CmpPropertyPath = JsonPath.match(/[^\$.][^\.]*/g)[0]
                if(CmpPropertyPath.search(/\[[0-9*]\]/g)!=-1){
                  CmpPropertyPath = CmpPropertyPath.split(/\[[0-9*]\]/g)[0];
                }
                if(watchProps[CmpPropertyPath]==undefined){
                  watchProps[CmpPropertyPath]=[];
                }
      
                if(Jpath[CmpPropertyPath] == undefined){
                  Jpath[CmpPropertyPath]=[];
                }
                
                var JSONPATH ;
                var reg = "^\\$\\."+CmpPropertyPath+"\\.?"
                reg = new RegExp(reg);
                JSONPATH = props[j].replace(reg,"$.")
                if(!watchProps[CmpPropertyPath].includes(JSONPATH)){
                  watchProps[CmpPropertyPath].push(JSONPATH)
                }
                
                if(!Jpath[CmpPropertyPath].includes(JSONPATH)){
                  Jpath[CmpPropertyPath].push(JSONPATH)
                }
      
      
                CmpPropertyPath =CmpPropertyPath+".*";
                if(!obsAttr.hasOwnProperty(CmpPropertyPath)){
                  actProp= Lyte.getProperty.call(this,CmpPropertyPath,fromStore,properties)
                  obsAttr[CmpPropertyPath]=true;
                  obsDuplicate = false;
                }
                else{
                  obsDuplicate = true;
                }
              }
              else if(props[j].indexOf('.[]') !== -1) {
                  isArrayObserver = true;
                  actProp = Lyte.getProperty.call(this,props[j].substring(0, props[j].indexOf('.[]')),fromStore,properties);
              } else {
              if(props[j].indexOf('.*') !== -1) {
                var prop = props[j].split(".")[0];
                var isDeepObs = (!fromStore && this.component.__data[prop] && this.component.__data[prop].watch) || (fromStore && model && model.fieldList && model.fieldList[prop] && model.fieldList[prop].watch) ? true : false;
                if(!isDeepObs){
                  continue;
                }
              } 
                actProp = Lyte.getProperty.call(this,props[j],fromStore,properties);
              }
              if(!obsDuplicate){
                if(!actProp._observers) {
                  Object.defineProperty(actProp, '_observers', {
                      value : new Set(),
                      enumerable: false, 
                      writable: true,
                      configurable: true
                  });
                }
              actProp._observers.add({callee : scope, observer: observers[i], isArrayObserver : isArrayObserver});
              }
          }else{
            Lyte.warn("ERR27",JSON.stringify(props[j]),observers[i].fnName,this.tagName);
          }
        }
        observers[i].Jpath  = Jpath;
        obsAttr={};
    }
  }
  
  Lyte.getProperty = function(key,fromStore,properties) {
      let arr = key.match(/([^[\].]+|\[\])/g);
      let property = this;
      if(fromStore){
          property = properties;
          if(!properties[arr[0]]){
              properties[arr[0]] = {};
          }
          property = properties[arr[0]];
      }
      else {                      
          if(!property._properties[arr[0]]) {
              property._properties[arr[0]] = {};
          } 
          property = property._properties[arr[0]];
      }
  
      Object.defineProperty(property, '_path', {enumerable: false, value : arr[0]});
      for(let i=1;i<arr.length;i++) {
        if (arr[i].startsWith("'") || arr[i].startsWith('"')) {
          arr[i] = arr[i].substring(1, arr[i].length -1);
        }
          if(!property[arr[i]]) {
              property[arr[i]] = {};
              Object.defineProperty(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
          }
          property = property[arr[i]];
      }
      return property;
  }
  
  Lyte.getErrorMessage = function(code) {
    var args = Array.from(arguments).slice(1);
    if(Lyte.errorCodes[code]) {
        return Lyte.errorCodes[code].replace(/{(\d+)}/g, function(t, i) {
            return args[i]
        });
    } else {
        return code;
    }
  }
  
  Lyte.error = function () {
    var errorObj = arguments[0],
    parse = errorObj.stack;
    errorObj = parse ? errorObj : Error(Lyte.getErrorMessage.apply(Lyte, arguments));
    if (Lyte.onerror) {
        Lyte.onerror.call(this, errorObj,arguments[1]);
    }
    Lyte.triggerEvent("error", errorObj,arguments[1]);
    var safari = errorObj.stack && errorObj.stack.indexOf(errorObj.message) == -1
    if (parse && !safari) {
        errorObj = JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj)));
    }
    if(arguments[1]) {
        console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message,arguments[1]);
    } else {
        console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message);    
    }
    
  };
  
  Lyte.warn = function () {
    var errorObj = arguments[0];
    errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : Error(Lyte.getErrorMessage.apply(Lyte, arguments));
    console.warn(errorObj.stack ? (errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace("Error: ", "") : errorObj) : errorObj.message);
  };
  
  var requiredMixins  = {};
  var fnProto = Function.prototype;
	if(!fnProto.on){
		fnProto.on = function(){
			Lyte.warn("'.on()' method with the argument '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "callBack", "value": this.type === "observer" ? this.value : this, "properties": arguments, "observes": this.type === "observer" ? this : undefined };
		};
	}
	if(!fnProto.observes){
		fnProto.observes = function(){
			Lyte.warn("'.observes()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "observer", "value": this, "properties": arguments, "on": Lyte._onObj, "lyteOn": Lyte._onObj };
		};
	}
	if(!fnProto.computed){
		fnProto.computed = function(){
			Lyte.warn("'.computed()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "computed", "value": this, "properties": arguments };
		};
	}
  Lyte._onObj = function(){
    return {"type": "callBack", "value":(this.type === "observer") ? this.value:this , "properties":arguments, "observes":(this.type === "observer" ? this: undefined)}
  }
  Lyte._observesObj = function() {
      return {"type" : "observer", "value" : this, "properties" : arguments, "on": Lyte._onObj, "lyteOn" : Lyte._onObj}
  }
  Lyte._computedObj = function() {
      return {"type" : "computed", "value" : this, "properties" : arguments}
  }
  Lyte._preRegister = function(){
    Lyte._actualFnProtoOn = Function.prototype.on;
    Lyte._actualFnProtoObserves = Function.prototype.observes;
    Lyte._actualFnProtoComputed = Function.prototype.computed;
    let fnProto = Function.prototype;
    fnProto.on = fnProto.lyteOn = Lyte._onObj;
    fnProto.observes = fnProto.lyteObserves = Lyte._observesObj;
    fnProto.computed = fnProto.lyteComputed = Lyte._computedObj;
  }
  Lyte._postRegister = function(){
    let fnProto = Function.prototype;
    fnProto.on = Lyte._actualFnProtoOn;
    fnProto.observes = Lyte._actualFnProtoObserves;
    fnProto.computed = Lyte._actualFnProtoComputed;
  }
  Object.defineProperty(Lyte.Mixin,"register",{
    get : function(){
        Lyte._preRegister();
        return Lyte.registerMixinWrapper;
    }
    , "enumerable" : true})
  Lyte.registerMixinWrapper = function(){
    try{
      Lyte.registerMixin.apply(Lyte, arguments);
      Lyte._postRegister();
    }catch(e){
      Lyte._postRegister();
    }
  }
  Lyte.registerMixin = function (name, mixin) {
    Lyte.registeredMixins[name] = mixin;
    var req;
    if(req = requiredMixins[name]) {
      for(var key in req) {
        Lyte.$.requiredMixins[key](mixin, req[key],key);
      }
    }
  };
  
  Lyte.Mixin.get = function(name) {
  return Lyte.registeredMixins[name];
  }
  
  Lyte.$.instantiateService = function(name, data){
    var service = Lyte.registeredServices[name];
    if(service.singleton == true){
      if(singletonServices.has(name)){
        return singletonServices.get(name);
      }
      else{
        var ins = new service(data);
        singletonServices.set(name, ins);
        return ins;
      }
    }
    else{
      return new service(data);
    }
  }
  
  Lyte.Service.register = function (name, service, isSingleton) {
    if(Lyte.registeredServices.hasOwnProperty(name)){
      Lyte.warn('Service -'+name+' is already registered');
      return;
    }
    if(!Lyte._keywords.is(name)){
      var data = service, 
      req;
      if(isSingleton){
        data.singleton = isSingleton;
      }
      Lyte.registeredServices[name] = data;
      var serv = Lyte.requiredServices[name];
      if(serv && serv.size) {
        serv.forEach(function(obj) {
          var toSend = data;
          if(obj.isGlobal){
            toSend = Lyte.__gS[obj.key] = Lyte.__gS[obj.key] || Lyte.$.instantiateService(name, obj.data);
          }
          obj.cB(toSend, obj.key, obj.name, name);
        });
      }
      return data;
    }
    else{
      Lyte.warn('Service name-'+name+' should not be a keyword used in Lyte');
    }
  };

  Lyte.Service.getInjected = function(key){
    if(Lyte.__gS.hasOwnProperty(key)){
      return Lyte.__gS[key];
    }
  }
  
  
  // Lyte.Service.get = function(name) {
  //   return Lyte.registeredServices[name];
  // }
  
  Lyte.$.requiredServices = function (key, serviceName, cB, type, name, isGlobal, data) {
		var reqServ = Lyte.requiredServices[serviceName];
		var req = reqServ ? reqServ : Lyte.requiredServices[serviceName] = new Map();
    var id = Lyte.$.genMapId(req);
    req.set(id, { key: key, cB: cB, type: type, name: name, serviceName:serviceName, isGlobal:isGlobal, data:data });
    return serviceName+"-"+id;
	};

  
  Lyte.$.lazyRegisterService = function(service,obj){
    var scope = obj.scope, name = obj.name , callback = scope[obj.type][name];
    if(callback){
      callback[obj.key] = service;
    }
  };
  
  Lyte.$.injectServices = {}; 
  Object.defineProperty(Lyte, "__gS", {
    value : {}
  });
	Lyte.injectServices = function (data) {
		var serv = {};
    if(!Array.isArray(data)){
      data = [data];
    }
		data.forEach(function (itm) {
			if (itm && typeof itm == 'object') {
				var key = itm.as, service = itm.service, args = itm.data;
				if (!Lyte._keywords.is(key)) {
					if (!Lyte.toBeInjectedServices.hasOwnProperty(key)) {
						Lyte.toBeInjectedServices[key] = service;
						serv[key] = {service:service, data:args};
						if(Lyte.registeredServices[service]){
							Lyte.__gS[key] = Lyte.$.instantiateService(service, args);
						}
					} else {
						Lyte.warn("A service has already been injected in the key named, ", key);
					}
				} else {
					Lyte.warn("Service cannot be used in any keywords of Lyte.");
				}
			} else if (typeof itm == "string") {
				if (!Lyte.toBeInjectedServices.hasOwnProperty(itm)) {
					Lyte.toBeInjectedServices[itm] = itm;
					serv[itm] = {service:itm};
					if(Lyte.registeredServices[itm]){
						Lyte.__gS[itm] = Lyte.$.instantiateService(itm);
					}
				} else {
					Lyte.warn("A service has already been injected in the key named, ", itm);
				}
			}
      else{
        Lyte.warn("Invalid data passed to injectServices", itm);
      }
		});
		var mdlObj = Lyte.$.injectServices;
		for (var mKey in mdlObj) {
			for (var key in serv) {
				mdlObj[mKey](key, serv[key].service, mKey, Lyte.__gS[key],undefined,serv[key].data);
			}
		}
	};

  Lyte.$.genMapId = function(map){
    var id = Math.floor(Math.random()*10000000000 + 1);
    while(map.get(id)){
        id = Math.floor(Math.random()*10000000000 + 1)
    }
    return id.toString();
  }

  Lyte.$.toRemoveFromRequiredServices = function(str){
    var arr = str.split("-"), id = arr[arr.length-1], idLen = id.length, servName = str.substr(0,str.length - (idLen+1));
    var reqArr = Lyte.requiredServices[servName];
    if(reqArr){
      reqArr.delete(id);
    }
  }


	Lyte.toBeUsedServices = function (obj) {
		// var serviceToBeUsed = obj.callback ? Object.assign({}, Lyte.toBeInjectedServices) : {};
		var serviceToBeUsed = {};
		var arr = obj.services;
		if (arr) {
			arr.forEach(function (service) {
				if (typeof service == "string") {
					serviceToBeUsed[service] = service;
				} else if (service && typeof service == "object") {
					var key = service.as, serv = service.service;
					if (!Lyte._keywords.is(key, obj.type)) {
						serviceToBeUsed[key] = serv;
					} else {
						Lyte.warn("Service cannot be used in any keywords of Lyte.");
					}
				}
			});
		}
		return serviceToBeUsed;
	};

	Lyte.extendService = function (arg) {
		var servObj = Lyte.toBeUsedServices(arg),
		    name;
		for (var serv in servObj) {
			name = servObj[serv];
			// var scp = arg.isGlobal && Lyte.__gS.hasOwnProperty(serv) : Lyte.registeredServices; 
			if ((arg.isGlobal && Lyte.__gS.hasOwnProperty(serv)) || (!arg.isGlobal && Lyte.registeredServices.hasOwnProperty(name))) {
				var ins = arg.ins,
				    service = arg.isGlobal ? Lyte.__gS[serv] : Lyte.$.instantiateService(name);
				if (!Array.isArray(ins)) {
					ins = [arg.ins];
				}
				ins.forEach(function (insObj) {
					insObj[serv] = arg.isGlobal ? Lyte.__gS[serv] : Lyte.$.instantiateService(name);
				});
			} else{
				Lyte.$.requiredServices(serv, name, arg.callback, arg.type, arg.name, arg.isGlobal, arg.data);
			}
		}
	};
  
  Lyte.$.requiredMixins = function(mixin,dir,type) {
  var req = requiredMixins[mixin] ? requiredMixins[mixin] : (requiredMixins[mixin] = {});
  if(!req[type]) {
    req[type] = [dir];
  } else {
    req[type].push(dir);  
  }
  }
  
  Lyte.Mixin.exists = function (name) {
  if (!Lyte.registeredMixins[name]) {
    // Lyte.error('Mixin used before being registered.');
    return false;
  }
  return true;
  };
  
  Lyte.log = function (text, src, color) {
  if (Lyte.debug) {
      if(color) {
          console.log("%c" + text,'color:' + color);
      } else {
        console.log(text);      
      }
  }
  };
  
  Lyte.time = function(fn) {
  if(Lyte.performance) {
    var index;
    if((index = Lyte.$.consoleTime.indexOf(fn)) != -1) {
      Lyte.$.consoleTime.splice(index,1);
      console.timeEnd(fn);
    } else {
      Lyte.$.consoleTime.push(fn)
      console.time(fn);
    }
  }
  }
  /* disable async function */
  Lyte.isRecord = function(object){
  if(object && object.$ && object.$.hasOwnProperty("isModified")) {
    return true;
  }
  return false;
  }
  
  Lyte.isComponent = function(object) {
  if(object && object.$node && object.__data) {
    return true;
  }
  return false;
  }
  
  
  /* --------- lyte router v2 changes starts---- */
  Lyte.$.reqFiles = {};
  
  Lyte.injectResources = function (files, every, completed, options) {
    var successFiles = [],
        errorFiles = [];
    every = every || function () {};
    completed = completed || function () {};
    return new Promise(function (resolve, reject) {
      processRequirements(files, function () {
        if (options && options.defer) {
          options.defer({
            injectJS: injectJS,
            files: files,
            errorFiles: errorFiles
          });
          resolve();
        } else {
          injectJS(files, function () {
            completed(successFiles, errorFiles);
            if (errorFiles.length) {
              reject(successFiles, errorFiles);
            } else {
              resolve(successFiles, errorFiles);
            }
          });
        }
      }.bind(this));
    });
  
    function injectJS(files, resolve, execFiles) {
      var len;
      execFiles = execFiles || [];
      if (!files) {
        resolve(successFiles, errorFiles);
      } else {
        if (!Array.isArray(files)) {
          files = [files];
        }
        if (!files.length) {
          resolve(successFiles, errorFiles);
        }
        len = -files.length;
        files.forEach(function (file) {
          if (typeof file == "string") {
            var type = getFileExtn(file);
            if (type && (type == ".js" || type == ".css") && execFiles.indexOf(file) == -1) {
              execFiles.push(file);
              createScript(file, function () {
                loaded();
              });
            } else {
              loaded();
            }
          } else if (Array.isArray(file)) {
            injectJS(file,function () {
              loaded();
            })
          } else {
            len--;
            injectJS(file.parent, function() {
              injectJS(file.child,function() {
                  loaded();
              })
              loaded();
          })
          }
        });
      }
  
      function loaded() {
        len++;
        if (len == 0) {
          resolve(successFiles, errorFiles);
        }
      }
    }
  
    function createScript(file, resolve) {
      var ev = Lyte.injectResources.respObj[file];
      if(ev && (!Lyte.injectResources.availableTags[file] || Lyte.injectResources.availableTags[file].tag.getAttribute("rel") == "preload")) {
        var type = getFileExtn(file),
        tag;
        if(type == ".js") {
          tag = document.createElement('script');
          tag.setAttribute('type', "text/javascript");
          tag.setAttribute('src', file);
        } else if(type == ".css") {
          tag = document.createElement('link');
          tag.setAttribute('type', "text/css");
          tag.setAttribute('rel', "stylesheet");
          tag.setAttribute('href', file);
        }
        ev.getAttributeNames().forEach(function (attr) {
          if (["href", "as", "rel"].indexOf(attr) == -1) {
            tag.setAttribute(attr, ev.getAttribute(attr));
          }
        });
        tag.onerror = tag.onload = function (event) {
          if (event.type == "error") {
            errorFiles.push(event);
          } else {
            successFiles.push(event);
          }
          delete Lyte.injectResources.respObj[file];
          Lyte.injectResources.availableTags[file].tag.remove();
          Lyte.injectResources.availableTags[file] = { tag: tag, event : event, type : event.type == "error" ? "error" : "load"  };
          resolve();
          tag.onerror = tag.onload = undefined;
        };
        Lyte.$.assetsDiv.appendChild(tag);
      } else {
        var t = Lyte.injectResources.availableTags[file];
        if(t.type == "error") {
          errorFiles.push(t.event)
        } else {
          successFiles.push(t.event);
        }
        resolve();
      }
    }
  
    function processRequirements(files, resolve) {
      var len;
      if (!files) {
        resolve();
      } else {
        if (!Array.isArray(files)) {
          files = [files];
        }
        if (!files.length) {
          resolve();
        }
        len = -files.length;
        files.forEach(function (file) {
          if (typeof file == "string") {
            requestFile(file, Lyte.injectResources.availableTags[file], function () {
              loaded();
            });
          } else if (Array.isArray(file)) {
            new Promise(function (r) {
              processRequirements(file, r);
            }).then(function () {
              loaded();
            });
          } else {
            len--;
            new Promise(function (r) {
              processRequirements(file.parent, r);
            }).then(function () {
              loaded();
            });
            new Promise(function (r) {
              processRequirements(file.child, r);
            }).then(function () {
              loaded();
            });
          }
        });
      }
  
      function loaded() {
        len++;
        if (len == 0) {
          resolve();
        }
      }
  
      function requestFile(file, cached, resolve) {
        if (Lyte.$.reqFiles[file]) {
          Lyte.$.reqFiles[file].push(resolve);
        } else {
          Lyte.$.reqFiles[file] = [resolve];
          if (cached && cached.event.type != "error") {
            if (Lyte.removeFromCache.arr.indexOf(file) != -1) {
              Lyte.removeFromCache.arr.splice(Lyte.removeFromCache.arr.indexOf(file), 1);
            }
            fileLoaded.call(cached.tag, file, cached.event, true);
            resolve();
          } else {
            makeRequest(file, function (event) {
              Lyte.injectResources.respObj[file] = this;
              Lyte.$.reqFiles[file].forEach(function (resolve) {
                resolve();
              });
              // filesObj[file] = this;
              fileLoaded.call(this, file, event);
              every.call(this, event);
            });
          }
        }
      }
  
      function fileLoaded(file, event, cached) {
        delete Lyte.$.reqFiles[file];
        if (!cached) {
          if (Lyte.injectResources.availableTags[file]) {
            Lyte.injectResources.availableTags[file].tag.remove();
            delete Lyte.injectResources.respObj[file];
          }
          Lyte.injectResources.availableTags[file] = { tag: this, event: event, type: event.type};
        }
      }
    }
  
    function makeRequest(file, callBack) {
      var tag,
      ev = every.internal || {},
      type = getFileExtn(file);
      ev.file = file;
      if (type == null) {
        Lyte.error('Type of file is not specified in injectResources.');
        return;
      }
      tag = document.createElement('link');
      tag.setAttribute('href', file);
      ev.tag = tag;
      if (type == '.css') {
        tag.setAttribute('as', "style");
      } else {
        tag.setAttribute('as', "script");
      }
      tag.setAttribute('rel', "preload");
      tag.onerror = tag.onload = function (event) {
        callBack.call(this, event);
        this.onerror = this.onload = undefined;
      };
      Lyte.triggerEvent("onBeforeInject", ev);
      Lyte.$.assetsDiv.appendChild(tag);
    };
  };

   function getFileExtn(file) {
    return file.match(/\.[a-zA-Z]+(?=\?|$)/);
  }
  
  Lyte.injectResources.availableTags = [];
  Lyte.injectResources.respObj = [];


  function getFileExtn(file) {
    return file.match(/\.[a-zA-Z]+(?=\?|$)/);
  }
  
  Lyte.$.replaceOldInjectResource = function() {
    Lyte.injectResources = function (files, every, completed) {
      var successFiles = [],
      errorFiles = []; 
      every = every || function() {};
      completed = completed || function() {};
      return new Promise(function(resolve) {
        processRequirements(files, resolve);   
      }).then(function() {
        completed(successFiles,errorFiles);  
      });
    
      function processRequirements(files, resolve) {
        var len;
        if(!files) {
          resolve();
        } else {
          if(!Array.isArray(files)) {
            files = [files];
          }
          if(!files.length) {
            resolve();
          }
          len = -(files.length);
          files.forEach(function(file) {
            if(typeof file == "string"){
              requestFile(file, Lyte.injectResources.availableTags[file], function() {
                loaded();
              });  
            } else if(Array.isArray(file)) {
              new Promise(function(r){
                processRequirements(file, r);
              }).then(function(){
                loaded();
              })
            } else {
              new Promise(function(r){
                processRequirements(file.parent, r);
              }).then(function(){
                new Promise(function(r1){
                  processRequirements(file.child, r1)
                }).then(function(){
                  loaded();
                })
              })
            }
          })
        }
    
        function loaded() {
          len++;
          if(len == 0) {
            resolve();
          }
        }
        
        function requestFile(file,cached,resolve) {
          if(Lyte.$.reqFiles[file]) {
            Lyte.$.reqFiles[file].push(resolve)
          } else {
            Lyte.$.reqFiles[file] = [resolve];
            if(cached && cached.event.type != "error") {
              if(Lyte.removeFromCache.arr.indexOf(file) != -1) {
                Lyte.removeFromCache.arr.splice(Lyte.removeFromCache.arr.indexOf(file),1);
              }
              fileLoaded.call(cached.tag,cached.event,true);
              resolve();
            } else {
              makeRequest(file,
                function(event) {
                  Lyte.$.reqFiles[file].forEach(function(resolve) {
                    resolve();
                  });
                  fileLoaded.call(this,event);
                  every.call(this,event);
                }
              );
            }
          }
        }
    
        function fileLoaded(event,cached) {
          var file = this.getAttribute('src') || this.getAttribute('href');
          delete Lyte.$.reqFiles[file];
          if(!cached) {
            if(Lyte.injectResources.availableTags[file]) {
              Lyte.injectResources.availableTags[file].tag.remove();
            }
            this.onerror = this.onload = undefined;
            Lyte.injectResources.availableTags[file] = {tag : this, event : {type : event.type}};
          }
        }
      }
    
      function makeRequest(file,callBack) {
        var tags = { ".js": 'script', ".css" : 'link' },
        type = getFileExtn(file);
        tag = document.createElement(tags[type]);
        if (!type) {
          Lyte.error('Type of file is not specified in injectResources.');
          return;
        } else if (type == '.css') {
          tag.setAttribute('href', file);
          tag.setAttribute('type', "text/css");
          tag.setAttribute('rel', "stylesheet");
        } else {
          tag.setAttribute('src', file);
        }
        tag.onerror = tag.onload = function (event) {
          if(event.type == "error") {
            errorFiles.push(event);  
          } else {
            successFiles.push(event);
          }
          if(callBack) {
            callBack.call(this,event);
          }
        };
        var ev = every.internal || {};
        ev.file = file;
        ev.tag = tag;
        Lyte.triggerEvent("onBeforeInject", ev);
        Lyte.$.assetsDiv.appendChild(tag);
      };
    };
  
    Lyte.injectResources.availableTags = [];
    Lyte.injectResources.respObj = [];
  }
  
  Lyte.removeFromCache = function (arr) {
    Lyte.removeFromCache.assign(arr);
    if (Lyte.removeFromCache.arr.length) {
      Lyte.removeFromCache.arr.forEach(function (file) {
        if (Lyte.injectResources.availableTags[file]) {
          Lyte.injectResources.availableTags[file].tag.remove();
          delete Lyte.injectResources.availableTags[file];
          delete Lyte.injectResources.respObj[file];
        }
      });
      Lyte.removeFromCache.arr = [];
    }
  };
  
  Lyte.removeFromCache.arr = [];
  
  Lyte.removeFromCache.assign = function (arr) {
    arr = arr == "*" ? Object.keys(Lyte.injectResources.availableTags) : Array.isArray(arr) ? arr : [arr];
    Lyte.removeFromCache.arr = Lyte.removeFromCache.arr.concat(arr);
    return;
  };

    Lyte.$.prefetchSupport = false;
    try {
        if(!Lyte.browser.ie) {
          var link = document.createElement('link');
          Lyte.$.prefetchSupport = link.relList.supports('prefetch') && link.relList.supports('preload');
        }
    } catch(e) {
    }
    if(!Lyte.$.prefetchSupport) {
        console.log("Prefetch is not supported. Falling back to old implementation")
        Lyte.$.replaceOldInjectResource();
    }
  
  /* --------- lyte router v2 changes ends ---- */
  
  Lyte.checkProperty = function(property, dataVal, key, fieldVal,field, record, type, name ,init){
    var exts = "extends";
    switch(property){
      case "type" : 
      if (Lyte.Transform.hasOwnProperty(fieldVal) && dataVal !== undefined && dataVal !== null) {
        var _fld = Lyte.Transform[fieldVal], _ret = true;
        if (Array.isArray(dataVal)) {
          if (Lyte.Transform[fieldVal][exts] != "array") {
            return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
          }
          if(_fld.hasOwnProperty("items")){
            _ret = Lyte.checkProperty("items", dataVal, key, _fld.items);
    
          }
        }else if(typeof dataVal === "object" && Lyte.Transform[fieldVal][exts] == "object" && _fld.hasOwnProperty("properties")){
          _ret = Lyte.checkProperty("properties", dataVal, key, _fld.properties);
        } 
        else if (Lyte.Transform[fieldVal][exts] != typeof dataVal) {
          return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
        }
        if(_ret !== true){
          return _ret;
        }
      }
        else if(dataVal !== undefined && dataVal !== null){
          if(Array.isArray(dataVal)){
             if(fieldVal != "array"){
                return {code : "ERR03", message : Lyte.errorCodes.ERR03, expected : fieldVal};
             }
          }
          else if(fieldVal != (typeof dataVal)){
            return {code : "ERR03", message : Lyte.errorCodes.ERR03, expected : fieldVal};
          }
        }
        break;
      case "mandatory":
          let validateFlag = fieldVal;
          if(typeof fieldVal == "object"){
            if(init && fieldVal.skipValidationOnInit == true){
              validateFlag = false;
            }
          }
          if (validateFlag && (dataVal == undefined || dataVal == null || dataVal === "")) {
            return { code: "ERR02", message: Lyte.errorCodes.ERR02 };
          }
          break;
      case "maximum" :
        if((typeof dataVal == "number") && dataVal > fieldVal){
          return {code : "ERR04", message : Lyte.errorCodes.ERR04, expected : fieldVal};
        }
        break;
      case "minimum" :
        if((typeof dataVal == "number") && dataVal < fieldVal){
          return {code : "ERR05", message : Lyte.errorCodes.ERR05, expected : fieldVal};
        }
        break;
      case "maxLength" :
      case "maxItems" :
        if(dataVal && dataVal.length > fieldVal){
          return {code : "ERR06", message : Lyte.errorCodes.ERR06, expected : fieldVal};
        }
        break;
      case "minLength" :
      case "minItems" :
        if(dataVal && dataVal.length < fieldVal){
          return {code : "ERR07", message : Lyte.errorCodes.ERR07, expected : fieldVal};
        }
        break;
      case "pattern" :
        if( typeof dataVal == "string" && !(new RegExp(fieldVal).test(dataVal))){
          return {code : "ERR08", message : Lyte.errorCodes.ERR08, expected : fieldVal};
        }
        break;
      case "uniqueItems" :{
        if(Array.isArray(dataVal) && fieldVal){
          var newArr = [];
          for(var i=0; i<dataVal.length; i++){
            var val = dataVal[i];
            if(newArr.indexOf(val) != -1){
              return {code : "ERR09", message : Lyte.errorCodes.ERR09};
            }
            newArr.push(val);
          }         
        }
        break;        
      }
      case "constant" :
        if(Array.isArray(dataVal)){
          var resp = dataVal.length==fieldVal.length && dataVal.every(function(v,i) { return v === fieldVal[i]});
          if(!resp){
            return {code : "ERR10", message : Lyte.errorCodes.ERR10, expected : fieldVal};
          }
        }
        else if(typeof dataVal == "object"){
          var resp = store.adapter.$.compareObjects(dataVal, fieldVal);
          if(!resp){
            return {code : "ERR10", message : Lyte.errorCodes.ERR10, expected : fieldVal};
          }
        }
        else if(dataVal && dataVal != fieldVal){
          return {code : "ERR10", message : Lyte.errorCodes.ERR10, expected : fieldVal};
        }
        break;
      case "items" :{
        if (Array.isArray(dataVal)) {
          for (var i = 0; i < dataVal.length; i++) {
            if(!(fieldVal.any && Array.isArray(fieldVal))){
              fieldVal = [fieldVal];
            }
            var fldLen = fieldVal.length, _ret = true;
            for(var j=0; j<fldLen; j++){
              var _fld = fieldVal[j];
              for (var property in _fld) {
              var resp = Lyte.checkProperty(property, dataVal[i], i, _fld[property], _fld);
              if (resp !== true) {
                if(_ret === true){
                resp.path = resp.path ? i + "." + resp.path : resp.path;
                _ret = resp;
                }
                break;
              }
              }
            }
            if(_ret !== true){
              return _ret;
            }
            }
        }
        break;        
      }
      case "properties" :
        if (typeof dataVal == "object" && !Array.isArray(dataVal)) {
					for (var key in dataVal) {
						if(fieldVal.hasOwnProperty(key)){
						  var fld = fieldVal[key];
						  if(!(fld.any && Array.isArray(fld))){
							  fld = [fld];
						  }
						  var fldLen = fld.length, _ret = true;
						  for(var i=0; i<fldLen; i++){
							var _fld = fld[i];
							for (var property in _fld) {
							  var resp = Lyte.checkProperty(property, dataVal[key], key, _fld[property], _fld);
							  if (resp != true) {
								if(_ret === true){
								resp.path = resp.path ? key + "." + resp.path : key.toString();
								_ret = resp;
								}
								break;
							  }
							}
						  }
						  if(_ret !== true){
							return _ret;
						  }
						}
						// else if(field.exact){
						// 	return { code : "ERR29", message: Lyte.errorCodes.ERR29, property: key };
						// }
					} 
				}
        break;
      case "validation" :{
        var resp =  Lyte.customValidator[fieldVal].apply(record, [key, dataVal, name]);
        if(resp != true){
          return resp;
        }
        break;
      }
      case "instanceof":{
        if(typeof dataVal === "object" && !Array.isArray(dataVal) && !(dataVal instanceof fieldVal)){
          return { code: "ERR30", message: Lyte.errorCodes.ERR30, property: key, instanceof: fieldVal};
        }
      }        
    }
    return true;
    }

    Lyte.checkNestedProp = function(id,path,dtype,wobj,object,property,value,check,fromStore){
      if (Lyte.Transform[dtype.type]){
        dtype = Lyte.Transform[dtype.type];
        dtype.type = dtype.extends;
      }
      if(path.length!=0){
          if(dtype.type == 'array'){
              if(dtype.items && !isNaN(path[0]) && typeof(dtype.items)=='object'){
                path= path.slice(1);
                Lyte.checkNestedProp(id,path,dtype.items,wobj,object,property,value,check,fromStore)
              }
          }
          else if( dtype.type == "object"){
              if(dtype.properties && dtype.properties.hasOwnProperty(path[0])){
                var k = path[0];
                path = path.slice(1);
                Lyte.checkNestedProp(id,path,dtype.properties[k],wobj,object,property,value,check,fromStore);
              }
          }
      }
      else {
        var err;
        if (dtype && (dtype.properties || dtype.items) && !check.hasOwnProperty("warn")) {
          var component = {};component.__data = {};
          if (dtype.properties) {
            component.__data[property] = dtype.properties[property];
        } else if (dtype.items && wobj.index) {
            component.__data[wobj.index] = dtype;
        } else {
            component.__data[property] = dtype.items;
        }
          var cp = Lyte.validate(object, property, value, component);
          var errKey = wobj.attr ? wobj.attr : wobj.key,_path = wobj.path.split(".");
          var PathWay = wobj.index == undefined && property? wobj.path+(wobj.path!="" ?".":"")+property : wobj.index !=undefined ? wobj.path+(wobj.path!="" ?".":"")+wobj.index : wobj.path;
          if (cp && (typeof cp === 'undefined' ? 'undefined' : typeof(cp)) == "object" && cp.code) {
              cp.value = value;
              cp.path = wobj.path !=""?wobj.path:property;
              if(wobj.isRec && fromStore && wobj.key ==  undefined && wobj.path!=""){
                  errKey = wobj.path.split(".")[0]
                  _path.shift();
                  _path = (_path.length == 1 && _path[0] == property) ? [] : _path;
              }
              // wobj.Error ? true : wobj.Error = {}
              wobj.Error && wobj.Error[errKey] ? wobj.Error[errKey].code && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : wobj.Error[errKey].nested = {} : wobj.Error[errKey] = { nested: {} };
              wobj.Error[errKey].code = "ERR34"
              wobj.Error[errKey].message = Lyte.errorCodes.ERR34;
              err = wobj.Error[errKey].nested;
              wobj._cmpErr[errKey] ? true : wobj._cmpErr[errKey]={};
              wobj._cmpErr[errKey].code = "ERR34";
              wobj._cmpErr[errKey].message = Lyte.errorCodes.ERR34;
              var cmpErrPath = wobj._cmpErr[errKey].path ? wobj._cmpErr[errKey].path : [] ;
              if(wobj.path !=""){
                  _path.forEach(function (k) {
                      if (err && !err[k]) {
                          err = err[k] = {};
                      } else {
                          err = err[k];
                      }
                  });
              }
              wobj.index != undefined ? err[wobj.index] = cp : err[property] = cp;
              if(!cmpErrPath.includes(PathWay)){
                cmpErrPath.push(PathWay)
              }
              wobj._cmpErr[errKey].path = cmpErrPath;
          } else{
              if(wobj.isRec && fromStore && wobj.key ==  undefined){
                  errKey = wobj.path.split(".")[0]
                  _path.shift();
                  _path = (_path.length == 1 && _path[0] == property) ? [property] : _path;
              }
              err = wobj.Error[errKey] && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : undefined;
              var cmpErr = wobj._cmpErr[errKey] || undefined;
              if(cmpErr && cmpErr.path && cmpErr.path.includes(PathWay)){
                var ind = cmpErr.path.indexOf(PathWay)
                cmpErr.path.splice(ind,1)
              }
              //var p = object.$.error[property];
              if(err){
                  var key = wobj.index || property; 
                  var flag = true,
                  p = PathWay.split(".");
                  p.forEach(function (r) {
                      if (err[r] && err[r].code) {
                          delete err[r];
                          if(err && Object.keys(err).length == 0){
                              flag = true;
                          }
                          else{
                              flag = false;
                          }
                      }
                      else{
                        err = err[r]
                      }
                  });
                  if (flag == true && wobj.Error[errKey] && wobj._cmpErr[errKey]) {
                      delete wobj.Error[errKey];
                      delete wobj._cmpErr[errKey]
                  }
              }
    
          }
          if((check.value && check.value.hasOwnProperty("code") && cp.code) || !check.value){
              check.value = cp;
          }
      }
    }
      wobj.index && delete wobj.index; 
    }
  
  Lyte.types = ["string", "object", "number", "boolean", "array"];
  
  Lyte.attr = function(type, opts){
  var obj = {};
  obj.type = type;
  if(opts == undefined){
    opts = {};
  }
  if(Lyte.types.indexOf(type) == -1 && !Lyte.Transform.hasOwnProperty(type)){
    throw new Error("Not a valid field type - "+type);
  }
  Object.assign(obj,opts);
  return obj;
  }
  
  window.prop = Lyte.attr;
  Lyte.defineRelation = function(name,type,opts){
  var relation = {type : "relation", relType : type, relatedTo : name};
  if(opts){
    relation.opts = opts;
  }
  return relation;
  }
  
  Lyte.belongsTo = function(name,opts){
  return this.defineRelation(name,"belongsTo",opts);
  }
  
  Lyte.hasMany = function(name,opts){
  return this.defineRelation(name,"hasMany",opts);
  }

  
  Lyte.Transform = {};
  
  Lyte.customValidator = {};
  
  Lyte.registerDataType = function(fieldTypeName, properties){
  var exts = "extends";
  if(this.Transform.hasOwnProperty(fieldTypeName)){
    Lyte.warn("Custom Field Type - "+fieldTypeName+" -  already exists.");
    return;
  }
  if(properties[exts] == undefined || Lyte.types.indexOf(properties[exts]) == -1){
    Lyte.error("Not a valid field type - "+properties[exts]);
    return;
  }
  this.Transform[fieldTypeName] = properties;
  }
  
  Lyte.registerValidator = function(customValidatorName, func){
  if(this.customValidator.hasOwnProperty(customValidatorName)){
    Lyte.warn("Custom Validator with name - "+customValidatorName+" - already exists");
    return;
  }
  this.customValidator[customValidatorName] = func;
  }
  
  Lyte.patterns = {
  email : /^([A-Za-z0-9._%\-'+/]+@[A-Za-z0-9.-]+\.[a-zA-Z]{2,22})$/,
  url : /(^(ht|f)tp(s?):\/\/[0-9a-zA-Z][-.\w]*(:[0-9])*(\/?)([a-zA-Z0-9\-.?,:'/\\+=&amp;%$#_[\]@!()*;~]*)?$)/,
  ampm : /^(AM|PM|am|pm)$/,
  hour : /^(0?[0-9]|1[0-9]|2[0-4])$/,
  minute : /^(0?[0-9]|[1-5][0-9]|60)$/,
  boolean : /^(true|false|TRUE|FALSE)$/,
  alphaNumeric : /([a-zA-Z0-9])+/,
  alphabetsOnly : /([a-zA-Z])+/,
  numeric : /([0-9])+/,
  phoneNo : /^[0-9a-zA-Z+.()\-;\s]+$/
  }

  Lyte.validate = function (object, key, value, component, init) {
		var definition = component.__data[key];
		var isError = false;
		var type = definition ? definition.type : undefined;
		var _def = definition;
		if(_def){
		  if(!(_def.any && Array.isArray(_def))){
			  _def = [_def];
		  }
		  var defLen = _def.length, _ret = true;
		  for(var i=0; i<defLen; i++){
			  var _d = _def[i];
			  for (var defKey in _d) {
				  isError = Lyte.checkProperty(defKey, value, key, _d[defKey], _d, object, type, undefined, init);
				  if (isError !== true) {
					  if(_ret === true){
						  _ret = isError;
					  }
				  }
			  }
		  }
		  if(_ret !== true){
			  return _ret;
		  }
		}
		return false;
	  };
    
  
  Lyte.registerPattern = function(patternName, pattern){
  this.patterns[patternName] = pattern;
  }
  
  Lyte.errorCodes = {
    ERR01 : "Primary key cannot be modified", ERR02 : "Mandatory field cannot be empty", ERR03 : "Type of value does not match the specified data type", ERR04 : "Value is greater than the maximum value allowed",
    ERR05 : "Value is less than the minimum value allowed", ERR06 : "Length of string/array is greater than the maximum limit allowed", ERR07 : "Length of string/array is less than the minimum limit allowed",
    ERR08 : "String does not match the specified pattern", ERR09 : "Values in array are not unique", ERR10 : "Value is not equal to the specified constant", ERR11 : "Model of related field is not defined",
    ERR12 : "Model of backward relation is not defined", ERR13 : "Record not found", ERR14 : "Model does not match the related field model", ERR15 : "Error in creating a record as a relation",
    ERR16 : "Record with primary key already exists", ERR17 : "Value cannot be changed because record has been deleted", ERR18 : "Action not defined", ERR19 : "Model not defined",
    ERR20 : "Key not specified", ERR21 : "'belongsTo' relationship expects a single object/id", ERR22 : "Type not specified for polymorphic relation", ERR23: "Primary Key value not present", ERR24: "Error while relating record", ERR25: "Backward relation not present", ERR26: "Primary key value cannot be undefined or null",
    ERR27 : "Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'",
    ERR28 : "Unloaded record cannot be saved",
    ERR29: "Property not defined in the object",
    ERR30:"Error in variables declaration for Query",ERR31: "Query not registered for the Model",
    ERR32: "Property not defined in the object",
    ERR33: "Property's value is not an instanceof the mentioned class",
    ERR34: "Type definition for nested properties / items does not match with the value" ,
    ERR35: "A datatype mismatch has occurred for custom DataType '{0}'"
  }
  
  Lyte.registeredGlobalEvents = Lyte.__lyteRegisteredEvents = {};
  Lyte.__lyteRegisteredEventsGlobal = {}
  Lyte.triggerEvent = function(obj) {
    var args;
    var actArgs;
    var eventObjectPath;
    if(typeof obj == "object" && obj.global) {
      actArgs = obj.args;
      args = Array.prototype.slice.call(actArgs, 1);
      eventName = actArgs[0];
      eventObjectPath = "__lyteRegisteredEventsGlobal";
    } else {
      args = Array.prototype.slice.call(arguments, 1);
      eventName = arguments[0];
      eventObjectPath = "__lyteRegisteredEvents";
    }
     var stopEvent = false;
     var s = this[eventObjectPath][eventName];
       if(!s) {
         s = this[eventObjectPath][eventName] = {"listeners" : []};
       } else {
         for(var i=0;i<s.listeners.length;i++) {
           var func = s.listeners[i];
           if(func) {
              var ret = func.apply(this, args);
              if(ret === false) {
                stopEvent = true;
                break;
              }
           }
         }
       }
       var customEvent = new CustomEvent(eventName, {"detail" : args});
       if(!stopEvent) {
        document.dispatchEvent(customEvent); 
       } 
   }
  Lyte.triggerGlobalEvent = function() {
    return Lyte.triggerEvent({"global" : true, "args" : Array.from(arguments)});
  }
  
   Lyte.addEventListener = function(eventName, func, options) {
     if(typeof func !== "function") {
         Lyte.error("Second parameter to Lyte.Component.addGlobalEventListener() must be a function");
         return;
     }
     var eventObjectPath = options && options.global ? "__lyteRegisteredEventsGlobal" : "__lyteRegisteredEvents";
     var s = this[eventObjectPath][eventName];
     if(!s) {
       s = this[eventObjectPath][eventName] = {"listeners" : []};
     }
     var d = s.listeners.push(func);
     return eventName + "-" + (d - 1);
    }
    
    Lyte.removeEventListener = function(id, options) {
      let lastIndex;
     if(!id || (lastIndex = id.lastIndexOf("-")) == -1) {
       Lyte.error("listener unique id not specified / invalid");
       return;
     }
     var globalId  = id.split("-");
     if(options){
      var globalId  = id.split("-");
      var eventObjectPath = options && options.global ? "__lyteRegisteredEventsGlobal" : "__lyteRegisteredEvents";
      var s = this[eventObjectPath][globalId[0]];
      if(!s || !s.listeners[globalId[1]]) {
          Lyte.error("No such listener registered");
          return;
      }
      s.listeners[globalId[1]] = null;
     }else{
      var eventName = id.substring(0,lastIndex);
      var eventId = id.substring(lastIndex + 1);
      var s = this.__lyteRegisteredEvents[eventName];
      if(!s || !s.listeners[eventId]) {
          Lyte.error("No such listener registered");
          return;
      }
      s.listeners[eventId] = null;
     }
    }
  
  
  Lyte.extendEventListeners = function(scp){
    if(scp && typeof scp == "object" && !scp.hasOwnProperty("__lyteRegisteredEvents")){
        Object.defineProperties(scp, {
            __lyteRegisteredEvents : {
                value : {}
            },
            addEventListener : {
                value : Lyte.addEventListener
            },
            removeEventListener : {
                value : Lyte.removeEventListener
            },
            triggerEvent : {
                value : Lyte.triggerEvent
            }
        });
    }
  }
  
  Lyte.deepCopyObject = function( obj )  {
  var targetVal = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
  var current, copies = [{source : obj, target : targetVal}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];
  var cloneObject = copies[0].target, targetReferences = [cloneObject];
  while(current = copies.shift()){
    keys = Object.keys(current.source);
    for(propertyIndex = 0; propertyIndex < keys.length; propertyIndex++){
        descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
        if(!descriptor){
            continue;
        }
        if(!descriptor.value || typeof descriptor.value != "object"){
            Object.defineProperty(current.target, keys[propertyIndex], descriptor);
            continue;
        }
        nextSource = descriptor.value;
        descriptor.value = Array.isArray(nextSource) ? [] : nextSource instanceof Set ? new Set() : Object.create(Object.getPrototypeOf(nextSource));
        indexOf = sourceReferences.indexOf(nextSource);
        if(indexOf != -1){
            descriptor.value = targetReferences[indexOf];
            Object.defineProperty(current.target, keys[propertyIndex], descriptor);
            continue;
        }
        sourceReferences.push(nextSource);
        targetReferences.push(descriptor.value);
        Object.defineProperty(current.target, keys[propertyIndex], descriptor);
        copies.push({source : nextSource, target : descriptor.value});
    }
    if(Lyte.isRecord(current.source)){
      Object.defineProperty(current.target, "$", {
        value: {}
      });
      current.target.$.isNew = current.source.$.isNew;
      current.target.$.isModified = current.source.$.isModified;
      current.target.$.isDeleted = current.source.$.isDeleted;
      current.target.$.pK = current.source.$.pK;
      current.target.$._attributes = current.source.$._attributes;
      current.target.$.isCloned = true;
      current.target.$.model = { _name : current.source.$.model._name };
      if(current.source.$.hasOwnProperty("deepNest")){
        current.target.$.deepNest = current.source.$.deepNest;
      }
      if(current.source.$.hasOwnProperty("partialType")){
        current.target.$.partialType = current.source.$.partialType;
      }
    }
    if(Array.isArray(current.source)){
      if(current.source.partial){
        Object.defineProperty(current.target, "partial", {
          value: current.source.partial
        });
      }
    }
  }
  return cloneObject;
  }
  
  Lyte.nestScpId = 1;
  Lyte.nestScp = {};
  Lyte.__nestRef__ = {};
  // Lyte.__nestScp__ = {};
  Lyte.__nestScp__ = new Map();
  // Lyte.__nestScp1__ = new Map();
  Lyte.establishObjectBinding = function (data, attr, fromStore, update,storeRecord,watch) {
    var model, fld, nestObj;
    var checkAttrs=data.__component__ && data.__component__.component.__data?data.__component__.component.__data[attr]:undefined;
    if (fromStore) {
      if(data && !data.$ && data._scp){
        var keys = Array.from(data._scp.keys());
        keys.forEach(function(id){
            var recObj = Lyte.nestScp[id];
            model = store.modelFor(recObj.model);
        })
      }else{
        model = data.$.model;
      }
       fld = model && model.fieldList && model.fieldList.hasOwnProperty(attr)? model.fieldList[attr] : {};
       var _checkDtype = false;
       if(fld){
        var _dtype = Lyte.Transform[fld.type];
        if(_dtype && (_dtype.hasOwnProperty("properties") || _dtype.hasOwnProperty("items"))){
          _checkDtype = true;
        }
       }
        if (fld && (fld.type !== "relation" && fld.watch) || _checkDtype){
            checkAttrs=fld;
        }
      else{
         if(data._scp){
            var keys = Array.from(data._scp.keys());
             keys.forEach(function (id) {
               var _mpObj = data._scp.get(id), 
               mpObj = _mpObj.paths;
               var _dtype = Lyte.nestScp[id] || undefined;
               watch = _dtype && _dtype["watch"]?_dtype["watch"]:watch;
                 for (var key in mpObj) {
                     var path = key ? key.split(".") : [];
                     path.push(attr);
                     Lyte.bindObj(data, attr, id, path, new Map(),undefined,checkAttrs,watch,true);
                 }
            });
         }
        return;
      }
    }
    if (update && data._scp && data._scp.size) {
        var keys = Array.from(data._scp.keys());
        keys.forEach(function (id) {
          var _mpObj = data._scp.get(id), 
          mpObj = _mpObj.paths;
          var _dtype = Lyte.nestScp[id] || undefined;
          watch = _dtype && _dtype["watch"]?_dtype["watch"]:watch;
            for (var key in mpObj) {
                var path = key ? key.split(".") : [];
                path.push(attr);
                Lyte.bindObj(data, attr, id, path, new Map(),undefined,checkAttrs,watch,true);
            }
        });
    }
    var customDtype = false;
    if (checkAttrs && Lyte.Transform[checkAttrs.type]) {
      var dtype = Lyte.Transform[checkAttrs.type];
      if(dtype.hasOwnProperty("properties") || dtype.hasOwnProperty("items")){
        checkAttrs = Lyte.Transform[checkAttrs.type];
        customDtype = true;
      }
    }
    if ((!fromStore || fld.watch || fld.properties || fld.items || watch || customDtype) && data[attr]) {
      var _scpObj, kmpKey;
        if (data && data.__component__) {
            data.__component__.__scpObj || Object.defineProperty(data.__component__, "__scpObj", {
                value: {}
            });
            kmpKey = data.__component__;
            _scpObj = data.__component__.__scpObj;
        } else if (Lyte.isRecord(data)) {
            data.$.__scpObj || Object.defineProperty(data.$, "__scpObj", {
                value: {}
            });
            kmpKey = data;
            _scpObj = data.$.__scpObj;
        }
        var obj = _scpObj,
        id;
        if (_scpObj) {
            var __nestScp1Set__ = false, __nestScp2Set__ = false;
            if (fromStore) {
                if(data[attr] && !Lyte.__nestScp__.has(data[attr])){
                    nestObj = { model: model._name, attr: attr, pK: data.$.pK , Error : {} };
                    __nestScp1Set__ = true;
                }
                else{
                  // var kmp = Lyte.__nestScp__[kid] = Lyte.__nestScp__[kid] || new Map();
                  // data ? kmp.set(data, true) : undefined;
                  var __nId = Lyte.__nestScp__.get(data[attr])
                  var refMp = Lyte.__nestRef__[__nId] = Lyte.__nestRef__[__nId] || new Map();
                  var refMpId = Lyte.$.genMapId(refMp);
                  refMp.set(refMpId, true);
                  Lyte.setRecBindMap(Lyte.nestScp[__nId], {model:model._name, attr: attr, pK: data.$.pK , Error : {}});
                  obj[attr] = __nId+"_"+refMpId;
                }
            } else {
              if(data[attr] && !Lyte.__nestScp__.has(data[attr])){
                var ErrMap = [],cmpDataKeys = {};
                cmpDataKeys.key=attr;
                cmpDataKeys.dtype = data.__component__.component.__data[attr];
                cmpDataKeys._cmpErr = data.errors;
                cmpDataKeys.Error={};
                ErrMap.push(cmpDataKeys);
                nestObj = { data: data[attr], PropsInfo : ErrMap };
                if(cmpDataKeys.dtype.watch){
                  nestObj.watch = true;
                }
                __nestScp2Set__ = true;
              }
              else{
                  var __nId = Lyte.__nestScp__.get(data[attr])
                  var scope = Lyte.nestScp[__nId];
                  if(scope){
                    if(!scope.PropsInfo){
                      scope.PropsInfo = [];
                    }
                    var errMp = scope.PropsInfo;
                    var cmpDataKeys = {};
                    cmpDataKeys.key=attr;
                    cmpDataKeys.Error = {};
                    cmpDataKeys._cmpErr = data.errors;
                    cmpDataKeys.dtype = data.__component__.component.__data[attr];
                    if(cmpDataKeys.dtype.watch){
                      scope.watch = true;
                    }
                    errMp.push(cmpDataKeys);
                  }
                  var refMp = Lyte.__nestRef__[__nId] = Lyte.__nestRef__[__nId] || new Map();
                  var refMpId = Lyte.$.genMapId(refMp);
                  refMp.set(refMpId, true);
                  obj[attr] = __nId+"_"+refMpId;
              }
          }
          if(nestObj){
            var nestScpId = Lyte.nestScpId++;
            var refMp = Lyte.__nestRef__[nestScpId] = Lyte.__nestRef__[nestScpId] || new Map();
            var refMpId = Lyte.$.genMapId(refMp);
            refMp.set(refMpId, true);
            // var kmp = Lyte.__nestScp__[nestScpId] = Lyte.__nestScp__[nestScpId] || new Map();
            // kmp.set(kmpKey, true);
            Lyte.__nestScp__.set(data[attr], nestScpId);
            if(__nestScp1Set__){
                Lyte.nestScp[nestScpId] = {};
                Lyte.setRecBindMap(Lyte.nestScp[nestScpId], nestObj);
                Lyte.nestScp[nestScpId].Error = nestObj.Error
                //     Lyte.setRecBindMap(model._name, attr, data.$.pK, nestScpId); 
            }
            if(__nestScp2Set__){   
                Lyte.nestScp[nestScpId] = nestObj;                 
            //     Lyte.__nestScp2__.set(data[attr], nestScpId);
            }
            Lyte.nestScp[nestScpId]._data = data[attr];
            obj[attr] = obj[attr] || nestScpId+"_"+refMpId;
            var path = [];
            // fromStore ? path.push(attr) : undefined;
            Lyte.bindObj(data, attr, nestScpId, path, new Map(), undefined, checkAttrs,watch);
          }
      }
  }
};

Lyte.removeNestScp2Bind = function(mp, mdlObj){
var mp = mp.model;
if (mp.has(mdlObj.model)) {
    var mp1 = mp.get(mdlObj.model);
    if (mp1.has(mdlObj.pK)) {
        var mp2 = mp1.get(mdlObj.pK);
        if (mp2.has(mdlObj.attr)) {
            mp2.delete(mdlObj.attr);
        }
        !mp2.size ? mp1.delete(mdlObj.pK) : undefined; 
    }
    !mp1.size ? mp.delete(mdlObj.model) : undefined;
}
}

Lyte.setRecBindMap = function(obj, nestObj){
var mp = obj.model = obj.model || new Map(), modelName = nestObj.model, pK = nestObj.pK, attr = nestObj.attr;
if(modelName && !mp.has(modelName)){
    mp.set(modelName, new Map());
}
mp = mp.get(modelName);
if(pK && !mp.has(pK)){
    mp.set(pK, new Map());
}
mp = mp.get(pK);
if(attr && !mp.has(attr)){
  mp.set(attr, true);
}
}
  

Lyte.bindObj = function (data, key, id, path, mp, check, checkAttrs,watch,ignoreCyclicDelete) {
  mp = mp || new Map();
var value = key != undefined ? data[key] : data;
var cyclic = false;
if(!ignoreCyclicDelete && !path.length && Lyte.__nestScp__.get(data) === id){
  delete Lyte.nestScp[id].cyclic;
}
if (path.length > 1 && value && Lyte.nestScp[id] && Lyte.nestScp[id].hasOwnProperty("data") && Lyte.nestScp[id].data === value) {
  if(mp.get(value)){
    cyclic = true;
  }
    else{
       try{ 
          JSON.stringify(value);
       }
       catch(exp){
           cyclic = true;
       }
   }
  if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
    Lyte.estObjScp(value, id, path, cyclic);
  }
  return;
}
var attrs,nestedSCP;
if(checkAttrs){
	if((checkAttrs.hasOwnProperty("items")||checkAttrs.hasOwnProperty("properties"))){
		attrs=checkAttrs.items || checkAttrs.properties;
    nestedSCP = true;
	}
	else if(watch == undefined && checkAttrs.watch == true){
		watch = checkAttrs.watch 
	}
}
attrs=watch?undefined:attrs;
if (Array.isArray(value)) {
  if (!mp.get(value)) {
    mp.set(value, true);
    value.forEach(function (val, idx) {
      path.push(idx);
      if(watch || (checkAttrs && checkAttrs.hasOwnProperty("items") && typeof(checkAttrs.items) == "object" )){
        Lyte.bindObj(value, idx, id, path, mp,undefined,attrs,watch);
      }
      path.pop();
    });
  } else {
    cyclic = true;
  }
  if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
    var _establish;
    if(Array.isArray(watch)){
      _establish = Lyte.checkEstablishingSCP(value,path,watch)
    }
    if(_establish || (typeof watch =="boolean" && watch ) || nestedSCP){
        Lyte.estObjScp(value, id, path, cyclic);
    }
  }
} else if (value && typeof(value) == "object") {
  var cyclic = false;
  if (!mp.get(value)) {
    mp.set(value, true);
    for (var str in value) {
      path.push(str);
      if(watch || (attrs && attrs.hasOwnProperty(str))){
        Lyte.bindObj(value, str, id, path, mp,undefined,attrs?attrs[str]:undefined,watch);
      }
      path.pop();
    }
  } else {
    cyclic = true;
  }
  if(Lyte.checkAndAddBind(value, id, path, cyclic)) {
    var _establish;
    if(Array.isArray(watch)){
      _establish = Lyte.checkEstablishingSCP(value,path,watch)
    }
    if(_establish || (typeof watch =="boolean" && watch ) || nestedSCP ){
      Lyte.estObjScp(value, id, path, cyclic);
    }
  }
}
};

  Lyte.checkAndAddBind = function(value, id, path, cyclic){
      if(!value._scp || !value._scp.size){
          return true;
      }
      if(value._scp.size){
        if(value._scp.has(id)){
            var _obj = value._scp.get(id);
            var obj = _obj.paths;
            if(obj.hasOwnProperty(path.join("."))){
              if(cyclic){
                Lyte.nestScp[id].cyclic = true;
              }                      
              return false;
            }
        }
      }
      return true;
  }   

  Lyte.estObjScp = function(value, id, path, cyclic){
    if(!value._scp){
      Object.defineProperty(value, "_scp", {
        value : new Map(),
        enumerable : false,
        configurable : true
      });
    }
    var mp = value._scp;
    if(!mp.has(id)){
      mp.set(id, {});
    }
    var obj = mp.get(id),
    path = path ? path.join(".") : path;
    var pathObj = obj.paths = obj.paths || {};
    pathObj[path] = true;
    var nestObj = Lyte.nestScp[id];
    if(!nestObj.cyclic && cyclic == true){
      nestObj.cyclic = true;
    }
  }
  
  Lyte.cmpObjs = function (obj1, obj2){
      if(Object.keys(obj1).length !== Object.keys(obj2).length){
          return false;
      }
      for(var key in obj1){
          if(!obj2.hasOwnProperty(key)){
              return false;
          }
          var ret = Lyte.cmpData(obj1[key], obj2[key]);
          if(ret == false){
              return false;
          }
      }
      return true;
  }	
  
  
  Lyte.cmpData = function(data1, data2){
    if(Array.isArray(data1)){
      if((!Array.isArray(data2)) || data1.length !== data2.length){
        return false;
      }
      if(data1 === data2){
        return true;
      }
      var len = data1.length, ret;
      for(var i=0;i <len; i++){
        ret = Lyte.cmpData(data1[i], data2[i]);
        if(ret == false){
          return false;
        }
      }
    }
    else if(data1 && data2 && typeof data1 == "object" && typeof data2 == "object"){
      if(data1 === data2){
        return true;
      }
      return Lyte.cmpObjs(data1,data2);
    }
    // else if(Lyte && Lyte.isRecord(data1) && Lyte.isRecord(data2)){
    //   if( (data1.$.model._name !== data1.$.model._name) || (Lyte.getpKVal(data1) !== Lyte.getpKVal(data2)) ){
    //     return false;
    //   }
    // }
    else if(data1 !== data2){
      return false;
    }
    return true;
  }

  Lyte.nestScpRmPath = function(obj, path){
    if(obj && obj.paths){
        obj = obj.paths;
        for(var key in obj){
            if(key.startsWith(path+".")){
                delete obj[key];
            }
        }
    }
  }
  
  Lyte.nestScpRemove = function(data, id, path){
    var mp = data._scp;
    if(mp && mp.size){
        if(path){
          Lyte.nestScpRmPath(mp.get(id), path);
          var _obj = mp.get(id); 
          var obj = _obj ? _obj.paths : undefined;
          if(obj && !Object.keys(obj).length){
              mp.delete(id);
          }  
        }
        else{
            mp.delete(id);
        }
        if(!mp.size){
          delete data._scp;
        }
    }
  }
  
  Lyte.rmNestScp = function(value, id, mp, data, path){
    if (Array.isArray(value)) {
        if (!mp.get(value)) {
            mp.set(value, true);
            value.forEach(function (val, idx) {
                Lyte.rmNestScp(val, id, mp, undefined, path);
            });
        }
        Lyte.nestScpRemove(value, id, path);
    } else if (value && typeof(value) == "object") {
        if (!mp.get(value)) {
            mp.set(value, true);
            for (var str in value) {
                Lyte.rmNestScp(value[str], id, mp, undefined, path);
            }
        }
        Lyte.nestScpRemove(value, id, path);
    }
  }

Lyte.removeNestScp = function (value, id, mpId, path, context, mp, data, recObj) {
  mp = mp || new Map();
  id = Number.parseInt(id);
  var obj = Lyte.nestScp[id], kmp = Lyte.__nestRef__[id];
  if(recObj && obj.model){
    Lyte.removeNestScp2Bind(obj, recObj);
  }
  if(context){
      if(kmp && kmp.has(mpId)){
          kmp.delete(mpId);
      }
      if(!kmp || (kmp && !kmp.size)){
          delete Lyte.__nestRef__[id];
          if(Lyte.__nestScp__.has(value)){
              Lyte.__nestScp__.delete(value);
          }
          Lyte.rmNestScp(value, id, mp, true, path);
          if(!data){
              delete Lyte.nestScp[id];
          }
      }
  }
  else{
    Lyte.rmNestScp(value, id, mp, true, path);
  }
};

  
  Lyte.resolvePromises = function(promises) {
  if(typeof promises == "string" || promises instanceof Promise) {
      return promises;
  } else {
    if(Array.isArray(promises)) {
      return promiseArray(promises);
    } else if(typeof promises == "object") {
      return promiseHash(promises);
    }    
  }
  
  function promiseHash(promiseObj) {
    var actPromKeys = [],
    promises = [],
    promiseKeys = Object.keys(promiseObj);
    promiseKeys.forEach(function(key) {
        var value = promiseObj[key];
      if(value instanceof Promise || (value && !Array.isArray(value) && typeof value == "object" && typeof value.then == "function")) {
        actPromKeys.push(key)
        promises.push(value);
      }
    });
    if(!promises.length) {
      return Promise.resolve(promiseObj);
    } else {
       var obj = {},promise = new Promise(function(resolve,reject) {
          Promise.all(promises).then(function(data) {
            promiseKeys.forEach(function(promiseKey) {
              if(actPromKeys.indexOf(promiseKey) != -1) {
                obj[promiseKey] = data[actPromKeys.indexOf(promiseKey)]
              } else {
                obj[promiseKey] = promiseObj[promiseKey];
              }
            });
          resolve(obj);
        },function(err) {
          reject(err);
          Lyte.error('Error on resolve promises',err);
        });
      });   
     return promise;
    }
  }
  
  function promiseArray(promiseArray) {
    var array = [],
    hasPromise = false;
    promiseArray.every(function(item,i) {
        if(item instanceof Promise || (item && !Array.isArray(item) && typeof item == "object" && typeof item.then == "function")) { 
            hasPromise = true;
            return false;
        }
        return true
    });
    if(!hasPromise) {
        return Promise.resolve(promiseArray);
    }
    var promise = new Promise(function(resolve,reject) {
      Promise.all(promiseArray).then(function(data) {
        promiseArray.forEach(function(key,index){
          array[index] = data[index];
        });
        resolve(array);
      },function(err) {
        reject(err);
        Lyte.error('Error on resolve promises',err);
      });
    });   
   return promise;
  }
  };
  function domContentLoaded1() {
    Lyte.assetsDivContainer.appendChild(Lyte.$.assetsDiv);
  }
  
  if(document.readyState === "complete" || document.readyState === "interactive") {
    domContentLoaded1();
  } else {
    document.addEventListener("DOMContentLoaded", function(e){
        domContentLoaded1();
    },true);
  };
  
  
    var XHRSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = function(){
        var event = window.event;  
        var type, target = event ? event.target : undefined; 
        if(Lyte.getConfig("stateHandling")){
            if(event){
                type = event.type;
                /^(click|dblclick)$/.test(type) && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false" ? addStateToMap(type,target,this) : undefined;
            }
            else{
                var router = Lyte && Lyte.Router ? Lyte.Router.getRouteInstance() : undefined;
                if(router){
                    var currentAction = router.transition ? router.transition.ev : undefined;
                    if(currentAction && currentAction.target && currentAction.target.getAttribute && currentAction.target.getAttribute("lyte-state-handling") != "false"){
                        var mp = Lyte.__transXHRMap = Lyte.__transXHRMap || new Map();
                        mp.set(router.transition, {currentAction : currentAction, XHR:this});
                        addStateToMap(currentAction.type, currentAction.target, this);
                    }
                }
            }
        }
        XHRSend.apply(this, arguments);
    }
    
    Lyte.addEventListener("transitionStart",function(obj){
      var trans = obj.nextTrans;
      if(trans && obj.prevTrans){
          if(window.event && /^(click|dblclick)$/.test(window.event.type)){
              trans.ev = window.event;
              if(obj.prevTrans.ev){
                delete obj.prevTrans.ev;
              }
          }
          else if((obj.prevTrans.state == 409 || obj.prevTrans.state == 308) && obj.prevTrans.ev){
              trans.ev = obj.prevTrans.ev;
              delete obj.prevTrans.ev;
          }
          
      }
    });
    
    Lyte.addEventListener("afterRouteTransition", function(obj){
        if(obj && obj.trans){
            var mp = Lyte.__transXHRMap, removeEv = false;
            if(obj.trans.state == 409 || obj.trans.state == 308){
                var ev1 = window.event, ev2 = obj.trans.ev;
                if(!ev1 || (ev1 && ev2 && ev1 != ev2 && ev1.target == ev2.target && ev1.type == ev2.type)){
                    obj.trans.nested = true;
                }
                else{
                  removeEv = true;
                }
                if(mp){
                    var mpObj = mp.get(obj.trans);
                    if(mpObj){
                        removeStateFromMap(mpObj.XHR, mpObj.currentAction.type, mpObj.currentAction.target);
                        mp.delete(obj.trans);
                    }
                }
            }
            else if(obj.trans.state == 200){
                mp ? mp.delete(obj.trans) : undefined;
                removeEv = true;
            }
            if(removeEv){
              obj.trans.ev ? delete obj.trans.ev : undefined;
            }
        }
    });
    
    Lyte.addEventListener("beforeRouteTransition", function(obj){
        if(obj && obj.prevTrans && obj.prevTrans.nested){
            obj.trans.ev = obj.prevTrans.ev;
            delete obj.prevTrans.ev;
            obj.trans.fromPrevTrans = true; // temp check
        }
    });
    
    function addStateToMap(event, target, XHR, stateName){
        var mp = Lyte.__nodeXHRMap = Lyte.__nodeXHRMap || new Map();
        var nodeMap = mp.get(target);
        if(!nodeMap){
            mp.set(target, new Map());
        }
        nodeMap = mp.get(target);
        var sr = target.lyteState = target.lyteState || [], type = stateName || XHR;
        if(sr.indexOf(type) == -1){
            sr.push(type);
        }
        target.setAttribute("lyte-state", "");
        var evMap = nodeMap.get(event);
        if(!evMap){
            nodeMap.set(event, []);
            evMap = nodeMap.get(event);
        }
        if(stateName){
            evMap.push({state:stateName});
            return {target: target, event: event};        
        }
        else{
            evMap.push({isXHR:true, xhr:XHR});
            var callback = function(arg){
                if(XHR.readyState == 4){
                    removeStateFromMap(XHR, event, target);
                    XHR.removeEventListener("readystatechange", callback);
                }
            }
            XHR.addEventListener("readystatechange", callback);
        }
    }
    function removeStateFromMap(type, event, target){
        var mp = Lyte.__nodeXHRMap; 
        var nodeMap = mp.get(target);
        if(!nodeMap){
            return;
        }
        var evMap = nodeMap.get(event);
        if(!evMap){
            return;
        }
        if(evMap){
            var arr = evMap;
            var ind = -1;
            arr.every(function(itm, idx){
                if((itm && itm.isXHR && itm.xhr == type)|| (typeof type == "string" && itm.state == type)){
                    ind = idx;
                    return false;
                }
                return true;
            });
            if(ind != -1){
                arr.splice(ind,1);
                var sind = target.lyteState.indexOf(type);
                target.lyteState.splice(sind, 1);
                if(!arr.length){
                    nodeMap.delete(event);
                    var tyInd = target && Array.isArray(target.lyteState) ? target.lyteState.indexOf(type) : -1; 
                    tyInd != -1 ? target.lyteState.splice(tyInd, 1) : undefined;
                    if(target && target.lyteState && target.lyteState.length == 0){
                        target.lyteState = null;
                        target.removeAttribute("lyte-state");
                    } 
                }
                if(!nodeMap.size){
                    mp.delete(target);
                }
            }
        }
    }
    
    Lyte.setState = function(str){
        if(!str){
            console.error("Please provide a state name");
        }
        var evnt = window.event;
        if(/^(click|dblclick)$/.test(evnt.type)){
            var target = evnt.target;
            if(Lyte.getConfig("stateHandling") == true &&  target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false"){
                var state = target.getAttribute("lyte-state");
                if(!state){
                    var mp = Lyte.__stateMap = Lyte.__stateMap || new Map();
                    var mpobj = mp.get(str);
                    if(!mpobj){
                        var obj = addStateToMap(evnt.type, target, undefined, str);
                        mp.set(str, obj);
                    }
                    else{
                        console.error("There is already a open state by the name",str);
                    }
                }
            }        
        }
    }
    
    Lyte.removeState = function(str){
        if(!str){
            console.error("Please provide a state name");
        }
        var mp = Lyte.__stateMap;
        if(mp){
            var obj = mp.get(str);
            if(obj){
                mp.delete(str);
                removeStateFromMap(str, obj.event, obj.target);
            }
        }
    }
    Lyte.setConfig = function(key, value, cons){
        if(key == "mutable"){
          if(value == true){
            Lyte.__gl = Lyte.mut(Lyte.__gl__);
          }
          else if(value == false){
            Lyte.__gl = Lyte.__gl__;            
          }
        }
        var configObj = Lyte.__config = Lyte.__config || {};
        if(cons){
          Object.defineProperty(configObj, key, {
            value: value
          })
        }
        else{
          configObj[key] = value;
        }
    }
    /*disable async function*/
    Lyte.getConfig = function(key){
        var configObj = Lyte.__config;
        if(configObj){
            return configObj[key];
        }
    }
    Lyte.establishWatchScope=function(watchProps,model){
      var scope = this,object;
      for (var v in watchProps){
        var property = v;
        var watch = watchProps[v]
        if(scope.component && scope.component.__data && scope.component.__data[property]){
          object = scope.getData(property);
          watch = scope.component.__data[property].watch ? true : watch;
          if(typeof object == "object"){
            Lyte.establishObjectBinding(scope.component.data,v,false,undefined,undefined,watch)
          }
          var dataDef = scope.component.__data;
          if( Lyte.nestScp[Lyte.__nestScp__.get(object)]){
            // nestScp[__nestScp__.get(object)].dtype.watch = watch;
            dataDef[v].watch = watch;        
          }
        }
        else{
          if(model){
            var fieldList = model.fieldList;
            if(fieldList[v] && fieldList[v].watch == undefined){
              fieldList[v].watch = watch ;
              model._fldGrps.watch[v] = fieldList[v];
            }
          }
        }
      }
    }

    Lyte.checkEstablishingSCP = function(value,path,watch){
      if(Array.isArray(watch)){
          var _path ='';
          _path = path.join(".")
          if(Lyte.checkWatchPath(_path,watch,true) && typeof value != "object"){
              return true
          }
          var _key = Object.keys(value);
          for(var i_scp =0 ; i_scp<_key.length ; i_scp++){
              var spiePath = _key[i_scp];
             var finalaUth =  _path == ""?spiePath : _path+"."+spiePath;
              if(Lyte.checkWatchPath(finalaUth,watch,true)){
                  return true
              }
          }
      }
    }
    Lyte.checkWatchPath=function(actualPath,watchArr,establishBind){
      if(typeof watchArr == "boolean" && watchArr === true){
          return true
      }
      else if(Array.isArray(watchArr)){
          for(var i_watch=0; i_watch < watchArr.length ; i_watch++){
              var path = watchArr[i_watch];
              path =path.replace(/ /g,"");
              path = path.replace(/\$\.\./g,"..");
              path = path.replace(/\$\./g,"")
              var weirdPath = path.search(/\.\./g) != -1 || path.search(/\[|\\]|\{|\}/g)!=-1 ? true : false || path.includes("*");
              if(actualPath == path){
                  return true;
              }
              else if (weirdPath){
                  if(establishBind){
                    if(path.search(/\.\./) != -1 ){
                      path = path.replace(/\.\.\S+/g,"..*")
                      if(path == "..*"){
                        return true;
                      }
                    } 
                  }
                  path = path.search(/\[/) == 0? path.replace("[",""):path;
                  path = path.search(/\.\.\[/)==0 ? path.replace("..[",".."):path
                  path = path.replace(/\.*\[/g,".");
                  path = path.replace(/\]/g,"");
                  var _watchPath = Lyte.checkWeirdPath(path,actualPath);
                  if(_watchPath){
                      return true
                  }
              }
          }
      }
    }
    Lyte.checkWeirdPath=function(watchPath,actualPath){
      if(actualPath == watchPath){
          return true;
      }
      else if(watchPath.includes("..") || watchPath.includes("*")) {
          var cmpPath = watchPath;
          cmpPath = cmpPath.replace(/\*/g, "$$")
          cmpPath = cmpPath.replace(/\.\./g,"::")
          // cmpPath = cmpPath.replace("[","\\[")
          cmpPath = cmpPath.replace(/\./g,"\\.")
          cmpPath=cmpPath.replace(/\:\:/g,"\\.?.*\\.?");
          cmpPath=cmpPath.replace(/\$/g,".*");
          var _wildCard = watchPath.split(".")
          var _wClenght = _wildCard.length;
          if(_wildCard[_wClenght-2] == "" && _wildCard[_wClenght-1]!="*"){
            cmpPath = cmpPath+"$";
          }
          var regularExp = new RegExp(cmpPath);
          if(regularExp.test(actualPath)){
              return true;
          }
          return false;
      }
    }

    var ignoreMut = false;
    Lyte.ignoreMut = function(method){
        ignoreMut = true;
        method();
        ignoreMut = false;
    }    
    
    /*disable async function*/
    var wkMap = new WeakMap();
    /*disable async function*/
    Lyte.mut = function mut(data){
        if(data && data.__ltPrx__){
            return data;
        }
        if(data && wkMap.has(data)){
            return wkMap.get(data);
        }
        if(!data || (data && (data.constructor.name !== "Object" && data.constructor.name !== "Record") && !Array.isArray(data) && !data.__ltPrx__)){
          return data;
      }
        let prxVal =  new Proxy(data, {
          set:function(target, prop, value){
            if(!Array.isArray(target)){
                Lyte.Component.set(target, prop, value);
            }else{
                target[prop] = value;
            }
            return true;
          },
          get:function(target, prop){
            if(prop === "__ltPrx__"){
                return true;
            }
            if(prop === "__target__"){
                return target;
            }
            var value = target[prop];
            if(value && value.__ltPrx__){
                return value;
            }
            if(value && wkMap.has(value)){
                return wkMap.get(value);
            }
            var descriptor = Object.getOwnPropertyDescriptor(target, prop);
            if(value && (value.constructor.name === "Object" || Array.isArray(value) || value && value.$ && value.$.hasOwnProperty("isModified")) && !value.__ltPrx__ && descriptor && descriptor.configurable){
                // path = path || [];
                // path.push(prop);
                // if(Array.isArray(value) && value.model && value.key){
                //     var hmPrx = value.record.$.__hmPrx = value.record.$.__hmPrx || {};
                //     var retVal;
                //     if(!hmPrx[value.key]){
                //         retVal = hmPrx[value.key] = Lyte.mut(value)
                //     }
                //     else{
                //         retVal = hmPrx[value.key]
                //     }
                //     return retVal;
                // }
                let prxVal = Lyte.mut(value);
                wkMap.set(value, prxVal);
                // Object.defineProperty(value, "__mcln__", { value: prxVal});
                return prxVal;
            }
            return value;
          }
        });
        wkMap.set(data, prxVal);
        // Object.defineProperty(data, "__mcln__", { value: prxVal});
        return prxVal;
    
    }
    /*disable async function*/
    Lyte.immut = function immut(data, mp){
        var mp = mp || new WeakMap(), nData;
        if(data && Array.isArray(data)){
            nData = Array.from(data);
        }
        else if(data && typeof data == "object"){
            nData = Object.assign({}, data);
        }
        mp.get(data, nData);
        return new Proxy(data, {
            get:function(data, prop){
                var _obj = mp.get(data), val;
                val = _obj[prop];
                if(val && typeof val == "object" && !mp.has(val)){
                    return Lyte.immut(val, mp);
                }
                return val;
            },
            set:function(data, prop, value){
                var _obj = mp.get(obj);
                // _obj[prop] = value;
                
                Lyte.Component.set(_obj, prop, value);
                return true;
            }
        })
    }
    // Lyte.mut = function mut(data){
    //     if(data && data.__ltPrx__){
    //         return data;
    //     }
    //     if(data && data.__mcln__){
    //         return data.__mcln__;
    //     }
    //     if(!data || (data && !data.constructor.name === "Object" && !Array.isArray(data)) && !value.__ltPrx__){
    //         return data;
    //     }
    //     // parent = parent || data;
    //     let prxVal =  new Proxy(data, {
    //         set:function(target, prop, value){
    //             if(!Array.isArray(target)){
    //                 Lyte.Component.set(target, prop, value);
    //             }else{
    //                 target[prop] = value;
    //             }
    //             return true;
    //         },
    //         get: function(target, prop){
    //             if(prop === "__mcln__"){
    //                 debugger
    //                 return target[prop];
    //             }
    //             if(prop === "__ltPrx__"){
    //                 return true;
    //             }
    //             if(prop === "__target__"){
    //                 return target;
    //             }
    //             var value = target[prop];
    //             if(value && value.__mcln__){
    //                 return value.__mcln__;
    //             }
    //             var descriptor = Object.getOwnPropertyDescriptor(target, prop);
    //             if((value && value.$ && value.$.hasOwnProperty("isModified") && value.$.getProxy)){
    //                 let prxVal = value.$.getProxy();
    //                 return prxVal;
    //             }
    //             else if(value && (value.constructor.name === "Object" || Array.isArray(value)) && !value.__ltPrx__ && descriptor && descriptor.configurable){
    //                 // path = path || [];
    //                 // path.push(prop);
    //                 if(Array.isArray(value) && value.model && value.key){
    //                     var hmPrx = value.record.$.__hmPrx = value.record.$.__hmPrx || {};
    //                     var retVal;
    //                     if(!hmPrx[value.key]){
    //                         retVal = hmPrx[value.key] = Lyte.mut(value)
    //                     }
    //                     else{
    //                         retVal = hmPrx[value.key]
    //                     }
    //                     return retVal;
    //                 }
    //                 let prxVal = Lyte.mut(value);
    //                 Object.defineProperty(value, "__mcln__", { value: prxVal});
    //                 return prxVal;
    //             }
    //             return value;
    //         }
    //     });
    //     Object.defineProperty(data, "__mcln__", { value: prxVal});
    //     return prxVal;
    // }
    Object.defineProperty(Lyte, "__gl__", {
      value: {}
    });
    Lyte.__gl = Lyte.__gl__;
})(_Lyte);
(function(window) {
var idleScheduler = new IdleTaskScheduler({delayInit:true, timeout:40});
window._wrapperComponents = [];
// For minification
var _Lyte = window.isLyteWidgetParent ? window._widgetLyte : window.Lyte;
var Lyte = _Lyte;
if(!window.__lyteConfig){
    window.__lyteConfig = {
        _definedBeforeBridging : [],
        _alreadyDefinedBeforeBridging : [],
        v3 : true,
        _pendingV3Components : {},
        _firstRegisteredComp : {}
    }
}
let ltCf = window.__lyteConfig;
if(!ltCf.customElementsDefine){
    ltCf.customElementsDefine = customElements.constructor.prototype.define; 
    Object.defineProperty(customElements.constructor.prototype,"define",{
        value : function(name, compClass, options, _lyteOptions){
            if(customElements.get(name)){
                ltCf._alreadyDefinedBeforeBridging.push({name : name, compClass : compClass, options :options, _lyteOptions : _lyteOptions, scope : this});
            }else{
                ltCf._definedBeforeBridging.push({name : name, compClass : compClass, options :options, _lyteOptions : _lyteOptions, scope : this});
                ltCf.customElementsDefine.apply(this,arguments);
            }
        },
        enumerable: false
    })
}
if(!ltCf.instanciateBridge){
ltCf.instanciateBridge = function(){
    if(ltCf.isWidgetBuild || (ltCf._LyteCustomElement && ltCf._customElementPrototype && ltCf._LyteYield)){
        ltCf.instanctiatedBridge = true;
        var versionBridge = {
            component : {}
        }
        ltCf.versionBridge = versionBridge;
        class V3Registry{
            static define(name,compClass,options,_lyteOptions){
                var customCrmComponent, otherComponent;
                if(!ltCf.isWidgetBuild){
                if(_lyteOptions){
                if(name == "lyte-yield"){
                    if(_lyteOptions && _lyteOptions.widget){
                        // console.log("Dummy")
                    }else{
                        customCrmComponent = ltCf._LyteYield;
                    }
                }
                else if(_lyteOptions && _lyteOptions.v4raw){
                    /*disable async function*/
                    let customElementClass = ltCf._LyteCustomElement;
                    /*disable async function*/
                    customCrmComponent = class extends customElementClass {
                        constructor(){
                            super()
                        }
                    }
                }
                else if(_lyteOptions && _lyteOptions.v3raw){
                    /*disable async function*/
                    let customElementClass = ltCf._LyteCustomElement;
                    /*disable async function*/
                    customCrmComponent = class extends customElementClass {
                        constructor(){
                            super()
                        }
                    }
                }
                else if(_lyteOptions && (_lyteOptions.v3 || _lyteOptions.v4)){
                    /*disable async function*/
                    let customElementPrototypeClass = ltCf._customElementPrototype
                    /*disable async function*/
                    customCrmComponent = class extends customElementPrototypeClass {
                        constructor(){
                            super()
                        }
                    }
                }
                else if(_lyteOptions && (_lyteOptions.widget || _lyteOptions.widgetRaw)){
                    // console.log("Dummy");
                }
                }
                else{
                    otherComponent = true;
                }
                }
                var arr = arguments;
                if(!otherComponent && _lyteOptions){
                    if(_lyteOptions.v3){
                        _LC.V3.pendingComp.firstRegister(name,"v3");
                        V3Registry.allList.v3[name] = compClass;
                        if(!ltCf.isWidgetBuild){
                            customCrmComponent._observedAttributes = compClass._observedAttributes;
                            arr = [name,customCrmComponent];
                        }
                    }
                    else if(_lyteOptions.widget){
                        _LC.V3.pendingComp.firstRegister(name,"widget");
                        V3Registry.allList.widget[name] = compClass;
                    }
                    else if(_lyteOptions.widgetRaw){
                        V3Registry.allList.widgetRaw[name] = compClass;
                        _LC.V3.pendingComp.firstRegister(name,"widgetRaw");
                    }
                    else if(_lyteOptions.v3raw){
                        V3Registry.allList.v3raw[name] = compClass;
                        _LC.V3.pendingComp.firstRegister(name,"v3raw");
                    }
                    else if(_lyteOptions.v4raw){
                        V3Registry.allList.v4raw[name] = compClass;
                        _LC.V3.pendingComp.firstRegister(name,"v4raw");
                    }
                    else if(_lyteOptions.v4){
                        V3Registry.allList.v4[name] = compClass;
                        _LC.V3.pendingComp.firstRegister(name,"v4");
                    }
                    let definedClass = customElements.get(name);
                    if(!definedClass && !V3Registry.definedHere[name]){
                        window.__lyteConfig.customElementsDefine.apply(this,arr);  
                        V3Registry.definedHere[name] = compClass;
                    }
                }else{
                    window.__lyteConfig.customElementsDefine.apply(this,arr);  
                }
            }
            static register(){
                var compArr = [ltCf._alreadyDefinedBeforeBridging , ltCf._definedBeforeBridging];
                compArr.forEach(function(itemArr){
                    if(itemArr && itemArr.length){
                        itemArr.forEach(function(obj){
                            if(obj._lyteOptions){
                                if(obj._lyteOptions.v3raw){
                                    V3Registry.allList.v3raw[obj.name] = obj.compClass;
                                    _LC.V3.pendingComp.firstRegister(obj.name,"v3raw");
                                }
                                else if(obj._lyteOptions && obj._lyteOptions.v4raw){
                                    V3Registry.allList.v4raw[obj.name] = obj.compClass;
                                    _LC.V3.pendingComp.firstRegister(obj.name,"v4raw");
                                }
                                else if(obj._lyteOptions && obj._lyteOptions.v3){
                                    V3Registry.allList.v3[obj.name] = obj.compClass;
                                    _LC.V3.pendingComp.firstRegister(obj.name,"v3");
                                }
                                else if(obj._lyteOptions && obj._lyteOptions.v4){
                                    V3Registry.allList.v4[obj.name] = obj.compClass;
                                    _LC.V3.pendingComp.firstRegister(obj.name,"v4");
                                }
                                else if(obj._lyteOptions && obj._lyteOptions.widget){
                                    V3Registry.allList.widget[obj.name] = obj.compClass;
                                    _LC.V3.pendingComp.firstRegister(obj.name,"widget");
                                }
                                else if(obj._lyteOptions && obj._lyteOptions.widgetRaw){
                                    V3Registry.allList.widgetRaw[obj.name] = obj.compClass;
                                    _LC.V3.pendingComp.firstRegister(obj.name,"widgetRaw");
                                }
                            }
                        })
                    }
                });
                if(!ltCf.versionBridge && !ltCf.customElementsDefine){
                    ltCf.customElementsDefine = customElements.constructor.prototype.define; 
                }
                Object.defineProperty(customElements.constructor.prototype,"define",{//no i18n
                    value : function(name, compClass, options, _lyteOptions){
                        V3Registry.define.apply(this,[name, compClass, options, _lyteOptions]);
                    },
                    enumerable: false
                })
            }
        }
        ltCf.versionBridge.component.V3Registry = V3Registry;
        V3Registry.allList = {v3 : {},v4 : {},other : {},v3raw : {},v4raw : {}, widget : {}, widgetRaw : {}};
        V3Registry.definedHere = {};
        V3Registry.register();
    }
}
}
//security
_Lyte.Security = {
    "_ourSanitizerInstance_" :{},
    "_userSanitizerInstance_":{}, 
    "_eM" : {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;',
        '=': '&#x3D;'
      }, 
    "_eR" : /[&<>"'`=]/g,
    "_eF" : function(str) {
        return this._eM[str];
    }, 
    "escape" : function(string) {
        if (typeof string !== 'string') {
            string = '' + string;
        }
        return string.replace(this._eR, this._eF.bind(this));
    }
};
if(!window.isLyteWidget) {
var sec = { "GLOBAL_TAGS": [], "GLOBAL_ATTRIBUTES": [],"FORBID_TAGS":[],"FORBID_ATTR":[] , REUSE_CONFIG : true};
_Lyte.Security._ourSanitizerInstance_ = ZWAF['7_0_0'].HTMLPurifier(sec);
_Lyte.Security._ourSanitizerInstance_._GLOBAL_TAGS = sec.GLOBAL_TAGS;
_Lyte.Security._ourSanitizerInstance_._GLOBAL_ATTRIBUTES = sec.GLOBAL_ATTRIBUTES;
sec.GLOBAL_ATTRIBUTES.push("is","yield-name","lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target","lt-prop-td","lt-prop-custom","lt-prop-target","lt-prop-id","lt-prop-class","lt-prop-style","lt-prop-rel","lt-prop-title");
sec.GLOBAL_TAGS.push("link-to");
_Lyte.Security._ourSanitizerInstance_._FORBID_TAGS = sec.FORBID_TAGS;
_Lyte.Security._ourSanitizerInstance_._FORBID_ATTR = sec.FORBID_ATTR;
_Lyte.Security.createSanitizer = function (obb) {
    if(obb && obb.__target__){
        obb = obb.__target__;
    }
  if (!obb.GLOBAL_ATTRIBUTES) {
		obb.GLOBAL_ATTRIBUTES = [];
	}
	if (!obb.FORBID_TAGS) {
		obb.FORBID_TAGS = [];
	}
	if (!obb.FORBID_ATTR) {
		obb.FORBID_ATTR = [];
	}
	if (!obb.GLOBAL_TAGS) {
		obb.GLOBAL_TAGS = [];
  }
  obb.REUSE_CONFIG = true;
  obb.GLOBAL_ATTRIBUTES.push("is","yield-name","lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target","lt-prop-td","lt-prop-custom","lt-prop-target","lt-prop-id","lt-prop-class","lt-prop-style","lt-prop-rel","lt-prop-title");
  obb.GLOBAL_TAGS.push("link-to");
    var globalTagArr = Array.from(obb.GLOBAL_TAGS);
    var attr = [];
    for(var a=0; a<globalTagArr.length; a++){
      if(_LC._registeredComponents[globalTagArr[a]]){
        attr = _LC._registeredComponents[globalTagArr[a]].observedAttributes;
      }else if(Lyte.registeredCustomComponent[globalTagArr[a]]){
        attr = Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes;
      }
        if(attr) {
            for(var i=0; i<attr.length; i++){
                if(obb.GLOBAL_ATTRIBUTES.indexOf(attr[i]) == -1){
                obb.GLOBAL_ATTRIBUTES.push(attr[i]);
                }
            }
        }
    }
	_Lyte.Security._userSanitizerInstance_ = ZWAF['7_0_0'].HTMLPurifier(obb);
	_Lyte.Security._userSanitizerInstance_._GLOBAL_TAGS = obb.GLOBAL_TAGS;
	_Lyte.Security._userSanitizerInstance_._GLOBAL_ATTRIBUTES = obb.GLOBAL_ATTRIBUTES;
	_Lyte.Security._userSanitizerInstance_._FORBID_TAGS = obb.FORBID_TAGS;
	_Lyte.Security._userSanitizerInstance_._FORBID_ATTR = obb.FORBID_ATTR;
	return _Lyte.Security._userSanitizerInstance_;
};
}
//var toArrayLyte = "toArrayLyte";
//var bindStr = "_bindings";
//var compStr = "component";
//var forHelperStr = "_forHelpers";
//var dynamicNodesStr = "_dynamicNodes";
//var calleeStr = "_callee";
//var getAttributeStr = "getAttribute";
//var hasAttributeStr = "hasAttribute";
//var removeAttributeStr ="removeAttribute";
//var setAttributeStr = "setAttribute";
//var parentNodeStr = "parentNode";
//var nodeNameStr = "nodeName";
//var ownerElementStr = "ownerElement";
var globalDOMEvents = ["focus","focusin","focusout","resize","scroll","click","dblclick","mousedown","mouseup","mousemove","mouseover","mouseout","change","select","submit","keydown","keypress","keyup","contextmenu"];
var registerHelperStr = "registerHelper";
var delStr = "delete";

/*disable async function*/
window.defProp = function defProp() {
	Object.defineProperty.apply(Object, arguments);
}

/*disable async function*/
function makeSet(obj, key) {
	if(!obj[key]) {
		defProp(obj, key, {
			value : new Set(),
			enumerable : false,
			writable : true,
			configurable : true
		})
	}
}
function makeVal(obj, key, val) {
	if(!obj[key]) {
		defProp(obj, key, {
			value : val,
			enumerable : false,
			writable : true,
			configurable : true
		})
	}
}
function addBindings(obj, property) {
    if(property){
        let bindings = obj._bindings;
        if(!bindings){
            makeSet(obj, "_bindings");
            bindings = obj._bindings;    
        }
        bindings.add(property);
    }
}
/*disable async function*/
function makeArray(obj, key) {
	if(!obj[key]) {
		defProp(obj, key, {
			value : [],
			enumerable : false,
			writable : true,
			configurable : true
		})
	}
}

function createDocFragment() {
	return document.createDocumentFragment();
}

function createElement(elm) {
	return document.createElement(elm);
}

function insertBefore(parent, newNode, refNode) {
	parent.insertBefore(newNode, refNode);
}

function deleteBindingCheckSize(obj, key, valToDelete) {
	obj[key][delStr](valToDelete);
	if(!obj[key].size) {
		delete obj[key];
	}
}
_Lyte.registerErrorCodes({
    "LC001" : "Error while parsing custom prop handler attribute {0}. Check if the value provided is a valid JSON",
    "LC002" : "{0} Component is not compiled. Please compile using Lyte CLI",
    "LC003" : "Helper named {0} is not defined",
    "LC004" : "Action named {0} doesn't exists",
    "LC005" : "Lyte.objectUtils doesn't support {0} function", 
    "LC006" : "Lyte.arrayUtils doesn't support {0} function", 
    "LC007" : "Component name not specified in Lyte.Component.render", 
    "LC008" : "Specified outlet {0} doesn't exists - Lyte.Component.render", 
    "LC009" : "Method named {0} doesn't exists in {1} component",
    "LC010" : "Parent Node / reference Node not provided for insertBefore method",
    "LC011" : "Error in promise provided in initialize function of data '{0}' of {1} component"
});

/*	IE Browser
	_Lyte._ie 
	Edge Browser
	_Lyte._ed 
	Replace with needed;
	_Lyte._rwpf 
	IE / Edge Browser
	_Lyte._ms
*/

let userAgent = navigator.userAgent;
//temporary fix for IE 11
if(userAgent.match(/rv:11/)) {
	_Lyte._ie = true;
    window.action = function() {
        return;
    }
}
if(userAgent.match('Edge')) {
    var s = createElement("div");
    s.innerHTML= "<template><div>c</div></template>";
    if(s.querySelector("template").childNodes.length) {
        _Lyte._ie = true;
    } else {
        _Lyte._ed = true;    
    }
    s.remove()
}


class Test extends HTMLElement {
    constructor() {
        super();
        if(!this.attributes.t) {
            _LC.frSpecial = true;
        }
    }
}

if(_Lyte._ie || _Lyte._ed) {
	var doc = createDocFragment();
	doc.appendChild(document.createTextNode("  dummy "));
	doc.childNodes[0].replaceWith(document.createTextNode("changed"));
	if(doc.childNodes[0].textContent !== "changed") {
		_Lyte._rwpf = true;
	}
	_Lyte._ms = true;
}

_Lyte.Component = {};
Lyte.Compile = {};
var _LyteComponent = _Lyte.Component;
_Lyte.Component.lazyRegisterScheduler = idleScheduler;
_Lyte.Component.priorityRegistrationQ = idleScheduler.priorityQueue;

_Lyte.arrayUtils =  function() {
	//arrayFunctions
    return _LC.aF.apply(_LC, arguments);
};
_Lyte.objectUtils =  function() {
	//objectFunctions
    return _LC.oF.apply(_LC, arguments);
}
Object.defineProperty(_LyteComponent,"register",{
    get : function(){
        Lyte._preRegister();
        return _LC.registerComponentWrapper;
    }, 
    "enumerable" : true
})
_LyteComponent.nonFalsyAttrs = {
    add : function(value){
        if(Array.isArray(value)){
            value.forEach(function(item){
                _LC.booleanAttrList.push(item)
            })
        }else{
            _LC.booleanAttrList.push(value)
        }
    },
    _remove : function(item){
        let ind = _LC.booleanAttrList.indexOf(item);
        if(ind !== -1){
            _LC.booleanAttrList.splice(ind,1);
        }
    },
    remove : function(value){
        if(Array.isArray(value)){
            value.forEach(function(item){
                _LyteComponent.nonFalsyAttrs._remove(item);
            })
        }else{
            _LyteComponent.nonFalsyAttrs._remove(item);
        }
    }
}

_LyteComponent.getComponentClass = function(compName){
    return _LC._registeredComponents[compName];
}
_LyteComponent.registerHelper = function() {
    _LC.registerHelper.apply(_LC, arguments);
}
_LyteComponent.set = function() {
    _LC.set.apply(_LC, arguments);
}
_LyteComponent.registeredHelpers = {};
_LyteComponent.registeredComponents = {};
function noop() {

}
_LyteComponent.customPropHandlersList = {};
_LyteComponent.registerCustomPropHandler = function(propName) {
    let dasherized = _LC.String.dasherize(propName);
    propName = _LC.String.toCamelCase(propName);
    if(_LC.customPropHandlers.indexOf(propName) === -1) {
        _LC.customPropHandlers.push(propName);
        let customPropHanlderFn = customElementPrototype.prototype[propName] = function() {
            let argsLength = arguments.length;
            let arg0 = arguments[0];
            let options = arguments[2];
            let compData = LyteComponent.getCmpData(this.component.data);
            if(!arg0) {
                //Read all the values
                let obj = {};
                for(let key in compData) {
                    if(key.startsWith(propName)) {
                        let objKey = key.substring(propName.length);
                        objKey = _LC.String.lowerCaseFirstLetter(objKey);
                        obj[objKey] = compData[key];
                    }
                }
                return obj;
                
            } else if(typeof arg0 === "string") {
                if(argsLength > 1) {
                    //Set a value
                    this.set(propName+ _LC.String.upperCaseFirstLetter(arg0), arguments[1] ,options);
                } else {
                    //Read a value
                    let actKey = propName + _LC.String.upperCaseFirstLetter(arg0);
                    return compData[actKey];
                }
            } else if(typeof arg0 === "object") {
                //Write a set of values
                for(let key in arg0) {
                    let objKey = propName + _LC.String.upperCaseFirstLetter(key);
                    this.set(objKey, arg0[key], arguments[1]);
                }
            }
        }
        _LyteComponent.customPropHandlersList[propName] = customPropHanlderFn;
        _LC.customPropRegex = new RegExp("^(" + _LC.customPropHandlers.join("|")+ ")");
    }
}
_LyteComponent.unregisterComponent = function(componentName, configObj) {
    configObj = configObj || {};
    if(_LyteComponent.registeredComponents[componentName]) {
        var comp = _LC._registeredComponents[componentName];
        if(comp.activeInstances > 0) {
            _Lyte.warn("There are active instances of the component " + componentName + " and hence cannot be unregistered");
        } else if(comp.component.activeInstances > 0) {
            _Lyte.warn("There are active instances of the component " + componentName + " and hence cannot be unregistered");
        } else {
            //Do the unregisteration here
            comp._properties = comp.component._properties = {};
            comp._mixins = comp._actions = comp._template = comp._dynamicNodes = null;            
            comp._callBacks = comp.component._callBacks = {};
            comp._observers = comp.component._observers = [];
            comp._data = comp.component_data = undefined;
            comp._methods = comp.component._methods = {};
            comp.prototype.get = noop;
            comp.prototype.set = noop;
            // delete comp.prototype.setData;
            // delete comp.prototype.getData;
            Object.defineProperty(comp.prototype, "setData", {
                configurable : true, 
                writable : true, 
                value : function(arg0, arg1) {
                    this._initProperties = this._initProperties || {};
                    if(typeof arg0 === "string") {
                        this._initProperties[arg0] = arg1
                    } else if(typeof arg0 === "object") {
                        for(let key in arg0) {
                            this._initProperties[key] = arg0[key];
                        }
                    }
                }
            });

            Object.defineProperty(comp.prototype, "setMethods", {
                configurable : true, 
                writable : true, 
                value : function(arg0, arg1) {
                    this._initMethods = this._initMethods || {};
                    if(typeof arg0 === "string") {
                        this._initMethods[arg0] = arg1
                    } else if(typeof arg0 === "object") {
                        for(let key in arg0) {
                            this._initMethods[key] = arg0[key];
                        }
                    }
                }
            });

            delete _LyteComponent.registeredComponents[componentName];
            var template = document.querySelector("template[tag-name="+componentName+ "]")
            if(template) {
                template.remove();
            }
            // lyteht -> lyteHelperTemplates
            var helperTemplate = comp._helperTemplate;
            if(helperTemplate) {
                helperTemplate.remove();
            }
            // if(comp._depthTemp) {
            //     comp._depthTemp.remove();    
            // }
            if(comp.component._depthTemp) {
                comp.component._depthTemp.remove();    
            }
        }
    } else {
        _Lyte.warn("Component "+ componentName + " not yet registered");
    }
}
_Lyte.createCustomElement = function (customElementName, definition) {
    var constructor = definition.constructor;
    delete definition.constructor;
    var connectedCallback = definition.connectedCallback;
    delete definition.connectedCallback;
    var attributeChangedCallback = definition.attributeChangedCallback;
    delete definition.attributeChangedCallback;
    var disconnectedCallback = definition.disconnectedCallback;
    delete definition.disconnectedCallback;
  
    this.defProperty = function(obj, key, val) {
      var obj1 = {};
      if(val.get) {
        /*disable async function*/
        obj1.get = val.get
      }
      if(val.set) {
        /*disable async function*/
        obj1.set = val.set
      }
      Object.defineProperty(obj, key, obj1, true);
    }

    class classDef extends HTMLElement {
        constructor() {
            super();
            if(window.ignoreParent) {
                this.__lyteIgnore = true;
                // window.ignoreParent = false;
                return;
            }
            this.decideConstructor();
        }
        decideConstructor(){
            if(ltCf && (ltCf.v4 || ltCf.isWidgetBuild)){
                // check wether v3 or v4
                // V3Registry // ?how
                let V3Registry = ltCf.versionBridge.component.V3Registry;
                let foundInV4List = V3Registry.allList.v4raw[this.localName]
                let foundInV3List = V3Registry.allList.v3raw[this.localName]
                let foundInWidgetList = V3Registry.allList.widgetRaw[this.localName]

                if(foundInV4List){ // found same name in v4
                if(!foundInV3List || ((this._callee && this._callee.__v4) || this.hasAttribute("lyte-v4") || this.hasAttribute("lyte-registry") || ltCf.lyteV4 || ltCf.fromV4Render)){
                    //v4
                    let v4compClass = foundInV4List;
                    let self = this;
                    classDef._V4InsApi.forEach(function(apiName){
                        self[apiName] = v4compClass.prototype[apiName];
                    })
                }
                }else if(foundInWidgetList){
                if((this._callee && this._callee.__widget) || this.hasAttribute("lyte-widget") || window.__lyteConfig.isWidgetComponent || ltCf.lyteWidget || ltCf.fromWidgetRender){
                    //v4
                    let widgetCompClass = foundInWidgetList;
                    let self = this;
                    if(ltCf._firstRegisteredComp[this.localName] != "widgetRaw"){
                    classDef._V3InsApi.forEach(function(apiName){
                        self[apiName] = widgetCompClass.prototype[apiName];
                    })
                    }
                }else if(foundInV3List){
                    let v3CompClass = foundInV3List;
                    if(ltCf._firstRegisteredComp[this.localName] != "v3raw"){
                        classDef._V3InsApi.forEach(function(apiName){
                            self[apiName] = v3CompClass.prototype[apiName];
                        })
                    }
                }else{
                    // not found in foundInV3List
                    _LC.V3.pendingComp.add(this);
                    this.__v3lyteIgnore = true;
                    return;
                }
                }
            }
            //v3
            this.actualConstructor();
        }  
      actualConstructor() {
        if(this.isNewComp(customElementName)){
          this.executeCallbacks(constructor,arguments);
        }else{
          this.__lyteIgnore = true;
        }
      }
      connectedCallback() {
            this._connectedCallback();
      }
      _connectedCallback(){
        if(this.__lyteIgnore || this.hasAttribute("lyte-rendered-ce")) {
          return;
        }
        this.executeCallbacks(connectedCallback,arguments);
        this.setAttribute("lyte-rendered-ce", "");
        this._connectedCalled = true;
      }
      attributeChangedCallback(attr, oldValue, newValue) {
        this._attributeChangedCallback(attr, oldValue, newValue);
        }
      _attributeChangedCallback(){
        if(!this.__lyteIgnore || this.__v3lyteIgnore) {
          this.executeCallbacks(attributeChangedCallback,arguments);
        }
      }
      disconnectedCallback() {
        this._disconnectedCallback();
        }
      _disconnectedCallback(){
        if(this.__v3lyteIgnore){
            _LC.V3.pendingComp.remove(this);
            return;
        }
        if(!_LyteComponent.shouldIgnoreDisconnect() && !this.__lyteIgnore) {
          this.executeCallbacks(disconnectedCallback,arguments);
          this._parentHelper = null;
        }
      }
      executeCallbacks(callBack,argArr){
        if(callBack) {
          callBack.apply(this, Array.from(argArr));
        }
      }
      isNewComp(customElementName){
        if(this.hasAttribute("lyte-rendered-ce")) {
          return false;
        }
        return true;
      }
    }
    classDef._V4InsApi = ["_connectedCallback", "_attributeChangedCallback" ,"_disconnectedCallback","actualConstructor","executeLyteCallbacks","isClonedNode","_isClonedAttribute","isClonedAttribute"];
    classDef._V3InsApi = ["_connectedCallback", "_attributeChangedCallback" ,"_disconnectedCallback","actualConstructor","executeCallbacks","isNewComp"];
    var staticDef = definition.static;
    definition._static = staticDef;
    if(staticDef) {
      for(var key in staticDef) {
        if(typeof staticDef[key] === "object") {
          this.defProperty(classDef, key, staticDef[key]);
        } else {
          Object.defineProperty(classDef, key, {
            value : staticDef[key]
          });
        }
      }
      delete definition.static;
    }
    classDef._definition = definition;
    for(var key in definition) {
      if(typeof definition[key] === "object") {
        this.defProperty(classDef.prototype, key, definition[key]);
      } else {
        Object.defineProperty(classDef.prototype, key, { writable: true, value : definition[key]});
      }
    }
    definition.static = staticDef;
    definition.constructor = constructor;
    definition.connectedCallback = connectedCallback;
    definition.attributeChangedCallback = attributeChangedCallback;
    definition.disconnectedCallback = disconnectedCallback;
    if (document.readyState === "complete" || document.readyState === "interactive") {     
      // document is already ready to go
      customElements.define(customElementName,classDef, undefined, _Lyte.isWidgetBuild ? { "widgetRaw" : true} : {v3raw : true});
    }
    else{
        LyteComponent.toBeRegistered.push({name:customElementName, def: classDef, _lyteOptions : _Lyte.isWidgetBuild ? { "widgetRaw" : true} : {v3raw : true} });
    }
    Lyte.registeredCustomComponent[customElementName] = classDef;
}
var elementPrototype = typeof HTMLElement !== "undefined" ? HTMLElement : Element;

_Lyte.appendTemplateDiv = function() {
    document.body.appendChild(_LC.tDiv);
    document.body.appendChild(_LC.h1Div);
    _LCHD.appendTemp();
}

document._addShadowForGlobalRegistry = function(shadow) {
    for(let i=0; i<globalDOMEvents.length; i++){    
        var evnt = globalDOMEvents[i];    
        shadow.addEventListener(evnt,globalEventHandler, true);    
    }
    for(var j=0;j<windowEventListeners.length;j++) {
        shadow.addEventListener.apply(shadow, windowEventListeners[j]);
    }
    shadow.addEventListener("change", changeEventHandler );
}

function onDomContentForLyte() {
    if(Lyte.$.assetsDiv) {
        Lyte.$.assetsDiv.addEventListener("click", function() {
            if(!window.event) {
                _LC._windowEvNeeded = true;
            }
        });
        Lyte.$.assetsDiv.dispatchEvent(new Event("click"));
    }
    
    // document.head.appendChild(Lyte.$.assetsDiv);
    if(!_Lyte._ie){
    	document.body.appendChild(_LC.lyteComponentsDiv);
        //document.body.appendChild(_LC.tDiv);
    }
    document.body.appendChild(_LC.hDiv);
    let bodyEvents = globalDOMEvents;    
    for(let i=0; i<bodyEvents.length; i++){    
        var evnt = bodyEvents[i];    
        document.body.addEventListener(evnt,globalEventHandler, true);    
    }    
    
    let comp = _LC.toBeRegistered;    
    if(comp.length){    
        for(let j=0; j<comp.length;j++){
            customElements.define(comp[j].name, comp[j].def, undefined, comp[j]._lyteOptions);    
        }    
        _LC.toBeRegistered = [];    
    }
    if(/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
        var style = createElement("style");
        style.innerHTML = "* { cursor : pointer}";
        document.head.appendChild(style);
    }
    if(Lyte.isWidgetBuild){
        let wrapper = Lyte.$.widgetWrapper;
		document.body.appendChild(wrapper);
        if(window.docEventListenerHandler) {
            window.docEventListenerHandler.attachShadow(wrapper.shadowRoot);
        }
        LyteComponent.shadow.shadowList.push(wrapper.shadowRoot);
        wrapper.shadowRoot._shadowChild = [];
        wrapper.shadowRoot._lyteShadow = true;
        wrapper.shadowRoot._compList = [];
        // wrapper.shadowRoot._id = id;
        wrapper.shadowRoot._duplicateStyle = [];
        wrapper.shadowRoot._linkRef = [];
        
        wrapper.instantiated = true;
        LyteComponent.shadow.attachEvents(wrapper.shadowRoot);
		// let appChild = document.body.appendChild;
		// let rmChild = document.body.removeChild;
		// document.body.appendChild = function(ele){
		// 	return _widgetLyte.$.widgetWrapper.shadowRoot.appendChild.apply(_widgetLyte.$.widgetWrapper.shadowRoot,arguments) ;
		// }
		// document.body.removeChild = function(ele){
		// 	return _widgetLyte.$.widgetWrapper.shadowRoot.removeChild.apply(_widgetLyte.$.widgetWrapper.shadowRoot,arguments) ;
		// }
    }
}

var changeEventHandler = function(event1) {
	var target = event1.target || event1.srcElement;
	if(!target._attributeDetails) {
		return;
	}
	var attributeName = "value";
	if(target.type === "checkbox" || target.type=== "radio") {
		attributeName = "checked";
	}
	let contextSwitchArray = [];
	var attrNode ;
	var attrDetail = target._attributeDetails[attributeName];
    let saveAttr = _LCSV.getAttr(target._specialAttributeDetails);
	if(!attrDetail || !attrDetail.isLbind && !saveAttr) {
		return;
	}
	//attrNode = (attributeName === "checked") ? target._attributeDetails[attributeName].bindedNode : target.getAttributeNode(attributeName);
	var callee = target;
	if(!target._callee){
		while(callee && !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
			if(callee.tagName === "BODY") {
				callee = null;
				break;
			}
			callee = callee.parentNode;
		}
		if(callee && callee.tagName === "LYTE-YIELD"){
			target._callee = callee._registerYield._callee;
		} else {
			target._callee = callee;
		}
	}
	let self = target._callee;
    if(saveAttr){
        _LCSV.triggerAllListeners(self, saveAttr.hookName, target, true);
        // return;
    }
	if(target) {
		_LC.adCx(target, contextSwitchArray);
	}
    if(attrDetail){
        let obj = _LC.getNew(self.component.data, attrDetail.dynamicValue);
        if(!obj.context){
            return;
        }
        let lastKeyIndex = +obj.lastKey;
        if(Array.isArray(obj.context) && typeof lastKeyIndex == "number") {
            let callReplaceAt = lastKeyIndex < obj.context.length;
            if(obj.context[lastKeyIndex] !== target[attributeName] || !callReplaceAt){
                _LC.aF(obj.context, callReplaceAt ? "replaceAt" : "insertAt", lastKeyIndex, target[attributeName]);
            }
        } else {
            _LC.set(obj.context, obj.lastKey, target[attributeName]);
        }
    }
	// _LC.set(obj.context, obj.lastKey, target[attributeName]);
	if(target) {
		_LC.rmCx(target, contextSwitchArray);
	}		
};
document.addEventListener("change", changeEventHandler );
var docCaptureGlobalEventHandler = function(ev){
	var evnt = ev.type;
    if(window.docEventListenerHandler && window.docEventListenerHandler.docEventlisteners && ev.composedPath()[0].getRootNode().host){
        let listenerArr = window.docEventListenerHandler.docEventlisteners.capture[evnt];
        if(listenerArr){
            let listenerArrCpy = Array.from(listenerArr);
            listenerArrCpy.forEach(function(listener){
                if(listenerArr.indexOf(listener) != -1){
                    listener(ev);
                }
            })
        }
        
    }
}
var docBubbleGlobalEventHandler = function(ev){
	var evnt = ev.type;
    if(window.docEventListenerHandler && window.docEventListenerHandler.docEventlisteners && ev.composedPath()[0].getRootNode().host){
        let listenerArr = window.docEventListenerHandler.docEventlisteners.bubble[evnt];
        if(listenerArr){
            let listenerArrCpy = Array.from(listenerArr);
            listenerArrCpy.forEach(function(listener){
                if(listenerArr.indexOf(listener) != -1){
                    listener(ev);
                }
            })
        }
        
    }
}
var globalEventHandler = function(ev){
    var target = ev.target;
	var evnt = ev.type;
    var toRemove;
    if(/^(click|dblclick)$/.test(evnt) && target.getAttribute && (target.getAttribute("lyte-state") != null && !_Lyte.isWidgetBuild)){
        ev.preventDefault();
		return;
	}
    if(ev.currentTarget && (ev.currentTarget !== document.body) && !(ev.currentTarget instanceof DocumentFragment)) {
        target = ev.currentTarget;
    }
	if(_LC._windowEvNeeded){
		toRemove = true;
		window.event = ev;
	}
    let eventStopped = false;
	while(target && target.getAttribute && (!target.getAttribute(evnt) || (!['mouseenter', 'mousemove', 'mouseover', 'mouseout', 'mouseleave'].includes(ev.type) && target.hasAttribute("disabled") && evnt != "blur")) && target.tagName != "BODY"){
        if(target._hiddenBoundEvents && target._hiddenBoundEvents[evnt]){
            break;
        }
		if(_LC.hasLyteEvents(target, evnt)) {
            eventStopped = _LC.handleLyteEvents(target, ev);
            if(eventStopped) {
                break;
            }
        }
        target = target.parentNode;
	}
    if(eventStopped || !target) {
        if(ev._handledResolve) {
            ev._handledResolve();
        }
        return;
    }
 	var callee = target;
     if((target._callee && target._callee.component && target._callee.component.constructor._v4) || (target.component && target.component.constructor && target.component.constructor._v4)){
        return;
    }
	if(!target._callee){
		while(callee && !_LC.isCustomElementV3(callee) && callee.tagName !== "LYTE-YIELD") {
			if(callee.tagName === "BODY") {
				callee = null;
				break;
			}
			callee = callee.parentNode;
		}
		if(callee && callee.tagName === "LYTE-YIELD"){
			target._callee = callee._registerYield._callee;
		} else {
			target._callee = callee === target ? undefined : callee;
		}
	}
	if(target._evBoundEvents && target._evBoundEvents[evnt]) {
        //Not needed - but check and remove
		// let actions = target._callee? target._callee.constructor._actions : target.constructor._actions ;
        //let actions = target.constructor._actions;
		let actObj = target._evBoundEvents[evnt];
        let cloneActObj = _Lyte.deepCopyObject(actObj);
        _LC.skipArgProcessing(cloneActObj, ev, target);
		_LC.throwAction.call(target,target,evnt,cloneActObj, undefined, undefined, target, ev, undefined, true);
	} else if(target.getAttribute && target.getAttribute(evnt) && target._boundEvents && target._boundEvents[evnt]){
		// let actions = target._callee.constructor._actions;
        let func = target.getAttribute(evnt).split(" => ")[1];
        let actObj = target._boundEvents[evnt];
		let cloneActObj = _Lyte.deepCopyObject(actObj);
		_LC.skipArgProcessing(cloneActObj, ev, target);
		_LC.throwAction.call(target._callee,target._callee,evnt,cloneActObj, undefined, undefined, target, ev);
	}
    _LCHD.triggerGlobalEvent(target,evnt,ev);
	if(target.tagName === "LABEL"){
		var input = target.querySelector("input");
		if(input && input.getAttribute(evnt)){
			// let actions = target._callee.constructor._actions;
			let func = input.getAttribute(evnt).split(" => ")[1];
			//	let actObj = target._callee.constructor.getHelper(func);
            let actObj = target._boundEvents[evnt];
            let cloneActObj = _Lyte.deepCopyObject(actObj);
			_LC.skipArgProcessing(cloneActObj, ev, target);
			_LC.throwAction.call(target._callee,target._callee,evnt,cloneActObj, undefined, undefined, input,ev);
		}
	}
	if(toRemove){
		window.event = undefined;
	}
    if(ev._handledResolve) {
        ev._handledResolve();
    }
    // if(postProcess && postProcess.length){
    //     postProcess.forEach(function(listener){
    //         listener(ev);
    //     })
    // }
}

class LyteYield extends HTMLElement{
    constructor() {
        super();
        this.decideConstructor();
    }
    decideConstructor(){
        // if(window.__lyteConfig && window.__lyteConfig.v4){
        if(ltCf && (ltCf.v4 || window.__lyteConfig.isWidgetBuild)){
            let V3Registry = ltCf.versionBridge.component.V3Registry;

            let foundInV4List = V3Registry.allList.v4[this.localName]
            let foundInV3List = V3Registry.allList.v3[this.localName]
            let foundInWidgetList = V3Registry.allList.widget[this.localName]
            
            if(foundInV4List){ // found same name in v4
                if(!foundInV3List || ((this._callee && this._callee.__v4) || this.hasAttribute("lyte-v4") || this.hasAttribute("lyte-registry") || ltCf.lyteV4 || ltCf.fromV4Render)){
                    //v4
                    let v4CompClass = foundInV4List;
                    let self = this;
                    LyteYield._V4InsApi.forEach(function(apiName){
                        self[apiName] = v4CompClass.prototype[apiName];
                    })
                }
            }else if(foundInWidgetList){
                if((this._callee && this._callee.__widget) || this.hasAttribute("lyte-widget")|| window.__lyteConfig.isWidgetComponent || ltCf.lyteWidget || ltCf.fromWidgetRender){
                    //v4
                    let widgetCompClass = foundInWidgetList;
                    let self = this;
                    if(ltCf._firstRegisteredComp[this.localName] != "widget"){
                        LyteYield._V3InsApi.forEach(function(apiName){
                            self[apiName] = widgetCompClass.prototype[apiName];
                        })
                    }
                }else if(foundInV3List){
                    let v3CompClass = foundInV3List;
                    if(ltCf._firstRegisteredComp[this.localName] != "v3"){
                        LyteYield._V3InsApi.forEach(function(apiName){
                            self[apiName] = v3CompClass.prototype[apiName];
                        })
                    }
                }else{
                    // not found in foundInV3List
                    _LC.V3.pendingComp.add(this);
                    this.__v3lyteIgnore = true;
                    return;
                }
            }
        }
        //v4
    }
    connectedCallback(){
        this._connectedCallback();
    }    
    _connectedCallback() {
        this._callee = this._callee || _LC.getCallee(this.parentNode, this);
        _LCHD.yield.connect(this);
        if(!this._registerYield && this._callee) {
            var yieldName;
            if(this._callee._fR && this._callee._fR._yieldCallee) {
                this._registerYield = {"_callee" : this._callee._fR._yieldCallee.component.$node};
            } else if(this._callee._yields &&  (yieldName=this.attributes["yield-name"]) && (yieldName = yieldName.nodeValue) && this._callee._yields[yieldName]) {
                this._registerYield = {"_callee" : this._callee._yields[yieldName]._callee};
            }
        }
    }
    disconnectedCallback(){
        this._disconnectedCallback();
    }
	_disconnectedCallback(){
        if(this.__v3lyteIgnore){
            _LC.V3.pendingComp.remove(this);
            return;
        }
		if(_LyteComponent.shouldIgnoreDisconnect() || this._deleted || this._ignoreDisconnect) {
		    return;
        }
        _LCHD.yield.disConnect(this);
        this._deleted = true;
        if(!this._properties) {
            return;
        }
		var nodeContextSwitchArray = [];
        let cmpData = LyteComponent.getCmpData(this.component.data);
		_LC.adCx(this, nodeContextSwitchArray);
		_LC.removeSelectedBindingDeep(this._properties, cmpData, true);
		let node = this._registerYield;
		if(!node) {
            _LC.rmCx(this, nodeContextSwitchArray);
        return;
		}
		var toAppendContextSwitchArray = [];
        this._parentHelper = null;
		//newContext not needed
        var del = "delete";//for ie 11.0
		_LC.adCx(node, toAppendContextSwitchArray);
		for(let key in this._dynamicProperty) {
			if(this._dynamicProperty[key].isActualNode) {
				this._dynamicProperty[key].isActualNode._helperNodes[del](this);
			}else {
                let helperNodes = node._callee.getProperty(key)._helperNodes;
				if(helperNodes) {
					helperNodes[del](this);
				}
			}
		}
        this._dynamicProperty = {};
		for(let i=0;i<this._helpers.length;i++) {
			node._callee.removeHelpers(this._helpers[i]);
		}
		this._helpers = [];
		_LC.rmCx(node, toAppendContextSwitchArray);
		_LC.rmCx(this, nodeContextSwitchArray);
        // var self = this;
        // setTimeout(function() {
        //     self._registerYield = null
        //     self._callee = null;
        // },0);
	}
	getProperty(key) {
            var arr = key.match(/([^[\].]+|\[\])/g);
        	let property = this;
        	if(!property._properties[arr[0]]) {
            		property._properties[arr[0]] = {};
       	 	} 
       	 	property = property._properties[arr[0]];
        
        	defProp(property, '_path', {enumerable: false, value : arr[0]});
        	for(let i=1;i<arr.length;i++) {
                if (arr[i].startsWith("'") || arr[i].startsWith('"')) {//added check
                    arr[i] = arr[i].substring(1, arr[i].length -1);
                }
            		if(!property[arr[i]]) {
                		property[arr[i]] = {};
                		defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
           	 	}
            	property = property[arr[i]];
       	 	}
       		return property;
    	}
}
LyteYield._V4InsApi = ["_connectedCallback", "getProperty","_disconnectedCallback"];
LyteYield._V3InsApi = ["_connectedCallback", "getProperty","_disconnectedCallback"] //no i18n

customElements.define("lyte-yield", LyteYield, undefined, _Lyte.isWidgetBuild ? { "widget" : true} : {v3 : true});
class customElementPrototype extends elementPrototype{
    constructor() {
        super();
        if(window.isLyteWidget && window.parentWrapperComps && window.parentWrapperComps.indexOf(this.tagName) != -1 && !this.children.length) {
            this.__lyteIgnore = true;
        }
        if(window.ignoreParent) {
            this.__lyteIgnore = true;
            // window.ignoreParent = false;
            return;
        }
        this.decideConstructor();
    }
    decideConstructor(){
        if(window.__lyteConfig && (window.__lyteConfig.v4 || window.__lyteConfig.isWidgetBuild)){
            let self = this;
            let V3Registry = ltCf.versionBridge.component.V3Registry;
            let foundInV4List = V3Registry.allList.v4[this.localName]
            let foundInV3List = V3Registry.allList.v3[this.localName]
            let foundInWidgetList = V3Registry.allList.widget[this.localName]
            if(foundInV4List){
                if(!foundInV3List || ((this._callee && this._callee.__v4) || this.hasAttribute("lyte-v4") || this.hasAttribute("lyte-registry") || ltCf.lyteV4 || ltCf.fromV4Render)){
                    //v4
                    let v4compClass = foundInV4List;
                    customElementPrototype._V4InsApi.forEach(function(apiName){
                        self[apiName] = v4compClass.prototype[apiName];
                    })
                    this.setData = v4compClass.componentClass.prototype.setData;
                    this.setMethods = v4compClass.componentClass.prototype.setMethods;
                }else if(foundInV3List){
                    //v3
                    let v3CompClass = foundInV3List;
                    self.component = self.constructor.component = v3CompClass.component;
                }
            }else if(foundInWidgetList){
                if((this._callee && this._callee.__widget) || ltCf.__widget || this.hasAttribute("lyte-widget") || window.__lyteConfig.isWidgetComponent || ltCf.lyteWidget || ltCf.fromWidgetRender){
                    let widgetCompClass = foundInWidgetList;
                    if(ltCf._firstRegisteredComp[this.localName] != "widget"){
                        customElementPrototype._V3InsApi.forEach(function(apiName){
                            self[apiName] = widgetCompClass.prototype[apiName];
                        })
                    }
                    self.component = widgetCompClass.component;
                    self.__widget = true;
                    // this.setData = v4compClass.componentClass.prototype.setData;
                    // this.setMethods = v4compClass.componentClass.prototype.setMethods;
                }else if(foundInV3List){
                    let v3CompClass = foundInV3List;
                    if(ltCf._firstRegisteredComp[this.localName] != "v3"){
                        customElementPrototype._V3InsApi.forEach(function(apiName){
                            self[apiName] = v3CompClass.prototype[apiName];
                        })
                    }
                    self.component = v3CompClass.component;
                }else{
                    // not found in foundInV3List
                    _LC.V3.pendingComp.add(this);
                    this.__v3lyteIgnore = true;
                    return;
                }
            }else if(this.hasAttribute("lyte-widget") || window.__lyteConfig.isWidgetComponent || ltCf.lyteWidget || ltCf.fromWidgetRender){
                //pending widget component;
                _LC.V3.pendingComp.add(this);
                this.__v3lyteIgnore = true;
                return;
            }

        }
        //v3
        this.actualConstructor();
    }
    doRegistration(componentName,customCrmComponent){
        if(!this.component.constructor.__isRegistered){
            if(idleScheduler.tasks.get(componentName) || (idleScheduler.currentTask && idleScheduler.currentTask.id === componentName)){
                // console.log("idleScheduler task handling in component ", componentName);
                if(idleScheduler.currentTask && idleScheduler.currentTask.id !== componentName){
                //   console.log("idleScheduler pending task handling in component ",idleScheduler.currentTask.id);
                  if(Lyte.performance){
                    var _p1 = performance.now();
                  }
                  var sval = idleScheduler.tasks.get(idleScheduler.currentTask.id);
                    if(sval && idleScheduler.isGenerator(sval.handler)){
                        var gnxt = sval.handler.next(), gval;
                        while(gnxt.done == false){
                            gval = gnxt.value;
                            if(typeof gval == "function"){
                                gval();
                            }
                            gnxt = sval.handler.next()
                        }
                        idleScheduler.dequeueTask(idleScheduler.currentTask.id);
                    }
                    if(Lyte.performance){
                        var _p2 = performance.now();
                        var oldPerf = Lyte.Component.registerPerf[idleScheduler.currentTask.id];
                        Lyte.Component.registerPerf[idleScheduler.currentTask.id] = (oldPerf ? oldPerf : 0) + (_p2 - _p1);
                    }                        
                }
                if(Lyte.performance){
                    var p1 = performance.now();
                }
                var obj = idleScheduler.dequeueTask(componentName);
                var gen = obj.handler;
                if(idleScheduler.isGenerator(gen)){
                    var gnxt = gen.next(), gval;
                    while(gnxt.done == false){
                        gval = gnxt.value;
                        if(typeof gval == "function"){
                            gval();
                        }
                        gnxt = gen.next()
                    }
                }
                if(Lyte.performance){
                    var p2 = performance.now();
                    var oldPerf = Lyte.Component.registerPerf[componentName];
                    Lyte.Component.registerPerf[componentName] = (oldPerf ? oldPerf : 0) + (p2 - p1);
                }
            }
            else{
                if(Lyte.performance){
                    var p1 = performance.now();
                }
                customCrmComponent._registerComponent(componentName,customCrmComponent,customCrmComponent.component._widget);
                _LC.postRegistration(componentName,customCrmComponent);
                idleScheduler.dequeueTask(componentName);
                if(Lyte.performance){
                    var p2 = performance.now();
                    var oldPerf = Lyte.Component.registerPerf[componentName];
                    Lyte.Component.registerPerf[componentName] = (oldPerf ? oldPerf : 0) + (p2 - p1);
                }
            }
        }
    }
    actualConstructor() {
        if(this.hasAttribute("lyte-rendered")  || this._ccCalled) {
            this.__lyteIgnore = true;
        	return;
        } else if(!_LyteComponent.registeredComponents[this.localName]){
            this.__lyteIgnore = true;
            var origClass = _LC._registeredComponents[this.localName];
            origClass._pendingComponents = origClass._pendingComponents || [];
            origClass._pendingComponents.push(this);
            return;
        }
        this.__v3 = true;
        var wdt = _LyteComponent.currentWidget ? _LyteComponent.currentWidget : this._callee ? this._callee.__lyteWidget : undefined;
        // if((!wdt && !_LyteComponent.registeredComponents[this.localName]) || (wdt && (!_LyteComponent.registeredWidgetComponents[wdt] || !_LyteComponent.registeredWidgetComponents[wdt][this.localName]))) {
        // 	return;
        // }
        this.constr = this.constructor;
        // Check this 
        // var widget = this.constr.__widgetName; // is throwing error
        /*disable async function*/
        var widget = this.constructor.__widgetName;
        /*disable async function*/
        var map;
        /*disable async function*/
        if(widget) {
            /*disable async function*/
            map = widgetMap;
            /*disable async function*/
            window.ss = widgetMap;
            /*disable async function*/
            widget = map.get(widget);
        }
        // if(widget) {
        //     widget = widgetMap.get(widget);
        // }
        // if(wdt){
        //     this.constr = _LyteComponent.registeredWidgetComponents[wdt][this.localName]; 
        // }
        // this.constructor.component.compInstances.push(this);
        this.constr.activeInstances++; 
        this.constructor.component.activeInstances++; 
        let fastRenderIndex;
        let lytePropAttr = this.attributes._lyteprop;
        lytePropAttr = lytePropAttr ? lytePropAttr.nodeValue : undefined;
        let fastRenderedProp = (fastRenderIndex = lytePropAttr) ? _LC.fRP[fastRenderIndex] : undefined;
        let compInstance = this.component = fastRenderedProp ? fastRenderedProp.component : this.component ? new this.component() : new this.constructor.component();
        compInstance.__isComponent__ = true;
        if(Lyte.getConfig("lazyComponentRegister")){
            this.doRegistration(this.localName, this.constructor);
        }
        this._properties = {};
        this.registeredProp = _LC.directive.registeredProp[this.localName];
        // compInstance.methods = {};
        // this._methods = compInstance.methods;
        
        compInstance._config = this.constructor._config;
//        this.component.data = this.constructor._data ? this.constructor._data() : {};
        let compData;
        //comment the following two when return cli update is done.
        
        var act = compInstance.actions;
        // Object.defineProperty(compInstance,"actions",{
        //     get : function() {
        // 		Lyte.warn("Accessing actions directly is deprecated. Move the required common code from action block to a common function and access it.");
        // 		return act;
        // 	}   
        // });
        if(!fastRenderedProp) {
            // var _cmpData = {};
            var _cmpData = {}; //this.$data ? this.$data : {}; //af check
            compData = compInstance.data = {};
            let data = this.component.constructor._data ? this.component.constructor._data.apply(compInstance) : {};
            var def = "default";
            defProp(_cmpData, '__component__', {
                value : this,
                configurable : true,
                writable: true,
                enumerable : false
            });
            _cmpData.errors = {};
            compData = compInstance.data = _cmpData;
            if(_LC.__data.length){
                _LC.__data.forEach(function(item){
                    data = Object.assign(data,item);
                })
            }
            compInstance.__data = data;
            this._hideAttr = {};
            var self = this;
            for(let key in data) {
                var obj = data[key];
                compData[key] = obj[def];
                if(obj.initialize) {
                    if(typeof obj.initialize == "function")  {
                        var promise = obj.initialize.apply(self.component);
                        if(promise) {
                            compData[key] = promise;
                        }else{
                            _Lyte.error("LC011", key, self.tagName );
                        }
                    }
                }
                var customDtype;
                if( Lyte.Transform[obj.type]){
                    var customDataType = Lyte.Transform[obj.type]
                    if(/^(object|array)$/.test(customDataType.extends) && (customDataType.hasOwnProperty("properties") || customDataType.hasOwnProperty("items"))){
                        customDtype=true;
                    }
                }
                if((/^(object|array)$/.test(obj.type) && obj.watch) || customDtype ){
                    Lyte.establishObjectBinding(compData, key, false,undefined,undefined,obj.watch?true:undefined);
                }
                if(obj.hasOwnProperty("hideAttr")){
                    this._hideAttr[key] = obj.hideAttr;
                }
            }
            // this.$data = compData;
            if(this._initMethods){
                let arr=Object.keys(this._initMethods);
                compData.$methodAttributes = arr.reduce((obj, key) => {
                    obj[key] = true;
                    return obj;
                  }, {});
            }
            if (this.$data) {
                let initProperties = this.$data;
                for (let key in initProperties) {
                    compData[key] = initProperties[key];
                }
            }
            this.$data = compData;
            if(this._initProperties){
                let arr=Object.keys(this._initProperties).filter((ele)=>{
                    if(!compData.$methodAttributes){return true};
                 return !compData.$methodAttributes[ele];
                });
                compData.$dataAttributes=arr.reduce((obj, key) => {
                    obj[key] = true;
                    return obj;
                  }, {});
            }
            let observed_attributes=this.component.constructor._observedAttributes;
            if(observed_attributes && this.attributes){
                Object.values(this.attributes).forEach(value => {
                    if(observed_attributes.includes(_LC.String.toCamelCase(value.name))){
                        compData.$dataAttributes=compData.$dataAttributes?compData.$dataAttributes:[];
                        compData.$dataAttributes[_LC.String.toCamelCase(value.name)]=true;
                    }
                });
            }
            observed_attributes=[];
            compInstance.$dataAttributes=compData.$dataAttributes;
            compInstance.$methodAttributes=compData.$methodAttributes;
            if(compInstance.$dataAttributes){
                Object.freeze(compInstance.$dataAttributes);
                Object.freeze(compData.$dataAttributes);
            }
            if(compInstance.$methodAttributes){
                Object.freeze(compInstance.$methodAttributes);
                Object.freeze(compData.$methodAttributes);
            }
            compInstance.$data = compData;
            if(window.isLyteWidget){
                _LCSV.connect(this); 
            }
            if(this.constructor._serviceToBeUsed){
                for(var serKey in this.constructor._serviceToBeUsed){
                    var serName = this.constructor._serviceToBeUsed[serKey];
                    if(Lyte.registeredServices.hasOwnProperty(serName)){
                        this.component[serKey] = new Lyte.registeredServices[serName]();
                    } 
                    else{
                        this.__toRemoveLazy = this.__toRemoveLazy || {}; 
                        var self = this;
                        var id = Lyte.$.requiredServices(serKey,serName,function(serviceData,serviceKey,_sname,servName){
                            self.component[serviceKey] = Lyte.$.instantiateService(servName);
                            var  _toRemove = self.__toRemoveLazy[servName];
                            _toRemove.forEach(function(id){
                                Lyte.$.toRemoveFromRequiredServices(id);
                            });
                            delete self.__toRemoveLazy[servName];
                        });
                        this.__toRemoveLazy[serName] = this.__toRemoveLazy[serName] || [];
                        this.__toRemoveLazy[serName].push(id);
                    }
                }
            }
            this.initializeMethod(this, this.component.constructor._methods);
        }
        if(compInstance.$node) {
            for(var key in compInstance.$node) {
                if(key != "localName"){
                    this[key] = compInstance.$node[key];
                }
            }
        }
        compInstance.$node = this;
        for(let propName in _LyteComponent.customPropHandlersList){
            this[propName] = _LyteComponent.customPropHandlersList[propName];
        }
        if(this.component && this.component.constructor._template && this.component.constructor._template.widget){
            this.__lyteWidget = this.component.constructor._template.widget;
            var widget = widgetMap.get(this.__lyteWidget);
            widget ? widget.components.set(this, true) : undefined;
        }
        let _config_flag;
        if( compInstance._config ){
            _config_flag = compInstance._config.clientLifeCycleHooks == true || ( typeof compInstance._config.clientLifeCycleHooks == 'object' ? compInstance._config.clientLifeCycleHooks.includes('constructor') : false );
        }
        let _overrides;
        
        if(!fastRenderedProp) {
            // this.callback("constructor");
            this._actions = this._actions ? this._actions : {};
            this._callee = this._callee || this.getCallee(this.parentNode);
            if(this._callee && this.constructor.__widgetName) {
                if(this._callee.constructor.__widgetName != this.constructor.__widgetName) {
                    widget.additionalComps.add(this.parentElement);
                }
            }
    
                //check if it is called from server || to ssr bind
                
                //check if it has ssr contructor for ssr
                //ssrcode_client              
                if( _config_flag || !this.hasAttribute( 'server-rendered' ) ){
                    if( _overrides && _overrides.constructor && this.serverCall ){
                        _overrides.constructor.apply( this );
                    }else{
                        // this.callback("constructor");
                    }
                }          

            //checking lyte.attr ytpe and given default value type
            for (var key in compData) {
                if((window.isLyteWidget || window.__lyteEnablePromise) && compData[key] instanceof Promise){ //ask ln
                    continue;
                }
                var error = _LC.handleValidation(compData, key, compData[key], compInstance ,true);
                if (error) {
                    compData[key] = undefined;
                }
            }
        } else {
            this._fR = fastRenderedProp;
            delete _LC.fRP[fastRenderIndex];
            // _LC.pushFrc(fastRenderIndex);
        }
    }

    getMethods(arg0) {
        return this.component.getMethods(arg0);
    }
    hasAction(arg0) {
        return this.component.hasAction(arg0);
    }
    setActions(arg0,arg1){
        return this.component.setActions(arg0,arg1);
    }
    setMethods(arg0, arg1) {
        return this.component.setMethods(arg0, arg1);
    }
    // getData(arg0) {
    //     return this.component.getData(arg0);
    // }
    // setData(arg0, arg1 ,options) {
    //     return this.component.setData(arg0, arg1, options);
    // }
    getCallee(callee){
        return _LC.getCallee(callee, this);
    }
    afterConnected(fastRenderProp,ssrBind) {
        let constr = this.constructor;
        let compConstr = this.component.constructor;
        if(this.constructor._mutable === true || Lyte.getConfig("mutable")){
            this.component.data = Lyte.mut(this.component.data);
        }

        //initProperties is used because, we may have cases where the component wouldn't have been registered but 
        //it would be in dom already with some attributes. In those cases we can store the data in _initProperties as key, value.
        //These properties would then be applied to the component, once it gets instantiated. 
        
        //This is done, in order to solve when on a string value update of an if helper, the binding in the true or false case must be established. 
        //Without this, we won't establish the _properties in the component to the actual Data. 
        if(this.getAttribute("_lyteprop")) {
        	return "";
        }
        let obsattr = compConstr._observedAttributes;
        for(let i=0;i<obsattr.length;i++){
            let key = obsattr[i];
            let prop = this.getProperty(key);
            defProp(prop, '__fromComponent', {
            	value : true,
                enumerable : false
            });
        }
        this.getProperty("errors");
        var $lg = Lyte.__gl, 
        compInstance = this.component,
        compData = compInstance.data;
        compData.$lg=$lg;
        if(this._initProperties) {
            let initProperties = this._initProperties;
            for(let key in initProperties) {
                let actVal;
                let field = compInstance.__data[key]; 
                if(field && field.type !== _LC.getDataType(initProperties[key]) && (initProperties[key] !== undefined  || field.type === "boolean")) {
                    actVal = _LC.typeCast(initProperties[key], compInstance.__data[key].type);
                } else {
                     actVal = initProperties[key];
                }
                // if(field){
                    let error = _LC.handleValidation(compData, key, actVal, compInstance ,true);
                    if(!error) {
                        compData[key] = actVal;
                        var customDtype;
                        if( field && Lyte.Transform[field.type]){
                            var customDataType = Lyte.Transform[field.type]
                            if(/^(object|array)$/.test(customDataType.extends) && (customDataType.hasOwnProperty("properties") || customDataType.hasOwnProperty("items"))){
                                customDtype=true;
                            }
                        }    
                        if((field && /^(object|array)$/.test(field.type) && field.watch ) || customDtype){
                            Lyte.establishObjectBinding(compData, key, undefined,undefined,undefined,field.watch?true:undefined);
                        }
                    }    
                // }
            }
            this._initProperties = undefined;
        }
        // if(compData.errors && Object.keys(compData.errors).length){
        //     Lyte.error("Error in data passed to component-"+this.component.$node.localName+" for the properties-"+Object.keys(this.component.data.errors).toString());
        // }
        if(this._initMethods) {
            let initMethods = this._initMethods;
            for(let key in initMethods) {
                compInstance.$node._methods[key] = initMethods[key];
            }
            this._initMethods = undefined;
        }
        _LCSV.afterConnect(this);
        let _config_flag;
        if( compInstance._config ){
            if( compInstance._config.clientLifeCycleHooks != undefined ){
                _config_flag = compInstance._config.clientLifeCycleHooks == true || ( typeof compInstance._config.clientLifeCycleHooks == 'object' ? compInstance._config.clientLifeCycleHooks.includes('init') : false );
            }
        }   
        let _overrides;      
        
        //ssrcode client
        ssrBind && this.cmpBind(fastRenderProp);    
        if(window.isLyteWidget) {
            let errorDetails = this.component.data.errors;
            if(Object.keys(errorDetails).length) {
                compData._error = true;
            }
        }    
        if( _config_flag || !this.hasAttribute( 'server-rendered' ) )
        {
            if( _overrides && _overrides.init && this.serverCall ){
                _overrides.init.apply( this );
            }else{        
                this.callback('init');
            }
            this.onCallBack('init');
        }
        this.registerYields();
        if(compData.lyteUnbound) {
        	_LC.unbound = true;
        }
        let content = "";
        let unboundBeta = compData.lyteFastRender;
    
        //to bind in ssr
        
        if(!unboundBeta) {
            content = this.renderNodes(compConstr._template, compConstr._dynamicNodes,undefined,undefined, undefined, undefined, compConstr._tC, undefined, true);
        } else {
            content = this.renderFast(compConstr._dynamicNodes, compConstr._sta, compInstance);
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    _LC.callCC();
                });
            });
        }
        return content;
    }
    initializeMethod(node,actMethods){
        let compInstance;
        if(node.component){
            compInstance = node.component;
        }else{
            compInstance = node;
            node = compInstance.$node;
        }
        compInstance.methods = {};
        node._methods = compInstance.methods;
        for(let key in actMethods) {
            compInstance.methods[key] = actMethods[key];
        }
        // var met = compInstance.methods;
        // Object.defineProperty(compInstance,"methods",{
        //     get : function() {
        // 		Lyte.warn("Accessing methods directly is deprecated. Kindly make use of 'this.executeMethod' Api.");
        // 		return met;
        // 	},
        //     set : function(value){
        //         met = value
        //     }   
        // });
    }
    renderComponent(dynNode, preDefObj) {
    	var componentName = dynNode.componentName;
    	var staticAttrs = dynNode.staticAttrs;
        var constr = LyteComponent._registeredComponents[componentName];
        if(!constr) {
          return "";
        }
        var compConstr = LyteComponent._registeredComponents[componentName].component;
    	var component =  new constr.component();
    	preDefObj.component = component;
        if(Lyte.getConfig("lazyComponentRegister")){
            this.doRegistration(componentName, constr);
        }
        if(this.constructor._mutable === true || Lyte.getConfig("mutable")){
            component.data = Lyte.mut({});
        }
        else{
            component.data = {};
        }
        let cmpData = LyteComponent.getCmpData(component.data);
    	let data = compConstr._data ? compConstr._data.apply(component) : {};
    	var def = "default";
    	for(let key in data) {
            cmpData[key] = data[key][def];
        }
        cmpData.errors = {};
        component.__data = data;
        // if(component.constructor) {
        // 	component.constructor.apply(component);
        // }
        var obsAttrs = LyteComponent._registeredComponents[componentName].component._observedAttributes;
        preDefObj.data = preDefObj.data || {};
		for(var key in staticAttrs) {
			if(obsAttrs.indexOf(key) !== -1) {
				preDefObj.data[key] = staticAttrs[key];
			}
		}
		let initProperties = preDefObj.data;
        if(initProperties) {
            for(let key in initProperties) {
                let actVal;
                if(component.__data[key] && component.__data[key].type !== _LC.getDataType(initProperties[key]) && (initProperties[key] !== undefined  || component.__data[key].type === "boolean")) {
                    actVal = _LC.typeCast(initProperties[key], component.__data[key].type);
                } else {
                     actVal = initProperties[key];
                }
                let error = _LC.handleValidation(cmpData, key, actVal, component);
                if(!error) {
                    cmpData[key] = actVal;    
                }
            }
        }
        if(true) {
            component.$node = {"querySelector" : noop, "localName" : componentName};
            this.initializeMethod(component, compConstr._methods);
        	if(component.init) {
            	component.init.apply(component);
            }
            let initCallbacks;
            if(compConstr._callBacks && (initCallbacks = compConstr._callBacks.init)) {
			    for(let i=0;i<initCallbacks.length;i++) {
			        initCallbacks[i].value.apply(component);
			    }
			}
            preDefObj.unbound = true;
            delete component.$node.querySelector;
            if(Lyte.getConfig("lazyComponentRegister") && !LyteComponent._registeredComponents[componentName].component.__isRegistered){
                var sval = Lyte.Component.lazyRegisterScheduler.dequeueTask(componentName);
                if(Lyte.performance){
                    var p1 = performance.now();
                }
                if(sval && idleScheduler.isGenerator(sval.handler)){
                    var gnxt = sval.handler.next(), gval;
                    while(gnxt.done == false){
                        gval = gnxt.value;
                        if(typeof gval == "function"){
                            gval();
                        }
                        gnxt = sval.handler.next()
                    }
                }
                if(Lyte.performance){
                    var p2 = performance.now();
                    var oldPerf = Lyte.Component.registerPerf[componentName];
                    Lyte.Component.registerPerf[componentName] = (oldPerf ? oldPerf : 0) + (p2 - p1);
                }
            }            
        	return this.renderFast(LyteComponent._registeredComponents[componentName].component._dynamicNodes, LyteComponent._registeredComponents[componentName].component._sta, component, preDefObj);
        }
    }

    renderFast(dynamicNodes, arr, comp, compPreDef) {
        var fastRenderIndex;
        var prevComp;
        if(comp) {
            prevComp = this.component;
            this.component = comp;
        }
        var compData = LyteComponent.getCmpData(this.component.data);
        var str = "";
        var dynamicCompile = arr;
        var dynamicCompileNodes = arr.cc;
        let removeFirstChar = false;
        for(var i=0;i<dynamicCompileNodes.length;i++) {
            if(dynamicCompileNodes[i] != undefined) {
                var inte = dynamicCompileNodes[i];
                var dynNode = dynamicNodes[inte];
                if(dynNode.dynamicValue) {
                    let locVal = _LC.getDD(compData, dynNode.newDynamicValue);
                    locVal = (locVal == undefined || locVal == null) ? "" : locVal; 
                    // str = str + ZSEC.Encoder.encodeForHTML(locVal);
                    str = str + Lyte.Security.escape(locVal);
                } else if(dynNode.helperInfo) {
                    _LC.ffr = true;
                      let helperVal = this.processHelper({name : dynNode.helperInfo.name, args : this.processArgs(this,dynNode, [], undefined, undefined, true)}, undefined);
                    _LC.ffr = false;
                     helperVal = (helperVal == undefined || helperVal == null) ? "" : helperVal;
                    //  str = str + ( (dynNode.helperInfo.name === "unescape") ? helperVal : ZSEC.Encoder.encodeForHTML(helperVal) );
                    str = str + ( (dynNode.helperInfo.name === "unescape") ? helperVal : Lyte.Security.escape(helperVal) );
                } else if(dynNode.type){
                    switch(dynNode.type) {
                        case "for" : {
                            let prevDynamic = dynamicNodes[inte-1].attr.items;
                            var items;
                            if(prevDynamic.dynamicValue) {      
                                items = _LC.getDD(compData, prevDynamic.newDynamicValue);
                            } else if(prevDynamic.helperInfo) {
                                items = this.processHelper({name : prevDynamic.helperInfo.name, args : this.processArgs(this,prevDynamic, [], undefined, undefined, true)}, undefined);
                            }
                            var itemKey = dynNode._args.item || "item";
                            var indexKey = dynNode._args.index || "index";
                            let renderedStr = "";
                            if(items && items.length) {
                                var initialItemValue = compData[itemKey];
                                var initialIndexValue = compData[indexKey];
                                for(var indexInd=0;indexInd<items.length;indexInd++) {
                                    let item = items[indexInd];
                                    compData[itemKey] = item;
                                    compData[indexKey] = indexInd;
                                    renderedStr += this.renderFast(dynNode.dynamicNodes, dynNode._sta, undefined, compPreDef);
                                }
                                compData[itemKey] = initialItemValue;
                                compData[indexKey] = initialIndexValue;
                            }
                            str += renderedStr;
                        }
                        break;
                        case "forIn" : {
                            let prevDynamic = dynamicNodes[inte-1].attr.object;
                            var object;
                            if(prevDynamic.dynamicValue) {
                                object = _LC.getDD(compData, prevDynamic.newDynamicValue);
                            } else if(prevDynamic.helperInfo) {
                                object = this.processHelper({name : prevDynamic.helperInfo.name, args : this.processArgs(this,prevDynamic, [], undefined, undefined, true)}, undefined);
                            }
                            var valueKey = dynNode._args.value || "value";
                            var keyKey = dynNode._args.key || "key";
                            let renderedStr = "";
                            let objKeys;
                            if(object && (objKeys = Object.keys(object))) {
                                var initialValueValue = compData[valueKey];
                                var initialKeyValue = compData[keyKey];
                                for(var keyIndex=0;keyIndex < objKeys.length;keyIndex++) {
                                    let key = objKeys[keyIndex];
                                    compData[valueKey] = object[key];
                                    compData[keyKey] = key;
                                    renderedStr += this.renderFast(dynNode.dynamicNodes, dynNode._sta, undefined, compPreDef);
                                }
                                compData[itemKey] = initialValueValue;
                                compData[indexKey] = initialKeyValue;
                            }
                            str += renderedStr;
                        }
                        break;
                        case "if" : 
                        case "switch" : {
                            let prevDynamic = dynamicNodes[inte-1].attr.value;
                            var value;
                            if(prevDynamic.dynamicValue) {
                                value = _LC.getDD(compData, prevDynamic.newDynamicValue);
                            } else if(prevDynamic.helperInfo) {
                                value = this.processHelper({name : prevDynamic.helperInfo.name, args : this.processArgs(this,prevDynamic, [], undefined, undefined, true)}, undefined);
                            }
                            var currentCaseName;
                            if(value) {
                                currentCaseName = dynNode.type === "if" ? "true" : value.toString();
                            } else {
                                if(dynNode.type=== "if")  {
                                    currentCaseName = "false";
                                } else {
                                    switch(value) {
                                    case undefined : 
                                        currentCaseName = "undefined";
                                        break;
                                    case null : 
                                        currentCaseName = "null";
                                        break;
                                    case false: 
                                        currentCaseName = "false";
                                        break;
                                    case "": 
                                        currentCaseName = '""';
                                        break;
                                    }
                                }
                            }
                            let scope = dynNode.cases[currentCaseName];
                            if(!scope) {
                                if((scope = dynNode.default) && scope._sta) {
                                    str += this.renderFast(scope.dynamicNodes, scope._sta, undefined, compPreDef);
                                }
                            } else {
                                while(scope) {
                                    str += this.renderFast(scope.dynamicNodes, scope._sta, undefined, compPreDef);
                                    if(scope.additional) {
                                        if(scope.additional.next) {
                                            scope = dynNode.cases[scope.additional.next];
                                        } else {
                                            scope = dynNode.default;
                                        }
                                        
                                    } else {
                                        break;
                                    }
                                }
                            }
                        }
                        break;
                        case "attr" : {
                            let nextDynamic;
                            let fastRenderProp;
                            let dynLength = dynamicNodes.length;
                            for(let k=inte+1;k<dynLength;k++) {
                                let locDyn = dynamicNodes[k];
                                if(locDyn.type !== "registerYield" && locDyn.type !== "componentDynamic" && locDyn.type !== "insertYield" && locDyn.type !== "component") {
                                    break;
                                } else {
                                    if(dynamicNodes[k].type === "componentDynamic" || dynamicNodes[k].type === "insertYield" || dynamicNodes[k].type === "component") {
                                        if(dynamicNodes[k].position.toString() == dynamicNodes[inte].position.toString()) {
                                            if(dynamicNodes[k].type == "componentDynamic") {
                                                if(_LyteComponent.registeredComponents[dynamicNodes[k].componentName]) {
                                                    nextDynamic = dynamicNodes[k];
                                                    break;
                                                }
                                            } else {
                                                nextDynamic = dynamicNodes[k];
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            let setAttr;
                            if(nextDynamic) {
                                setAttr = nextDynamic.type !== "component";
                                fastRenderIndex = _LC.fRC++;
                                fastRenderProp = _LC.fRP[fastRenderIndex] = {"data" : {}};
                            }
                            if(!nextDynamic || nextDynamic.type !== "component") {
                                str = str.substring(0, str.length - 11);
                            }
                            let attr = dynNode.attr;
                            let actionObj = {};
                            for(let key in attr) {
                                if(attr[key].dynamicValue) {
                                    // let nodeValue = this.get(attr[key].dynamicValue);
                                    let nodeValue = attr[key].newDynamicValue ? _LC.getDD(compData, attr[key].newDynamicValue) : this.get(attr[key].dynamicValue);
                                    
                                    if(fastRenderProp) {
                                        fastRenderProp.data[attr[key].camelCase] = nodeValue;
                                        if(typeof nodeValue == "string" && setAttr) {
                                            nodeValue = this.formatValue(key, nodeValue);
                                            str = str + nodeValue + " ";
                                        }
                                    } else {
                                        nodeValue = this.formatValue(key, nodeValue);
                                        str = str + nodeValue + " ";
                                    }
                                } else if(attr[key].helperInfo) {
                                    if(attr[key].helperInfo.name === "action") {
                                        let actionName = attr[key].helperInfo.args[0];
                                        let boundName;
                                        if(actionName.startsWith('"') || actionName.startsWith("'")) {
                                            boundName = actionName.substring(1, actionName.length - 1);
                                        } else {
                                            _Lyte.warn("Deprecation warning. Action name " + actionName + " must be in quotes");
                                            boundName = actionName;
                                        }
                                        let actArgs = this.processArgs(this, attr[key], [], "__lyteEvent__", "__lyteNode__");
                                        let actualAttrName = attr[key].globalEvent ? attr[key].name : (attr[key].name.indexOf("-") !== -1)? attr[key].name : attr[key].name.substr(2);
                                        actionObj[actualAttrName] = {"name" : boundName, "args" : attr[key].helperInfo.args, "actArgs" : actArgs, "globalEvent" : attr[key].globalEvent ? true : false, "skipArgProcessing" : true};
                                    }  else if (attr[key].helperInfo.name === "method") {
                                        var methodsObj = compPreDef ? compPreDef.methods : this.component.methods; 
                                        if(fastRenderProp) {
                                            let methods = fastRenderProp.methods = fastRenderProp.methods || {};
                                            let parentComp = compPreDef ? compPreDef.component : this.component;
                                            let actArgs = this.processArgs(this, attr[key], [], "__lyteEvent__", "__lyteNode__");
                                            var methodFunc = function() { //eslint-disable-line no-loop-func
                                                let node = this.$node;
                                                let args = actArgs.slice(1);
                                                let functionName = actArgs[0];
                                                let customArgs = Array.from(arguments);
                                                let mainArgs = args.concat(customArgs);
                                                return parentComp.$node._methods[functionName].apply(parentComp, mainArgs);
                                            }
                                            methods[attr[key].camelCase] = methodFunc;
                                        }
                                    } else {
                                        let nodeValue = this.processHelper({name : attr[key].helperInfo.name, args : this.processArgs(this,attr[key], [], undefined, undefined, true)}, undefined);
                                        if(fastRenderProp) {
                                            fastRenderProp.data[attr[key].camelCase] = nodeValue;
                                            if(typeof nodeValue == "string" && setAttr) {
                                                nodeValue = this.formatValue(key, nodeValue);
                                                str = str + nodeValue + " ";
                                            }
                                        } else {
                                            nodeValue = this.formatValue(key , nodeValue);
                                            str = str + nodeValue + " ";                                        
                                        }
                                    }
                                }
                            }
                            if(Object.keys(actionObj).length) {
                                let locIndex = _LC.fRC++;
                                str = str + "lyteaction=" + locIndex + " ";
                                _LC.fRP[locIndex] = actionObj;
                                actionObj.componentName = this.component.$node.localName || "undefined";
                                //str = str + "lyteaction=" + ZSEC.Encoder.encodeForHTMLAttribute(JSON.stringify(actionObj)) + " ";
                            }
                            if(fastRenderProp && nextDynamic.type !== "component" && nextDynamic.type !== "insertYield") {
                                str = str + "_lyteprop=" + fastRenderIndex + " ";
                            }
                            if(!dynNode.attrHandling) {
                                dynamicCompile[i+1] = dynamicCompile[i+1].substr(1);
                                dynNode.attrHandling = true;
                            }
                        }
                        break;
                        case "insertYield" : {
                            let preDefObj = fastRenderIndex !== undefined ? _LC.fRP[fastRenderIndex] : undefined;
                            if(preDefObj) {
                                delete _LC.fRP[fastRenderIndex];
                                // _LC.pushFrc(fastRenderIndex);
                            }
                            fastRenderIndex = undefined;
                            let yieldObj;
                            let yieldName = dynNode.yieldName || preDefObj.data.yieldName;
                            if(preDefObj) {
                                delete preDefObj.data.yieldName;
                            }
                            let yieldCallee;
                            if(!compPreDef || !compPreDef.yields) {
                                yieldObj = this._yields[yieldName];
                                if(yieldObj) {
                                    yieldCallee = yieldObj._callee;
                                } else {
                                    break;
                                }
                            } else {
                                yieldObj = compPreDef.yields[yieldName];
                                yieldCallee = compPreDef._yieldCallee;
                            }
                            if(yieldObj) {
                                let parentScope;
                                let locComp;
                                if(yieldCallee instanceof HTMLElement) {
                                    parentScope = yieldCallee;
                                } else {
                                    parentScope = this;
                                    locComp = this.component;
                                    this.component = yieldCallee.component;
                                }
                                let contextSwitch = {};
                                let contextSwitchArray = [];
                                var psCmpData = LyteComponent.getCmpData(parentScope.component.data);
                                if(yieldObj._cx) {
                                    _LC.adCx(yieldObj, contextSwitchArray);
                                }
                                if(preDefObj) {
                                    for(var key in preDefObj.data) {
                                        contextSwitch[key] = psCmpData[key];
                                        psCmpData[key] = preDefObj.data[key];
                                    }
                                }
                                var componentScope = parentScope.component;
                                if(prevComp && prevComp.$node == yieldCallee) {
                                    componentScope = prevComp
                                }
                                // if(componentScope == this.component) {
                                //     componentScope = prevComp;
                                // }
                                str = str + parentScope.renderFast(yieldObj.dynamicNodes || yieldObj._dynamicNodes, yieldObj._sta, componentScope, yieldCallee);
                                for(let key in contextSwitch) {
                                    psCmpData[key] = contextSwitch[key];
                                }
                                if(yieldObj._cx) {
                                    _LC.rmCx(yieldObj, contextSwitchArray); 
                                }
                                if(locComp) {
                                    parentScope.component = locComp;
                                }
                            }
                            //str = str + this.renderComponent(dynNode, preDefObj, compData);
                        }
                        break;
                        case "component" : {
                            if(fastRenderIndex !== undefined) {
                                let preDefObj = _LC.fRP[fastRenderIndex];
                                let componentName = preDefObj.data.componentName;
                                if(componentName) {
                                    if(_LyteComponent.registeredComponents[componentName]) {
                                        str = str + "<" + componentName + (_Lyte.isWidgetBuild ? " lyte-widget " : "" )+" _lyteprop="+ fastRenderIndex+">";
                                        fastRenderIndex = undefined;
                                        str = str + this.renderComponent({"componentName" : componentName}, preDefObj, compData);
                                        str = str + "</" + componentName + ">";
                                    } else {
                                        str = str + "component not registered";
                                        // Handle case where component has not been registered yet. 
                                    }   
                                }
                            }
                        }
                        break;
                        case "componentDynamic" : {
                            let preDefObj = fastRenderIndex !== undefined ? _LC.fRP[fastRenderIndex] : {};
                            fastRenderIndex = undefined;
                            str = str + this.renderComponent(dynNode, preDefObj, compData);
                        }
                        break;
                        case "registerYield" : {
                            let preDefObj;
                            if(fastRenderIndex !== undefined) {
                                preDefObj = _LC.fRP[fastRenderIndex];
                            } else {
                                fastRenderIndex = _LC.fRC++;
                                preDefObj = _LC.fRP[fastRenderIndex] = {};
                            }
                            preDefObj.yields = preDefObj.yields || {};
                            preDefObj.yields[dynNode._args["yield-name"]] = dynNode;
                            if(!preDefObj._yieldCallee) {
                                preDefObj._yieldCallee = compPreDef ? compPreDef : {"component" : this.component};
                            }
                        }
                    }
                } else {
                    str = str + dynamicCompile[i];
                }
            } else {
                str = str + dynamicCompile[i];
            }
        }
        if(comp) {
            this.component = prevComp;
        }
        return str;
    }

    formatValue(key, nodeValue) {
        let type = typeof nodeValue;
        if(nodeValue === "") {
            type = "undefined";
        }
        let retVal;
        let isSpecialAttr = (key == "src") || (key == "href");
        switch(type) {
        case "boolean" : 
            return nodeValue ? key : "";
        case "object" : 
            retVal = ((typeof Record != "undefined" && nodeValue instanceof Record) ? JSON.stringify(nodeValue.$.toJSON()) : JSON.stringify(nodeValue));
            // return key + "=" + (isSpecialAttr ? retVal : ZSEC.Encoder.encodeForHTMLAttribute(retVal));
            return key + "=\"" + (isSpecialAttr ? retVal : Lyte.Security.escape(retVal)) + "\"";
        case "undefined" : 
            return key
        default : 
            {
                // return key + "=" + (isSpecialAttr ? nodeValue : ZSEC.Encoder.encodeForHTMLAttribute(nodeValue) );
                return key + "=\"" + (isSpecialAttr ? nodeValue : Lyte.Security.escape(nodeValue) ) + "\"";
            }
        }
    }
    
    //RN
    //ssroverrides
    renderNodes(toAppend, dynamicNodes, helperNode, options, establishBindings, returnVal, templateContent, yieldComp, initialRender) {
        options = options || {};
        let content;
        let constr = this.constr;
        /*if(_Lyte._ie){
            let newFrag = toAppend.cloneNode(true, "lyte");
            this.constructor.splitTextNodes(newFrag);
            content = newFrag;
        }
        else{
            content = toAppend.cloneNode(true, "lyte");
        }*/
        let templateDepthHandlingNeeded = false;
        if (_Lyte._ms || !toAppend) {
            templateDepthHandlingNeeded = true;
            content = _LC.getContentForIE(templateContent , constr);
        } else if(toAppend.hasAttribute("depth")) {
        	templateDepthHandlingNeeded = true;
        	content = _LC.getContentForIE(toAppend , constr);
        } else {
            content = toAppend.content.cloneNode(true, "lyte");
        }
        let updateHelpers = [],processLast = [],helperFunc,stoppedNode;
        let cmpData = LyteComponent.getCmpData(this.component.data);
        //to get bindings in ssr components
        
        // componentDynamic = "1" , text ="2" , attr = "3" , for = "4" , forIn = "5", component = "6" , if = "7" , switch = "8" , registeryield = "9" , insertyield = "10" , action = "A1" , method = "M2", forContent = "4C"
        let toBeInsMap = new Map();
        for(let i=0;i<dynamicNodes.length;i++) {
            let info = dynamicNodes[i], type = info.type, pos = info.position, dynamicN = content, helperInfo;
            dynamicN = getDynamicNode(dynamicN,pos);
            if(info.trans){
                dynamicN._hooksPresent = true;
            }
            if(!dynamicNodes._cache && !(this.registeredProp && this.registeredProp.length)){
                dynamicNodes._cache = {};
            }
            if(type ===  "componentDynamic") {
                if(_Lyte.isWidgetBuild) {
                    dynamicN.setAttribute("lyte-widget", "");
                }
                if(helperNode){
                    dynamicN._parentHelper = helperNode;
                }
            	if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}

                //to bind componentDynamic in ssr components
                          
            } 
            else if(type === "text"){
                 this.bindNode(dynamicN, undefined, helperNode, options, dynamicNodes[i], processLast, establishBindings,undefined,dynamicNodes._cache, type, undefined, toBeInsMap);
            }
            else if(type === "attr"){
            	dynamicN._attributeDetails = info.attr;            	
                if(dynamicN.nodeName === "LYTE-YIELD") {
                    dynamicN._callee = this;
                    dynamicN.component = {}
                    dynamicN.component.data = {};
                    defProp(dynamicN.component.data, "__component__", {
                    	value : dynamicN,
                    	configurable : true,
                    	writable : true,
                        enumerable : false
                    });
                    dynamicN._properties = {};
                    for(let j=0;j<dynamicN.attributes.length;j++) {
                        let attr = dynamicN.attributes[j];
                        if(attr.nodeName !== "is" && attr.nodeName !== "yield-name") {
                            dynamicN._properties[_LC.String.toCamelCase(attr.nodeName)] = {};
                        }
                    }
                }
                let toBeRemoved = [];
                let processDirectiveLazy = [];
				for(let key in info.attr) {
                	let attr = info.attr[key];
                	attr._depthTemp = info._depthTemp;
                	let attrName = key;
                    let node;
                    if(attr && (attr.dynamicValue || attr.helperInfo)) {
                        if(options.node) {
                                dynamicN._cx = options;
                        }
                        else if(helperNode) {
                            dynamicN._cx = helperNode._cx;
                        }
                        let actionName, boundName;
                        if(attr.helperInfo && attr.helperInfo.name === "action") {
                            dynamicN._boundEvents = dynamicN._boundEvents || {};
                            actionName = attr.helperInfo.args[0];
                            if(actionName.startsWith('"') || actionName.startsWith("'")) {
                                boundName = actionName.substring(1, actionName.length - 1);
                            } else {
                                // _Lyte.warn("Deprecation warning. Action name " + actionName + " must be in quotes");
                                boundName = actionName;
                            }
                            let actualAttrName = attr.globalEvent ? attrName : (attrName.indexOf("-") !== -1)? attrName : attrName.substr(2);
                            dynamicN._boundEvents[actualAttrName] = {"name" : boundName, "args" : attr.helperInfo.args};

                                //to bind actions in ssr components
                                let id;
                                // if( dynamicN.hasAttribute( "bindId" ) ){
                                //    id = dynamicN.getAttribute( "bindId" );
                                // }else{
                                //    id = type + Math.floor( Math.random() * 1000 );
                                //    dynamicN.setAttribute( "bindId", id );
                                // }
                                id = "A1_"+Math.floor( Math.random() * 1000 ) ;
                                                       
                        }            
			            if(!attr.globalEvent) {
                            /*this.bindNode(dynamicN.getAttributeNode(attrName), toBeRemoved, helperNode, options, attr, undefined, establishBindings);
                             */
                            if(!dynamicN.hasAttribute(attrName)) {
                                dynamicN.setAttribute(attrName, "{{dummy}}");
                            }
                        	node = this.bindNode(dynamicN.attributes.getNamedItem(attrName), toBeRemoved, helperNode, options, attr, undefined, establishBindings,undefined,dynamicNodes._cache, type, i);
                            if(node !== dynamicN.attributes.getNamedItem(attrName)) {
                            	dynamicN._removedAttributes = dynamicN._removedAttributes || {};
                            	dynamicN._removedAttributes[attrName] = node;
                            }
                        }
                    }
                    if(attr.hookNode){
                        processDirectiveLazy.push({attr : attr, node : node});
                    }
                }
                _LCSV.addNodeLazy(processDirectiveLazy, this, info, dynamicN, helperNode, yieldComp, options);
                // _LCCL.addNodeLazy(processDirectiveLazy, this, info, dynamicN, helperNode, yieldComp, options);
                //Added now
                if(info.attr && Object.keys(info.attr).length) {
                	dynamicN._callee = this;
                }
                for(let d=0;d<toBeRemoved.length;d++) {
                    dynamicN.removeAttribute(toBeRemoved[d]);
                }
            }
            else if(/^(for|forIn|component)$/.test(type)){
                if(window.isLyteWidget || window.__lyteEnablePromise){
                    dynamicN._cases = info.cases;
                }
            	if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                dynamicN._dynamicNodes = info.dynamicNodes;
                if(_Lyte._ms) {
                    dynamicN._tC = info.templateContent;  
                }
                if(info.actualTemplate) {
                    dynamicN._tC = info.actualTemplate;
                }
                if(!dynamicN._hiddenTemplate){
                   dynamicN._hiddenTemplate = [];
                }
                let returnVal;
                switch(type) {
                case "for" : 
                    dynamicN._ht = info._ht;
                    returnVal = this.updateForHelper(dynamicN,{"type" : "default"} , options.node? options : undefined, establishBindings, info._sta, undefined, initialRender);
                	break;
                case "forIn" : 
                    dynamicN._ht = info._ht;
                    returnVal = this.updateForInHelper(dynamicN,{"type" : "default"} , options.node? options : undefined, establishBindings, undefined, initialRender);
                	break;
                case "component" : 
                	returnVal = this.updateDynamicComponent(dynamicN, false, options.node ? options : undefined, establishBindings,i,helperNode);
                }
                if(returnVal) {
                	updateHelpers.push(returnVal);
                }
            }
            else if(/^(if|switch)$/.test(type)){
                var def ="default";
                dynamicN._cases = info.cases; 
                dynamicN._default = info[def];
                dynamicN._ht = info._ht;
                if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                if(info.actualTemplate) {
                    dynamicN._tC = info.actualTemplate;
                    if(!dynamicN._origTemplate) {
                    	if(_Lyte._ie) {
                    		dynamicN._origTemplate = createElement("template")
                    	} else {
        	            	dynamicN._origTemplate = info._depthTemp.cloneNode(true);
                    	}
                    	if(dynamicN.hasAttribute("value")) {
                    		dynamicN._origTemplate.setAttribute("value", dynamicN.getAttribute("value"));
                    	}
                    }
                }
                if(!dynamicN._hiddenTemplate){
                    dynamicN._hiddenTemplate = [];
                }
                //to bind if/switch in ssr components
                let id;
                
                    
                let returnVal = this.updateSwitchHelper(type, dynamicN, options.node ? options : undefined, undefined, establishBindings,yieldComp, id, toBeInsMap);
                if(returnVal) {
                	updateHelpers.push(returnVal);
                	let isBreak = returnVal.toAppendMain.querySelector("template[is=break]");
                	if(isBreak) {
                		dynamicN._isStopped = "break";
                		content = Lyte.Compile.getTrimmedContent(content, info.position,undefined);
                		stoppedNode = info.position;
                		break;
                	}
                	let isContinue = returnVal.toAppendMain.querySelector("template[is=continue]");
                	if(isContinue) {
                		dynamicN._isStopped = "continue";
                		content = Lyte.Compile.getTrimmedContent(content, info.position,undefined);
//                		stoppedNode = info.position;
                		break;
                	}
                }
            } else if(type === "registerYield") {
                if(options.node) {
                    dynamicN._cx = options;
                }
                else if(helperNode) {
                    dynamicN._cx = helperNode._cx;
                }
                
                dynamicN._dynamicNodes = info.dynamicNodes;
                dynamicN._sta = info._sta;
                dynamicN._ht = info._ht;
                if(_Lyte._ms) {
                    dynamicN._tC = info.templateContent;  
                }
//                updateHelpers.push(dynamicN);
                //Added now                
                dynamicN._callee = this;
            } else if(type === "insertYield") {
                if(helperNode){
                    dynamicN._parentHelper = helperNode;
                }
            	if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                if(!dynamicN._hiddenTemplate){
                    dynamicN._hiddenTemplate = [];
                }
                dynamicN.component = dynamicN.component || {"data" : {}};
                dynamicN._properties = dynamicN._properties || {};
                    //to bind insertYield in ssr components
                    
                    dynamicN.component = dynamicN.component || {"data" : {}};
                    dynamicN._properties = dynamicN._properties || {};         
                    let dData = LyteComponent.getCmpData(dynamicN.component.data);  
                    for(let x=0; x<dynamicN.attributes.length; x++) {
                        let attrObj = dynamicN.attributes[x];
                        let attrName = attrObj.name;
                        let attrValue = attrObj.value;
                        if(attrName !== "yield-name") {
                            if(dynamicN._properties && !dynamicN._properties[attrName]){
                                dynamicN._properties[attrName] = {};
                            }
                            
                            if(dynamicN._attributeDetails && !dynamicN._attributeDetails[attrName]){
                                dData[attrName] = attrValue;
                            }
                        }
                    }
                this.updateYield(dynamicN, false, options.node? options : undefined);
            }
        }
        dynamicNodes._cache = undefined;
        for(let i=0;i<processLast.length;i++) {
             let dynamicPosition = processLast[i].dynamicPositions;
                 let processNode = dynamicPosition.initialNode;
                 let nodeValue = dynamicPosition.dynamicNodeValue;
                 let childLen = nodeValue.childNodes.length;
                 if(!childLen) {
                    nodeValue.appendChild(document.createTextNode(""));
                        childLen = 1;
                 }
                 let startingNode = nodeValue.childNodes[0];
                 if(_Lyte._rwpf && processNode.parentNode.nodeName === "#document-fragment") {
                 	while(nodeValue.childNodes.length) {
                 		insertBefore(processNode.parentNode, nodeValue.childNodes[0], processNode);
                    }
                 	processNode.remove();
                 } else {
                	 processNode.replaceWith.apply(processNode,nodeValue.childNodes);
                 }
                 processLast[i].dynamicPositions = {startingNode : startingNode, length: childLen}
        }
        if(toBeInsMap.size){
            toBeInsMap.forEach(function(val, key){
                val.pN.insertBefore(key, val.cN);
                if(val.cN.nextSibling){
                    val.pN.insertBefore(document.createElement("textend"), val.cN.nextSibling);
                }
                else{
                    val.pN.appendChild(document.createElement("textend"));
                }
            })
        }  
        if(stoppedNode) {
        	returnVal = returnVal || {};
        	returnVal.stop = true;
        }
        if(helperNode) {
            if(options.type) {
                helperNode._helpers[options.itemIndex] = updateHelpers;
                if(templateDepthHandlingNeeded) {
                    content = constr.createDocFragment1(content);  
                }
                return content;
            } else {
                helperNode._helpers = helperNode._helpers || [];
                helperNode._helpers.push.apply(helperNode._helpers, updateHelpers);
                if(templateDepthHandlingNeeded) {
                    content = constr.createDocFragment1(content);  
                }
                return content;
            }
        }
        this.executeBlockHelpers(updateHelpers);
        if(templateDepthHandlingNeeded) {
            content = constr.createDocFragment1(content);  
        }
        return content;
    }

    executeBlockHelpers(updateHelpers, node) {
	    for(let i=0;i<updateHelpers.length;i++) {
            var lastNode = updateHelpers[i].lastNode;
            var parentNode = lastNode.parentNode; 
                
            if(lastNode._placeHolder) {
                lastNode = lastNode._placeHolder;
                parentNode = lastNode.parentNode;
            }
            //parentNode = updateHelpers[i].lastNode.parentNode || updateHelpers[i].lastNode._placeHolder.parentNode;
            insertBefore(parentNode, updateHelpers[i].toAppendMain, lastNode);
            updateHelpers[i] = updateHelpers[i].lastNode;
	    		// updateHelpers[i].lastNode.parentNode.insertBefore(updateHelpers[i].toAppendMain, updateHelpers[i].lastNode);
	    		// updateHelpers[i] = updateHelpers[i].lastNode;
	    		//updateHelpers[i]._parentIf = node;
//	    		if(!updateHelpers[i]._cx && node) {
//	    			updateHelpers[i]._cx = node._cx;
//	    		}
	    }	
    }
    
    updateBlockHelpers(updateHelpers,contextSwitchInfo){
        for(let i=0;i<updateHelpers.length;i++) {
            switch(updateHelpers[i].getAttribute('is')) {
            case "for" :
                this.updateForHelper(updateHelpers[i], {"type" : "default"},contextSwitchInfo);
                break;
            case "if" : 
                this.updateSwitchHelper("if",updateHelpers[i],contextSwitchInfo);
                break;
            case "forIn" : 
                this.updateForInHelper(updateHelpers[i] , {"type" : "default"},contextSwitchInfo);
                break;
            case "switch" :
                this.updateSwitchHelper("switch",updateHelpers[i],contextSwitchInfo);
                break;
            case "component" : 
                this.updateDynamicComponent(updateHelpers[i], false, contextSwitchInfo);
                break;
            case "insertYield" : 
//              this.updateYield(updateHelpers[i], false, contextSwitchInfo);
                break;
            case "yield" : 
            case "registerYield" : 
                if(contextSwitchInfo) {
                    updateHelpers[i]._cx = contextSwitchInfo;
                }
                break;
            default: 
                if(updateHelpers[i].tagName === "LYTE-YIELD") {
                    this.updateYield(updateHelpers[i], false, contextSwitchInfo);
                }
                
            }
         }
    }
    /*disable async function*/
    static get observedAttributes() { 
        return this._observedAttributesDasherized;
    }
    //AttributeChangedCallback will be called for the attributes mentioned in the this._observedAttributes array. 
    static dasherizeObservedAttributes() {  
    		let newArr = [];
            for(let i=0;i<this._observedAttributes.length;i++) {
                newArr[i] = _LC.String.dasherize(this._observedAttributes[i]);
            }
            _LC.__dataNames.forEach(function(name){
                newArr.push(_LC.String.dasherize(name));
            })
            _LC.customPropHandlers.forEach(function(item,index) {
                newArr.push(_LC.String.dasherize(item));
            })
            this._observedAttributesDasherized = newArr;
    }
    //Callback from browser, whenever any of the observed attribute changes. 
    //We call the component set, in order to affect the related changes. 
    attributeChangedCallback(attr, oldValue, newValue) {
        this._attributeChangedCallback(attr, oldValue, newValue);
    }
    _attributeChangedCallback(attr, oldValue, newValue) {
        if(this.__lyteIgnore || this.__v3lyteIgnore) {
            return;
        }
        let constr = this.constructor;
        let compConstr = this.component.constructor;
        if((compConstr._observedMethodAttributes && compConstr._observedMethodAttributes[attr])) {
            return;
    	}
        let actualAttr = _LC.String.toCamelCase(attr);
        let isCustomProp = _LC.customPropHandlers.indexOf(actualAttr);
        if(isCustomProp !== -1) {
            let propValue = _LC.customPropHandlers[isCustomProp];
            let lyteProps = newValue;
            if(lyteProps) {
                try{
                    lyteProps = JSON.parse(lyteProps);
                    for(let key in lyteProps) {
                        let actKey = propValue + _LC.String.upperCaseFirstLetter(key);
                        this.set(actKey, lyteProps[key]);
                    }
                } catch (e) {
                    _Lyte.error("LC001", attr);
                }
            }
            return;
        }
        if(oldValue === newValue) {
            return;
        }
        var attrNode = this.attributes.getNamedItem(attr);
        if(attrNode) {
            if(attrNode.__lyteIgnore) {
                this.attributes.getNamedItem(attr).__lyteIgnore = false;
                return;    
            }
        } else if(this["__"+attr]) {
            this["__"+attr] = false;
            return;
        }
        let compInstance = this.component;
        let dataDef = compInstance.__data[actualAttr];
        if(dataDef && dataDef.type){
            let dataType = dataDef.type;
            if(dataType !== "string") {
                let obj = {"attr" : attr, "tagName" : this.tagName};
                newValue = _LC.typeCast(newValue, dataType, obj);
                if(obj.isError) {
                    _Lyte.warn("data type of the value provided for attribute "+attr+ " of " + this.tagName + " is not valid");
                    return;
                }
            }
        }
        
        let compData = compInstance.data;
        if(compData[actualAttr] !== newValue) {
            // Null check is done because when we do a removeAttribute directly on a component, the corresponding value expected is that of undefined and not null.
            this.set(actualAttr, newValue === null ? undefined: newValue, undefined, undefined, true);
        } else {
            _LC.clearError(compData, actualAttr);
        }
    }
    
    //Used to remove helpers of specific index in a for helper. 
    removeHelpersSpecificIndex(node, index, destroyChild, type) {
        let isType = node.getAttribute("is");
        if(node._helpers[index]) {
            for(let j=0;j<node._helpers[index].length;j++) {
                    this.removeHelpers(node._helpers[index][j], undefined, undefined, index, node, type);
            }
        }
        _LCSV.removeAll(isType, this, node, index, destroyChild, index, node, type)
        _LCHD.rmHelpersSpecificIndex(node, index);
        if(node._forContent[index]) {
            for(let i=0;i<node._forContent[index].length; i++ ) {
                node._forContent[index][i].remove();
            }
            var self = this;
            Object.keys(node._items[index]._dynamicProperty).forEach(function(key) {
                node._dynProps[key]--;  
                if(!node._dynProps[key]) {
                    let prop  = self.getProperty(key);
                    if(prop._helperNodes) {
                        prop._helperNodes[delStr](node);
                    }
                }
            });
            node._items[index] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}, "propProperty" : {},"propPropertyDyn" : {}, "propNodes" : {}};
        }
    }
    //Used to remove all the helpers within an helper. 
    removeHelpers(node, update, direct, updateIndex, parentNode, type) {
        let isType = node.getAttribute("is");
        if(!direct) {
            node.remove();
            var helpersObj = node.getAttribute("is") === "component" ? this.__dc : this.__h;
            let nodeId = node.__lyteId;
            delete helpersObj[nodeId];
        }
        
        var del = "delete";
        let parent;
        var contextSwitchArray = [];
        _LC.adCx(node, contextSwitchArray);
        if(node._forContent) {
            if(node.getAttribute("is") === "for") {
        	if(node._helpers) {
                for(let i=0;i<node._helpers.length;i++) {
                    for(let j=0;j<node._helpers[i].length;j++) {
                            this.removeHelpers(node._helpers[i][j], undefined, undefined, updateIndex, parentNode, type);
                    }
                    node._helpers[i] = [];
                }
            }
            for(let s=0;s<node._forContent.length;s++) {
                for(let i=0;i<node._forContent[s].length; i++ ) {
                    node._forContent[s][i].remove();
                }
            }
            let key = node.getAttribute("item");
            if(node._items.length) {
                let prop = node._items[0].itemProperty;
                for(let i=0;i<node._items.length;i++) {
                    let dynProp = node._items[i]._dynamicProperty;
                    for(let dP in dynProp) {
                        let property = this.getProperty(dP); 
                        if(property._helperNodes){
                            property._helperNodes[del](node);                    
                        }
                    }    
                }
                if(prop) {
                    for(let i=0;i<node._items.length;i++) {
                        this.removeBindings({[key] : node._items[i].itemProperty}, {[key] : node._attributes.items[i]});
                    }
                }
            }
            _LCSV.removeAll(isType, this, node, undefined, undefined, updateIndex, parentNode, type);
            if(!update) {
            	if(node._actualBinding) {
            		if(node._attributes.items && node._attributes.items._bindings && node._actualBinding._createdBinding) {
                        node._attributes.items._bindings[del](node._actualBinding);
                    } 
                    if(node._actualBinding._forHelpers) {
                        node._actualBinding._forHelpers[del](node);
                    }
                    var multiplePrpty = node._removedAttributes.items._multipleProperty;
                    if(node._removedAttributes && node._removedAttributes.items && !node._removedAttributes.items.helperValue && multiplePrpty && multiplePrpty[0].actProp._forHelpers) {
                    	multiplePrpty[0].actProp._forHelpers[del](node);
                    }
            	}
            }
            node._items = [];
        } else {
        	if(node._helpers) {
                let keys = Object.keys(node._helpers);
                for(let i=0;i<keys.length;i++) {
                    for(let j=0;j<node._helpers[keys[i]].length;j++) {
                        this.removeHelpers(node._helpers[keys[i]][j], undefined, undefined, updateIndex, parentNode, type);
                    }
                    node._helpers[keys[i]] = [];
                }
            }
            for(var ind in node._forContent) {
                for(let i=0;i<node._forContent[ind].length; i++ ) {
                    node._forContent[ind][i].remove();
                }
            }
            let items = node._items;
            let key = node.getAttribute("key");
            for(let index in items){
                let item = items[index];
                let prop = item.itemProperty;
                let dynamicProp = item._dynamicProperty;
                for(let dP in dynamicProp) {
                    let property = this.getProperty(dP); 
                    if(property._helperNodes){
                        property._helperNodes[del](node);                    
                    }
                }
                if(prop) {
                    this.removeBindings({[key] : node._items[index].itemProperty}, {[key] : node._attributes.object[index]});
                }

            }
            if(!update) {
                if(node._actualBinding) {
                    if(node._attributes.object && node._attributes.object._bindings && node._actualBinding._createdBinding) {
                        node._attributes.object._bindings[del](node._actualBinding);
                    } 
                    if(node._actualBinding._forHelpers) {
                        node._actualBinding._forHelpers[del](node);
                    }
                }
                var multiplePrpty = node._removedAttributes.object._multipleProperty;
                if(node._removedAttributes.object && !node._removedAttributes.object.helperValue && multiplePrpty && multiplePrpty[0].actProp._forHelpers) {
                    multiplePrpty[0].actProp._forHelpers[del](node);
                }
                if(node._propBindingObject && node._attributes.object && node._attributes.object._bindings) {
                    node._attributes.object._bindings[del](node._propBindingObject);
                }
            }
            _LCSV.removeAll(isType, this, node, undefined, undefined, updateIndex, parentNode, type);
            node._items= {};
          }
        if((window.isLyteWidget || window.__lyteEnablePromise) && node._promiseContent){
            for(let s=0;s<node._promiseContent.length;s++) {
                node._promiseContent[s].remove();
            }
        }
        _LCHD.forRmHelpers(node);
        } else if(node._caseContent || node._yieldContent) {
        	if(node._helpers) {
                for(let j=0;j<node._helpers.length;j++) {
                    this.removeHelpers(node._helpers[j], undefined, undefined, updateIndex, parentNode, type);
                }
                node._helpers = [];
            }
        	if(node._caseContent){
                for(let i=0;i<node._caseContent.length; i++ ) {
                    node._caseContent[i].remove();
                }
                for(let key in node._dynamicProperty) {
                    if(node._dynamicProperty[key].isActualNode) {
                        node._dynamicProperty[key].isActualNode._helperNodes[del](node);
                    }else {
                        let helperNodes = this.getProperty(key)._helperNodes;
                        if(helperNodes) {
                            helperNodes[del](node);
                        }
                    }
                }
                node._dynamicProperty = {};
                //node._parentIf = null;
            } else {
                for(let i=0;i<node._yieldContent.length; i++ ) {
                    node._yieldContent[i].remove();
                }
                node._dynamicProperty = {};
            }
            _LCHD.ifRmHelpers(node);
            var pve = _LC.pendingViewPortElements;
            if(node._inPve && pve.length){
                let ind = pve.indexOf(_LC.getFakeTemplate(node));
                if(ind != -1){
                    pve.splice(ind,1);
                }
            }
            _LCSV.removeAll(isType,this, node, undefined, undefined, updateIndex, parentNode, type);
        } else if(node._renderedComponent) {
            for(let key in node._renderedComponent) {
                let comp = node._renderedComponent[key];
                if(comp) {
                    comp.constructor.prototype._disconnectedCallback.call(comp);
                    comp.remove();
                    node._renderedComponent[key] = null;
                }
            }
        }
          _LC.rmCx(node, contextSwitchArray);
    }
    
    updateYield(node, update, contextSwitchInfo) {
        if(!node._specialNodes){
            node._specialNodes = [];
        }
        let constr = this.constructor;
        let compConstr = this.component.constructor;
        if(!node._callee) {
            node._callee = this;
        }        
        let toAppend = node._callee._yields[node.getAttribute("yield-name")];
        if(!toAppend) {
        	return;
        }
        node._registerYield = toAppend;
        //ADded now
        let parentScope = toAppend._callee || node._callee._callee;
        if(!parentScope) {
            if(_Lyte._ms) {
                var div = createElement("div");
                div.innerHTML = toAppend.outerHTML;
                if(_Lyte._ie){
                    div.firstChild.innerHTML = toAppend.innerHTML;
                 }
                var content1 = div.childNodes[0];
                constr.splitTextNodes(content1);
                content1 = constr.createDocFragment1(content1);
                node.appendChild(content1);
            } else {
                node.appendChild(toAppend.content.cloneNode(true, "lyte"));    
            }
            
            node._helpers = [];
            return;
        }    
	    if(!toAppend._callee) {
    		toAppend._callee = parentScope;
    	} 
        node._dynamicProperty = node._dynamicProperty || {};
        //set values from child component. 
        let obj = {},contextSwitchingArray = {},self = this,contextSwitchArray = [];
        _LC.adCx(toAppend, contextSwitchArray);
        var cmpData = LyteComponent.getCmpData(parentScope.component.data);
        Object.keys(node._properties).forEach(function(key) {
            contextSwitchingArray[key] = {};
            contextSwitchingArray[key].value = cmpData[key];
            contextSwitchingArray[key].property = parentScope._properties[key];
            parentScope._properties[key] = node._properties[key];
            let nData = LyteComponent.getCmpData(node.component.data);
            cmpData[key] = nData[key];
        }); 
        // htA -> helpertemplateApplied
        if(!_Lyte._ms && toAppend._ht && !toAppend._htA) {
            toAppend._htA = true;
            toAppend.content.append(toAppend._ht.content.cloneNode(true));
        }
        let yieldComp = node._callee;
        let content = parentScope.renderNodes(toAppend, toAppend._dynamicNodes || [], node, {"node" : node}, true, undefined, toAppend._tC, yieldComp);
        if(!node.component.data.lyteUnbound) {      
            let nData = LyteComponent.getCmpData(node.component.data);   	
        	_LC.establishBindings(node._properties, nData);
        }
        parentScope.executeBlockHelpers(node._helpers);
        Object.keys(node._properties).forEach(function(key) {
            cmpData[key] = contextSwitchingArray[key].value;
            parentScope._properties[key] = contextSwitchingArray[key].property;
        });
        _LC.rmCx(toAppend, contextSwitchArray); 
        node.appendChild(content);
    }
    
     // It constructs/updates the dynamicComponent creation
    //upddc
    updateDynamicComponent(node, update, contextSwitchInfo, establishBindings,idx,helperNode) {
        if(!node._specialNodes){
            node._specialNodes = [];
        }
    	let returnVal;
        node._callee = this;
        let keepAlive = node.hasAttribute("lyte-keep-alive");
        if(!node._placeHolder){
            let emptyTextNode = document.createTextNode("");
            _LC.replaceWithPf(node, emptyTextNode);
            node._placeHolder = emptyTextNode;
            emptyTextNode._helper = node;
            // node._placeHolder.__lytehelper = node._placeHolder._helper;
            node._placeHolder._actTemplate = node;
            _LC.tDiv.content.appendChild(node);
            if(this._removedTemplate){
                this._removedTemplate.push(node);
            }else{
                this._removedTemplate=[];
                this._removedTemplate.push(node);
            }
        }
        if(!node._renderedComponent) {
            node._renderedComponent = {};
            let id = _LC.createLyteId(this);
            this.__dc[id] = node;
            node.__lyteId = id;
        }
        
        node._cx = contextSwitchInfo || node._cx;
        node._dynamicProperty = node._dynamicProperty || {};
        let componentName = node.getAttribute("component-name") || (node._attributes ? node._attributes["component-name"] : undefined);
        if(!componentName) {
            return;
        }
        let component,newComponent = false;
        if(update) {
        	if(keepAlive) {
                _LyteComponent._setIgnoreDisconnect(true)
        	}
            if(node._renderedComponent[node._currentComponent]) {
                let activeComponent = node._renderedComponent[node._currentComponent];
                keepAlive ? _LC.hDiv.content.appendChild(activeComponent) : activeComponent.remove();
            }
            _LyteComponent._setIgnoreDisconnect(false)
            if(!keepAlive) {
                node._dynamicProperty = {};
            }
            if(node._renderedComponent[componentName] && keepAlive) {
                component = node._renderedComponent[componentName];
            } else {
                let wdFlag = false;
                if(this.__widget){
                    ltCf.__widget = wdFlag = true;
                }
                component = createElement(componentName);
                if(wdFlag){
                    ltCf.__widget = false;
                }
                newComponent = true;
            }
        }  else {
            let wdFlag = false;
            if(this.__widget){
                ltCf.__widget = wdFlag = true;
            }
            component = createElement(componentName);
            if(wdFlag){
                ltCf.__widget = false;
            }
            newComponent = true;
        }
        if(!keepAlive && node._currentComponent) {
            node._renderedComponent[node._currentComponent] = null;
        }
        if(newComponent) {
//          let componentData = {};
            for(let i=0;i<node.attributes.length;i++) {
                if(node.attributes[i].name !== "is" && node.attributes[i].name !== "component-name" && node.attributes[i].name !== "lyte-keep-alive") {
                    component.setAttribute(node.attributes[i].name, node.attributes[i].value);
                }
            }
//          componentData = component._attributes;
            if(node._attributes) {
                for(var key in node._attributes) {
                	if(key!== "component-name") {
                		component.setData(_LC.String.toCamelCase(key), node._attributes[key]);
                	}
                }
            }
            let toAppend = this.renderNodes(node, node._dynamicNodes, node, undefined, establishBindings, undefined, node._tC);
            component.appendChild(toAppend);
        }
        if(newComponent) {
                component._toRegEvnts = node._toRegEvnts;
        }
        if(!update) {
        	returnVal = {"toAppendMain" : component, "lastNode" : node};
        } else {
            _LyteComponent._setIgnoreDisconnect(true)
            if(!node._placeHolder){
                insertBefore(node.parentNode,component, node);
            }else{
                insertBefore(node._placeHolder.parentNode,component, node._placeHolder); 
            } 
            _LyteComponent._setIgnoreDisconnect(false)
        }
        node._renderedComponent[componentName] = component;
        node._currentComponent = componentName;
	    component._callee = this;
        
	    component._actions = node._actions;
        component.setMethods(node._initMethods);
        component._attributeDetails = node._attributeDetails;
        component._boundEvents = node._boundEvents;
        component._cx = node._cx;
        return returnVal;
    }
    beforeUpdateFor(comp, helperNode, propValue, index){
        // let index = options.itemIndex;
        let propObj = helperNode._items[index].propProperty;
        if(!propObj[propValue]){
            propObj[propValue] = {};
        }
        if(!comp._properties[propValue]){
            comp._properties[propValue] = {};    
        }
        helperNode._properties = {[propValue] : propValue}; //to make it as dynamicnode in bindNode
        let oldProp = propObj[propValue];
        propObj[propValue] = comp._properties[propValue];
        comp._properties[propValue] = oldProp;
    }
    afterUpdateFor(comp ,helperNode,propValue,options){
        let index = options.itemIndex;
        let propObj = helperNode._items[index].propProperty;
        let oldProp = propObj[propValue];
        propObj[propValue] = this.getProperty(propValue);
        comp._properties[propValue] = oldProp;
    }
    //updFH
    // It constructs/updates the for helper. 
    updateForHelper(node, options, contextSwitchInfo, establishBindings, staticTempArr,yieldComp, initialRender) {
        let hasChild = node.hasAttribute("has-child");
        if(!node._specialNodes){
            node._specialNodes = [];
        }
        if(!node._propNodes){
            node._propNodes = {};
        }
        if(node.tagName !== "TEMPLATE") {
            Object.keys(node).forEach(function(item) {
            	if(item !== "innerHTML" && item !== "innerText") {
	                node._origTemplate[item] = node[item];            	
            	}
            });
            if(_Lyte._ie) {
            	var div = createElement("div");
                div.innerHTML = node._tC;
                node._origTemplate.innerHTML = div.children[0].innerHTML;
                this.constr.splitTextNodes(node._origTemplate);
                if(node.hasAttribute("depth")) {
                    node._origTemplate.setAttribute("depth", node.getAttribute("depth"));    
                }
            }
            let placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
            node._origTemplate.setAttribute("item", node.getAttribute("item"));
            node._origTemplate.setAttribute("index", node.getAttribute("index"));
            if((window.isLyteWidget || window.__lyteEnablePromise) && node.hasAttribute("has-child")){
                node._origTemplate.setAttribute("has-child", node.getAttribute("has-child"));
            }
            
            if(node.hasAttribute("unbound")) {
                //What if unbound is dynamic attribute ? It will be set in _attributes of node._origTemplate -> So No worries (y)
                node._origTemplate.setAttribute("unbound", "true");
            }
            //node.replaceWith(node._origTemplate._placeHolder);
            _LC.replaceWithPf(node, node._origTemplate._placeHolder);
            node = _LC.replaceWithOrigTemplate(node)
            // node = node._origTemplate;
            node.setAttribute("is", "for");
            _LC.apdNode(node, this);
            placeHolder._helper = node;
            
        } 
        // datasumma
        else if(!node._placeHolder){
            // var emptyTextNode = document.createTextNode("");
            //node.replaceWith(emptyTextNode);
            //to bind in ssr
            var emptyTextNode,tnode;
            
                emptyTextNode = document.createTextNode("");
                
            _LC.replaceWithPf(node, emptyTextNode)
            node._placeHolder = emptyTextNode;
            emptyTextNode._helper = node;
            _LC.apdNode(node, this);
        }
        node._sta = node._sta || staticTempArr;
        let callee = this;
        node._callee = this;
        node._attributes = node._attributes || {};
        if(options.type === "update" && node._currentItems === node._attributes.items && (!options || !options.force)) {
            return {};
        }
        node._cx = contextSwitchInfo || node._cx;
        let  indexValue = node.getAttribute("index");
        if(!indexValue) {
            node.setAttribute("index", "index");
            indexValue = "index";
        }
        let itemValue = node.getAttribute("item");
        if(!itemValue) {
            node.setAttribute("item", "item");
            itemValue = "item";
        }
        if(node.hasAttribute("dir-obj")){   
            node._dirObj = JSON.parse(node.getAttribute("dir-obj"));
        }
        let cmpData = LyteComponent.getCmpData(callee.component.data);
        let initialItemValue = cmpData[itemValue],initialIndexValue = cmpData[indexValue];
        let initialItemProp = callee._properties[itemValue],initialIndexProp = callee._properties[indexValue];
        callee._properties[itemValue] = callee._properties[indexValue] = {};
        let items = node._attributes.items,content = node.content,dynamicNodes = node._dynamicNodes,lastNode = node;
        if(!node._items) {
            node._items = [];
        }
        node._dynProps = node._dynProps || {};
        let lastIndexForIteration;
        let firstIndexForIteration;
        let firstIndex = options.firstIndex;
        let secondIndex = options.secondIndex;
        let thirdIndex = options.thirdIndex;
        var totalNodeIndex = firstIndex + secondIndex;
        var updateIndexProperty = true;
        var indexPropertyStartIndex = 0;
        if(options) {
            switch(options.type) {
            case "remove"  :{
                lastIndexForIteration = firstIndex;
                indexPropertyStartIndex = firstIndex;
                for(let i=firstIndex, v=secondIndex;v>0;v--, i++) {
                    this.removeHelpersSpecificIndex(node, i);
                }
                _LCSV.for.beforeUpdate(node, [firstIndex, secondIndex], [], []);
                //ln
                /*for(let i=(firstIndex)?firstIndex-secondIndex:firstIndex;i<node._items.length;i++) {
                    let forItem = node._items[i].itemProperty;
                    if(forItem._helperNodes){
                        for (var item of forItem._helperNodes){
                            let ind = item._cx.itemIndex;
                            item._cx.itemIndex = (ind)? ind- secondIndex : ind;
                        }
                    }
                }*/
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {        
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex - secondIndex;        
                }
                node._items.splice(firstIndex, secondIndex);
                node._helpers.splice(firstIndex, secondIndex);
                _LCSV.for.afterUpdate(node, [firstIndex, secondIndex], []);
                node._forContent.splice(firstIndex, secondIndex);
                node._specialNodes && node._specialNodes.splice(firstIndex, secondIndex);
                // node._propNodes && node._propNodes.splice(firstIndex, secondIndex);
                break;
            }
            case "insert" : {
                firstIndexForIteration = firstIndex;
                lastIndexForIteration = secondIndex;
                indexPropertyStartIndex = firstIndex + secondIndex;
                if(node._forContent[firstIndex]) {
                    lastNode = node._forContent[firstIndex][0];
                }
                let newArr = [], newObj = [], newArr1 = [], newPropObj = [];
                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {
                    newArr.push([]);
                    newObj.push({});
                    newArr1.push([]);
                    newPropObj.push({__dummy : true});
                }
                _LCSV.for.beforeUpdate(node, [firstIndex, 0], newPropObj, newObj);
                node._helpers.splice.apply(node._helpers, [firstIndex, 0].concat(newArr));
                node._items.splice.apply(node._items, [firstIndex, 0].concat(newObj));
                _LCSV.for.afterUpdate(node, [firstIndex, 0], newPropObj);
                //ln
//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
//                      let forItem = node._items[i].itemProperty;
//                      for (var item of forItem._helperNodes){
//                          item._cx.itemIndex = item._cx.itemIndex + secondIndex;
//                      }
//                  }
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex;
                }
                node._forContent.splice.apply(node._forContent, [firstIndex, 0].concat(newArr1));
                node._specialNodes && node._specialNodes.splice.apply(node._specialNodes,  [firstIndex, 0].concat(newArr1));
                // node._propNodes && node._propNodes.splice.apply(node._propNodes,  [firstIndex, 0].concat(newArr1));
            }
                break;
            case "replace" : {
                firstIndexForIteration = firstIndex;
                lastIndexForIteration = secondIndex;
                indexPropertyStartIndex = firstIndex + secondIndex;
                this.removeHelpersSpecificIndex(node, firstIndex); //removed bindning of prop of this node and child nodes - mean btn.ltProp , btn.some.some
                let newArr = [], newObj = [], newArr1 = [], newPropObj = [];
                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {
                    newArr.push([]);
                    newArr1.push([]);
                    newObj.push({});
                    newPropObj.push({__dummy : true});
                }
                _LCSV.for.beforeUpdate(node, [options.firstIndex, 1], newPropObj, newObj);
                let toAppendMain = createDocFragment();
                if(node._forContent[firstIndex+1]) {
                    lastNode = node._forContent[firstIndex+1][0];
                }
                node._helpers.splice.apply(node._helpers,[firstIndex, 1].concat(newArr));
                node._items.splice.apply(node._items, [firstIndex, 1].concat(newObj));
                _LCSV.for.afterUpdate(node, [options.firstIndex, 1], newPropObj);
//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
//                      let forItem = node._items[i].itemProperty._forItem;
//                      forItem.itemIndex = forItem.itemIndex + secondIndex - 1 ;
//                  }
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex - 1;
                }
                node._forContent.splice.apply(node._forContent, [firstIndex, 1].concat(newArr1));
                node._specialNodes && node._specialNodes.splice.apply(node._specialNodes,  [firstIndex, 1].concat(newArr1)); 
                // node._propNodes && node._propNodes.splice.apply(node._propNodes,  [firstIndex, 1].concat(newArr1)); 
                if(options.secondIndex == 1){
                    updateIndexProperty = false;
                }
                break;
            }
            case "splice" : {
                firstIndexForIteration = firstIndex;
                lastIndexForIteration = secondIndex;
                indexPropertyStartIndex = firstIndex + secondIndex;
                let newArr = [], newObj = [], newArr1 = [], newPropObj = [];
                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {
                    newArr.push([]);
                    newArr1.push([]);
                    newObj.push({});
                    newPropObj.push({__dummy : true});
                }
                for(let i=thirdIndex,j=0;i>0;i-- , j++) {
                    this.removeHelpersSpecificIndex(node, firstIndex + j);
                }
                _LCSV.for.beforeUpdate(node, [firstIndex, thirdIndex], newPropObj, newObj);
                let toAppendMain = createDocFragment();
                if(node._forContent[firstIndex+thirdIndex]) {
                    lastNode = node._forContent[firstIndex+thirdIndex][0];
                }
                node._helpers.splice.apply(node._helpers,[firstIndex, thirdIndex].concat(newArr));
                node._items.splice.apply(node._items, [firstIndex, thirdIndex].concat(newObj));
                _LCSV.for.afterUpdate(node, [firstIndex, thirdIndex], newPropObj);
//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
//                      let forItem = node._items[i].itemProperty._forItem;
//                      forItem.itemIndex = forItem.itemIndex + secondIndex - 1 ;
//                  }
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex - thirdIndex;
                }
                node._forContent.splice.apply(node._forContent, [firstIndex, thirdIndex].concat(newArr1));
                node._specialNodes && node._specialNodes.splice.apply(node._specialNodes,  [firstIndex, thirdIndex].concat(newArr1));
                // node._propNodes && node._propNodes.splice.apply(node._propNodes,  [firstIndex, thirdIndex].concat(newArr1));
                if(options.secondIndex == options.thirdIndex){
                    updateIndexProperty = false;
                }
                break;
            }
            break;
            case "update" : 
            {
                let key = node.getAttribute("item");
//                  this.removeHelpers(node, true);
                for(let i=0;i<node._items.length;i++) {
                    this.removeHelpersSpecificIndex(node, i);
                    _LCSV.for.update(node);
                }
//                  if(node._attributes.items) {
//                      for(let i=0;i<node._attributes.items.length && node._items[i];i++) {
//                          _LC.removeSelectedBindingDeep(node._items[i].itemProperty[key], node._attributes.items[i]);
//                      }
//                  }
                node._items = [];
        }
            case "default" : 
            {
                node._forContent = [];
                node._specialNodes = [];
                node._propNodes = {};
                node._helpers = [];
                firstIndexForIteration = 0;
                lastIndexForIteration = items? items.length : 0 ;
                indexPropertyStartIndex = items? items.length : 0 ;
            }
            break;
            default: 
            _Lyte.error("Error in updateForHelper");
            }
        }
        if(!lastNode) {
            lastNode = node;
        }
        if(lastNode != node && node._helpers.length > 0  && (options.type == "insert" ||"replace"|| "splice") ){
            lastNode = _LC.findLastNodeL(lastNode,totalNodeIndex,node);
        }
        let returnVal;
        var localUnbound = false;
        var initialUnbound = _LC.unbound;
        if(node.hasAttribute("unbound") || (node._attributes && node._attributes.unbound && node._attributes.unbound !== "false") ) {
            localUnbound = true;
            _LC.unbound = true;
        }
        if(!node._fRender && (node.getAttribute("unbound") == "lyteFastRender" || (node._attributes && node._attributes.unbound == "lyteFastRender"))) {
            node._fRender = true;
        }
        node._currentItems = items;        
        if(!_Lyte._ms && ((lastIndexForIteration - firstIndexForIteration) > 0) || ((window.isLyteWidget || window.__lyteEnablePromise) && items instanceof Promise)) {
            if(node._ht && !node._htA) {
                node.content.append(node._ht.content.cloneNode(true));
                node._htA = true;
            }
        }
        let currentCaseName;
        var dirObjData = {data : {},prop : {}};
        var dirObjProp = {data : {},prop : {}};
        let trueNode = node;
        if(options.type !== "remove") {
            var totalString = "";
            var domArr = [];
            var toAppendMain = createDocFragment();
            if(hasChild && (window.isLyteWidget || window.__lyteEnablePromise)){
                let scope,renderPromiseNodes = true;
                let status = items instanceof Promise ? items.__lyte.status : "resolved";
                switch(status){
                    case "init" : {
                        currentCaseName = '__lyteAwait__';
                    } break;
                    case "resolved" : {
                        currentCaseName = 'true';
                        renderPromiseNodes = false;
                    } break;
                    case "rejected" : {
                        currentCaseName = '__lyteFail__';
                    } break;
                        
                }
                if(node._promiseContent && node._promiseContent.length) {
                    this.removeHelpers(node, undefined, true);
                }
                trueNode = node.content.querySelector("[case="+ currentCaseName +"]");
                scope = node._cases[currentCaseName];
                trueNode._ht = scope._ht;
                if(trueNode._ht && !trueNode._htA) {
                    trueNode.content.append(trueNode._ht.content.cloneNode(true));
                    trueNode._htA = true;
                }
                dynamicNodes = scope.dynamicNodes;
                if(renderPromiseNodes){
                    this.renderPromiseNodes(trueNode, dynamicNodes, node, {}, establishBindings, undefined, node._tC,yieldComp,toAppendMain);
                }
            }
            _LCSV.beforeDirObj(node, dirObjData, dirObjProp);
            for(let k = firstIndexForIteration,v=lastIndexForIteration;v>0; k++, v--) {
                node._helpers[k] = [];
                node._specialNodes[k] = [];
                node._items[k] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}, "propProperty" : {},"propPropertyDyn" : {}, "propNodes" : {}};
                cmpData[itemValue] = items[k];
                cmpData[indexValue] = k;
                var cacheData = {};
                cacheData[itemValue]={}
                cacheData[itemValue]._data = items[k];
                cacheData[itemValue]._dyn = [itemValue];
                cacheData[indexValue]={}
                cacheData[indexValue]._data = k;
                cacheData[indexValue]._dyn = [indexValue];
                callee._properties[itemValue] = {};
                callee._properties[indexValue] = {};
                let optns = {"itemValue" : itemValue, "itemIndex" : k, "type" : "for", "node" : node, "indexValue" : indexValue};
//                  defProp(callee._properties[itemValue], '_forItem', {
//                      enumerable: false, 
//                      writable: true, 
//                      configurable: true, 
//                      value : optns
//                  });
                node._items[k]._cx = optns;
                let breakCheck = {};
                let toAppend;
                if(node._fRender) {
                    let str = this.renderFast(dynamicNodes, node._sta, this.component);
                    totalString = totalString + str;
                    // var template = document.createElement("template");
                    // template.innerHTML = str;
                    // toAppend = template.content;
                } else {
                    dynamicNodes._cache = cacheData;
                    toAppend = this.renderNodes(trueNode.hasAttribute("depth") && trueNode._depthTemp ? trueNode._depthTemp : trueNode, dynamicNodes, node, optns, establishBindings, breakCheck, node._tC,yieldComp);
                }
    
                    //to bind in ssr components
                    
                let dynProps = Object.keys(node._items[k]._dynamicProperty);
                for(let d=0;d<dynProps.length;d++) {
                    let key = dynProps[d];
                    node._dynProps[key] ? node._dynProps[key]++ : (node._dynProps[key] = 1);    
                }
                node._items[k].itemProperty = this.getProperty(itemValue);
                node._items[k].indexProperty = this.getProperty(indexValue);    
//                  if(options.type !== "default") {
                if(!_LC.unbound) {
                	_LC.establishBindings({[itemValue] : node._items[k].itemProperty},{[itemValue]:node._attributes.items[k]});
                    // for(let propName in node._items[k].propProperty){
                    //     _LC.establishBindings({[propName] : this.getProperty(propName)} ,this.component.data);    
                    // }
                }
//                  }
                if(!node._fRender){
                    node._forContent[k] = Array.from(toAppend.childNodes);
                } else {
                    domArr.push(node._forContent[k] = []);
                }
                //Needs to revisit this and make sure it happen within renderNodes function itself;
//                  if(options.type !== "update") {
                this.executeBlockHelpers(node._helpers[k],node);
                if(!node._fRender) {
                    toAppendMain.appendChild(toAppend);
                }
                if(breakCheck.stop) {
                    break;
                }
            }
            if(node._fRender) {
                var s = document.createElement("template");
                s.innerHTML = totalString;
                toAppendMain.appendChild(s.content);
                _LC.processAction(toAppendMain);
                var childrenArr;
                if(_Lyte._ie) {
                    childrenArr = [];
                    var childNodes = toAppendMain.childNodes;
                    for(var i=0;i<childNodes.length;i++) {
                        if(childNodes[i].nodeType == 1) {
                            childrenArr.push(childNodes[i]);
                        }
                    }
                } else {
                    childrenArr = toAppendMain.children;
                }
                for(var i=0;i<domArr.length;i++) {
                    domArr[i].push(childrenArr[i]);
                }
                requestAnimationFrame(function() {
                    requestAnimationFrame(function() {
                        _LC.callCC();
                    });
                });
            }
            //Provided so that before appending the component to DOM it is reset to previous value
            _LC.unbound = initialUnbound;
            if(options.type === "default") {
                returnVal = {"toAppendMain" : toAppendMain, "lastNode" : lastNode};
            } else {
                //lastNode.parentNode.insertBefore(toAppendMain, lastNode);
                if(lastNode._placeHolder) {
                	insertBefore(lastNode._placeHolder.parentNode, toAppendMain, lastNode._placeHolder);                	
                } else {
                	insertBefore(lastNode.parentNode,toAppendMain, lastNode);                
                }     
            }
            if(!localUnbound && node._removedAttributes && node._removedAttributes.items && !node._removedAttributes.items.helperValue && node._removedAttributes.items._multipleProperty) {
            	_LC.establishBindings({"items" : node._removedAttributes.items._multipleProperty[0].actProp}, {"items" : items});
            }
        }
        _LC.unbound = initialUnbound;
        if(updateIndexProperty){
            for(let i=indexPropertyStartIndex; i<node._items.length; i++) {
                if(node._items[i].indexProperty) {
                    _LC.affectChanges(node._items[i].indexProperty);
                }
            }
        }
        cmpData[itemValue] = initialItemValue;
        cmpData[indexValue] = initialIndexValue;
        callee._properties[itemValue] = initialItemProp;
        callee._properties[indexValue] = initialIndexProp;
        _LCSV.afterDirObj(node, dirObjData, dirObjProp);
        _LCSV.afterRender(node,this,dirObjProp,options,initialRender);
        node._currentItems = items;
        return returnVal;
    }
    renderPromiseNodes(trueNode, dynamicNodes, node, optns, establishBindings, returnVal, templateContent,yieldComp,toAppendMain){
        let toAppend = this.renderNodes(trueNode, dynamicNodes, undefined,/*node,*/ {}, establishBindings, undefined, templateContent,yieldComp);
        node._promiseContent = [];
        let contentArr = [toAppend];
        for(let i=0;i<contentArr.length;i++) {
            if(contentArr[i].nodeType == 11){
                node._promiseContent = node._promiseContent.concat(Array.from(contentArr[i].childNodes));
            }
            else{
                node._promiseContent.push(contentArr[i]);
            }
            toAppendMain.append(contentArr[i]);
        }
    }
    //It constructs/updates forIn Helper.
    //updFIH
    updateForInHelper(node, options, contextSwitchInfo, establishBindings,yieldComp, initialRender) {
        let hasChild = node.hasAttribute("has-child");
        if(!node._specialNodes){
            node._specialNodes = [];
        }
        if(!node._propNodes){
            node._propNodes = {};
        }
        if(node.tagName !== "TEMPLATE") {
            Object.keys(node).forEach(function(item) {
                if(item !== "innerHTML" && item !== "innerText") {
	                node._origTemplate[item] = node[item];            	
            	}
            });
            if(_Lyte._ie) {
            	var div = createElement("div");
                div.innerHTML = node._tC;
                node._origTemplate.innerHTML = div.children[0].innerHTML;
                this.constr.splitTextNodes(node._origTemplate);
                if(node.hasAttribute("depth")) {
                    node._origTemplate.setAttribute("depth", node.getAttribute("depth"));
                }
            }
            let placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
            node._origTemplate.setAttribute("key", node.getAttribute("key"));
            node._origTemplate.setAttribute("value", node.getAttribute("value"));
            if(node.hasAttribute("unbound")) {
                //What if unbound is dynamic attribute ? 
                node._origTemplate.setAttribute("unbound", "true");
            }
            if((window.isLyteWidget|| window.__lyteEnablePromise) && node.hasAttribute("has-child")){
                node._origTemplate.setAttribute("has-child", node.getAttribute("has-child"));
            }
            
            //node.replaceWith(node._origTemplate._placeHolder);
            _LC.replaceWithPf(node, node._origTemplate._placeHolder)
            node = _LC.replaceWithOrigTemplate(node)
            // node = node._origTemplate;
            node.setAttribute("is", "forIn");
            _LC.apdNode(node, this);
            placeHolder._helper = node;
        } else if(!node._placeHolder){
            // var emptyTextNode = document.createTextNode("");
            //node.replaceWith(emptyTextNode);
            //to bind in ssr
            var emptyTextNode;
            
                emptyTextNode = document.createTextNode("");
                
            _LC.replaceWithPf(node, emptyTextNode);
            node._placeHolder = emptyTextNode;
            _LC.apdNode(node, this);
            emptyTextNode._helper = node;
        }
        let callee = this;
        node._callee = this;
        node._attributes = node._attributes || {};
        if(options.type === "update" && node._currentObject === node._attributes.object && (!options || !options.force)) {
            return {};
        }
        contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : node._cx;
        node._cx = contextSwitchInfo;
        let key = node.getAttribute("key");
        if(!key) {
            key = "key";
            node.setAttribute("key", "key");
        }
        let value = node.getAttribute("value");
        if(!value) {
            value = "value";
            node.setAttribute("value", "value");
        }
        _LCSV.setDirObj(node);
        let cmpData = LyteComponent.getCmpData(callee.component.data);
        let initialKeyValue = cmpData[key];
        let initialValueValue = cmpData[value];
        let initialKeyProp = callee._properties[key];
        let initialValueProp = callee._properties[value];
        callee._properties[key] = callee._properties[value] = {};
        let object = node._attributes.object;
        let content = node.content;
        let dynamicNodes = node._dynamicNodes;
        let lastNode = node;
        let keysArray = [];
        if(!node._items) {
            node._items = {};
        }
        node._dynProps = node._dynProps || {};
        if(options) {
            switch(options.type) {
            case "delete"  :{
                this.removeHelpersSpecificIndex(node, options.property, undefined, options.type);
                _LCSV.forIn.delete(node, options);
                var delIndex = node._keysArray.indexOf(options.property);
                if(delIndex > -1) {
                  node._keysArray.splice(delIndex,1);
                }
                if(node._helpers) {
                    delete node._helpers[options.property];    
                }
                delete node._propBindingObject[options.property];
                node._forContent[options.property] = null;
                delete node._forContent[options.property];
            }
            break;
            case "add" : {
                let replace = false;
                keysArray = [options.property]; //what if options.propety is array
                replace = node._keysArray.indexOf(options.property) != -1 ? true : false;
                !replace && node._keysArray.push(options.property);
                let returnedLastNode = _LCSV.forIn.add(node, options, keysArray, replace);
                if(returnedLastNode){
                    lastNode = returnedLastNode
                }
            }
            break;
            case "update" : 
            {
                node._keysArray.forEach(function (itemKey, index, array) {
                    this.removeHelpersSpecificIndex(node, itemKey, undefined, options.type);
                }, this);
                _LCSV.forIn.update(node);
                node._keysArray = keysArray = object ? Object.keys(object) : [];
                node._helpers = {};
                node._items = {};
                node._propBindingObject = {};
            }
            // break;
            case "default" : 
            {
                node._forContent = {};
                node._specialNodes = {};
                node._propNodes = {};
                node._helpers = {};
                node._keysArray = keysArray = object? Object.keys(object) : [];
//                  keysArray = Object.keys(object);

            }
            break;
            default: 
            _Lyte.error("Error in updateForHelper");  

            }
        }
        let returnVal;
        if(!object) {
            let toAppendMain = createDocFragment();
            if(options.type !== "default") {
            	insertBefore(lastNode.parentNode,toAppendMain, lastNode);
            } else {
                returnVal = {"toAppendMain" : toAppendMain, "lastNode" : lastNode};
            }    
        }
        let localUnbound = false;
        let initialUnbound = _LC.unbound;
        if(node.hasAttribute("unbound") || (node._attributes && node._attributes.unbound)) {
            localUnbound = true;
            _LC.unbound = true;
        }
        node._currentObject = object;
        if(!_Lyte._ms && (keysArray.length || ((window.isLyteWidget || window.__lyteEnablePromise) && object instanceof Promise)) && node._ht && !node._htA) {
            node.content.append(node._ht.content.cloneNode(true));
            node._htA = true;
        }
        let currentCaseName;
        let trueNode = node;
        var dirObjData = {data : {},prop : {}};
        var dirObjProp = {data : {},prop : {}};
        if(object && options.type !== "remove") {
            var toAppendMain = createDocFragment();
            node._propBindingObject = node._propBindingObject || {};
            if(hasChild && (window.isLyteWidget || window.__lyteEnablePromise)){
                let scope,renderPromiseNodes = true;
                let status = object instanceof Promise ? object.__lyte.status : "resolved";
                switch(status){
                    case "init" : {
                        currentCaseName = '__lyteAwait__';
                    } break;
                    case "resolved" : {
                        currentCaseName = 'true';
                        renderPromiseNodes = false;
                    } break;
                    case "rejected" : {
                        currentCaseName = '__lyteFail__';
                    } break;
                        
                }
                if(node._promiseContent && node._promiseContent.length) {
                    this.removeHelpers(node, undefined, true);
                }
                trueNode = node.content.querySelector("[case="+ currentCaseName +"]");
                scope = node._cases[currentCaseName];
                trueNode._ht = scope._ht;
                if(trueNode._ht && !trueNode._htA) {
                    trueNode.content.append(trueNode._ht.content.cloneNode(true));
                    trueNode._htA = true;
                }
                dynamicNodes = scope.dynamicNodes;
                if(renderPromiseNodes){
                    this.renderPromiseNodes(trueNode, dynamicNodes, node, {}, establishBindings, undefined, node._tC,yieldComp,toAppendMain);
                }
            }
            _LCSV.beforeDirObj(node, dirObjData, dirObjProp);
            keysArray.forEach(function(itemKey, index, array) {
                node._helpers[itemKey] = [];
                node._specialNodes[itemKey] = [];
                node._items[itemKey] = {"_dynamicProperty" : {}, "itemProperty" : {}, "propProperty" : {}, "propPropertyDyn" : {}, "propNodes" : {}};
                cmpData[key] = itemKey;
                cmpData[value] = object[itemKey];
                callee._properties[key] = {};
                callee._properties[value] = {};
                var cacheData = {};
                cacheData[key] = {}
                cacheData[key]._data = itemKey;
                cacheData[key]._dyn = [key];
                cacheData[value] = {}
                cacheData[value]._data = object[itemKey];
                cacheData[value]._dyn = [value];
                let optns = {"itemIndex" : itemKey, "itemValue" : value, "keyValue" : key, "type" : "forIn", "node" : node};
                node._items[itemKey]._cx = optns;
                dynamicNodes._cache = cacheData;
                let toAppend = this.renderNodes(trueNode.hasAttribute("depth")&& trueNode._depthTemp ? trueNode._depthTemp : trueNode, dynamicNodes, node, optns, establishBindings, undefined, node._tC,yieldComp);
                Object.keys(node._items[itemKey]._dynamicProperty).forEach(function(key) {
                    node._dynProps[key] ? node._dynProps[key]++ : (node._dynProps[key] = 1);    
                })
                node._items[itemKey].itemProperty = this.getProperty(value);
                node._propBindingObject[itemKey] = node._items[itemKey].itemProperty;
                node._forContent[itemKey] = Array.from(toAppend.childNodes);
//                    this.updateBlockHelpers(node._helpers[itemKey], optns);
                this.executeBlockHelpers(node._helpers[itemKey],node);
                    
                    //to bind in ssr components
                    
                toAppendMain.appendChild(toAppend);
            }, this); 
//              if(options.type !== "update") {
            	if(!_LC.unbound) {
            		// makeSet(node._attributes.object, "_bindings");
                    addBindings(node._attributes.object,node._propBindingObject);
                    _LC.establishBindings(node._propBindingObject, node._attributes.object);
            	}
//              }
				_LC.unbound = initialUnbound;
                if(options.type !== "default") {
                    //lastNode.parentNode.insertBefore(toAppendMain, lastNode);
                    if(lastNode._placeHolder) {
                    	insertBefore(lastNode._placeHolder.parentNode,toAppendMain, lastNode._placeHolder);                    
                    } else {
                    	insertBefore(lastNode.parentNode,toAppendMain, lastNode);
                    }
                } else {
                    returnVal = {"toAppendMain" : toAppendMain, "lastNode" : lastNode};
                }

        }
        _LC.unbound = initialUnbound; 
        cmpData[key] = initialKeyValue;
        cmpData[value] = initialValueValue;
        callee._properties[key] = initialKeyProp;
        callee._properties[value] = initialValueProp;
        _LCSV.afterDirObj(node, dirObjData, dirObjProp)
        _LCSV.afterRender(node,this,dirObjProp,options,initialRender);
        node._currentObject = object;
        return returnVal;
    }
   //updSH
   updateSwitchHelper(type,node, contextSwitchInfo, update, establishBindings,yieldComp, id, toBeInsMap){
        // let hasChild = node.hasAttribute("has-child");
        if(!node._specialNodes){
            node._specialNodes = [];
        }
        if(!_Lyte._ms && node._ht && !node._htA) {
            node.content.append(node._ht.content.cloneNode(true));
            node._htA = true;
        }
        if(node.tagName !== "TEMPLATE") {
            Object.keys(node).forEach(function(item) {
            	if(item !== "innerHTML" && item !== "innerText") {
            		node._origTemplate[item] = node[item];
            	}
            });
            if(_Lyte._ie) {
            	var div = createElement("div");
                div.innerHTML = node._tC;
                node._origTemplate.innerHTML = div.children[0].innerHTML;
                this.constr.splitTextNodes(node._origTemplate);
                if(node.hasAttribute("depth")) {
                    node._origTemplate.setAttribute("depth", node.getAttribute("depth"));    
                }
            }
            let placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
            //node.replaceWith(node._origTemplate._placeHolder);
            _LC.replaceWithPf(node, node._origTemplate._placeHolder);
            // node = node._origTemplate;
            node = _LC.replaceWithOrigTemplate(node)
            node.setAttribute("is", type);
            _LC.apdNode(node, this);
            placeHolder._helper = node;
        } else if(!node._placeHolder){
            var emptyTextNode;
            //node.replaceWith(emptyTextNode);
            
                emptyTextNode = document.createTextNode("");
                
            _LC.replaceWithPf(node, emptyTextNode);
            node._placeHolder = emptyTextNode;
            emptyTextNode._helper = node;
            _LC.apdNode(node, this);
        }
        let isNew = false;
        let lastNode = node;
        if(!node._callee) {
            node._callee = this;
            isNew = true;
        }
        contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : node._cx;
        node._cx = contextSwitchInfo;
        node._dynamicProperty = node._dynamicProperty ? node._dynamicProperty : {};
        let currentCaseName;
        let value;
        if(node.getAttribute("value")=== "" || node.getAttribute("value")) {
            value = node.getAttribute("value");
        } else if(node._attributes) {
            value = node._attributes.value;
        }
        // if(node._currentCase && value === node._currentCase){
        //     return;
        // }
        if(value) {
            let status = value instanceof Promise ? value.__lyte.status : "resolved";
            switch(status){
                case "init" : {
                    currentCaseName = '__lyteAwait__';
                } break;
                case "rejected" : {
                    currentCaseName = '__lyteFail__';
                } break;
                case "resolved" : {
                    // currentCaseName = 'true';
                    // renderPromiseNodes = false;
                    currentCaseName = type === "if" ? "true" : value.toString();
                }
            }
        } else {
            if(type=== "if")  {
                currentCaseName = "false";
            } else {
                switch(value) {
                case undefined : 
                    currentCaseName = "undefined";
                    break;
                case null : 
                    currentCaseName = "null";
                    break;
                case false: 
                    currentCaseName = "false";
                    break;
                case "": 
                    currentCaseName = '""';
                    break;
                case 0 : 
                    currentCaseName = '0';
                }
            }
        }
        if(currentCaseName === node._currentCase) {
            return;
        }
        node._currentCase = currentCaseName;
        var nodeTemp = node._depthTemp || node;
//        let currentCase = node.content.querySelector('[case=\''+currentCaseName+'\']'),scope;
        let scope = node._cases[currentCaseName];
        let defaultContent;
        if(!scope){
            scope = node._default;
            defaultContent = (_Lyte._ms) ? scope.templateContent : nodeTemp.content.querySelector('[default]');
            if(!_Lyte._ms && scope._ht && !defaultContent._htA) {
                defaultContent._htA = true;
                defaultContent.content.append(scope._ht.content.cloneNode(true));
            }
            node._isDefault = true; 
            if(!defaultContent) {
                if(node._caseContent && node._caseContent.length) {
                    this.removeHelpers(node, undefined, true);
                }
                node._caseContent = [];
                let emptyTextNode = document.createTextNode("");
                node._caseContent.push(emptyTextNode);
                node._currentCaseName = currentCaseName;
                node._helpers = node._helpers || [];
                if(update) {
                	//lastNode.parentNode.insertBefore(emptyTextNode, node);
                    if(lastNode._placeHolder) {
                    	insertBefore(lastNode._placeHolder.parentNode,emptyTextNode, lastNode._placeHolder);                    
                    } else {
                    	insertBefore(lastNode.parentNode,emptyTextNode, node);
                    }
                	return;
                } else {
                	let toAppendMain = createDocFragment();
                	toAppendMain.append(emptyTextNode);
                	return {lastNode : lastNode, toAppendMain : toAppendMain};
                }
            }
        }
        
//        if(currentCase) {
//              if(currentCase.tagName === "TEMPLATE" && !currentCase.getAttribute("is")){
//                  currentCase = currentCase.content;
//              } else {
//                  let temp = createElement('template');
//                  let clone = currentCase.cloneNode(true);
//                  temp.content.appendChild(clone);
//                  currentCase.removeAttribute('slot');
//                  currentCase = temp.content;
//              }
//              scope.content = currentCase;
//        }
 
        if(node._caseContent && node._caseContent.length) {
            this.removeHelpers(node, undefined, true);
        }
        let dummyScope = scope;
        let additionalContentArr = [];
        let cnt=0;
        let dummyCaseName = currentCaseName;
        let template;
        if(defaultContent) {
            template = defaultContent
        } else {
            template = (_Lyte._ms) ? {} : nodeTemp.content.querySelector('[case=\''+_LC.cssEscape(dummyCaseName)+'\']');
        }
        let contentArr = [];
        while(dummyScope) {
            if(!_Lyte._ms && dummyScope._ht && !template._htA) {
                template._htA = true;
                template.content.append(dummyScope._ht.content.cloneNode(true));
            }
            let dynamicNodes = dummyScope.dynamicNodes;
            let compName = template.getAttribute("render-view-port-template");
            if(compName){
                let compConstr = LyteComponent._registeredComponents[compName];
                if(compConstr){
                    let preTemp = compConstr.component._preRenderTemplate;
                    if(!preTemp){
                        _Lyte.error("Viewport template for the component '" + compName + "' not found.");
                    }
                    let root = preTemp.getAttribute("root");
                    let viewTempContent = preTemp.content.cloneNode(true);
                    !root && template.content.appendChild(document.createElement("dummy-view-port"));
                    template.content.appendChild(viewTempContent);
                    root && template.content.appendChild(document.createElement("dummy-view-port"));
                }else{
                    _Lyte.error("Unable to load viewport template for the component '" + compName + "' . Since it is not registered yet.");
                }
            }
            let processedContent = this.renderNodes(template, dynamicNodes, node, undefined, establishBindings, undefined, dummyScope.templateContent,yieldComp);
                
                //to bind ssr in if/switch
                
                
            contentArr.push(processedContent);
            if(dummyScope.additional) {
                if(dummyScope.additional.next) {
                    template = (_Lyte._ms) ? {} : node.content.querySelector('[case=\''+_LC.cssEscape(dummyScope.additional.next)+'\']');
                    dummyScope = node._cases[dummyScope.additional.next];
                } else {
                    template = (_Lyte._ms) ? {} : node.content.querySelector('[default]');
                    dummyScope = node._default;
                }
            } else {
                    break;
            }
        }
        node._caseContent = [];
        let toAppendMain = createDocFragment();;
        for(let i=0;i<contentArr.length;i++) {
            if(contentArr[i].nodeType == 11){
//                for(let j=0;j<contentArr[i].childNodes.length;j++) {
//                    node._caseContent.push(contentArr[i].childNodes[j]);
//                }
                node._caseContent = node._caseContent.concat(Array.from(contentArr[i].childNodes));
            }
            else{
                node._caseContent.push(contentArr[i]);
            }
                toAppendMain.append(contentArr[i]);
//            node.parentNode.insertBefore(contentArr[i], node);
        }
          this.executeBlockHelpers(node._helpers, node);
          if(update) {
        	  let returnVal;
        	  if(toAppendMain.querySelector("template[is=break]")) {
        		  returnVal = "break";
        	  } else if(toAppendMain.querySelector("template[is=continue]")) {
        		  returnVal = "continue";
        	  }
        	  //node.parentNode.insertBefore(toAppendMain, node);
              if(node._placeHolder) {
            	  insertBefore(node._placeHolder.parentNode,toAppendMain, node._placeHolder);              
              } else {
            	  insertBefore(node.parentNode,toAppendMain, node);
              }
        	  return returnVal;
          } else {
        	  return {"toAppendMain" : toAppendMain, "lastNode" : node};
          }
    }
    
    dummy(a,b) {
        let dummy = this.constr._properties[boundValue].observer;
    }
    
    callObservers(boundValue, key) {
        let property = this.constr._properties[boundValue];
        let observers = property?property.observer: undefined;
        if(observers) {
            for(let i=0;i<observers.length;i++) {
                if(key.indexOf('.') === -1 || observers[i].path === key) {
                    this["_"+observers[i].functionName].apply(this);
                }
            }
        }
    }
    
    static updateValue(property, path, value) {
        let pathVals = path.split('.');
        let context = property;
        for(let i=0;i<pathVals.length -1;i++) {
            context = context[pathVals[i]];
        }
        context[pathVals[i]] = value;
    }
    
//    static createDocFragment(template){
//        let childNodes = template.cloneNode(true,"lyte").childNodes;
////           let childNodes = template.childNodes;
//        let frag = document.createDocumentFragment();
//        let len = childNodes.length;
//        for(let i=0; i<len; i++){
//            frag.appendChild(childNodes[0]);
//        }
//        return frag;
//    }
    
    static createDocFragment1(template) {
        if(template.content) {
            return template.content;
        }
    	let childNodes = template.childNodes;
    	let frag = createDocFragment();
    	let len = childNodes.length;
    	for(let i=0; i<len; i++){
            frag.appendChild(childNodes[0]);
        }
    	return frag;
    }
    
    static* _registerComponentFn(a,b, widget) {
        if(_LC._reRegisteredComponents.indexOf(a) != -1){
            b.component._template = JSON.parse(b.component._template);
            if(Lyte.getConfig("lazyComponentRegister")){
                _LC._reRegisteredComponents.splice(_LC._reRegisteredComponents.indexOf(a),1);
            }
        }
        if(widget) {
            window.widgetComps = window.widgetComps || {};
            var currWidgetComps = window.widgetComps[widget] = window.widgetComps[widget] || [];
            currWidgetComps.push(a);
        }
        this.__widgetName = widget; 
        let componentsDiv = _LC.lyteComponentsDiv;
        let styleDiv = _Lyte.$.assetsDiv;
        let origTemplateValue = this.component._template;
        var clonedDummyTemp;
        var newCompile;
        var ta;
        var _temp;
        var styleTags;
        let div = createElement("div");
        var hasUnbound, s
        yield () => {
            if(this.component._template && typeof this.component._template === "string"){
                this.component._template.replace(/\\'/g,"'");
                div.innerHTML = this.component._template;
                if(widget) {
                    styleTags = document.createElement("template");
                }
                while(div.firstChild){
                    if(div.firstChild.nodeName === "STYLE") {
                        if(styleDiv.querySelector("style[from-component='"+a+"']")){
                            styleDiv.querySelector("style[from-component='"+a+"']").remove();
                        }
                        div.firstChild.setAttribute("from-component",a);
                        styleTags && styleTags.content.appendChild(div.firstChild.cloneNode(true));
                        styleDiv.appendChild(div.firstChild);
                    } else {
                        if(div.firstChild.tagName == "TEMPLATE") {
                            _temp = div.firstChild;
                        }
                        componentsDiv.appendChild(div.firstChild);
                    }
                }
    /*        } else if(document.querySelector("#" + a)) { */
            } else if(document.querySelector("template[tag-name='"+a+"']")) {
                _temp = document.querySelector("template[tag-name='"+a+"']");
                componentsDiv.appendChild(_temp);
            }
            this.component._template = _temp;
            if(widget){
                this.component._template.setAttribute("widget", widget);
                this.component._template._widgetStyles = styleTags;
            }
            this.component._template.class = this;
            this.component._template.widget = widget;
            this._helperTemplate = document.createElement("template");
            this._helperTemplate.setAttribute("_lyteht", a );
            _LC.h1Div.content.appendChild(this._helperTemplate);
            if(!this.component._template) {
                return;
            }
            if(_LC.needDummyComponentsDiv) {
                if(_Lyte._ie) {
                    let temp = _Lyte.Compile.getTemplateFromString(origTemplateValue);
                    _LC.dummyLyteComponentsDiv.appendChild(temp);
                } else {
                    clonedDummyTemp = this.component._template.cloneNode(true); 
                }
            }
            if(this.component._template && !this.component._template.content){
                // console.log("Dummy")
    //            var frag = document.createDocumentFragment();
    //            let childNodes = this._template.cloneNode(true,"lyte").childNodes;
    //            //let childNodes = this._template.childNodes;
    //            let len = childNodes.length;
    //            for(let i=0; i<len; i++){
    //                frag.appendChild(childNodes[0]);
    //            }
    //            this._template.content = frag;
            }
            hasUnbound = this.component._observedAttributes.indexOf("lyteUnbound") !== -1;
            s = _Lyte._ie ? this.component._template : this.component._template.content;//)?this._template.content:document.createDocumentFragment(this._template);
            //This is used to split text nodes which contain multiple dynamic values 
            //Eg." Name is {{name}} and age is {{age}} "
            if(hasUnbound) {
                if(_Lyte._ie) {
                    newCompile = document.createElement("div");
                    newCompile.innerHTML = this._template.outerHTML;
                    newCompile = newCompile.childNodes[0];
                } else {
                    newCompile = this.component._template.cloneNode(true);
                }
            }
            this.splitTextNodes(s);
            if(hasUnbound) {
                this.splitTextNodes(newCompile);
            }
            //This is used to find the dynamicNodes and helper nodes for the given component. 
            if(!this.component._dynamicNodes){
                if(_Lyte.Compile.getDynamicNodes) {
                    var returnVal = _Lyte.Compile.getDynamicNodes(a, undefined, _Lyte._ie ? s : undefined);
                    if(returnVal.errors){
                        console.error("Error in the component",returnVal.componentName,returnVal.errors);
                        return false;
                    }else{
                        this.component._dynamicNodes = returnVal.dynamicNodes;
                    }
                } else {
                    _Lyte.error("LC002", a);  
                }
            } 
        }
        if(!this.component._dynamicNodes) {
            yield "";
        }
        else {
            yield* doCompile(s, this.component._dynamicNodes, a, this, newCompile ? (_Lyte._ie  ? newCompile : newCompile.content) : undefined);
            // var gnxt = generator.next(), gval, retVal;
            // while(gnxt && gnxt.done == false){
            //     gval = gnxt.value;
            //     if(typeof gval == "function"){
            //         retVal = gval();
            //     }
            //     gnxt = generator.next()
            // }
            yield () => {
                if(_Lyte._ed) { 
                    this._tC = this.component._tC = this.component._template.outerHTML;
                } else if(_Lyte._ie) {
                    this._tC = this.component._tC = s.outerHTML;
                }
                this.component._templateAttributes = this.component._templateAttributes || {type : "attr", "attr" : {}, position: []};
                ta = [this.component._templateAttributes];
            }
            yield* doCompile(this.component._template, ta, a, this);
            // var gnxt, gval;
            // while(gnxt = gtr.next() && gnxt.done == false){
            //     gval = gnxt.value;
            //     if(typeof gval == "function"){
            //         gval();
            //     }
            // }
            yield () => {
                this.component._templateAttributes = ta[0];
                if(this.component._templateAttributes && this.component._templateAttributes.attr) {
                    var attributesT = this.component._template.attributes;
                    try{
                        for(let i=0;i<attributesT.length;i++) {
                            let attrName = attributesT[i].name;
                            if(!this.component._templateAttributes.attr[attrName] && attrName !== "tag-name" && attrName !== "use-strict") {
                                this.component._templateAttributes.attr[attrName] = {"name" : attrName, "staticValue" :  attributesT[i].value};
                                this.component._template.removeAttribute(attrName);
                                clonedDummyTemp && clonedDummyTemp.removeAttribute(attrName);
                                i--;
                            }
                        }    
                    } catch(e) {
                        _Lyte.error("Error with templateAttributes. ");
                    }
                }
                clonedDummyTemp && _LC.dummyLyteComponentsDiv.appendChild(clonedDummyTemp);
                this.component._sta = newCompile ? _LC.processStatic(newCompile) : undefined;
            }
        }
        yield () => {
            this.component.__isRegistered = true;
        }
    }    

    static _registerComponent(a,b, widget) {
        var gen = this._registerComponentFn(a,b, widget);
        var gnxt = gen.next(), gval;
        while(gnxt.done == false){
            gval = gnxt.value;
            if(typeof gval == "function"){
                gval();
            }
            gnxt = gen.next()
        }
    }
    //This is used to split text nodes which contain multiple dynamicNodes. 
    static splitTextNodes(node) {
        if(node && node.childNodes && node.childNodes.length) {
            for(let i=node.childNodes.length-1;i>=0;i--) {
                this.splitTextNodes(node.childNodes[i]);
            }
        }
        if(node.tagName === "TEMPLATE" && !_Lyte._ie) {
            this.splitTextNodes(node.content);
        }
        if(node.nodeType === node.TEXT_NODE) {
            let nodeValue = node.nodeValue;
            if(nodeValue){
                let mustacheValues = nodeValue.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g); //'
                if(!mustacheValues) {
                    return;
                }
                let newNodeArray = [];
                for(let i=0;i<mustacheValues.length;i++) {
                    let mustacheStartIndex = nodeValue.indexOf(mustacheValues[i]);
                    let mustacheEndIndex = mustacheStartIndex + mustacheValues[i].length;
                    if(mustacheStartIndex) {
                            newNodeArray.push(document.createTextNode(nodeValue.substring(0, mustacheStartIndex)));
                    }
                    newNodeArray.push(document.createTextNode(nodeValue.substring(mustacheStartIndex, mustacheEndIndex)));
                    nodeValue = nodeValue.substring(mustacheEndIndex);
                }
                if(!(!nodeValue.trim() && node.nextSibling && node.nextSibling.nodeType === 3 && !node.nextSibling.nodeValue.trim())) {
                    newNodeArray.push(document.createTextNode(nodeValue));
                }
                //Fix for IE Edge issue with higher versions where node.replaceWith is not working when the parent is a doc fragment.
                if(_Lyte._rwpf && node.parentNode.nodeName === "#document-fragment") {
                	for(let i=0;i<newNodeArray.length;i++) {
                		insertBefore(node.parentNode,newNodeArray[i],node);
                      }
                    node.remove();
                } else {
                	node.replaceWith.apply(node, newNodeArray);
                }
            }
        }
    }
    //It registers the binding of the node with the properties with which the dynamicNode depends. 
    bindNode(node, toBeRemoved, helperNode, options, nodeInfo, processLast, establishBindings, isTemplate,cache, type, idx, toBeInsMap) {
        let itemValue = options.itemValue;
        let forIndex = options.itemIndex;
        let forType = options.type;
        let indexValue = options.indexValue;
        let dynamicValue = nodeInfo.dynamicValue;
        let directiveValue = nodeInfo.directiveValue;
        let helperFunc = nodeInfo.helperInfo;
        let nodeValue, ownerElement = node.ownerElement;
        let dynamicValuesArray = [];
        let cmpData = LyteComponent.getCmpData(this.component.data);
        let isDirectiveNode;
//        if(node.nodeType === 2 && _LC.isCustomElement(node.ownerElement,true) ) {
//          node = {nodeName : node.nodeName, ownerElement: ownerElement, nodeType : 2, nodeValue : node.nodeValue};
//        }
        if(node.nodeType === 2) {
            node = {nodeName : node.nodeName, ownerElement : node.ownerElement, nodeType : 2, nodeValue : node.nodeValue, _attributeDetails : node._attributeDetails, _isDirectiveNode : nodeInfo._isDirectiveNode};
            isDirectiveNode = _LC.directive.isDirectiveNode(nodeInfo)
        }
        let hel_name = helperFunc?helperFunc.name:undefined; 
        //to get bindings in ssr components
        
        node._callee = this;
        let isHelper = false;
        if(!directiveValue && helperFunc && Object.keys(helperFunc).length) {
            isHelper = true;
            let attrName = node.nodeName;
            nodeValue = node.helperValue = helperFunc;
            let helperArgs = [];
            if(helperFunc.name === "action"){
                let actName = helperFunc.args[0];
                helperFunc.args[0] = actName.startsWith("'")? actName.replace(/'/g,''):  actName;               
                actName = helperFunc.args.slice(0,1)[0];
                let args = helperFunc.args.slice(1,helperFunc.args.length), isCustom = false;
                let attrName = node.nodeName;
                if(attrName.indexOf("-") != -1){
                    isCustom = true;
                }
                helperArgs = [ownerElement,attrName,isCustom,{name:actName,args:args}];
                this.processHelper({"name" : helperFunc.name, "args" : helperArgs}, node);
                return;
            } else{
                if(helperFunc.name === "method") {
                    helperArgs = helperFunc.args;
                                   
                } else {
                    helperArgs = this.processArgs(this,{"helperInfo" : helperFunc} ,dynamicValuesArray,undefined,node,undefined,cache);    
                }
            }
            nodeValue = this.processHelper({"name" : helperFunc.name, "args" : helperArgs}, node);
            if(helperFunc.name === "unescape"){
//              let test = node.replaceWith.apply(node,nodeValue.childNodes);
                let obj = {initialNode : node, dynamicNodeValue : nodeValue};
                node = {dynamicPositions : obj, "_callee" : node._callee, helperValue : node.helperValue};
                nodeValue = undefined;
                processLast.push(node);
            }
        } else {
            helperFunc = {};
            if(directiveValue){
                dynamicValue = directiveValue;
            }
            node.syntaxValue = dynamicValue;
            let dynamicValues = [];
            nodeValue = _LC.get(cmpData, dynamicValue, dynamicValues,cache, this);
            dynamicValuesArray.push(dynamicValues);
        }
        //if(node.nodeType === 2 && ( (typeof nodeValue !== "string" && (_LC.isCustomElement(node.ownerElement,true) || typeof nodeValue === "boolean") ) || _LC.isControlHelper(node.ownerElement) )) {
        //	let bindedNode = node;
            //node = {nodeName : node.nodeName, ownerElement: ownerElement, nodeType : 2, nodeValue : node.nodeValue, _callee : this, syntaxValue : node.syntaxValue, helperValue : node.helperValue, _attributeDetails : node._attributeDetails};
        if(node.nodeType == 2) {
            let tagName = node.ownerElement.tagName;
            if(tagName == "INPUT" || tagName == "TEXTAREA" || (tagName == "DIV" && node.ownerElement.hasAttribute("contenteditable") )) {
                var rA = node.ownerElement._rA = node.ownerElement._rA || [];
                node.ownerElement._rA.push(node);
            }
            if(!ownerElement._origTemplate) {
                if(( ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin") ) && ownerElement.tagName !== "TEMPLATE") {
                    if(_Lyte._ie) {
                        node.ownerElement = createElement("template");
                        node.ownerElement.setAttribute("is", nodeInfo._depthTemp);
                    } else {
                        node.ownerElement = nodeInfo._depthTemp.cloneNode(true);
                    }
                    ownerElement._origTemplate = node.ownerElement;
                }
            } else {
                node.ownerElement = ownerElement._origTemplate;
            }
        //	node.ownerElement._attributeDetails[node.nodeName].bindedNode = node;
        //}
        }
        let estuh = false;
        let actMultiProp; 
        if(!_LC.unbound) {
            let dynamicProp;
            if(helperNode) {
                dynamicProp = forType? helperNode._items[forIndex]._dynamicProperty : helperNode._dynamicProperty;
            }
            let obj, helperId;
            for(let d=0;d<dynamicValuesArray.length;d++) {
            	let dynamicValues = dynamicValuesArray[d];
                
                let lazyProp = [];
                let nodeFreezed;
            	for(let v=0;v<dynamicValues.length;v++) {
                        //to get binding in ssr components
                        var _nes = false;
                        if(nodeFreezed){continue};
                        
                    if(dynamicValues[v].startsWith('$dataAttributes') || dynamicValues[v].startsWith('$methodAttributes')){
                            nodeFreezed=true;
                            continue;
                    }
                    let boundValue;
            		let actProperty = this.getProperty(dynamicValues[v]);
            		if(helperNode) {
            			let ind = dynamicValues[v].search(/\W/);
            			if(ind !== -1) {
            				boundValue = dynamicValues[v].substring(0, ind);
            			} else {
            				boundValue = dynamicValues[v];
            			}
                        let doHp = true;
                        if(helperNode && helperNode._dirObj && forType && boundValue){ //2for check af
                            if(helperNode._dirObj.prop && helperNode._dirObj.prop.indexOf(boundValue) != -1){
                                doHp = false;
                                estuh = true;
                            }else if(helperNode._dirObj.data && helperNode._dirObj.data.indexOf(boundValue) != -1){
                                doHp = false;
                                estuh = true;
                            }else{
                                estuh = false;
                            }
                        }
            			if( doHp && boundValue !== itemValue && boundValue !== indexValue && (!options.node || !options.node._properties || !options.node._properties[boundValue])) {
                            //to bind for in ssr
                            // obj._type = "nestedIf";
                            
                            makeSet(actProperty, "_helperNodes");
            				actProperty._helperNodes.add(
            						helperNode
            				);
            				dynamicProp[dynamicValues[v]] ? dynamicProp[dynamicValues[v]].push(node): (dynamicProp[dynamicValues[v]] = []).push(node);
            			} 
            			else {
            				node._cx = options;
//            				if(!actProperty._dynamicNodes) {
//            					actProperty._dynamicNodes = [];
//            					defProp(actProperty, '_dynamicNodes', {
//            						value: [],
//            						enumerable: false, 
//            						writable: true, 
//            						configurable: true
//            					});
//            				}
            				makeArray(actProperty, "_dynamicNodes");
            				actProperty._dynamicNodes.push(node);
            				if(boundValue !== indexValue) {
            					actMultiProp = actProperty;
            				}
            			}
            		} else {
//            			if(!actProperty._dynamicNodes) {
//            				defProp(actProperty, '_dynamicNodes', {
//            					value : [], 
//            					enumerable: false, 
//            					writable: true,
//            					configurable: true
//            				});
//            			}
            			makeArray(actProperty, "_dynamicNodes");
            			actProperty._dynamicNodes.push(node);
            		}
            		if ((ownerElement && (ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin") )) || (ownerElement && ownerElement.tagName === "TEMPLATE" && /^(for|forIn)$/.test(ownerElement.getAttribute("is")) && !isHelper)) {
            			let type= ownerElement.getAttribute("is");
            			if( (type=== "for" && node.nodeName === "items") || (type==="forIn" && node.nodeName === "object")) {
            				if(!actProperty._forHelpers) {
            					makeSet(actProperty, "_forHelpers");
            				}
                            //to bind for in ssr
                            
            				node.ownerElement._actualBinding = actProperty;
            				actProperty._forHelpers.add(node.ownerElement);
            			}
            		}
            		if(establishBindings) {
            			_LC.establishSelectedBinding(actProperty, cmpData, this );
            		}else{
                        if(estuh) {
                            _LCSV.lazyProp.add(lazyProp, node, helperNode, forIndex, boundValue, dynamicValuesArray,  dynamicValues[v]);
                        }
                    }
                    //to get ssr bindings 
                                    
            	}
            	if(dynamicValues.length > 1 && !nodeFreezed) {
                    
            		node._multipleProperty = node._multipleProperty || [];
            		node._multipleProperty.push({"dynamicProp" : actMultiProp ? undefined : dynamicProp, "actProp" : this.getProperty(dynamicValues[0]), "helperNode" : helperNode, "dynamicValues" : dynamicValues, index:d});
            	}
                _LCSV.lazyProp.iterate(this, lazyProp);
                             
            }
        }
        nodeValue = !typeof nodeValue === "boolean" && !typeof nodeValue === "number" ? (nodeValue? nodeValue : ""): nodeValue;
        if(isDirectiveNode){
            if(!directiveValue){
                _LC.directive.setNodeArgs(node,nodeValue,this);
            }
        }        
        else if(node.nodeType === 2) {
            let parentNode = node._parentNode? node._parentNode : node.ownerElement;
            if(parentNode.tagName) {
                let is = parentNode.getAttribute("is");
            }
            let isCustomElement = _LC.isCustomElementV3(parentNode,true);
            if(isCustomElement && !isDirectiveNode) {
                if(parentNode.set) {
                    parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue);
                 } else {
                    parentNode._initProperties = parentNode._initProperties || {};
                     parentNode._initProperties[_LC.String.toCamelCase(node.nodeName)] =nodeValue;
                }
            }
            let origNodeValue = nodeValue;
            //!== "string"
            if(isCustomElement && typeof nodeValue !== "string" && !isTemplate) {
                parentNode._attributes = parentNode._attributes || {};
                parentNode._attributes[node.nodeName] = nodeValue;
                if(parentNode.nodeName === "TEMPLATE" && isHelper) {
                    if((parentNode.getAttribute("is") === "for" && node.nodeName === "items") || (parentNode.getAttribute("is") === "forIn" && node.nodeName === "object") && !_LC.unbound) {
                        //node._actualBinding = {"_forHelpers" : new Set().add(parentNode)};
                        node.ownerElement._actualBinding = {"_forHelpers" : new Set().add(parentNode), "_createdBinding" : true};
                        if(nodeValue){
                            // makeSet(nodeValue, "_bindings");
                            addBindings(nodeValue,node.ownerElement._actualBinding);
                        }
                    }
                }
                toBeRemoved.push(node.nodeName);
            }
            else {
                if(isDirectiveNode && window.isLyteWidget && node.tagName.indexOf("-") != -1){
                    if(!node.$data){
                        node.$data = {};
                    }
                    node.$data[_LC.String.toCamelCase(node.nodeName)] = nodeValue;
                }
                if(typeof nodeValue === "boolean") {
                    parentNode._attributes = node.ownerElement._attributes || {};
                    parentNode._attributes[node.nodeName] = nodeValue;
                    if(!nodeValue) {
//                      node.ownerElement.removeAttribute(node.nodeName);
                        toBeRemoved.push(node.nodeName);
                    } else {
                        parentNode.setAttribute(node.nodeName, "");
                    }
                } else {
                    if(nodeValue && typeof nodeValue === "object"){
                        var res;
                        if(typeof Record != "undefined" && nodeValue instanceof Record){
                            res = JSON.stringify(nodeValue.$.toJSON())
                        }
                        else{
                            try{
                                res = JSON.stringify(nodeValue)
                            }
                            catch(exp){
                                Lyte.error("Data passed for property '"+node.nodeName+"' of '"+node.ownerElement.nodeName.toLocaleLowerCase()+"' cannot be serialized. The component '"+node.ownerElement.nodeName.toLocaleLowerCase()+"' might not be registered before its use.");
                            }
                        }
                    }
                    else if(nodeValue== null || nodeValue == undefined){
                        res = ""
                    }
                    else{
                        res = nodeValue;
                    }
                    nodeValue = res;
                    if(_LC.isControlHelper(node.ownerElement)) {
                    	 parentNode._attributes = node.ownerElement._attributes || {};
                         parentNode._attributes[node.nodeName] = nodeValue;
                         toBeRemoved.push(node.nodeName);
                    } else {
                         let locNodeVal = nodeValue === undefined ? "" : nodeValue;
                         //if(node.nodeName === "style") {
                         //   node.ownerElement.setAttribute("style",locNodeVal);
                         //} else {
                         //   node.nodeValue = locNodeVal;
                         //}
                         node.ownerElement.setAttribute(node.nodeName, locNodeVal);
                    }
                    
                }
            }
            if(parentNode.tagName === "LYTE-YIELD" /*parentNode.getAttribute("is") === "insertYield"*/) {
                let pData = LyteComponent.getCmpData(parentNode.component.data);
                pData[_LC.String.toCamelCase(node.nodeName)] = origNodeValue;
            }
            if (/^(INPUT|TEXTAREA|SELECT)$/.test(parentNode.nodeName)) {
                        if (node.nodeName === "value") {
                            parentNode.value = (nodeValue === undefined) ? "" : nodeValue;
                        } else if (node.nodeName === "checked") {
                            parentNode.checked = nodeValue;
                        }
            }
            if(!nodeValue && _LC.booleanAttrList.indexOf(node.nodeName) !== -1) {
                toBeRemoved.push(node.nodeName);
            }
        } 
        else {
            node.nodeValue = nodeValue === undefined ? '' : nodeValue;
        }
	return node;
    }
    
    debounce(func, threshold) {
        var timeout;
        return function debounced() {
            var obj = this, args = arguments;
            function delayed() {
            	func.apply(obj, args);
                timeout = null;
            };
            if (timeout){
            	clearTimeout(timeout);
            }
            timeout = setTimeout(delayed, threshold || 100);
            //console.log(timeout,threshold);
        };
    }
    /*disable async function*/
    getProperty(key) {
        var arr = key.match(/([^[\].]+|\[\])/g);
        let property = this;
        if(!property._properties[arr[0]]) {
            property._properties[arr[0]] = {};
        } 
        property = property._properties[arr[0]];
        
        defProp(property, '_path', {enumerable: false, value : arr[0]});
        for(let i=1;i<arr.length;i++) {
            if (arr[i].startsWith("'") || arr[i].startsWith('"')) {//added check
			    arr[i] = arr[i].substring(1, arr[i].length -1);
		    }
            if(!property[arr[i]]) {
                property[arr[i]] = {};
                defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
            }
            property = property[arr[i]];
        }
        return property;
    }
    //updN
    updateNode(node, updatePath, options) {
        let compInstance = this.component;
        var del = "delete";
        let multiplePropNode = [];
        let multipleProp;
        let isDirectiveNode;
        if(node.nodeType == 2){
            isDirectiveNode = _LC.directive.isDirectiveNode(node)
        }        
        if(node._multipleProperty) {
        	for(var i=0;i<node._multipleProperty.length;i++) {
        		if(node._multipleProperty[i] && node._multipleProperty[i].dynamicValues.lastIndexOf(updatePath) > 0) {
                    multiplePropNode[i] = false;
                    multipleProp = node._multipleProperty[i];
		            let nodes;
		            if(multipleProp.dynamicProp) {
                        multiplePropNode[i] = multipleProp;
		                nodes = multipleProp.dynamicProp[multipleProp.actProp._path];
		                if(nodes) {
		                    let index = nodes.indexOf(node);
		                    nodes.splice(index, 1);
		                }
		                let helperNode = multipleProp.helperNode;
		                if(nodes.length === 0) {
		                    if(helperNode.getAttribute("is") === "if") {
		                        multipleProp.actProp._helperNodes[del](helperNode);
		                        delete multipleProp.dynamicProp[multipleProp.actProp._path];
		                    } else {
		                        delete multipleProp.dynamicProp[multipleProp.actProp._path];
		                        if(helperNode._items) {
		                            let removeHelper = true;
		                            for(let i=0;i<helperNode._items.length;i++) {
		                                if(helperNode._items[i]._dynamicProperty && helperNode._items[i]._dynamicProperty[multipleProp.actProp._path]) {
		                                    removeHelper = false;
		                                    break;
		                                }
		                            }
		                            if(removeHelper) {
		                                multipleProp.actProp._helperNodes[del](helperNode);
		                                //console.log('for helper is removed');
		                            }
		                        }
		                    }
		                }
		            }
		            if(!multiplePropNode[i]) {
		                multiplePropNode[i] = "dynamicNodes";
		                nodes = multipleProp.actProp._dynamicNodes;
		                if(nodes) {
		                    let index = nodes.indexOf(node);
		                    nodes.splice(index, 1);
		                    if(!nodes.length) {
		                        delete multipleProp.actProp._dynamicNodes;
		                    }
		                }
		            }
		        }
			}
		}
        if(!node.syntaxValue && !node.helperValue) {
            return;
        }
        let contextSwitchInfo;
        let isYieldContext;
        if(node._cx || (node.nodeType === 2 && node.ownerElement._cx)) {
            contextSwitchInfo = node._cx || node.ownerElement._cx;
            var contextSwitchArray = [];
            _LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo );
        } else if(node.tagName === "LYTE-YIELD" && node._callee._cx) {
        	isYieldContext = true;
        	contextSwitchInfo = node._callee._cx;
        	var contextSwitchArray = [];
        	_LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, true);
        }
        let nodeValue;
        let dynamicValues = [];
        var isHelper = false;
        if(node.helperValue){
            isHelper = true;
            nodeValue = node.helperValue;
                    let helperFunc = nodeValue;
                    let helperRetVal = this.processHelper({name : helperFunc.name, args : this.processArgs(this,{"helperInfo" : helperFunc} , dynamicValues, undefined, node)}, node);  
                    nodeValue = helperRetVal;
                    if(helperFunc.name === "unescape") {
                        let oldDynamicPosition = node.dynamicPositions;
                        let oldStartingNode = oldDynamicPosition.startingNode;
                        let oldChldLen = oldDynamicPosition.length;
                        while(oldChldLen > 1) {
                            let next = oldStartingNode.nextSibling;
                            oldStartingNode.remove();
                            oldStartingNode = next;
                            oldChldLen--;
                        }
                        let childLen = nodeValue.childNodes.length;
                        if(!childLen) {
                            nodeValue.appendChild(document.createTextNode(""));
                            childLen = 1;
                        }
                        let startingNode = nodeValue.childNodes[0];
                        oldStartingNode.replaceWith.apply(oldStartingNode,nodeValue.childNodes);
                        let obj = {startingNode : startingNode, length: childLen};
                        node.dynamicPositions = obj;
                        nodeValue = undefined;
                    }
        } else {
            let boundValue = node.syntaxValue;
            let path;
            if(boundValue.indexOf('.') !== -1 || boundValue.indexOf('[') !== -1) {
                path = boundValue;
                boundValue = boundValue.substring(0,boundValue.indexOf('.'));
            }
            let cmpData = LyteComponent.getCmpData(compInstance.data);
            let value = path ? _LC.get(cmpData, path, dynamicValues, undefined, compInstance.$node) : cmpData[boundValue]; 
            nodeValue = !typeof value === "boolean" && !typeof value === "number" ? (value? value : ""): value;
        }
		if(!(dynamicValues[0] instanceof Array)) {
        	dynamicValues = [dynamicValues];
		}
        
        if(multiplePropNode) {
        	for(var i=0;i<multiplePropNode.length;i++) {
        		if(multiplePropNode[i]) {
					let multipleProp = node._multipleProperty[i];
                    let dynamicValIndex = node._multipleProperty[i].index;
                    let boundName = dynamicValues[dynamicValIndex][0].substring(0, dynamicValues[dynamicValIndex][0].indexOf('.'));
                    let beforeProp;
                    if(node._propNode){
                        beforeProp = this._properties[boundName];
                        this._properties[boundName] = null;
                    }
                    let prop = this.getProperty(dynamicValues[dynamicValIndex][0]);
                    let totalProp = this.getProperty(boundName);
                    var value = this.getData(boundName);
	                if(multiplePropNode[i] === "dynamicNodes") {
//	                    if(!prop._dynamicNodes) {
//	                        defProp(prop, '_dynamicNodes', {
//	                            value: [],
//	                            enumerable: false, 
//	                            writable: true,
//	                            configurable: true
//	                        });
//	                    }
	                	makeArray(prop, "_dynamicNodes");
	                    prop._dynamicNodes.push(node);
	                } else {
	                	makeSet(prop, "_helperNodes");
	                    prop._helperNodes.add(
	                            multipleProp.helperNode
	                    );
	                    let dynamicProp = multipleProp.dynamicProp;
	                    dynamicProp[prop._path] ? dynamicProp[prop._path].push(node): (dynamicProp[prop._path] = []).push(node);
	                }
	                if(node.ownerElement && (node.ownerElement.hasAttribute("lyte-for") || node.ownerElement.hasAttribute("lyte-if") || node.ownerElement.hasAttribute("lyte-switch") || node.ownerElement.hasAttribute("lyte-forin")) || node.ownerElement && node.ownerElement.tagName === "TEMPLATE" && /^(for|forIn)$/.test(node.ownerElement.getAttribute("is")) && !isHelper) {
                        var type = node.ownerElement.getAttribute("is");
                        if (type === "for" && node.nodeName === "items" || type === "forIn" && node.nodeName === "object") {
                            if(multipleProp.actProp._forHelpers.has(node.ownerElement)){
                                multipleProp.actProp._forHelpers.delete(node.ownerElement);
                            }
                            if (!prop._forHelpers) {
                                makeSet(prop, "_forHelpers");
                            }
                            node.ownerElement._actualBinding = prop;
                            prop._forHelpers.add(node.ownerElement);
                        }
                    }
                    if(value != undefined){
                        _LC.establishBindings(totalProp, value);
                        if(node._propNode){
                            _LCSV.updateMulProp(node, multipleProp, boundName, totalProp, prop);
                        }
                    }
                    if(beforeProp){
                        this._properties[boundName] = beforeProp;
                    }
                    node._multipleProperty[i].actProp = prop;
                    node._multipleProperty[i].dynamicValues = dynamicValues[dynamicValIndex];
	        	}
	        }
		}
        
        if(isDirectiveNode){
            _LC.directive.setNodeArgs(node,nodeValue,this);
            if(node.ownerElement.hasAttribute("comp-in-parent")){
                Lyte.Component.set(node.ownerElement.$data, _LC.String.toCamelCase(node.nodeName), nodeValue);
            }
            if(node._saveNode){
                _LCSV.updateName(this, node, nodeValue);
            }else if(node.ownerElement._initialClassValue){
                _LC.directive.class.updateValue(node.ownerElement);
            }
        }
        else if(node.nodeType === 2) {
        	let parentNodes = [];
            let pN = node._parentNode ? node._parentNode :  node.ownerElement;
            if(pN.tagName === "TEMPLATE" && pN.getAttribute("is") === "component" && node.nodeName !== "component-name") {
            	let isKeepAlive = pN.hasAttribute("lyte-keep-alive");
            	if(isKeepAlive) {
            		for(var key in pN._renderedComponent) {
            			parentNodes.push(pN._renderedComponent[key]);
            		}
            	} else {
                    var compName = pN._currentComponent;
                    if(compName && pN._renderedComponent[compName]){
                        parentNodes.push(pN._renderedComponent[compName]);
                    }
            	}
            }
            parentNodes.push(pN);
            for(let i=0;i<parentNodes.length;i++) {
            	let parentNode = parentNodes[i];
            	if(parentNode.set) {
                    parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue, undefined,true);
                    } else {
                        parentNode._initProperties = parentNode._initProperties || {};
                        let keyName = _LC.String.toCamelCase(node.nodeName);
                        if(window.isLyteWidget && parentNode.tagName != "TEMPLATE") {
                            DataBindingLayer.updateInitProperties(parentNode, keyName, nodeValue);
                        } else {
                            parentNode._initProperties[keyName] = nodeValue;
                        }
                    }
                    let pData = parentNode && parentNode.tagName === "LYTE-YIELD" ? (LyteComponent.getCmpData(parentNode.component.data)) : undefined;
                    if(parentNode.tagName === "LYTE-YIELD" && pData && node.nodeName && pData[node.nodeName] !== nodeValue /*parentNode.getAttribute("is") === "insertYield"*/) {
                        _LC.set(pData, _LC.String.toCamelCase(node.nodeName), nodeValue,undefined , undefined, parentNode);
                    }
                    parentNode._attributes = parentNode._attributes || {};
                    //!== "string"
                    if(_LC.isCustomElementV3(parentNode,true) && typeof nodeValue !== "string") {
                        if(node.ownerElement.nodeName === "TEMPLATE") {
                            if(node.helperValue) {
                            	if((node.ownerElement.getAttribute("is") ===  "for" && node.nodeName === "items") || (node.ownerElement.getAttribute("is") ===  "forIn" && node.nodeName === "object")) {
                            		let oldValue = node.ownerElement._attributes[node.nodeName];
                            		let newValue = nodeValue;
                            		_LC.removeSelectedBindingDeep(node.ownerElement._actualBinding, oldValue);
                            		if(newValue) {
                            			// makeSet(newValue, "_bindings");
                                        addBindings(newValue,node.ownerElement._actualBinding);
                            			_LC.establishBindings(node.ownerElement._actualBinding, newValue);
                            		}
                            		if(node.nodeName === "object") {
                            			_LC.removeSelectedBindingDeep(node.ownerElement._propBindingObject, oldValue);
                            		}
                            		//console.log("old Value ", oldValue, " new Value ", newValue);
                            	}
                            }else{
                                if((node.ownerElement.getAttribute("is") ===  "for" && node.nodeName === "items") || (node.ownerElement.getAttribute("is") ===  "forIn" && node.nodeName === "object")) {
                            		let oldValue = node.ownerElement._attributes[node.nodeName];
                            		if(node.nodeName === "object") {
                            			_LC.removeSelectedBindingDeep(node.ownerElement._propBindingObject, oldValue);
                            		}
                            	}
                            }
                            parentNode["__"+node.nodeName] = true;
                            parentNode.removeAttribute(node.nodeName);
                        } else {
                            //Needs revisiting
                            //parentNode.removeAttribute(node.nodeName);
                        }

                    } else {
                        if(typeof nodeValue === "boolean") {
                            parentNode._attributes = parentNode._attributes || {};
                            parentNode._attributes[node.nodeName] = nodeValue;
                            if(!nodeValue) {
                                parentNode.removeAttribute(node.nodeName);
                            } else {
                                parentNode.setAttribute(node.nodeName, "");
                            }
                        } else {
                            if(nodeValue && typeof nodeValue === "object"){
                                var res;
                                if(typeof Record != "undefined" && nodeValue instanceof Record){
                                    res = JSON.stringify(nodeValue.$.toJSON())
                                }
                                else{
                                    try{
                                        res = JSON.stringify(nodeValue)
                                    }
                                    catch(exp){
                                        Lyte.error("Data passed for property '"+node.nodeName+"' of '"+node.ownerElement.nodeName.toLocaleLowerCase()+"' cannot be serialized. The component '"+node.ownerElement.nodeName.toLocaleLowerCase()+"' might not be registered before its use.");
                                    }                                
                                }
                            }
                            else if(nodeValue== null || nodeValue == undefined){
                                res = ""
                            }
                            else{
                                res = nodeValue
                            }
                            nodeValue = res;
                            let locNodeVal = nodeValue === undefined ? "" : nodeValue;
                            // if(node.nodeName === "style") {
                            //     node.ownerElement.setAttribute("style",locNodeVal);
                            // } else {
                            //     node.nodeValue = locNodeVal;
                            // }

                            // if(node instanceof Node) {
                            //Check safari issue once
                            let oE = node.ownerElement;
                            if(oE.hasAttribute(node.nodeName)) {
                                if(oE.tagName != "INPUT" || node.nodeName != "value" || !oE.validity.badInput) {
                                    oE.setAttribute(node.nodeName, locNodeVal);
                                }
                            } else {
                                node.nodeValue = locNodeVal;                              
                            }
                        }
                    }
                    parentNode._attributes[node.nodeName] = nodeValue;
                    if(/^(INPUT|TEXTAREA|SELECT)$/.test(parentNode.nodeName)) {
                        if(node.nodeName === "value") {
                             let val = (nodeValue === undefined) ? "" : nodeValue;
                             if(parentNode.value !== val) {
                                parentNode.value = val;
                             } 
                        } else if(node.nodeName === "checked") {
                            parentNode.checked = nodeValue;
                        }
                    }
                    if(!nodeValue && _LC.booleanAttrList.indexOf(node.nodeName) !== -1) {
                        parentNode.removeAttribute(node.nodeName);
                    }
                    let isStopped = parentNode._isStopped;
                    let result;
                    switch(parentNode.getAttribute("is")) {
                        case "for" :
                            if(!options){
                                options = {"type" : "update"}
                            }else{
                                options.type = "update"
                            }
                            this.updateForHelper(parentNode, options);
                            break;
                        case "if" : 
                            result = this.updateSwitchHelper("if",parentNode, undefined, true, true);
                            break;
                        case "forIn" : 
                            if(!options){
                                options = {"type" : "update"}
                            }else{
                                options.type = "update"
                            }
                            this.updateForInHelper(parentNode , options);
                            break;
                        case "switch" :
                            this.updateSwitchHelper("switch",parentNode, undefined, true, true);
                            break;
                        case "component" : 
                            if(node.nodeName === "component-name") {
                                this.updateDynamicComponent(parentNode, "update");    
                            }
                            break;
                        default:            
                    }
                	let handleBreakOptions;
                	if(isStopped &&  isStopped !== result) {
                		//console.log("new value is stopped");
                		if(!result) {
                			//console.log("new value is not stopped");
                			if(isStopped === "break") {
                				handleBreakOptions = "SM"
                			} else {
                				handleBreakOptions = "SS"
                			}
                		} else if(result === "break") {
                			handleBreakOptions = "MS";
                			//console.log("old value is continue and new value is break");
                		} else {
                			handleBreakOptions = "SM";
                			//console.log("old value is break and new value is continue");
                		}
                	} else if(result === "break") {
                		handleBreakOptions = "MS";
                		//console.log("old value not stopped and new value is break");
//                		this.handleBreak(parentNode._cx, "break");
                	} else if(result === "continue") {
                		handleBreakOptions = "SS";
                		//console.log("old value not stopped and new value is continue");
//                		this.handleBreak1(parentNode._cx , "continue");
                	}
                	if(handleBreakOptions) {
                		this.handleBreak(parentNode._cx, handleBreakOptions);
                	}
            }
        }
        else {
            node.nodeValue = nodeValue === undefined ? '' : nodeValue;
        }
        if(node.ownerElement && node.ownerElement._hooksPresent){
            let saveAttr = _LCSV.getAttr(node.ownerElement._specialAttributeDetails);
            if(saveAttr){
                _LCSV.triggerAllListeners(this, saveAttr, node.ownerElement);
            }
        }
        if(contextSwitchInfo) {
            _LC.removeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, isYieldContext);
        }
    }
    
    handleBreak(contextSwitchInfo, options) {
    	if(contextSwitchInfo) {
    		let forTemplate = contextSwitchInfo.node;
    		let breakIndex = contextSwitchInfo.itemIndex;
			let itemValue = forTemplate.getAttribute("item");
			let forContent = contextSwitchInfo.node._forContent;
			let endIndex = options[0] === "M" ? forContent.length : breakIndex + 1;
			for(let j=breakIndex;j<endIndex;j++) {
    			let currentForContent = forContent[j];
    			for(let i=0;i<currentForContent.length;i++) {
    				currentForContent[i].remove();
    				if(currentForContent[i]._forContent || currentForContent[i]._caseContent) {
    					this.removeHelpers(currentForContent[i]);
    				}
    			}	
    				forContent[j] = [];
    				_LC.removeSelectedBindingDeep(forTemplate._items[j].itemProperty, forTemplate._attributes.items[j]);
    				forTemplate._helpers[j] = [];
    				forTemplate._items[j] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}};
                    forTemplate._items[j] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}, "propProperty" : {},"propPropertyDyn" : {}, "propNodes" : {}};
    		}
			let length = forTemplate._attributes.items.length;
			if(options[1] === "M") {
				this.updateForHelper(forTemplate, {firstIndex : breakIndex, secondIndex : length - breakIndex, "type" : "replace"}, undefined, {});
			} else {
				this.updateForHelper(forTemplate, {firstIndex : breakIndex, secondIndex : 1, "type" : "replace"}, undefined, {});
			}
    	}
    }
    
    createCustomEvent(eventName, parentNode, actObj){
        const customEvent = new CustomEvent(eventName);
        parentNode._actions[eventName] = customEvent;
        parentNode._actions[eventName].processAction = actObj;
    }
    /*disable async function*/
    isEmptyString(str){
        return (!(typeof str === "string") || str === "" );
    }

    processArgs(scope,dynN,dynamicValues,event, node, newCompile,cache,unboundFlag){
        unboundFlag=dynN.helperInfo.name=='unbound'?true:unboundFlag;
        let args = dynN.newHelperInfo && newCompile ? dynN.newHelperInfo.args : dynN.helperInfo.args;
        let helpers , j ;
        dynamicValues = dynamicValues || [];
        let scpData = LyteComponent.getCmpData(scope.component.data);
        args = (Array.isArray(args)) ? Array.from(args) : args;
        let widget = scope.__lyteWidget;
        for(let i=0; i<args.length; i++){
            if(args[i] && args[i].type){
                this.internalHelpers(scope,args,i,dynamicValues, event, node, newCompile,cache,unboundFlag);
            } else {
                if(!this.isEmptyString(args[i])) {
                    if(args[i].startsWith("'") && args[i].endsWith("'")){
                        args[i] = args[i].substr(1,args[i].length-2);       
                    } else {
                        args[i] = args[i].trim();
                        let dynamicVals = [];
                        if(args[i] === "event" && event) {
                            args[i] = widget && widgetMap.has(widget) ? widgetMap.get(widget).getClone(event) : event;
                        } else if(args[i] === "this" && node) {
                            let thisNode = node.nodeType === 2 ? node.ownerElement : node;
                            args[i] = widget && widgetMap.has(widget) ? widgetMap.get(widget).getClone(thisNode) : thisNode;
                        } else {
                            args[i] = _LC.get(scope.component.data,args[i],dynamicVals,cache);
                        }
                        if(unboundFlag!==true){dynamicValues.push(dynamicVals); }
                    }
                } else if(newCompile) {
                    if(args[i] instanceof Array) {
                        args[i] = _LC.getDD(scpData, args[i]);
                    }
                }
            }
            
        }
        return args;
    }
    
    internalHelpers(scope,args,i,dynamicValues, event, node, newCompile,cache,unboundFlag){
        //helperFunc = this.constructor.getHelper(args[i]);
        let helperFunc = args[i].value;
        let helperVal =  this.processHelper({"name" : helperFunc.name, "args" : this.processArgs(scope,{"helperInfo" : helperFunc},dynamicValues, event, node, newCompile,cache,unboundFlag)}, node);
        args[i] = helperVal;
   }
    
    processHelper(helperFunc, node){
        let args = [];
        let helperName = helperFunc.name;
        let compConstr;
        let helperFn = _LyteComponent.registeredHelpers[helperName];
        if(window.isLyteWidget && _LC.defaultHelpers.indexOf(helperName) == -1) {
            compConstr = this.component.constructor;
            if(compConstr._widget) {
                helperFn = compConstr._helpers[helperName] || helperFn;
                if(!helperFn) {
                    _Lyte.error("LC003", helperFunc.name);
                    return;
                }
            }
        }
        if(!helperFn){
            _Lyte.error("LC003" , helperFunc.name);
            return;
	    }
        switch(helperFunc.name){
            case "method" : 
                args.push(this, node);
                break;
            case "lbind" :
                args.push(this, node.ownerElement);
                break;
            case "lyteViewPort" :
                if(node && node.ownerElement){
                    args.push(node.ownerElement);
                    if(!helperFunc.args.length){
                        args.push(false);
                    }
                }else{
                    return false;
                }
        }
        return helperFn.apply(this,args.concat(helperFunc.args));
    }
    
    getActionProperty(prop){
        let hostProp = this._properties;
        let value = (hostProp)?hostProp[prop].value:undefined;
        return value;
    }
    
    hasInternalBindings(content){
        return content.match(/[(]{1}[^)]+[)]{1}/);
    }
    
    getArgValues(argNames, properties) {
        let argValueArray = [];
        for(let i=0;i<argNames.length;i++) {
            argValueArray.push(properties[argNames[i]].value);
        }
        return argValueArray;
    }
    
    createEventListeners(node,actionType,actObj){
        let self = this;
        if(!node._callee && node !== this) {
            node._callee = this;
        }
        if(globalDOMEvents.indexOf(actionType) == -1){
            let infoAttr = actionType.substr(2);
            let infoAttrVal = node.getAttribute(infoAttr);
            // var evntListener = function(event) {
        	// 	var toRemove;
            //     if(!window.event) {
            //         window.event = event;
            //         toRemove = true;
            //     }
            //     _LC.throwAction.call(self,self,actionType.substr(2),actObj, undefined, undefined, node, event);
            //     if(toRemove) {
            //         window.event = undefined;
            //     }
            // };
            if ((_LyteComponent.registeredComponents[node.localName] && !node.component) || (node.tagName === "TEMPLATE" && node.getAttribute("is") === "component")) {
            	node._toRegEvnts = node._toRegEvnts || {};
            	node._toRegEvnts[actionType.substr(2)] = {"listener" : globalEventHandler , "attrVal" : this.tagName.toLowerCase()+" => "+actObj.name};
            } else {
            	node.setAttribute(infoAttr, this.tagName.toLowerCase()+" => "+actObj.name);
            	//Event is not in capture phase because, in capture phase, multiple event listeners in hierarchy are called from parent to child (since registration is done in that order)
            	node.addEventListener(actionType.substr(2), globalEventHandler);
            }
            if(node.hasAttribute(actionType)){
            	node[actionType] = undefined;
            }
            node.removeAttribute(actionType);
        }
    }
    registerParentYield(yieldName){
        let parentYield = this._callee._yields[yieldName]
        let locYield;
        if(parentYield){
            if(_Lyte._ie) {
                locYield = document.createElement("div");
                locYield.innerHTML = parentYield.outerHTML;
                locYield = locYield.childNodes[0];
                this.constructor.splitTextNodes(locYield);
            } else {
                locYield = parentYield.cloneNode(true);
            }
            Object.keys(parentYield).forEach(function(item) {  //eslint-disable-line no-loop-func
                locYield[item] = parentYield[item];
            });
            this._yields[yieldName] = locYield;   
        }         
    }  
    registerYields() {
        this._yields = {};
        let yields = this.querySelectorAll('template[is=registerYield],template[is=yield]');
        let lazyYields = [];
        for(let i=0;i<yields.length;i++) {
            var yld = yields[i];
            while(yld.hasChildNodes()) {
                yld.content.appendChild(yld.childNodes[0]);
            }
            if(yld.hasAttribute("from-parent") && this._callee) {
                if(this._callee._yields){                    
                    this.registerParentYield(yld.getAttribute("yield-name"));
                }
                else{
                    lazyYields.push(yld);
                }    
            } else {
                this._yields[yld.getAttribute("yield-name")] = yld;
            }
            _LCHD.setTxtNode(this, yld);
        }
        if(lazyYields.length && this._callee){
            var self = this;
            this.lazyYield = function(){
                if(self._callee){
                    for(let j=0;j<lazyYields.length;j++){
                        let lYield = lazyYields[j];
                        self.registerParentYield(lYield.getAttribute("yield-name"));
                    }
                    self._callee.removeEventListener("onReady", self.lazyYield);
                    delete self.lazyYield;
                }
            };
            this._callee.addEventListener("onReady", this.lazyYield);
        }
    }
    connectedCallback() {
        if(this._connectedCalled || this.__lyteIgnore || this.__v3lyteIgnore) {
            return;
        }
        this._connectedCalled = true;
        this._connectedCallback();
    }
    _connectedCallback() {
        if(this.hasAttribute("lyte-rendered") || !_LyteComponent.registeredComponents[this.localName] || this._ccCalled) {
            return;
        }
        let fastRenderProp = this._fR;
        if(!fastRenderProp) {
            this._callee = this._callee || this.getCallee(this.parentNode);
        }
        this.__h = {};
        this.__counter = 0;
        this.__dc = {};
        if(fastRenderProp) {
            if(_LyteComponent.shouldIgnoreDisconnect()){
                return;
            }
            let methods = fastRenderProp.methods;
            if(methods) {
                this.setMethods(methods);
            }
            _LC.ccDelay.push(this);
            this._ccCalled = true;
        } else {
            this.actualConnectedCallback();
        }
        var isViewPort;
        let cmpData = LyteComponent.getCmpData(this.component.data);
        if(this._initProperties && this._initProperties.hasOwnProperty('lyteViewPort')){
            isViewPort = this._initProperties.lyteViewPort;
        }
        else{
            isViewPort = cmpData.lyteViewPort;
        }
        if(isViewPort) {
            if(!_LC.isViewPortPending) {
                requestAnimationFrame(function() {
                    requestAnimationFrame(function() {
                        _LC.executePendingViewPort();
                    });
                });
                _LC.isViewPortPending = true;
            }
            _LC.pendingViewPortElements.push(this);
        }
    }
    cmpBind(fastRenderProp){
        let compData = LyteComponent.getCmpData(this.component.data);
        if(!_LC.unbound && !fastRenderProp) {
        	Lyte.establishObserverBindings.call(this,this.component.constructor._observers);
            Lyte.establishWatchScope.call(this,this.constructor._deepWatchProperties)
        	//this.establishObserverBindings();
        	// makeSet(compData, "_bindings");
            addBindings(compData,this._properties);
        	_LC.establishBindings(this._properties, compData);
        }
    }
    actualConnectedCallback(){
        this._transitionHelperNodes = [];
        this._specialNodes = [];
        this._propProperty = {};
        this._propList = [];
        this._propNodes = {};
        this._hiddenTemplate = [];
        // var wdt = _LyteComponent.currentWidget ? _LyteComponent.currentWidget : this._callee ? this._callee.__lyteWidget : undefined;
        // if((!wdt && !_LyteComponent.registeredComponents[this.localName]) || (wdt && (!_LyteComponent.registeredWidgetComponents[wdt] || !_LyteComponent.registeredWidgetComponents[wdt][this.localName]))) {
        // 	return;
        // }
        let compData = LyteComponent.getCmpData(this.component.data);
        let fastRenderProp = this._fR;
        if(fastRenderProp) {
            this._callee = this._callee || this.getCallee(this.parentNode);
        }
        let templateAttributes = this.component.constructor._templateAttributes;
        if(templateAttributes && templateAttributes.attr) {
        	for(let key in templateAttributes.attr) {
//        		let attr = templateAttributes.attr[i];
				let attr = templateAttributes.attr[key];
        		if((!this.hasAttribute(attr.name) && !compData.hasOwnProperty(attr.name) ) || attr.globalEvent) {
        			if(attr.helperInfo && attr.helperInfo.name === "action") {
                        this._evBoundEvents = this._evBoundEvents || {};
                        let actionName = attr.helperInfo.args[0];
					    let boundName;
					    if(actionName.startsWith('"') || actionName.startsWith("'")) {
						boundName = actionName.substring(1, actionName.length - 1);
					    } else {
						//_Lyte.warn("Deprecation warning. Action name should be in quotes");
						boundName = actionName;
                        }
                        let actualAttrName = attr.globalEvent ? attr.name : (attr.name.indexOf("-") !== -1)? attr.name : attr.name.substr(2);
                        this._evBoundEvents[actualAttrName] = {"name" : boundName, "args" : attr.helperInfo.args, "from" : "component"};
                        let prevAttribute = this.getAttribute(attr.name);
                        let currentAttribute = this.component.constructor._template.getAttribute(attr.name);
                        //this.setAttribute("ev:"+attr.name, this.constructor._template.getAttribute(attr.name));
                        this.setAttribute(attr.name, currentAttribute + (prevAttribute ? " ; " + prevAttribute : ""));
                    }
                    if(!attr.globalEvent) {
                        attr.from = "component";
                        if(attr.staticValue) {
                            this.setAttribute(templateAttributes.attr[key].name, attr.staticValue);
                        } else {
                            this.setAttribute(templateAttributes.attr[key].name, "{{dummy}}");
							this.bindNode(this.attributes.getNamedItem(templateAttributes.attr[key].name), [], undefined, {}, templateAttributes.attr[key], undefined, undefined, true );
                        }
                    }
        			
        		}
        	}
        }
        for(let key in this._toRegEvnts) {
        	this.addEventListener(key, this._toRegEvnts[key].listener);
        	if(this.hasAttribute(key)) {
        		this.setAttribute(key, this.getAttribute(key) + " ; "+ this._toRegEvnts[key].attrVal);
        	} else {
        		this.setAttribute(key, this._toRegEvnts[key].attrVal);
        	}
        }
        this._toRegEvnts = {};
        let initialUnbound = _LC.unbound;

        let ssrBind  = this.getAttribute("ssrbindservernode")
        if(ssrBind && !this.component.data.lyteUnbound){
            this.bindServerData();
            this.removeAttribute("ssrbindservernode");
        }
        let content =  this.afterConnected(fastRenderProp,ssrBind);
        !ssrBind && this.cmpBind(fastRenderProp);

        _LC.unbound = initialUnbound;
        if(typeof content === "string") {
            if(content) {
                if(_LC.frSpecial) {
                    let temp = document.createElement("template");
                    temp.innerHTML = content;
                    this.innerHTML = "";
                    this.appendChild(temp.content);
                } else {
                    this.innerHTML = content;
                }
            }
            _LC.processAction(this);
        } else {
            if(this.component.data.lyteViewPort) {
                this._vpc = true;
                if(_Lyte._ie) {
                    for(var i=0;i<content.childNodes.length;i++) {
                        if(content.childNodes[i].tagName) {
                            this._dummyViewPortF = content.childNodes[i];
                            break;
                        }
                    }
                    for(var i=content.childNodes.length-1;i>=0;i--) {
                        if(content.childNodes[i].tagName) {
                            this._dummyViewPortL = content.childNodes[i];
                            break;
                        }
                    }
                } else {
                    this._dummyViewPortF = content.children[0];
                    this._dummyViewPortL = content.children[content.children.length - 1];
                }
            }
            if(_LC.directive.getTransitionArg(this,'hide-tag')){
                _LCHD.connect(this, content);
            }
            else{
                this.appendChild(content);
            }
        }
        let dataDef = this.component.__data;
        let attributes = this.attributes;
        this.__lyteIgnore = true;
        for(let i=attributes.length-1;i>-1;i--) {
            let camelCase = LyteComponent.String.toCamelCase(attributes[i].nodeName);
            if(dataDef[camelCase] && dataDef[camelCase].hideAttr) {
            this.removeAttribute(attributes[i].nodeName);
            }
        }
        for(let dataName in this._hideAttr){
            let attrName = _LC.String.dasherize(dataName);
            let dataVal = this._hideAttr[dataName];
            if(dataVal == false){
                if(this.getAttribute(attrName) != this.component.data[dataName]){
                    this.setAttribute(attrName, this.component.data[dataName])
                }
            }
        }
        this.__lyteIgnore = false;
    
        if( this._callee && this._callee.serverCall ){
            this.serverCall = true;
        }
        //to bind in ssr
        if( this.serverCall && !this.hasAttribute( "server-rendered") ){
            this.setAttribute( "server-rendered", "");
            var newData = LyteComponent.sendtoclient.call(this,this,true,this.component.__data);
            this.setAttribute("component-data", JSON.stringify( newData ) );
        }
        if( !this.hasAttribute( "server-rendered" ) )
        {        
	        this.setAttribute("lyte-rendered", "");
        }
        if(!fastRenderProp && !Lyte._ignoreOnReady) {
            this.dispatchEvent(new CustomEvent("onReady"));
        }
        let _config_flag;
        if( this.component._config ){
            if( this.component._config.clientLifeCycleHooks != undefined ){
                _config_flag = this.component._config.clientLifeCycleHooks == true || ( typeof this.component._config.clientLifeCycleHooks == 'object' ? this.component._config.clientLifeCycleHooks.includes('didConnect') : false );
            }
        }
        if(!window.isLyteWidget){
            _LCSV.connect(this);
        }
        let _overrides = this.component._ssr ? this.component._ssr.overrides : undefined;
        if( !this.hasAttribute( "server-rendered" ) || this.serverCall ||  _config_flag ){
            if( _overrides && _overrides.didConnect && this.serverCall ){
                _overrides.didConnect.apply( this );
            }else{        
                this.callback("didConnect");
            }
            this.onCallBack("didConnect");
        }

        // Widget Data update from parent to child
        // if(_Lyte.isWidgetBuild && this.hasAttribute("comp-in-parent")) {
        //     let self = this;
        //     setTimeout(function() {
        //         DataBindingLayer.sendDataUpdateToFrame(self, self.component.data);
        //     },0)
            
        // }        
    
        if( this.serverCall == undefined ){
            this.callback( "didRender" );
        }            
        if(fastRenderProp) {
            this.removeAttribute("_lyteprop");
        }
    }
    onCallBack(name){
        let callbacks = this.component.constructor._callBacks[name];
        if(callbacks){
            for(let i=0;i<callbacks.length;i++){
                try{
                    callbacks[i].value.call(this.component);    
                } catch(e) {
                    _Lyte.error(e);
                }
                
            }
        }
    }
    callback(name){
        var func = this.component[name];
        var args;
        if(func){
            if(arguments.length > 1) {
                args = Array.from(arguments);
                args.splice(0,1)
            }
            try{
                var context = this.component;
                if(this.__lyteWidget && widgetMap.has(this.__lyteWidget)){
                    context = widgetMap.get(this.__lyteWidget).getClone(context);
                }
                func.apply(context, args || []);    
            } catch(e) {
                _Lyte.error(e);
            }
        }
    }
    establishObserverBindings() {
        let observers = this.component.constructor._observers;
        for(let i=0;i<observers.length;i++) {
            let props = observers[i].properties;
            for(let j=0;j<props.length;j++) {
                let actProp;
                let isArrayObserver = false;
                if(props[j].indexOf('.[]') !== -1) {
                    isArrayObserver = true;
                    actProp = this.getProperty(props[j].substring(0, props[j].indexOf('.[]')));
                } else {
                    actProp = this.getProperty(props[j]);
                }
                makeSet(actProp, "_observers");
                actProp._observers.add({callee : this, observer: observers[i], isArrayObserver : isArrayObserver});
            }
        }
    }
    removeBindings(properties, actualData) {
        var del = "delete";
        for(let i in properties) {
            let actData = actualData[i];
            if(actData && actData._bindings) {
                actData._bindings[del](properties[i]);
                //Error while trying to delete _bindings from actData when actData is of type Array
                /*  if(!actData._bindings.size) {
                    delete actData._bindings;
                } */
            }
            if(typeof properties[i] === "object" && actData) {
                this.removeBindings(properties[i], actData);
            }
        }
    }
    actualDisconnected() {
        try{
            var self = this;
            if(!self.component) {
                return;
            }
            self._cx = null;
            self._callee = null;
            self.component.$node = null;
            self.component.__data = null;
            if(self.component.data.__target__){
                self.component.data.__target__.__component__ = null;
            }
            else{
                self.component.data.__component__ = null;
            }
            self.component.data = null;
            self.component = null;
            self.__dc = self.__dc || {};
            self.__h =  self.__h || {};
            for (key in self.__dc) {
                var helper = self.__dc[key];
                //helper.remove();
                if(helper.hasAttribute("lyte-keep-alive")) {
                    var objKeys = Object.keys(helper._renderedComponent);
                    for(var j=0;j<objKeys.length;j++) {
                        let key = objKeys[j];
                        if(key !== helper._currentComponent) {
                            // Will remove from hDiv.
                            let comp = helper._renderedComponent[key];
                            comp.constructor.prototype._disconnectedCallback.call(comp);
                            comp.remove();
                        }
                    }
                }
            }
            for (key in self.__h) {
                self.__h[key].remove();
            }
            self.__h = {};
            self.__dc = {};
            let yields = self._yields;
            for(var key in yields) {
                yields[key]._callee = null;
            }
            self = null;
        }
        catch(exp){
            console.error(exp);
        }
    }
    disconnectedCallback() {
        this._disconnectedCallback();
    }
    _disconnectedCallback() {
        if(this.__v3lyteIgnore){
            _LC.V3.pendingComp.remove(this);
            return;
        }
        if(_LyteComponent.shouldIgnoreDisconnect() || !this.component || this.__lyteIgnore || this._ignoreDisconnect) {
            return;
        }
        if(Array.from(_LC.hiddenComponentsDiv.content.childNodes).indexOf(this)!=-1){
            _LC.hiddenComponentsDiv.content.removeChild(this)
        }
        if(this._hiddenTemplate && this._hiddenTemplate.length){
            _LCHD.callDisconnectedCallback(this);
        } 
        /*disable async function*/
        var widget = this.constructor.__widgetName;
        /*disable async function*/
        var map;
        /*disable async function*/
        if(widget) {
            map = widgetMap;
            /*disable async function*/
            widget = map.get(widget);
            widget.additionalComps.delete(this.parentElement);
        }
        if(this._removedTemplate){
            this._removedTemplate.forEach(el=>{
                if(_LC.tDiv.content.contains(el)){
                    _LC.tDiv.content.removeChild(el);
                }
            })
            this._removedTemplate=[];
        }
        var pve = _LC.pendingViewPortElements;
        if(this.component.data.lyteViewPort) {
            var index = pve.indexOf(this);
            if(index != -1) {
                pve.splice(index, 1);
            }
        }
        if(_LyteComponent.viewPortSettings.handlePendingItems && this._vpc) {
            _LC.executeVpe = true;
        }
        if(pve.length){
            for(let i=0; i<pve.length; i++){
                let actTemp = _LC.getActViewPortTemplate(pve[i]);
                if(actTemp && actTemp.tagName == "TEMPLATE" && actTemp.getAttribute("is") == "if" && actTemp._callee == this){
                    pve.splice(i,1);
                    i--;
                }
            }
        }
        if(this.__elmCnt) {
            delete DataBindingLayer.parentMap[this.__elmCnt];
        }
        if(this.__elmCntW) {
            delete DataBindingLayer.childMap[this.__elmCntW];
        }        
        this._destroyed = true;
        if(this.__toRemoveLazy){
            for(var __key in this.__toRemoveLazy){
                var __arr = this.__toRemoveLazy[__key];
                __arr.forEach(function(id){
                    Lyte.$.toRemoveFromRequiredServices(id);
                });
            }
            delete this.__toRemoveLazy;
        }
        this.component._bindings = null;
        this._parentHelper = null;
        var scpObj = this.__scpObj;
        let cmpData = LyteComponent.getCmpData(this.component.data);
        if(scpObj){
            for(var key in scpObj){
                var propData = cmpData[key], id = scpObj[key], idArr = id.split("_");
                if(propData){
                    Lyte.removeNestScp(cmpData[key], idArr[0], idArr[1], undefined, this);
                }
            }
        }
        if(!this._fR) {
            _LC.removeSelectedBindingDeep(this._properties, cmpData, true);
        }
        var h = this.__h;
        for (key in h) {
            if(h[key]._actualBinding || (h[key]._hiddenTemplate && h[key]._hiddenTemplate.length)){
                this.removeHelpers(h[key]);
            }
        }
        h = {};
//      _LC.removeBindings(this._properties, this.component);
        for(let key in this._properties) {
            this._properties[key] = {};
        }
        _LCSV.removeAll("comp",this, this);
        _LCSV.removeData(this);
        this._specialNodes = null;        
        this.callback('didDestroy');
        this.onCallBack('didDestroy');
        this._didDestroyCalled = true;
        if(this.__lyteWidget){
            var wIns = widgetMap.get(this.__lyteWidget);
            if(wIns) {
                wIns.removeComponent(this);
            }
            // wIns.components.delete(this);
        }        
        if(!_LC.dcc) {
            _LC.dcc = [];
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    try{
                        if(_LC.executeVpe){
                            _LyteComponent.viewPortSettings.executePendingViewPortElements();
                            _LC.executeVpe = false;
                        }
                        for(var i=0,item;item=_LC.dcc[i];i++) {
                            item.actualDisconnected();
                        }
                    }
                    catch(e) {
                        console.error(e);
                    }
                    _LC.dcc = undefined;
                });
            });
        }
        _LC.dcc.push(this);
        // var self = this;
        // setTimeout(function() {
        //     self.actualDisconnected();
        // },0);
        if(this.lazyYield){
            this.removeEventListener("onReady", this.registerParentYield);
        }        
        this.constr.activeInstances--;
        this.component.constructor.activeInstances--;
        // var rmIndex = this.constructor.component.compInstances.indexOf(this);
        // this.constructor.component.compInstances.splice(rmIndex,1);  
    }
}

customElementPrototype._V4InsApi = ["getData","getDirectiveObj","getShadowObj","getFastObj","cmpBind","component","actualConstructor","_connectedCallback","actualConnectedCallback", "getMethods","hasAction", "setActions", "setMethods", "getCallee", "afterConnected","bindServerData","bindServerNode","getServerTemplates","bindServerFor","bindServerIf","getRandomId","getssrType", "renderComponent", "renderFast", "formatValue", "renderNodes", "executeBlockHelpers", "updateBlockHelpers", "_attributeChangedCallback" , "removeHelpersSpecificIndex", "removeHelpers", "updateYield", "updateDynamicComponent","updateForHelper", "updateForInHelper","rmCaseBindings","getCaseTemplate","getCaseIndexScope","getSwitchScope", "updateSwitchHelper", "callObservers","bindNode","debounce", "getProperty", "updateNode", "handleBreak", "createCustomEvent", "isEmptyString", "processArgs", "internalHelpers","internalArray", "processHelper", "getActionProperty", "hasInternalBindings", "getArgValues", "createEventListeners", "registerParentYield","getYieldName", "registerYields", "onCallBack", "callback", "establishObserverBindings", "removeBindings", "actualDisconnected" ,"_disconnectedCallback","throwAction","get","set"];
customElementPrototype._V3InsApi = ["getData","cmpBind","component","actualConstructor","_connectedCallback","actualConnectedCallback", "getMethods","hasAction", "setActions", "setMethods", "getCallee", "afterConnected", "renderComponent", "renderFast", "formatValue", "renderNodes", "executeBlockHelpers", "updateBlockHelpers", "_attributeChangedCallback" , "removeHelpersSpecificIndex", "removeHelpers", "updateYield", "updateDynamicComponent","updateForHelper", "updateForInHelper", "updateSwitchHelper", "callObservers","bindNode","debounce", "getProperty", "updateNode", "handleBreak", "createCustomEvent", "isEmptyString", "processArgs", "internalHelpers", "processHelper", "getActionProperty", "hasInternalBindings", "getArgValues", "createEventListeners", "registerParentYield", "registerYields", "onCallBack", "callback", "establishObserverBindings", "removeBindings", "actualDisconnected" ,"_disconnectedCallback","throwAction","get","set","initializeMethod"]
customElementPrototype._V4StaticApi = ["_observers","_callBacks","_properties","activeInstances","_depthTemp","_bindsIds","_ssr","_config","_mixins","_serviceToBeUsed","_actions","_template","_dynamicNodes","_templateAttributes","_observedAttributes","_observedMethodAttributes","_data","_methods","_pendingComponents","splitTextNodes" ,"_registerComponent", "createDocFragment1" , "updateValue","seperateStyle","getFastRenderSupported","setTemplateAttributes"];
customElementPrototype.version = {v3 : {component : undefined}};
let _stringReplacer = String.prototype._replace ? String.prototype._replace : String.prototype.replace;
let LyteComponent = {
        "_windowEvNeeded" : false,
        "defaultHelpers" : ["unbound","action","lbind","method","stringifyHTML","unescape","escape","debugger","log","ifEquals","if","negate","ifNotEquals","concat","encAttr","expHandlers","lyteViewPort"],
        "baseCompClass" : class Component {
            constructor() {
                if(!this.$) {
                    this.$ = {};
                }
                Object.assign(this.$, this.$functions);
                this.$._ins = this;
                this.$.validate = function() {
                    var compInstance = this._ins;
                    var data = compInstance.data;
                    for(var key in data) {
                        LyteComponent.handleValidation(data, key, data[key], compInstance);
                    }
                }
                if(this._setWidget) {
                    this._setWidget();
                }
            }
        },    
        "fRP" : {},
        "fRC" : 0,
        // "frcUnused" : [],
        "customPropRegex" : "",
        // "pushFrc" : function(fastRenderIndex) {
        //     this.frcUnused.push(fastRenderIndex);
        //     delete _LC.fRP[fastRenderIndex];
        // },
        // "getFrc" : function() {
        //     let frcIndex;
        //     if(this.frcUnused.length) {
        //         frcIndex = this.frcUnused.shift()
        //     } else {
        //         frcIndex = this.fRC++;
        //     }
        //     return frcIndex;
        // },
        "customPropHandlers" : [],
        "_registeredComponents" : {},
        "_reRegisteredComponents" : [],
        "toBeRegistered" : [],
        "getCmpData":function(data){
            return data && data.__target__ ? data.__target__ : data;
        },
        "getCmpData":function(data){
            return data && data.__target__ ? data.__target__ : data;
        },
        "updateCustomCrmComponent" : function(def,customCrmComponent){
            for (let key in def) {
                if (def[key] && def[key].type === "observer") {
                    def[key].fnName = key;
                    customCrmComponent.component._observers.push(def[key]);
                } else if (def[key] && def[key].type === "callBack") {
                    var props = def[key].properties;
                    for (var k = 0; k < props.length; k++) {
                        if (!customCrmComponent.component._callBacks[props[k]]) {
                            customCrmComponent.component._callBacks[props[k]] = [];
                        }
                        def[key].fnName = key;
                        customCrmComponent.component._callBacks[props[k]].push(def[key]);
                    }
                    if (def[key].observes) {
                        def[key].observes.fnName = key;
                        customCrmComponent.component._observers.push(def[key].observes);
                    }
                } else {
                        customCrmComponent.component.prototype[key] = def[key];
                }
            }
            return def;
        },
        "dataFromMixin" : function(mixinsToBeUsed,actionsFromMixin,methodsFromMixin,newDefinition){
            var mixinslen = mixinsToBeUsed.length;
            for(let i=0; i<mixinslen ; i++) {
                for(let item in mixinsToBeUsed[i]){
                    if(item === "actions") {
                        Object.assign(actionsFromMixin, mixinsToBeUsed[i][item]);    
                    } else if(item === "methods") {
                        Object.assign(methodsFromMixin, mixinsToBeUsed[i][item]);    
                    } else {
                        newDefinition[item] = mixinsToBeUsed[i][item];
                    }
                }
            }
            return{"actionsFromMixin":actionsFromMixin,"methodsFromMixin":methodsFromMixin,"newDefinition":newDefinition}
          },
        "throwEvent" : function(eventName){
            let self = this.$node ? this.$node : this;
            const evt = self._actions? self._actions[eventName] : undefined; 
            let customArgs = [];        
            if(arguments.length > 1){        
                for(let i=1;i<arguments.length; i++){            
                    customArgs.push(arguments[i]);                
                    }        
                }
                //wait for release
                //eventName = _LC.String.toCamelCase(eventName);
                _LC.throwAction.call(self,self._callee,eventName,undefined,true,customArgs,self);
            if(this.$node) {
                self.dispatchEvent(evt? evt : new CustomEvent(eventName, {"detail" : customArgs}));
            }
        },
        //this and scope reference should be either a node or a route.
        "throwAction" : function(scope,eventName,actObj,isCustom,customArgs, node, event, hasHandled, fromEv){
            let actionsObj;
            let stopBubble = false;
            if(this._route && isCustom) {
                scope = _Lyte.Router.getRouteInstance(this._route);
                actionsObj = scope.actions || (scope.actions = {});
            } else if(this.routeName) {
                //process for the parent route and get the current component and proceed;
                let parentRoute = this.parent;
                if(parentRoute) {
                    if(parentRoute.component) {
                        scope = parentRoute.component;
                        if(scope.component){
                            actionsObj = scope.component.constructor._actions; 
                        }else{
                            scope = _Lyte.Router.getRouteInstance(scope._route);
                            actionsObj = scope.actions || (scope.actions = {}); 
                        }
                    } else {
                        scope = parentRoute;
                        actionsObj =  scope.actions || (scope.actions = {});            
                    }
                }
            } else if(scope){
                if(scope.component && !scope._didDestroyCalled){
                    actionsObj = scope.component.constructor._actions
                }else{
                    return;
                }
            }
            if(!scope) {
                //Only warning is thrown because, we can have a eventListener for the dom directly. 
                if(!hasHandled) {
                    _Lyte.warn("Nothing handled the action "+ eventName + ".");    
                }
                return;
            }
            if(_Lyte.isWidgetBuild){
                if(!this.__widget){
                    return;
                }
            }else if(this.__widget){
                return;
            }
            actObj = (actObj) ? actObj : this._actions && this._actions[eventName]? this._actions[eventName].processAction : void 0;     
            //wait for release
            /* 
            var dasherizedEventName = _LC.String.dasherize(eventName);
            actObj = (actObj) ? actObj : this._actions && this._actions[dasherizedEventName]? this._actions[dasherizedEventName].processAction : void 0;     
            */
            let args = customArgs ? customArgs : [];
            if(actObj){
            	var contextSwitchArray = [];
                if(node) {
                	_LC.adCx(node, contextSwitchArray);
                }
                let concatArgs;
                if(actObj.skipArgProcessing) {
                    // concatArgs = _Lyte.deepCopyObject(actObj.args);
                    // concatArgs.shift();
                    // var eventIndex = concatArgs.indexOf("__lyteEvent__");
                    // var nodeIndex = concatArgs.indexOf("__lyteNode__");
                    // if(eventIndex !== -1) {
                    //     concatArgs[eventIndex] = event;
                    // } 
                    // if(nodeIndex !== -1) {
                    //     concatArgs[nodeIndex] = target;
                    // }
                    concatArgs = actObj.args;
                } else {
                    concatArgs = this.processArgs(scope,{"helperInfo" : actObj}, undefined, event, node);
                }
                args.splice.apply(args, [0,0].concat(concatArgs) );
                if(node) {
                	_LC.rmCx(node, contextSwitchArray);
                }
                if(actionsObj[actObj.name]){
                    if(!isCustom){  
                        //args.unshift(window.event);
                        let parent = node.parentNode;
                        let context = this.component;
                        if(this.__lyteWidget && widgetMap.has(this.__lyteWidget)){
                            context = widgetMap.get(this.__lyteWidget).getClone(this.component);
                        }
                        let val = actionsObj[actObj.name].apply(context,args);
                        if(!(event.currentTarget instanceof DocumentFragment) && (event.currentTarget != document.body) && !fromEv) {
                            val = false;
                        }
                        hasHandled = true;
                        stopBubble = _LCHD.shouldStop(node, event);
                     if(val !== false && !event.cancelBubble && !stopBubble){
                        if(actObj.from && node.getAttribute(event.type) && node._boundEvents && node._boundEvents[event.type]) {
                        		let actions = node._callee.component.constructor._actions;
                        		let actObj = node._boundEvents[event.type];
                        		let cloneActObj = _Lyte.deepCopyObject(actObj);
                                // cloneActObj.args.shift();
                                _LC.skipArgProcessing(cloneActObj, event, node);
                        		_LC.throwAction.call(node._callee,node._callee,event.type,cloneActObj, undefined, undefined, node, event, hasHandled);
                        	} else {
                                if(_LC.hasLyteEvents(node, eventName)) {
                                    let eventStopped = _LC.handleLyteEvents(node, event);
                                    val = eventStopped ? false : true;       
                                }
                                if(val === false) {
                                    return;
                                }
                        		if(_LC.isCustomElement(node)){
                        			scope = parent;
                        		}
                        		if(parent  &&  !(event.currentTarget !== document.body)){
                                    let eventStopped;
                                    while(parent && parent.getAttribute && (!parent.getAttribute(eventName) || parent.hasAttribute("disabled") ) && parent.tagName != "BODY"){
                                        if(parent._hiddenBoundEvents && parent._hiddenBoundEvents[eventName]){
                                            break;
                                         }
                        				if(_LC.hasLyteEvents(parent, eventName)) {
                                            eventStopped = _LC.handleLyteEvents(parent, event);
                                            if(eventStopped) {
                                                break;
                                            }
                                        }
                                        parent = parent.parentNode;
                        			}
                        			if(eventStopped || !parent || parent.tagName === "BODY"){
                        				return;
                        			}
                        			if(!parent._callee){
                        				parent._callee = parent.getCallee ? parent.getCallee(parent) : _LC.getCallee(parent);
                        			}
                        			if(parent && event.type === eventName && !event.cancelBubble){
                                       if(parent._evBoundEvents && parent._evBoundEvents[eventName]) {
                                           let actObj = parent._evBoundEvents[eventName];
                        		           let cloneActObj = _Lyte.deepCopyObject(actObj);
                                        //    cloneActObj.args.shift();
                                            _LC.skipArgProcessing(cloneActObj, event, parent);
                                           _LC.throwAction.call(parent,parent,eventName,cloneActObj,undefined,undefined,parent,event, hasHandled);  
                                       } else if(parent && parent._boundEvents && parent._boundEvents[eventName]) {
                                           let actObj = parent._boundEvents[eventName];
                        		           let cloneActObj = _Lyte.deepCopyObject(actObj);
		                                   _LC.skipArgProcessing(cloneActObj, event, parent);
                                           _LC.throwAction.call(parent._callee,parent._callee,eventName,cloneActObj,undefined,undefined,parent,event, hasHandled);  
                                       }
                                       _LCHD.triggerGlobalEvent(parent, eventName, event, hasHandled, true);
                        			}
                        		}
                        	}
                        }
                    }            
                    else{           
                        let context = this._callee.component;
                        if(this.__lyteWidget && widgetMap.has(this.__lyteWidget)){
                            context = widgetMap.get(this.__lyteWidget).getClone(this._callee.component);
                        }     
                        actionsObj[actObj.name].apply(this._callee.component,args);
                        hasHandled = true;                                             
                    } 
                }
                else{
                    _Lyte.error("LC004" , actObj.name);
                }
            } else if(isCustom && actionsObj) {
                var eventsObj = actionsObj[eventName]  || actionsObj[_LC.String.toCamelCase(eventName)] || actionsObj[_LC.String.dasherize(eventName)];
                if(eventsObj) {
                    var scopeS = _LC.isCustomElement(scope) ? scope.component : scope;
                    let context = scopeS;
                    if(this.__lyteWidget && widgetMap.has(this.__lyteWidget)){
                        context = widgetMap.get(this.__lyteWidget).getClone(scopeS);
                    } 
                    let val = eventsObj.apply(context,args);
                    //let val = eventsObj.apply(_LC.isCustomElement(scope)? scope.component : scope, args);
                    hasHandled = true;
                    if(val !== false) {
                        _LC.throwAction.call(scope, scope._callee, eventName, actObj, isCustom, customArgs, undefined, undefined, hasHandled);
                    }
                } else {
                    _LC.throwAction.call(scope, scope._callee, eventName, actObj, isCustom, customArgs, undefined, undefined, hasHandled);
                }
            }
            
        },
        "isControlHelper" : function(ownerElement) {
        	return (ownerElement.tagName === "TEMPLATE" && ownerElement.getAttribute("is") && ownerElement.getAttribute("is") !== "component") || (ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin"));
        },
        "isCustomElement" : function(node, isTemplate) {
            return node.hasAttribute && ((( node.tagName ==="TEMPLATE" || node.attributes["lyte-for"] || node.attributes["lyte-if"] || node.attributes["lyte-switch"] || node.attributes["lyte-forin"] ) && isTemplate )  || (node.nodeName && node.nodeName.indexOf('-') !== -1 && ( node.localName.startsWith("lyte-") || node.localName.startsWith("crux-") || _LyteComponent.registeredComponents[node.localName] || node.tagName === "LYTE-YIELD" || node.hasAttribute("lyte-v4") || node.hasAttribute("lyte-widget") || node.hasAttribute("lyte-registry") || (node._attributes ? node._attributes["lyte-registry"] : undefined) )));
        },
        "isCustomElementV3" : function(node, isTemplate) {
            return node.hasAttribute && ((( node.tagName ==="TEMPLATE" || node.attributes["lyte-for"] || node.attributes["lyte-if"] || node.attributes["lyte-switch"] || node.attributes["lyte-forin"] ) && isTemplate )  || (node.nodeName && node.nodeName.indexOf('-') !== -1 && (_LyteComponent.registeredComponents[node.localName] || node.tagName === "LYTE-YIELD")));
        },
        "componentSet" : function(key, value, options, forceExecute, fromParent, fromAttr) {
            if(!forceExecute && this.get(key) === value) {
                _LC.clearError(this.data, key);
                return;
            }else if((window.isLyteWidget || window.__lyteEnablePromise) && value instanceof Promise && !value.__lyte){
                _LC.listenPromise(this.data, key ,value);
                if(!options){
                    options = {};
                }
                options.skipTypeCast = true;
                options.skipValidation = true;
                // return;
            }
            //temporary fix
            _LC.set(this.data, key, value, options, undefined, fromParent, fromAttr);
        },
        /* disable async function */
        "componentGet" : function(key) {
            return key ? _LC.get(this.data, key) : this.data;
        },
        "nodeGet" : function(key) {
            return key ? this.component.get(key) : this.component.data;
        },
        "nodeSet" : function(key, value, options, fromParent, fromAttr) {
            if(window.isLyteWidget && this.hasAttribute("comp-in-parent")) {
                if(typeof value == "object"){
                    this.setAttribute(_LC.String.dasherize(key), JSON.stringify(value));
                }else{
                    this.setAttribute(_LC.String.dasherize(key), value);
                }
            }
            if(!this.component && window.isLyteWidget) {
                DataBindingLayer.valueSet(this.$data, key, value);
            } else {
                this.component.set(key, value, options, undefined, fromParent, fromAttr);
            }
        },
        "registerComponentWrapper" : function() {
            try{
                let rt = _LC.registerComponent.apply(_LC, arguments);
                _Lyte._postRegister();
                return rt;
            }catch(e){
                _Lyte._postRegister();
            }
        },
        "registerComponent" : function(componentName, definition, options, widget, compClass) {
            var Component;
            if(compClass) {
                Component = compClass;
                definition.data = Component.prototype.data;
                definition.actions = Component.actions ? Component.actions() : {};
                definition.methods = Component.methods ? Component.methods() : {};
                definition._helpers = Component.helpers ? Component.helpers() : {};
                var observers = Component.observers ? Component.observers() : {};
                for(var key in observers) {
                    definition[key] = observers[key];
                }
            }
            if(_LC._reRegisteredComponents.indexOf(componentName) == -1 && _LyteComponent.registeredComponents[componentName]) {
                if(!widget || (widget && _LyteComponent.registeredWidgetComponents && _LyteComponent.registeredWidgetComponents[widget] && _LyteComponent.registeredWidgetComponents[widget][componentName])){
                    _Lyte.warn("Component "+ componentName + " already registered");
                    return;
                }
            }
            let customCrmComponent;
            let alreadyRegistered;
            if((!widget && _LC._registeredComponents[componentName]) || (widget && _LyteComponent.registeredWidgetComponents && _LyteComponent.registeredWidgetComponents[widget] && _LyteComponent.registeredWidgetComponents[widget][componentName])) {
            	customCrmComponent = _LC._registeredComponents[componentName];
                alreadyRegistered = true;
            } else {
            	customCrmComponent = class extends customElementPrototype {};
                customCrmComponent._properties = {};
                customCrmComponent.activeInstances = 0;
                // customCrmComponent.compInstances = [];
                // customCrmComponent._depthTemp = document.createElement("template");
                customCrmComponent.prototype.throwAction = this.throwAction;
                customCrmComponent.compName = componentName;
                _LC.directive.registeredProp[componentName] = [];
            }
            // customCrmComponent.prototype.setData = function(arg0, arg1 ,options) {
            //     return this.component.setData(arg0, arg1, options);
            // }
            // customCrmComponent.prototype.getData = function(arg0) {
            //     return this.component.getData(arg0);
            // }
            _LCHD.define.remove(customCrmComponent);
            _LCHD.define.getContent(customCrmComponent);
            Object.defineProperty(customCrmComponent.prototype, "setData", {
                configurable : true, 
                writable : true,
                value : function(arg0, arg1 ,options) {
                    return this.component.setData(arg0, arg1, options);
                }
            });

            Object.defineProperty(customCrmComponent.prototype, "toggleData", {
                configurable : true, 
                writable : true,
                value : function(arg0) {
                    return this.component.toggleData(arg0);
                }
            });

            Object.defineProperty(customCrmComponent.prototype, "getData", {
                configurable : true, 
                writable : true,
                value : function(arg0) {
                    return this.component.getData(arg0);
                }
            });

            Object.defineProperty(customCrmComponent.prototype, "setMethods", {
                configurable : true, 
                writable : true, 
                value : function(arg0, arg1) {
                    return this.component.setMethods(arg0, arg1);
                }
            })
            
            customCrmComponent.prototype.get = this.nodeGet;
            customCrmComponent.prototype.set = this.nodeSet;
            customCrmComponent._bindsIds = [];
            options = options ? options : {};
            let aliasName = options.alias;
            let mixinsToBeUsed = [];
            let wdgtScp = widget ? widgetScopeMap.get(widget) : undefined;
            let scp = wdgtScp ? wdgtScp.Lyte : Lyte;
            // let serviceToBeUsed = Object.assign({},wdgtScp ? wdgtScp.Lyte.toBeInjectedServices : Lyte.toBeInjectedServices);
            // let serviceToBeUsed = {};
            var laterToBeUsed = {};

            let toBeUsed = {};
            // serviceToBeUsed = Object.assign({},Lyte.toBeInjectedServices);
			for (var key in options) {
				if (key == "services") {
					toBeUsed[key] = {};
					options.services.forEach(function (service) {
						if (typeof service == "string") {
							toBeUsed[key][service] = service;
						} else if (service && typeof service === "object") {
                            var srKey = service.as, srVal = service.service;
                            if (!Lyte._keywords.is(srKey, "component")) {                                
                                if(!service.scope || service.scope == "static"){
                                    toBeUsed[key][srKey] = srVal;
                                }
                                else if(service.scope == "instance"){
                                    var srKey = service.as, srVal = service.service;
                                    laterToBeUsed[key] = laterToBeUsed[key] || {};
                                    laterToBeUsed[key][srKey] = srVal;
                                }
                            }
                            else{
                                Lyte.warn("Service cannot be used in any keywords of Lyte.");
                            }
						}
					});
				}
                if (key == "mixins") {
                    toBeUsed[key] = [];
                    options.mixins.forEach(function (element) {
                        if (_Lyte.Mixin.exists(element)) {
                            toBeUsed[key].push(_Lyte.registeredMixins[element]);
                        } else {
                            _Lyte.$.requiredMixins(element, componentName, "component");
                        }
                    });
                }
    
                if( key == "ssr"){
                    customCrmComponent._ssr = options[ key ];
                    if(options[key].config){
                        customCrmComponent._config = options[key].config;
                    }
                }        
            }
            if(!Component) {
                /*disable async function*/
                let baseCompClass = LyteComponent.baseCompClass;
                /*disable async function*/
                Component = class extends baseCompClass {

                }
            }
            let $functions = Component.prototype.$functions = {};
            $functions.validate = function() {
                var compInstance = this._ins;
                var data = compInstance.data;
                for(var key in data) {
                    _LC.handleValidation(data, key, data[key], compInstance);
                }
            }
            $functions.getError = function(path){
                return _LC.getErrorStructure(this._ins,path)
            }
            $functions.addEventListener = function(eventName, func, options, wName) {
                // let widgetName = wName || this._ins.__wName;
                if(eventName.indexOf("-") != -1) {
                    console.error("Event Name can't be hypenated");
                }
                let widgetName = this._ins.__wName;
                let widgetInstance = window.LyteWidgetClass._widgetInstances[widgetName];
                let listenerId = widgetName + "-" + widgetInstance.eventCounter++ + "-" + eventName;
                if(!options || !options.origin) {
                    options = { "origin" : [widgetName]};
                } else if(typeof options.origin != "string") {
                    options.origin.forEach(function(item, index) {
                        if(item == "_self") {
                            options.origin[index] = widgetName;
                        }
                    });
                }
                options.componentName = this._ins.$node.localName;
                window.LyteWidgetClass.addEventListener(eventName, func, options, widgetName || this._ins.__wName, listenerId);
                return listenerId;
            }

            $functions.removeEventListener = function(listenerId ) {
                let widgetName = this._ins.__wName;
                window.LyteWidgetClass.removeEventListener(listenerId, widgetName);
            }
            $functions.triggerEvent = function(eventName, data, options, wName) {
                // let widgetName = wName || this._ins.__wName;
                let widgetName = this._ins.__wName;
                if(!options || !options.target) {
                    options = { "target" : [widgetName]}
                } else if(typeof options.target != "string") {
                    options.target.forEach(function(item, index) {
                        if(item == "_self") {
                            options.target[index] = widgetName;
                        }
                    })
                }
                window.LyteWidgetClass.triggerEvent(eventName, data, options, widgetName || this._ins.__wName);
            }
            /*disable async function*/
            Component.prototype._setWidget = function() {
                if(widget) {
                    Object.defineProperty(this, "__wName", {
                        "enumerable" : false, 
                        "configurable" : false, 
                        "writable" : false, 
                        "value" : widget
                    })
                }
            }
            Component._v3 = true;
            // Component.compInstances = [];
            Component._widget = widget;
            customCrmComponent.component = Component;
            Component._helpers = definition._helpers || {};
            delete definition.helpers;
            let compPrototype = Component.prototype;
            compPrototype.$lg = Lyte.__gl;
            compPrototype.set = this.componentSet;
            compPrototype.get = this.componentGet;
            if(window.requireValidateInComponent) {
                compPrototype.validate = function() {
                    var data = this.data;
                    for(var key in data) {
                        _LC.handleValidation(data, key, data[key], this);
                    }
                }
            }
            compPrototype.throwEvent = this.throwEvent;
            compPrototype.executeMethod = _LC.executeMethod;
            compPrototype.getData = _LC.componentGetData;
            compPrototype.setData = _LC.componentSetData;
            compPrototype.toggleData = _LC.componentToggleData;
            compPrototype.getMethods = _LC.componentGetMethods;
            compPrototype.setMethods = _LC.componentSetMethods;
            compPrototype.hasAction = _LC.componentHasAction;
            compPrototype.setActions = _LC.componentsetActions;
            customCrmComponent._mixins = options.mixins;
			customCrmComponent._serviceToBeUsed = laterToBeUsed ? laterToBeUsed.services : undefined;
            var actionsFromMixin = {};
            var ltInjServ = Lyte.toBeInjectedServices;
            if(ltInjServ){
                for(var injServ in ltInjServ){
                    Lyte.$.injectServices.component(injServ, ltInjServ[injServ], undefined, Lyte.__gS[injServ], customCrmComponent);
                }
            }
            for(var tKey in toBeUsed){
                if(tKey == "mixins"){
                    var aFromMixin = {}, methodsFromMixin = {},newDefinition = {};
                    _LC.dataFromMixin(toBeUsed.mixins,actionsFromMixin,methodsFromMixin,newDefinition);
                    definition = Object.assign(newDefinition, definition);
                    actionsFromMixin = Object.assign(actionsFromMixin, aFromMixin);
                }
                else if(tKey == "services"){
                    var serviceToBeUsed = toBeUsed[tKey];
                    for(var serv in serviceToBeUsed){
                        if(Lyte.registeredServices.hasOwnProperty(serviceToBeUsed[serv])){
							definition[serv] = Lyte.$.instantiateService(serviceToBeUsed[serv]);
                        }else{
                            Lyte.$.requiredServices(serv,serviceToBeUsed[serv],function(serviceData,serviceKey,cname,sname){
								var customCrmComponent = _LC._registeredComponents[componentName];
								customCrmComponent.component.prototype[serviceKey] = Lyte.$.instantiateService(sname);
                            })
                        }
                    }        
                }
            }
            customCrmComponent._actions = Object.assign({}, actionsFromMixin, definition.actions);
            // customCrmComponent._template = definition._template;
            customCrmComponent._dynamicNodes = definition._dynamicNodes;
            customCrmComponent._templateAttributes = definition._templateAttributes;
            customCrmComponent._callBacks = {};
            customCrmComponent._observers = [];
            Component._callBacks = {};
            Component._observers = [];
            Component._properties = {};
            Component.activeInstances = 0;
            Component._depthTemp = document.createElement("template");
            Component._mixins = options.mixins;
            Component._actions = customCrmComponent._actions
            Component._template = definition._template;
            Component._dynamicNodes = definition._dynamicNodes;
            Component._templateAttributes = definition._templateAttributes;
            if(definition._preRenderTemplate){
                let html = definition._preRenderTemplate;
                let div = document.createElement("div");
                div.innerHTML = html;
                Component._preRenderTemplate = div.firstChild;
                definition._preRenderTemplate = null;
            }
            delete definition._template;
            delete definition._dynamicNodes;
            delete definition._templateAttributes;
//            let properties = definition.data ? definition.data : {};
            let properties = definition.data ? definition.data : undefined;
            let methods = Object.assign({},methodsFromMixin, definition.methods);
//            customCrmComponent._observedAttributes = Object.keys(properties);
            customCrmComponent._observedAttributes = definition._observedAttributes || [];
            customCrmComponent.dasherizeObservedAttributes();
            customCrmComponent._observedMethodAttributes = definition._observedMethodAttributes || {};
            Component._observedAttributes = definition._observedAttributes || [];
            Component._observedMethodAttributes = definition._observedMethodAttributes || {};
            customCrmComponent._deepWatchProperties = definition._deepWatchProperties || {};
            delete definition._observedAttributes;
            delete definition._observedMethodAttributes;
            delete definition.data;
            delete definition.methods;
            definition = _LC.updateCustomCrmComponent(definition,customCrmComponent);
            customCrmComponent._data = properties;
            customCrmComponent._methods = methods;
            Component._data = properties;
            Component._methods = methods;
            if(!Lyte.getConfig("lazyComponentRegister")){
                customCrmComponent._registerComponent(componentName,customCrmComponent,widget);
            }
            else{
                if(idleScheduler.tasks.get(componentName)){
                    idleScheduler.deleteTask(componentName);
                }
                idleScheduler.enqueueTask(customCrmComponent._registerComponentFn(componentName,customCrmComponent,widget), [], componentName);
                // idleScheduler.enqueueTask(function(componentName, customCrmComponent, widget){
                //     customCrmComponent._registerComponent(componentName,customCrmComponent,widget);
                // }, [componentName, customCrmComponent, widget], componentName);
            }
            _LyteComponent.registeredComponents[componentName] = true;
            if(aliasName) {
                _LyteComponent.registeredComponents[aliasName] = true;
            }
            if(_Lyte.isWidgetBuild) {
                window._wrapperComponents.push(componentName.toUpperCase());
                if(aliasName) {
                    window._wrapperComponents.push(aliasName.toUpperCase());
                }
            }
            let aliasClass;
            if(!_LC._registeredComponents[componentName]) {
            	if (document.readyState === "complete" || document.readyState === "interactive" || window.preLoadLyteComponents) {     
            		// document is already ready to go
            		customElements.define(componentName, customCrmComponent, undefined , _Lyte.isWidgetBuild ? { "widget" : true} : {v3 : true});
                    if(aliasName) {
                        aliasClass = class extends customCrmComponent {};
                        customElements.define(aliasName, aliasClass, undefined , _Lyte.isWidgetBuild ? { "widget" : true} : {v3 : true});
                    }
            	}
            	else{
            		_LC.toBeRegistered.push({name:componentName, def: customCrmComponent, _lyteOptions : _Lyte.isWidgetBuild ? { "widget" : true} : {v3 : true} });
                    if(aliasName) {
                        aliasClass = class extends customCrmComponent {

                        };
                        _LC.toBeRegistered.push({name:aliasName, def: aliasClass, _lyteOptions : _Lyte.isWidgetBuild ? { "widget" : true} : {v3 : true} });
                    }
            	}
                _LC._registeredComponents[componentName] = customCrmComponent;
                if(aliasName) {
                    _LC._registeredComponents[aliasName] = aliasClass;
                }
            }
            if(!Lyte.getConfig("lazyComponentRegister")){
                _LC.postRegistration(componentName, customCrmComponent);
            }
            if(widget){
                var wObj = _LyteComponent.registeredWidgetComponents = _LyteComponent.registeredWidgetComponents || {};
                var wObj1 = wObj[widget] = wObj[widget] || {};
                wObj1[componentName] = customCrmComponent;
            }
            let pendComps = _LC.V3.pendingComp.find(componentName);
            if(pendComps && pendComps.length){
                _LC.V3.pendingComp.execute(pendingComps);
            }
            if(alreadyRegistered) {
                var pendingComps = customCrmComponent._pendingComponents || [];
                pendingComps.forEach(function(item) {
                    delete item.__lyteIgnore 
                    item.actualConstructor();
                    var arr = Array.from(item.attributes);
                    arr.forEach(function(attr) {
                        if(item.constructor.observedAttributes.indexOf(attr.name) != -1) {
                            item.attributeChangedCallback(attr.name, null, attr.value);
                        }
                        
                    });
                    item.connectedCallback();
                });
                customCrmComponent._pendingComponents = [];
            }
            return customCrmComponent;
        },
        "postRegistration" : function(componentName, customCrmComponent){
            let depthTemp = customCrmComponent.component._depthTemp;
            if(!_LC._ie && depthTemp && depthTemp.content.childNodes.length) {
                depthTemp.setAttribute("data-id", "depthTemp_" + componentName);
                _LC.lyteComponentsDiv.appendChild(depthTemp);
            } else {
                delete customCrmComponent.component._depthTemp;
            }
        },
        "registerHelper" : function(name,helper){
            _LyteComponent.registeredHelpers[name] = helper;
        },
        "registerMixin" : function(name,mixin){
            _Lyte.Mixin.register.call(_Lyte, name, mixin);
        },
        "typeCast" : function(value, dataType, obj) {
        	if(value === null) {
        		return value;
        	}
        	try {
        		switch(dataType) {
            	case "string" : 
            		return typeof value === "object" ? JSON.stringify(value) : value.toString(); 	
            	break;
            	case "number" :
            		{
                    if(value == "") {
                        return undefined;
                    }
            		let val = +value;
            		if(isNaN(val)) {
            			throw "TypeCast exception";
            		} 
            		return val;
            		}
            	break;
            	case "array" : 
            	case "object" :
            		return JSON.parse(value);
            		break;
            	case "boolean" :
            		return ( (!value && value !== "") || value=== "false") ? false : true; 
            	break;
            	default : 
            		return value;
            	}
        	} catch(e) {
        		if(obj) {
        			obj.isError = true;
        		}
        		return value;
        	}    	
        },
        "sendtoclient": function(prop,server,node){
            var data = server ? prop.component.data : prop;
            var newData = {};
            var data_prop = node;
            for (var i in data){
                if(server){
                    var def = prop.component.__data[i];
                    if(i == "bindIds"){ 
                        newData[i] = {value : data[i] }
                    }
                        if(def && /^(object|array)$/.test(def.type) && prop._attributeDetails && prop._attributeDetails.hasOwnProperty(LyteComponent.String.dasherize(i))){
                            newData[i] = { "fP" : true };
                        }
                        else if(data[i] instanceof Date){
                            newData[i] = { "value" : data[i] , "type" : "Date" }
                        }
                        else if(data_prop[i]){
                            newData[i] = { "value" : data[i] , "type" : data_prop[i].type }
                        }else{
                            var type = typeof(data[i])
                            if(data[i] == undefined){
                                type = undefined;
                            }
                            newData[i] = {"value" : data[i] ,"type":type}
                        }
                }else{
                    if(data[i].type=="Date"){
                        newData[i] = new Date(data[i].value);
                    }
                    else if(!data[i].fP){
                        newData[i]= data[i].value;
                    }
                }
            }
            return newData;        	
        },
        "getDataType" : function(value) {
            var type = typeof value;
            if(type === "object") {
                if(Array.isArray(value)) {
                    return "array";
                }
            }
            return type;
        },
        "handleValidation" : function(object, property, value, component ,init) {
            let error = _Lyte.validate(object, property, value, component ,init);
            let cmpData = LyteComponent.getCmpData(component.data);
            if(error) {
                _LC.set(cmpData.errors, property, error);
                if(component.$node.callback) {
                    component.$node.callback("onError", property, error);
                }
            } else {
                _LC.clearError(object, property);
            }
            return error;
        },
        "clearError" : function(data, property) {
            if(data.errors && data.errors[property]) {
                _Lyte.objectUtils(data.errors, "delete", property);
            }
        },
        "createLyteId" : function(comp){
            comp.__counter++;
            return "__lyteId" + comp.__counter;
        },
        "apdNode" : function(node, comp) {
            _LC.tDiv.content.appendChild(node);
            let id = this.createLyteId(comp);
            comp.__h[id] = node;
            node.__lyteId = id;
        },
        "update":function(object, property, value, options, fromStore,oldValue,setterScope, actualProperty, fromParent,storeRecord, fromAttr){
        	let fromComponent = object.__component__;
        	let updateAttr = true;
            
            let dataType, dataDef, estObjBind = false;
        	if(!oldValue){
                oldValue = object[property];
                if(fromComponent && fromComponent.tagName !== "LYTE-YIELD") {
                    dataDef = fromComponent.component.__data[property];
                    if(!options || (typeof options == "object" && options.skipValidation != true)){
                        if(dataDef && (dataType = dataDef.type)) {
                            updateAttr = !dataDef.hideAttr;
                            if(dataType !== _LC.getDataType(value) && (value !== undefined || dataType === "boolean")) {
                                value = _LC.typeCast(value, dataType);
                            }
                        }
                    }
                	if(value === oldValue && (!options || !options.force)) {
                        _LC.clearError(object, property);
                        return;
                	}
                    if(!options || (typeof options == "object" && options.skipValidation != true)){
                        let error = _LC.handleValidation(object, property, value, fromComponent.component);
                        if(error) {
                            return;
                        }
                    }
            }
            
            	//object[property] = value;
                if(!object.hasOwnProperty(property) && !(Array.isArray(object))) {
                    _LC.oF(object, "add", property, value, true )
                } else {
                    // DataBindingLayer Set
                    if(window.isLyteWidget && (!options || (options.postmessage != false)) ) {
                        DataBindingLayer.valueSet(object, property, value);
                    }
                    else if(Lyte.isWidgetBuild && (!options || (options.postmessage != false)) && object.__component__ && object.__component__.hasAttribute("comp-in-parent") && !fromAttr) {
                        DataBindingLayer.sendDataUpdateToFrame(object.__component__, { [property] :  value });
                    }
                    object[property] = value;
                }
            }
            if(window.isLyteWidget && options && options.postmessage === false) {
                updateAttr = false;
            }
            let toBeExecuted = fromComponent ? true : false;
            let dasherizedAttr = _LC.String.dasherize(property);
            let callDeepObs = false;
            if(object._scp){
                if(!Lyte.cmpData(oldValue, value)){
                    callDeepObs = true;
                }
                if(oldValue && (Array.isArray(oldValue) || typeof oldValue == "object")){
                    var keys = Array.from(object._scp.keys());
                    keys.forEach(function(id){
                        var nestObj = Lyte.nestScp[id];
                        var isCyclic = nestObj.cyclic;
                        Lyte.removeNestScp(oldValue, id);
                        if(isCyclic){
                            Lyte.bindObj(nestObj._data, undefined, id, [], new Map(), undefined, undefined, true);
                        }
                    });
                }
            }
            if((Lyte.isRecord(object) && object.$.__scpObj) || (object.hasOwnProperty("__component__") && object.__component__.__scpObj)){
                var _scpObj, kmpKey;
                if(Lyte.isRecord(object)){
                    _scpObj = object.$.__scpObj;
                    kmpKey = object;
                }else{
                    _scpObj = object.__component__.__scpObj;
                    kmpKey = object.__component__;
                }
                if(_scpObj.hasOwnProperty(property)){
                    var _sId = _scpObj[property].split("_");
                    Lyte.removeNestScp(oldValue, _sId[0], _sId[1], undefined, kmpKey, undefined, Lyte.isRecord(value) || Array.isArray(value) && value.model && value.add ? value : undefined);
                    delete _scpObj[property];
                }
            }
            var customDtype;
            if(dataDef &&  Lyte.Transform[dataDef.type]){
                var customDataType = Lyte.Transform[dataDef.type]
                if(/^(object|array)$/.test(customDataType.extends) && (customDataType.hasOwnProperty("properties") || customDataType.hasOwnProperty("items"))){
                    customDtype=true;
                }
            }
            if (fromStore && Lyte.isRecord(object) || object && object.hasOwnProperty("_scp") && object._scp.size || dataDef && /^(object|array)$/.test(dataDef.type) && dataDef.watch == true || customDtype) {
                Lyte.establishObjectBinding(object, property, fromStore, true, storeRecord, (dataDef && dataDef.watch)?dataDef.watch:undefined);
           }
            if(fromComponent && actualProperty && ( (typeof value === "string" && fromComponent.getAttribute(dasherizedAttr) !==  value) || fromComponent.hasAttribute(dasherizedAttr) )) {
                 if((!_LC.customPropRegex.exec(property) || fromComponent.hasAttribute(dasherizedAttr) ) && updateAttr) {
                     if(value && typeof value === "object") {
                    	 let jsonString;
                         try{
                            jsonString = JSON.stringify(value);
                            let attrNode1 = fromComponent.attributes.getNamedItem(dasherizedAttr);
                            attrNode1.__lyteIgnore = true;
                            fromComponent.setAttribute(dasherizedAttr, jsonString);
                            attrNode1.__lyteIgnore = false;
                         } catch(e) {

                         }
                     } else {
                    	 let attributeString = _LC.typeCast(value, "string");
                    	 if(fromComponent.getAttribute(dasherizedAttr) !== attributeString) {
                             let detAttr = fromComponent.attributes.getNamedItem(dasherizedAttr);
                             if(detAttr) {
                                 detAttr.__lyteIgnore = true;
                             }
                             attributeString = attributeString || "";
                             fromComponent.setAttribute(dasherizedAttr, attributeString);
                             if(detAttr) {
                                detAttr.__lyteIgnore = false;
                             }
                         }
                     }
                 }
            }
            if(value && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number" ) {
                //newValue is of type object 
                
                if(oldValue && typeof oldValue === "object" && oldValue._bindings) {
                    //Both oldValue and newValue are objects. 
                    if(!value._bindings) {
                        defProp(value, "_bindings", {
                            enumerable: false, 
                            writable: true, 
                            value : new Set(),
                            configurable: true
                        });
                    }
                    let fcmpData = fromComponent ? (LyteComponent.getCmpData(fromComponent.component.data)) : undefined;
                    //for changing only child component
                    if(fromComponent && fcmpData === object && property.indexOf('.')=== -1 && !window.isLyteWidget) {
                        let bindings = fromComponent.getProperty(property);
                        this.removeSelectedBindingDeep(bindings, oldValue);
                        addBindings(value,bindings);
                        this.establishBindings(bindings, value);
                        //For removing binding in the object due to forIn Helper ( actual object binding and not the _dynamicNodes binding).
                        if(bindings._forHelpers) {
                            let bindfor = bindings._forHelpers.toArrayLyte();
                            for(var i=0;i<bindfor.length;i++){
                                let item = bindfor[i];
                                if(item._propBindingObject) {
                                    this.removeSelectedBindingDeep(item._propBindingObject, oldValue);
//                                  value._bindings.add(item._propBindingObject);
//                                  this.establishBindings(item._propBindingObject, value);
                                }
                            }
                        }
                        this.affectChanges(bindings,undefined,oldValue,setterScope,object[property],undefined,options);
                    } else {
                    	//To change only the bindings present in the object and not all the bindings present in the oldValue.
                    	if(object._bindings) {
                    		let oldbind = object._bindings.toArrayLyte();
                            for(let i=0; i<oldbind.length;i++){
                                let item = oldbind[i][property];
                                if(item) {
                                	this.removeSelectedBindingDeep(item, oldValue);
                                    addBindings(value,item);
                                	this.establishBindings(item, value);
                                	//For removing binding in the object due to forIn Helper ( actual object binding and not the _dynamicNodes binding).
                                	if(item._forHelpers) {
                                		let forbind = item._forHelpers.toArrayLyte();
                                		for(let j=0;j<forbind.length;j++){
                                			let itemBinding = forbind[j];
                                			if(itemBinding._propBindingObject) {
                                				this.removeSelectedBindingDeep(itemBinding._propBindingObject, oldValue);
                                			}
                                		}
                                	}
                                	this.affectChanges(item,undefined,oldValue,setterScope,object[property],undefined,options);
                                }
                            }
                    	}
                    
                    
                    }
                } else {
                    //newValue is object and oldValue is string. Hence establish bindings from oldValue's object and place it in the newValue. 
                    if(object._bindings) {
                    	// makeSet(value, "_bindings");
                        let objbind = object._bindings.toArrayLyte();
                        for(let i=0;i<objbind.length;i++){
                            let item = objbind[i];
                            if(item[property]) {
                                addBindings(value,item[property]);
                                this.establishBindings(item[property], value);
                                this.affectChanges(item[property],undefined,oldValue,setterScope,object[property],undefined,options);
                            }
                        }
                    }
                }
                dataDef = dataDef || (fromComponent && fromComponent.tagName !== "LYTE-YIELD" ? fromComponent.component.__data[property] : undefined); 
                if((fromStore && Lyte.isRecord(object)) || (object && object.hasOwnProperty("_scp") && object._scp.size) || (dataDef && (/^(object|array)$/.test(dataDef.type))&& (dataDef.watch || (dataDef.hasOwnProperty("items") || dataDef.hasOwnProperty("properties"))) )){
                    estObjBind = true;
                }
            } else {
                //newValue is string
                
                if(oldValue && typeof oldValue === "object" && oldValue._bindings && object._bindings) {
                    //newValue is string and oldValue is object 
                    let objbind = object._bindings.toArrayLyte();
                    for(let i=0;i<objbind.length;i++){
                        let item = objbind[i];
                        if(item[property]) {
                            //oldValue._bindings.delete(item[property]);
                            //if(oldValue._bindings.size === 0) {
                            //  delete oldValue._bindings;
                            //  break;
                            //}
                        this.removeSelectedBindingDeep(item[property], oldValue);
                            if(item[property]._forHelpers) {
                                let forbind = item[property]._forHelpers.toArrayLyte();
                                for(let j=0;j<forbind.length;j++){
                                    let itemBinding =forbind[j];
                                    if(itemBinding._propBindingObject) {
                                        this.removeSelectedBindingDeep(itemBinding._propBindingObject, oldValue);
                                    }
                                }
                            }
                        }
                    }
                }
                
                //when newValue and oldValue , both are string, no need to change bindings. 
                if(object._bindings) {
                    let objbind = object._bindings.toArrayLyte();
                    for(let i=0;i<objbind.length;i++){
                        let item = objbind[i];
                        if(item[property]) {
                            this.affectChanges(item[property],undefined,oldValue,setterScope,object[property],undefined,options);
                        }
                    }
                }
            }
            if(callDeepObs && object._scp){
                this.callDeepObservers(object, { type:"deepChange", oldValue:oldValue, newValue : value }, property);
            }
            let dasherizedProperty = _LC.String.dasherize(property);
            if(fromComponent && fromComponent.__widgetP) {
                DataBindingLayer.sendLbindUpdate(fromComponent, dasherizedProperty, value);
            }
            if(toBeExecuted && !fromParent && fromComponent._attributeDetails && fromComponent._callee) {
            	//let syntaxValue = fromComponent.getAttributeNode(property).syntaxValue;
            	let dasherizedProperty = _LC.String.dasherize(property);
            	let attrDetail = fromComponent._attributeDetails[dasherizedProperty];
            	let syntaxValue;
            	if(attrDetail && attrDetail.isLbind) {
            		syntaxValue = attrDetail.dynamicValue;
            	}
            	if(syntaxValue) {
            		let contextSwitchArray;
            		if(fromComponent._cx) {
            			contextSwitchArray = [];
            			_LC.changeContext(fromComponent._cx.node, contextSwitchArray, fromComponent._cx )
            		}
                    let fclData = LyteComponent.getCmpData(fromComponent._callee.component.data);
                    let obj = _LC.getNew(fclData, syntaxValue);
                    if(!obj.context){
                        return;
                    }
            		let exec = false;
            		if(obj.context === fclData) {
            			if(fromComponent._callee._properties[obj.lastKey] && fromComponent._callee._properties[obj.lastKey].__fromComponent) {
            				exec = true;
            			}
            		} else {
            			exec = true;
            		}
            		//self.setData(this._lbind,this.value);
            		if(exec) {
                        let lastKeyIndex = +obj.lastKey;
                        if(Array.isArray(obj.context) && typeof lastKeyIndex == "number") {
                            let callReplaceAt = lastKeyIndex < obj.context.length;
                            if(obj.context[lastKeyIndex] !== value || !callReplaceAt){
                                _LC.aF(obj.context, callReplaceAt ? "replaceAt" : "insertAt", lastKeyIndex, value);
                            }
                        } else {
                            _LC.set(obj.context, obj.lastKey, value, options);
                        }
            		}
            		if(contextSwitchArray) {
            			_LC.removeContext(fromComponent._cx.node, contextSwitchArray, fromComponent._cx )
            		}
            	}
            }
        },
        "getContentForIE" : function getContentForIE(content, constr, newlyCreated, info) {
            if(typeof content === "string") {
                newlyCreated = true;
                var div = createElement("div");
                div.innerHTML = content;
                content = div.childNodes[0];
                constr.splitTextNodes(content);
            }
            if(content.getAttribute && content.getAttribute("depth")) {
                if(Lyte._ms && info) {
                    info._content = div;
                }
                var itr = parseInt(content.getAttribute("depth"));
                content = _Lyte._ie ? content : (newlyCreated ? content.content : content.content.cloneNode(true));
                for(var i=0;i<itr;i++) {
                    content = content.childNodes[0];
                }
            }
            return content;
        },
        "replaceWithPf" : function(node1, node2) {
            if(_Lyte._rwpf) {
            	insertBefore(node1.parentNode,node2, node1);
                node1.remove();
            } else {
                node1.replaceWith(node2);
            }
        },
        "getCallee" : function(callee, self){
            while(callee &&  !_LC.isCustomElementV3(callee) && callee.tagName !== "LYTE-YIELD") {
                if(callee.tagName === "BODY") {
                    callee = null;
                    break;
                }
                callee = callee.parentNode;
            }
            if(callee && callee.tagName === "LYTE-YIELD") {
            return callee._registerYield? callee._registerYield._callee : undefined;
            }
            return ((self ===  callee) ? undefined : callee);
        },
        "set" : function(object, property, value, options, fromStore, fromParent, fromAttr) {
            let lastIndex = -1;
            var s_rec,check={},recDottedProp;
            if(Lyte.isRecord(object) && fromStore){
                s_rec=object;
            }
            if(!(typeof property === "object") || !property){
                property = property+"";
                lastIndex = property.lastIndexOf('.');
            }
            let actualProperty = property;
            if(lastIndex !== -1) {
                let outerPropertyPath = property.substring(0, lastIndex);
                property = property.substring(lastIndex + 1);
                object = _LC.get(object, outerPropertyPath);
                recDottedProp=true;
            }
            if(object && object.__ltPrx__){
                object = object.__target__;
                // object[property] = value;
                // return;
            }
            let val1 = object[property] && object[property].__target__ ? object[property].__target__ : object[property];
            let val2 = value && value.__target__ ? value.__target__ : value;
            if(typeof property === "string" && val1 === val2 && (!options || !options.force)) {
                if(object.__component__) {
                    _LC.clearError(object, property);
                } else if(_Lyte.isRecord(object) && !object.$.isCloned) {
                    store.$.clrRecErr(object.$, property);
                    object.$.emit ? object.$.emit("set", [object, property]) : undefined;
                    object.$.model && object.$.model.emit ? object.$.model.emit("set", [object.$.model._name, object, property]) : undefined;
                    store.emit ? store.emit("set", [object.$.model._name, object, property]) : undefined;
                }
                return;
            }
            let oldValues = [];
            if(object._setterScope){
                var setterScope = object._setterScope;
            }
            var checkSim = false, watch = [];
            if(object._scp && object._scp.size){
                var keys = Array.from(object._scp.keys());
                keys.forEach(function(id){
                    var _obj = object._scp.get(id);
                    obj = _obj.paths;
                    var recObj = Lyte.nestScp[id], model, field, rec, attr, wobj = {};
                    var pathArr = Object.keys(obj), aPath;
                    if(pathArr.length > 1){
                        aPath = "*";
                    }
                    else if(pathArr.length == 1){
                        aPath = pathArr[0];
                    }
                    wobj.path = aPath;
                    wobj.id = id;
                    if(pathArr.length > 1){
                        wobj.paths = pathArr;
                    }
                    wobj.attr = attr;
                    wobj.data = recObj.data;
                    wobj.PropsInfo = recObj.PropsInfo||undefined;
                    if(recObj.model){
                        var mMap = recObj.model;
                        wobj.Error = recObj.Error;
                        var mKeys = Array.from(recObj.model.keys());
                        for(var i=0; i<mKeys.length; i++){
                            var mName = mKeys[i];
                            var pkMap = mMap.get(mName);
                            if(pkMap){
                                var pkArr = Array.from(pkMap.keys());
                                var pkLen = pkArr.length;
                                for(var j=0; j<pkLen; j++){
                                    var mPk = pkArr[j];
                                    var attrMap = pkMap.get(mPk);
                                    var attrArr = Array.from(attrMap.keys());
                                    var attrLen = attrArr.length;
                                    for(k=0; k<attrLen; k++){
                                        var mAttr = attrArr[k];
                                        var mObj = Object.assign({}, wobj);
                                        var mRec = store.peekRecord(mName, mPk);
                                        if(mRec){
                                            model = mRec.$.model;
                                            field = model.fieldList[mAttr];
                                            if(field && (field.properties || field.items || field.watch == true || Lyte.Transform[field.type])){
                                                mObj.data = Lyte.deepCopyObject(mRec[mAttr]);
                                                mObj.rec = mRec;
                                                mObj.isRec = true;
                                                mObj.attr = mAttr;
                                                mObj.dtype = model.fieldList[mAttr];
                                                mObj._cmpErr=mRec.$.error;
                                                mObj.key=mAttr;
                                            }
                                            watch.push(mObj);
                                        }
                                    }
                                }
                            }
                        }
                    } 
                    else{
                        watch.push(wobj);
                    }
                    // var isAttr = rec.$._attributes.hasOwnProperty(attr);
                    // if(!isAttr){
                    //     rec.$._attributes[attr] = Lyte.deepCopyObject(rec[attr]);
                    // }
                    // else{
                    //     checkSim = true;
                    // }
                    // rec.$.isModified = true;          
                });
                watch.forEach(function(val){
                    if((!options || (typeof options == "object" && options.skipValidation != true)) ){
                        var id = val.id,path=val.path.split("."),dtype=val.dtype,errs;
                        if(val.isRec){
                            if(fromStore){
                                path = actualProperty.split(".")
                                path.splice(-1);
                                path.shift();
                            }
                            path = path.length == 1 && path[0] == property ? []:path;
                            check.Prop = dtype;
                            Lyte.checkNestedProp(id,path,dtype,val,object,property,value,check,fromStore); 
                        }
                        if(val.PropsInfo){
                            val.PropsInfo.forEach(function(props){
                                props.path = val.path;
                                props.attr = val.attr;
                                dtype = props.dtype;
                                check.Prop = dtype;
                                Lyte.checkNestedProp(id,path,dtype,props,object,property,value,check,fromStore);
                            })
                        }
                    }
                })
                if(check.value && check.value.code){
                    _Lyte.error("ERR35",check.Prop.type)
                    return;
                }
            }
            actualProperty = actualProperty === property ? actualProperty : undefined;
            var shareObj = {};
            if(typeof property === "object"){
            	if(_Lyte.isRecord(object) && !fromStore && !object.$.isCloned) {
                        // for(let key in property){
                        //     if(Array.isArray(object[key])){
                        //         oldValues.push({key:key,oldValue:object[key].slice(0)});    
                        //     }
                        //     else{
                        //         oldValues.push({key:key,oldValue:object[key]});
                        //     }
                        // }
                        for(let key in property) {
                            let locValue = property[key];
                            let dataType = object.$.model.fieldList[key];
                            dataType = dataType ? dataType.type : undefined;
                            if(dataType && (locValue !== undefined || dataType === "boolean") && dataType !== _LC.getDataType(locValue)) {
                                property[key] = _LC.typeCast(locValue, dataType);
                            }
                        }
                        let record = store.$.setData(object.$, property, undefined, options, undefined, undefined, shareObj);
                        if(record.$.isError){
                            return record;
                        }
                        // for(let i=0; i<oldValues.length; i++){
                        //     _LC.update(object,oldValues[i].key,object[oldValues[i].key],fromStore,(oldValues[i].oldValue === undefined)?null:oldValues[i].oldValue ,setterScope, actualProperty, fromParent);
                        // }
                } else {
                    //object[property] =  value;
                    for(let key in property){
                        //_LC.update(object,key,property[key],fromStore,undefined,setterScope, actualProperty, fromParent);
                        //value is option here
                        _LC.set(object,key,property[key],value,fromStore, fromParent);
                    }
                }
            }
            else{
                if(_Lyte.isRecord(object) && (!fromStore || (fromStore && recDottedProp)) && !object.$.isCloned) {
                    let old = object[property];
					let dataType = object.$.model.fieldList[property];
                    dataType = dataType ? dataType.type : undefined;
                    if(dataType && (value !== undefined || dataType === "boolean") && dataType !== _LC.getDataType(value)) {
                        value = _LC.typeCast(value, dataType);
                    }
                    let record = store.$.setData(object.$, property,value, options, undefined, undefined, shareObj);
                    if(record.$.isError){
                        return record;
                    }
                    //Commented because update will happend when "set" is called from setData of store. 
                    //_LC.update(object,property,value,fromStore,(old === undefined) ? null : old,setterScope , actualProperty);    
                } else {
                    _LC.update(object,property,value,options,fromStore,undefined,setterScope,actualProperty, fromParent, s_rec, fromAttr);
                }
            }
            if(watch && watch.length){
                watch.forEach(function(obj){
                    if(obj.isRec){
                        store.$.deepValueChange(obj.rec, obj.attr, obj.rec[obj.attr], obj);
                    }
                });
            }
        },
        "adCx" : function(node, contextSwitchArray) {
        	let isYield = node.tagName === "LYTE-YIELD";
        	if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
        		_LC.changeContext(node._cx.node, contextSwitchArray, node._cx, isYield);
        	} else if(isYield && node._callee._cx) {
        		_LC.changeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx, true);
        	}
        }, 
        "rmCx" : function(node, contextSwitchArray, oneLevel) {
        	let isYield = node.tagName === "LYTE-YIELD";
        	if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
        		_LC.removeContext(node._cx.node, contextSwitchArray, node._cx, isYield, oneLevel);
        	} else if(isYield && node._callee._cx) {
        		_LC.removeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx, true, oneLevel);
        	}
        },
        "changeContext" : function(node, contextSwitchArray, contextSwitchInfo, proceedFurther) {
            if(!contextSwitchInfo) {
                return;
            }
            let isYield = node.tagName === "LYTE-YIELD";
            if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
                _LC.changeContext(node._cx.node, contextSwitchArray, node._cx, node.tagName === "LYTE-YIELD" || proceedFurther);
            } else if((node.tagName === "LYTE-YIELD" || proceedFurther) && node._callee && node._callee._cx) {
            	_LC.changeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx);
            }
            if(isYield) {
                let insertYield = node._registerYield;
                let callee = insertYield._callee;
                if(callee && callee._cx) {
                    _LC.changeContext(callee._cx.node, contextSwitchArray, callee._cx);
                }
            }
            let indexValue, itemValue;
            if(contextSwitchInfo.type) {
                if(contextSwitchInfo.type === "for") {
                    indexValue = node.getAttribute("index");
                    itemValue = node.getAttribute("item");
                    if(node._items.length === 0) {
                        return;
                    }
                } else {
                    indexValue = node.getAttribute("key");
                    itemValue = node.getAttribute("value");
                    if(Object.keys(node._items).length === 0) {
                        return;
                    }
                }
                let callee = node._callee;
                let cmpData = LyteComponent.getCmpData(callee.component.data);
                let initialItemValue = cmpData[itemValue];
                let initialIndexValue = cmpData[indexValue];
                let initialItemProp = callee._properties[itemValue];
                let initialIndexProp = callee._properties[indexValue];
                let initialPropDetails = {};
                if(node._childProp && node._childProp.length){
                    node._childProp.forEach(function(propName){
                        if(contextSwitchInfo.node._propNodes[propName]){
                            initialPropDetails[propName] = {
                                data : callee.component.data[propName],
                                prop : callee._properties[propName]
                            }
                            let itInd = contextSwitchInfo.itemIndex;
                            callee.component.data[propName] = contextSwitchInfo.node._propNodes[propName][itInd];
                            callee._properties[propName] = node._items[itInd].propProperty[propName];
                            contextSwitchInfo.__prop = true;
                        }
                    })
                }
                else if(node._currentProp && node._currentProp.length){
                    node._currentProp.forEach(function(propName){
                        if(contextSwitchInfo.node._propNodes[propName]){
                            initialPropDetails[propName] = {
                                data : callee.component.data[propName],
                                prop : callee._properties[propName]
                            }
                            let itInd = contextSwitchInfo.itemIndex;
                            callee.component.data[propName] = contextSwitchInfo.node._propNodes[propName][itInd];
                            callee._properties[propName] = node._items[itInd].propProperty[propName];
                            contextSwitchInfo.__prop = true;
                        }
                    })
                }
                 let items = contextSwitchInfo.type === "for" ? node._currentItems : node._currentObject;
                // let items = contextSwitchInfo.type === "for" ? node._attributes.items : node._attributes.object;
                cmpData[itemValue] = items[contextSwitchInfo.itemIndex];
                cmpData[indexValue] = contextSwitchInfo.itemIndex;
                callee._properties[itemValue] = node._items[contextSwitchInfo.itemIndex].itemProperty;
                callee._properties[indexValue] = node._items[contextSwitchInfo.itemIndex].indexProperty;
                let dummyObject = {"initialItemValue" : initialItemValue , "initialIndexValue" : initialIndexValue, "initialItemProp" : initialItemProp, "initialIndexProp" : initialIndexProp, "initialPropDetails" : initialPropDetails};
                contextSwitchArray.push(dummyObject);
            } else {
                //handling for yield
                let dummyObject = {};
                let callee = node._registerYield._callee;
                let cmpData = LyteComponent.getCmpData(callee.component.data);
                Object.keys(contextSwitchInfo.node._properties).forEach(function(key) {
                    dummyObject[key] = {};
                    dummyObject[key].value = cmpData[key];
                    dummyObject[key].property = callee._properties[key];
                    callee._properties[key] = contextSwitchInfo.node._properties[key];
                    let ctxtData = LyteComponent.getCmpData(contextSwitchInfo.node.component.data);
                    cmpData[key] = ctxtData[key];
                }); 
                contextSwitchArray.push(dummyObject);
            }
        },
        "removeContext" : function(node, contextSwitchArray, contextSwitchInfo, proceedFurther, oneLevel) {
            if(!contextSwitchInfo) {
                return;
            }
            let isYield = node.tagName === "LYTE-YIELD";
            if(!oneLevel) {
                if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
                    _LC.removeContext(node._cx.node, contextSwitchArray, node._cx, node.tagName === "LYTE-YIELD" || proceedFurther);
                } else if((node.tagName === "LYTE-YIELD" || proceedFurther) && node._callee && node._callee._cx) {
                    _LC.removeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx)
                }
            }
            if(isYield) {
                let insertYield = node._registerYield;
                let callee = insertYield._callee;
                if(callee && callee._cx) {
                    _LC.removeContext(callee._cx.node, contextSwitchArray, callee._cx);
                }
            }
            let indexValue, itemValue;
            if(contextSwitchInfo.type) {
                if(contextSwitchInfo.type === "for") {
                    indexValue = node.getAttribute("index");
                    itemValue = node.getAttribute("item");
                    if(node._items.length === 0) {
                        return;
                    }
                } else {
                    indexValue = node.getAttribute("key");
                    itemValue = node.getAttribute("value");
                    if(Object.keys(node._items).length === 0) {
                        return;
                    }
                }
                let callee = node._callee;
                let items = node._attributes.items;
                let removedObject;
                let cmpData = LyteComponent.getCmpData(callee.component.data);
                if(contextSwitchInfo.__prop){
                    removedObject = contextSwitchArray.pop();
                }else{
                    removedObject = contextSwitchArray.shift();
                }
                cmpData[itemValue] = removedObject.initialItemValue;
                let initialPropDetails = removedObject.initialPropDetails
                if(initialPropDetails){
                    for(let propName in initialPropDetails){
                        let propDetails = initialPropDetails[propName];
                        cmpData[propName] = propDetails.data;
                        callee._properties[propName] = propDetails.prop;
                    }
                }
                cmpData[itemValue] = removedObject.initialItemValue;
                cmpData[indexValue] = removedObject.initialIndexValue;
                callee._properties[itemValue] = removedObject.initialItemProp;
                callee._properties[indexValue] = removedObject.initialIndexProp;
            } else {
                let callee = node._registerYield._callee;
                let removedObject = contextSwitchArray.shift();
                let cmpData = LyteComponent.getCmpData(callee.component.data);
                Object.keys(contextSwitchInfo.node._properties).forEach(function(key) {
                    cmpData[key] = removedObject[key].value;
                    callee._properties[key] = removedObject[key].property;
                });
            }
        },
        "sortCommands" : function(array1, arrayB) {
            var retVal = {};
            if(array1 && array1.__target__){
                array1 = array1.__target__;
            }
            let arrayA = array1.slice();
            retVal.origianlArray = array1;
            var commands = [];
            for (let i = 0; i < arrayB.length; i++) {
                // var targetIndex = arrayA.findIndex((element) => element === arrayB[i]);
                let arrBi = arrayB[i];
                if(arrayB[i] && arrayB[i].__target__){
                    arrBi = arrayB[i].__target__;
                }
                var targetIndex = arrayA.indexOf(arrBi);
            
                if (targetIndex === -1) {
                commands.push({
                    type: 'Add',
                    element: arrBi, 
                    toIndex : i
                });
                arrayA.splice(i, 0, arrBi);
                } else {
                if (targetIndex !== i) {
                    commands.push({
                    type: 'Move',
                    element: arrBi,
                    fromIndex: targetIndex,
                    toIndex: i
                    });
                    arrayA.splice(targetIndex, 1);
                    arrayA.splice(i, 0, arrBi);
                }
                }
            }
            
            for (let i = arrayA.length - 1; i >= arrayB.length; i--) {
                commands.push({
                type: 'Remove',
                element: arrayA[i]
                });
                arrayA.splice(i, 1);
            }
            retVal.commands = commands;
            retVal.changedArray = arrayB;
            return retVal;
        },
        "oF" : function() {
            let object = arguments[0];
            if(object && object.__target__){
                object = object.__target__;
            }
            let functionName = arguments[1];
            let property = arguments[2];
            let newValue = arguments[3];
            if(newValue && newValue.__target__){
                newValue = newValue.__target__;
            }
            let fromComponent = arguments[4];
            let fromStore = arguments[5];
            if(functionName === "add" && !fromComponent && !object._propNodes) {
            	_LC.set(object, property, newValue, undefined,fromStore);
            	return;
            }
            let options = {};
            options.type = functionName;
            options.property = property;
            if(!/^(add|delete)$/.test(functionName)) {
                _Lyte.error("LC005", functionName);
                return;
            }
            let bindings = object._bindings;
            if(functionName === "delete") {
            	_LC.set(object, property, undefined, undefined,fromStore);
            } else {
                object[property] = newValue;
            }
            if(bindings) {
                let bind = bindings.toArrayLyte();
                for(let i=0;i<bind.length;i++) {
                    let binding = bind[i];
                    let forHelpers = binding._forHelpers;
                    if(forHelpers) {
                    	let helperBind = forHelpers.toArrayLyte();
                        for(let j=0;j<helperBind.length;j++) {
                            let forHelper = helperBind[j];
                            if(forHelper.getAttribute("is") != "forIn"){
                                continue;
                            }
                            let itemValue = forHelper.getAttribute("key");
                            //Need to check
//                            _LC.removeSelectedBindingDeep({[itemValue] :                        forHelper._items[property].itemProperty}, {[itemValue] : object[property]});
                        	let contextSwitchArray = [];
                            if(functionName === "add") {
                            	_LC.adCx(forHelper, contextSwitchArray);
                            }
                            forHelper._callee.updateForInHelper(forHelper, options);
                            if(functionName === "add") {
                                _LC.rmCx(forHelper, contextSwitchArray);
                            }
                            _LCSV.affectChangesComp(forHelper);
                        }
                    }
                }
            }
            if(functionName === "delete") {
                delete object[property];
            }
        },
        "aF" : function() {
            let array = arguments[0];
            if(array && array.__target__){
                array = array.__target__;
            }
            let initialArrLength = array.length;
            let callLengthObserver = true;
            let functionName = arguments[1];
            let value = arguments[3],check={};
            if(value && value.__target__){
                value = value.__target__;
            }
            if(/^(replaceAt|removeAt|shift)$/.test(functionName) && !array.length) {
                _Lyte.warn(functionName + " operation cannot be performed on empty array");
                return;
            }
            let commands;
            if(functionName == "sort") {
                var originalArray = arguments[0];
                var sortFunction = arguments[2];
                var addedArguments = arguments[3] || [];
                var dummyArray = originalArray.slice();
                addedArguments.forEach(function(item) {
                    dummyArray.push(item);
                });
                if(typeof arguments[2] == "function") {
                    dummyArray.sort(sortFunction);
                } else {
                    var obj = arguments[2];
                    var key = obj.sortBy;
                    var order = obj.sortOrder;
                    function sorting(item1, item2) {
                        var item1 = key ? (Lyte.isRecord(item1) ? item1.$.get(key) : item1[key]) : item1;
                        var item2 = key ? (Lyte.isRecord(item2) ? item2.$.get(key) : item2[key]) : item2;
                        if(item1 > item2) {
                            return order ? 1 : -1;
                        } else if(item1 < item2) {
                            return order ? -1 : 1;
                        } else {
                            return 0;
                        }
                    }
                    dummyArray.sort(sorting)
                }
                commands = this.sortCommands(originalArray, dummyArray).commands;
            }
            let commArgs = arguments[2], oldVal, obsObj, watch = [];
            if(array._scp && /^(replaceAt|splice|removeAt|remove|insertAt)$/.test(functionName)){
                array._scp.forEach(function(_obj, id){
                    var rec, attr, wobj = {};
                    var recObj = Lyte.nestScp[id];
                    var obj = _obj.paths;
                    var pathArr = Object.keys(obj), aPath;
                    if(pathArr.length > 1){
                        aPath = "*";
                    }
                    else if(pathArr.length == 1){
                        aPath = pathArr[0];
                    }
                    wobj.path = aPath;
                    wobj.id = id;
                    if(pathArr.length > 1){
                        wobj.paths = pathArr;
                    }
                    wobj.attr = attr;
                    wobj.data = recObj.data;
                    wobj.reInit = Lyte.isRecord(recObj.data) || (Array.isArray(recObj.data) && recObj.data.model && recObj.data.add);
                    wobj.PropsInfo = recObj.PropsInfo || undefined;
                    wobj.index=commArgs;
                    if(recObj.model){
                        var mMap = recObj.model;
                        wobj.Error = recObj.Error;
                        var mKeys = Array.from(recObj.model.keys());
                        for(var i=0; i<mKeys.length; i++){
                            var mName = mKeys[i];
                            var pkMap = mMap.get(mName);
                            if(pkMap){
                                var pkArr = Array.from(pkMap.keys());
                                var pkLen = pkArr.length;
                                for(var j=0; j<pkLen; j++){
                                    var mPk = pkArr[j];
                                    var attrMap = pkMap.get(mPk);
                                    var attrArr = Array.from(attrMap.keys());
                                    var attrLen = attrArr.length;
                                    for(k=0; k<attrLen; k++){
                                        var mAttr = attrArr[k];
                                        var mObj = Object.assign({}, wobj);
                                        var mRec = store.peekRecord(mName, mPk);
                                        if(mRec){
                                            model = mRec.$.model;
                                            field = model.fieldList[mAttr];
                                            if(field && (field.properties || field.items || field.watch == true || Lyte.Transform[field.type] )){
                                                mObj.data = Lyte.deepCopyObject(mRec[mAttr]);
                                                mObj.rec = mRec;
                                                mObj.isRec = true;
                                                mObj.attr = mAttr;
                                                mObj.dtype = model.fieldList[mAttr];
                                                mObj._cmpErr=mRec.$.error;
                                                mObj.key=mAttr;
                                            }
                                            // mObj.reInit = true;
                                            watch.push(mObj);
                                        }
                                    }
                                }
                            }
                        }
                    } 
                    else{
                        wobj.reInit = Lyte.isRecord(recObj.data) || (Array.isArray(recObj.data) && recObj.data.model && recObj.data.add);
                        watch.push(wobj);
                    }
                });
                watch.forEach(function(val){
                    var id = val.id,
                    path=val.path == "" ? [] : val.path.split("."),
                    dtype=val.dtype || undefined;
                    if(val.isRec){
                        // path.shift();
                        // path = path.length == 1 && path[0] == property ? []:path;
                        check.Prop = dtype;
                        Lyte.checkNestedProp(id, path, dtype, val, array, val.index, value, check);
                    }
                    if(val.PropsInfo){
                        val.PropsInfo.forEach(function(props){
                            props.path = val.path ;
                            dtype = props.dtype;
                            props.index = val.index;
                            check.Prop = dtype;
                            Lyte.checkNestedProp(id, path, dtype, props, array, val.index, value, check);
                        })
                    }
                })
                if(check.value && check.value.code){
                    _Lyte.error("ERR35",check.Prop.type);
                    return;
                }
            }  
            switch(functionName) {
            case "replaceAt" : 
                {
                let index = parseInt(arguments[2]);
                if(index > array.length) {
                    _Lyte.warn("index provided for replaceAt is greater than array length");
                    return [];
                }
                //let args = Array.prototype.slice.call(arguments, 3);
                let args = arguments[3];
                if(!(Array.isArray(args))) {
                    args = [args];
                }
                let deletedItems = array.splice.apply(array, [index, 1].concat(args));
                let options = {"firstIndex" : index, "secondIndex" : args.length, "type" : "replace"};
                //All references updated by now
                if(options.secondIndex == 1){
                    callLengthObserver = false;
                }
                //remove binding from previous object
                if(array._bindings) {
                    let objbind = array._bindings.toArrayLyte();
                    for(let i=0;i<objbind.length;i++){
                        let item = objbind[i];
                        if(item._forHelpers) {
                            let helperbind = item._forHelpers.toArrayLyte();
                            for(let j=0;j<helperbind.length;j++){
                                let helper = helperbind[j];
                                if(helper.getAttribute("is") != "for"){
                                    continue;
                                }
                                /*if(helper.hasAttribute("unbound")) {
                            		continue;
                            	}*/
                                let finalIndex = index + deletedItems.length;
                                let itemValue = helper.getAttribute("item");
                                for(let i=index, j=0;i<finalIndex;i++,j++) {
                                    _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});
                                }
                                let contextSwitchArray = [];
                                _LC.adCx(helper, contextSwitchArray);
                                helper._callee.updateForHelper(helper, options);
                                _LC.rmCx(helper, contextSwitchArray);
                                _LCSV.affectChangesComp(helper);
                            }
                        }
                        for(let key in item) {
                            let parsedKey = parseInt(key);
                            let cond = (options.secondIndex == 1) ? (parsedKey == options.firstIndex) : (parsedKey >= options.firstIndex);
                            if(!isNaN(parsedKey) && cond) {
                                let diff = parsedKey - options.firstIndex;
                                let oldObject;
                                if(diff < 1) {
                                    oldObject = deletedItems[diff];
                                } else {
                                    oldObject = array[options.firstIndex - 1  + options.secondIndex + diff];
                                }
                                this.removeSelectedBindingDeep(item[key], oldObject);
                                if(item[key]._forHelpers) {
                                    let bindfor = item[key]._forHelpers.toArrayLyte();
                                    for(var j=0;j<bindfor.length;j++){
                                        let item1 = bindfor[j];
                                        if(item1._propBindingObject) {
                                            this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                        }
                                    }
                                }
                                if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                	makeSet(array[parsedKey], "_bindings");
                                this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});
                                }
                                this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);
                                if(options.secondIndex == 1){
                                    break; 
                                }
                            }
                        }
                    }
                }
                obsObj = {type:"array",insertedItems:args, removedItems:deletedItems, index:index};
                _LC.bindWatchObj(watch, array, args, deletedItems, index);
                _LC.callArrayObservers(array,obsObj,callLengthObserver,initialArrLength);
                return deletedItems[0];
                }
                break;
            case "splice" : {
                let index = parseInt(arguments[2]);
                if(index > array.length) {
                    _Lyte.warn("index provided is greater than array length");
                    return [];
                }
                let toBeDeleted = arguments.length > 3 ? arguments[3] : array.length - index;
                let args = arguments.length > 4 ? arguments[4] : [];
                if(!(Array.isArray(args))) {
                    args = [args];
                }
                let deletedItems = array.splice.apply(array, [index, toBeDeleted].concat(args));
                let options = {"firstIndex" : index, "secondIndex" : args.length, "thirdIndex" : toBeDeleted, "type" : "splice"};
                //All references updated by now
                if(options.secondIndex == options.thirdIndex){
                    callLengthObserver = false
                }
                //remove binding from previous object
                if(array._bindings) {
                    let objbind = array._bindings.toArrayLyte();
                    for(let i=0;i<objbind.length;i++){
                        let item = objbind[i];
                        if(item._forHelpers) {
                            let helperbind = item._forHelpers.toArrayLyte();
                            for(let j=0;j<helperbind.length;j++){
                                let helper = helperbind[j];
                                /*if(helper.hasAttribute("unbound")) {
                            		continue;
                            	}*/
                                if(helper.getAttribute("is") != "for"){
                                    continue;
                                }
                                let finalIndex = index + deletedItems.length;
                                let itemValue = helper.getAttribute("item");
                                for(let i=index, j=0;i<finalIndex;i++,j++) {
                                    _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});
                                }
                                let contextSwitchArray = [];
                                _LC.adCx(helper, contextSwitchArray);
                                helper._callee.updateForHelper(helper, options);
                                _LC.rmCx(helper, contextSwitchArray);
                                _LCSV.affectChangesComp(helper);
                            }
                        }
                        for(let key in item) {
                            let parsedKey = parseInt(key);
                            var cond = options.secondIndex == options.thirdIndex ? key >= options.firstIndex && key < (options.firstIndex+options.secondIndex) : parsedKey >= options.firstIndex;
                            if(!isNaN(parsedKey) && cond) {
                                let diff = parsedKey - options.firstIndex;
                                let oldObject;
                                if(diff < options.thirdIndex) {
                                    oldObject = deletedItems[diff];
                                } else {
                                    oldObject = array[options.firstIndex - options.thirdIndex  + options.secondIndex + diff];
                                }
                                this.removeSelectedBindingDeep(item[key], oldObject);
                                if(item[key]._forHelpers) {
                                    let bindfor = item[key]._forHelpers.toArrayLyte();
                                    for(var j=0;j<bindfor.length;j++){
                                        let item1 = bindfor[j];
                                        if(item1._propBindingObject) {
                                            this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                        }
                                    }
                                }
                                if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                	makeSet(array[parsedKey], "_bindings");
                                this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});
                                }
                                this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);
                            }
                        }
                    }
                }
                obsObj = {type:'array',index:index,insertedItems:args, removedItems:deletedItems};
                _LC.bindWatchObj(watch, array, args, deletedItems, index);
                _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength);
                return deletedItems;
            }
            break;
            case "push" : 
                {
                let toPush = arguments[2];
                if(!(Array.isArray(toPush))) {
                    toPush = [toPush];
                }
                _LC.aF(array, 'insertAt', array.length, toPush);
                }
                break;
            case "pop" : 
                   return _LC.aF(array, 'remove', array.length -1)[0];
                break;
            case "shift" : 
            case "shiftObject" :
                  return _LC.aF(array, 'remove', 0)[0];
                  break;
            case "removeAt" : 
            case "remove" : 
                {
                let index = parseInt(arguments[2]);
                if(index > array.length) {
                    _Lyte.warn("index provided for removeAt is greater than array length");
                    return [];
                }
                let length = arguments[3] ? parseInt(arguments[3]) : 1;
                let options = {"firstIndex" : index, "secondIndex" : length, "type" : "remove"};
                let deletedItems = array.splice(index,length);
                if(array._bindings) {
                    let objbind = array._bindings.toArrayLyte();
                    for(let i=0;i<objbind.length;i++){
                        let item = objbind[i];
                        if(item._forHelpers) {
                            let helperbind = item._forHelpers.toArrayLyte();
                            for(let j=0;j<helperbind.length;j++){
                                let helper = helperbind[j];
                                /*if(helper.hasAttribute("unbound")) {
                            		continue;
                            	}*/
                                if(helper.getAttribute("is") != "for"){
                                    continue;
                                }
                                let finalIndex = index + deletedItems.length;
                                let itemValue = helper.getAttribute("item");
                                for(let i=index, j=0;i<finalIndex;i++,j++) {
                                    _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});
                                }
                                let contextSwitchArray = [];
                                _LC.adCx(helper, contextSwitchArray);
                                helper._callee.updateForHelper(helper, options);
                                _LC.rmCx(helper, contextSwitchArray);
                                _LCSV.affectChangesComp(helper);
                            }
                           }
                            for(let key in item) {
                            let parsedKey = parseInt(key);
                            if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
                                let diff = parsedKey - options.firstIndex;
                                let oldObject;
                                if(diff < options.secondIndex) {
                                    oldObject = deletedItems[diff];
                                } else {
                                    oldObject = array[options.firstIndex - options.secondIndex + diff];
                                }
                                this.removeSelectedBindingDeep(item[key], oldObject);
                                if(item[key]._forHelpers) {
                                    let bindfor = item[key]._forHelpers.toArrayLyte();
                                    for(var j=0;j<bindfor.length;j++){
                                        let item1 = bindfor[j];
                                        if(item1._propBindingObject) {
                                            this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                        }
                                    }
                                }
                                if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                	makeSet(array[parsedKey], "_bindings");
                                this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});
                                }
                                this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);
                            }
                        }
                    }
                }
                obsObj = {type:"array",removedItems:deletedItems,index:index};
                _LC.bindWatchObj(watch, array, undefined, deletedItems, index);
                _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength); 
                return deletedItems;
                }
                break;
            case "removeObject" : 
                    commArgs = [commArgs];
            case "removeObjects" :
                if(!(Array.isArray(commArgs))) {
                    commArgs = [commArgs];
                }
                if(commArgs == array){
                    commArgs = Array.from(commArgs);// both array are same instance so cloning
                }
                for(var i=0;i<commArgs.length;i++) {
                    var indVal = commArgs[i];
                    if(indVal && indVal.__target__){
                        indVal = indVal.__target__;
                    }
                    let inde = array.indexOf(indVal);
                    if(inde !== -1) {
                       _LC.aF(array, 'removeAt', inde);                         
                    }
                }
                //_Lyte.arrayUtils(array, 'removeObject', actObj);
                //_Lyte.arrayUtils(array, 'removeObjects', []);
            break;
            case "unshift" : 
            case "unshiftObject" : 
            case "unshiftObjects" : 
                //_LC.aF.apply(_LC, [array, 'insertAt', 0].concat(Array.prototype.slice.call(arguments, 2)));
                {
                let toPush = arguments[2];
                if(!(Array.isArray(toPush))) {
                    toPush = [toPush];
                }
                _LC.aF(array, 'insertAt', 0, toPush);
                }
                break;
            case "insertAt" : 
                {
                let index = parseInt(arguments[2]);
                //let args = Array.prototype.slice.call(arguments, 3);
                let args = arguments[3];
                let len = args.length;
                if(!(Array.isArray(args))) {
                    args = [args];
                }
                for(let i=index;i>array.length;i--) {
                    args.unshift(undefined);
                    index--;
                }
                let options = {"firstIndex" : index, "secondIndex" : args.length, "type" : "insert"};
                array.splice.apply(array, [index, 0].concat(args));
                if(array._bindings) {
                    let arrbind = array._bindings.toArrayLyte();
                    for(let i=0;i<arrbind.length;i++){
                        let item = arrbind[i];
                        if(item._forHelpers) {
                            let forbind = item._forHelpers.toArrayLyte();
                            for(let j=0;j<forbind.length;j++){
                            	/*if(forbind[j].hasAttribute("unbound")) {
                            		continue;
                            	}*/
                                let helper = forbind[j];
                                if(helper.getAttribute("is") != "for"){
                                    continue;
                                }
                                let contextSwitchArray = [];
                                _LC.adCx(helper, contextSwitchArray);
                                helper._callee.updateForHelper(helper, options);
                                _LC.rmCx(helper, contextSwitchArray);
                                _LCSV.affectChangesComp(helper);
                            }
                        }
                        for(let key in item) {
                            let parsedKey = parseInt(key);
                            if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
                                this.removeSelectedBindingDeep(item[key], array[parsedKey+options.secondIndex]);
                                if(item[key]._forHelpers) {
                                    let bindfor = item[key]._forHelpers.toArrayLyte();
                                    for(var j=0;j<bindfor.length;j++){
                                        let item1 = bindfor[j];
                                        if(item1._propBindingObject) {
                                            this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                        }
                                    }
                                }
                                if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                	makeSet(array[parsedKey], "_bindings");
                                this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});    
                                }
                                this.affectChanges(item[key],undefined,array[parsedKey + options.secondIndex],undefined,array[parsedKey]);
                            }
                        }
                    }
                }
                let position = parseInt(arguments[2]);
                obsObj = {type:"array",insertedItems:(!(Array.isArray(arguments[3]))) ? [arguments[3]]: arguments[0].slice(position,position+len),index:position};
                _LC.bindWatchObj(watch, array, args, undefined, position);
                _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength);                
                }
                break;
            case "concat" : 
                //_LC.aF.apply(_LC, [array, 'insertAt',array.length].concat(arguments[2]));
                _LC.aF(array, 'insertAt', array.length, arguments[2]);
                break;
            case "sort" :  {
                let optionsArray = [];
                commands.forEach(function(command) {
                    switch(command.type) {
                        case "Remove" : {
                            let removedItems = array.splice(command.toIndex, 1);
                            optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "type" : "remove", "removedItem" : removedItems[0]});
                        }
                        break;
                        case "Move" : {
                            let removedItems = array.splice(command.fromIndex, 1);
                            array.splice(command.toIndex, 0, command.element);
                            optionsArray.push({"firstIndex" : command.fromIndex, "secondIndex" : 1, "type" : "remove", "removedItem" : removedItems[0]});
                            // optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "thirdIndex" : 0, "type" : "splice"});
                            optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "type" : "insert"});
                        }
                        break;
                        case "Add" : {
                            array.splice(command.toIndex, 0, command.element);
                            // optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "thirdIndex" : 0, "type" : "splice"});
                            optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "type" : "insert"});
                        }
                        break;
                    }
                });
                if(array._bindings) {
                    let arrbind = array._bindings.toArrayLyte();
                    for(let i=0;i<arrbind.length;i++){
                        let item = arrbind[i];
                        if(item._forHelpers) {
                            let forbind = item._forHelpers.toArrayLyte();
                            for(let j=0;j<forbind.length;j++){
                            	/*if(forbind[j].hasAttribute("unbound")) {
                            		continue;
                            	}*/
                                let helper = forbind[j];
                                if(helper.getAttribute("is") != "for"){
                                    continue;
                                }
                                let contextSwitchArray = [];
                                _LC.adCx(helper, contextSwitchArray);
                                for(let j=0;j<optionsArray.length;j++) {
                                    let optionItem = optionsArray[j];
                                    // Removal of bindings
                                    let itemValue = helper.getAttribute("item");
                                    if(optionItem.type == "remove") {
                                        this.removeSelectedBindingDeep({[itemValue] : helper._items[optionItem.firstIndex].itemProperty}, {[itemValue] : optionItem.removedItem});
                                    }
                                    helper._callee.updateForHelper(helper, optionItem);
                                }
                                _LC.rmCx(helper, contextSwitchArray);
                                _LCSV.affectChangesComp(helper);
                            }
                        }
//                         for(let key in item) {
//                             let parsedKey = parseInt(key);
//                             if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
//                                 this.removeSelectedBindingDeep(item[key], array[parsedKey+options.secondIndex]);
//                                 if(item[key]._forHelpers) {
//                                     let bindfor = item[key]._forHelpers.toArrayLyte();
//                                     for(var j=0;j<bindfor.length;j++){
//                                         let item1 = bindfor[j];
//                                         if(item1._propBindingObject) {
//                                             this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
// //                                          value._bindings.add(item._propBindingObject);
// //                                          this.establishBindings(item._propBindingObject, value);
//                                         }
//                                     }
//                                 }
//                                 if(array[parsedKey] && typeof array[parsedKey] === "object") {
//                                 	makeSet(array[parsedKey], "_bindings");
//                                 this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});    
//                                 }
//                                 this.affectChanges(item[key],undefined,array[parsedKey + options.secondIndex],undefined,array[parsedKey]);
//                             }
//                         }
                    }
                }
                if(Array.isArray(arguments[3]) && arguments[3].length) {
                    obsObj = {type:"array",insertedItems:arguments[3]};
                    var indices = [];
                    arguments[3].forEach(function(item) {
                        indices.push(array.indexOf(item));
                    });
                    obsObj.indices = indices;
                    _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength);
                }
            }
                break;
            default: 
                _Lyte.error("LC006" , functionName);
                return;
            }
        },
        "callDeepObservers" : function (data, args, property ,callLengthObserver){
            var self = this;
            var keys = Array.from(data._scp.keys());
            keys.forEach(function(id){
                var _scp = data._scp.get(id), 
                scp = _scp.paths,
                pathArr = Object.keys(scp), 
                aPath;
                if(pathArr.length == 1){
                    aPath = pathArr[0];
                }
                else if(pathArr.length > 1){
                    aPath = pathArr;
                }
                var recObj = Lyte.nestScp[id], 
                attr, 
                rec, 
                isRec = false;
                if(recObj.model){
                    var mMap = recObj.model;
                    var mKeys = Array.from(recObj.model.keys());
                    for(var i=0; i<mKeys.length; i++){
                        var mName = mKeys[i];
                        var pkMap = mMap.get(mName);
                        if(pkMap){
                            var pkArr = Array.from(pkMap.keys());
                            var pkLen = pkArr.length;
                            for(var j=0; j<pkLen; j++){
                                var mPk = pkArr[j];
                                var attrMap = pkMap.get(mPk);
                                var attrArr = Array.from(attrMap.keys());
                                var attrLen = attrArr.length;
                                for(k=0; k<attrLen; k++){
                                    var mAttr = attrArr[k];
                                    var mRec = store.peekRecord(mName, mPk);
                                    self.deepObsBind(mRec, true, mAttr, args, pathArr, aPath, data, property, callLengthObserver)                                    
                                }
                            }
                        }
                    }
                } 
                else{
                    rec = recObj.data;
                    self.deepObsBind(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver)
                }
            });
        },
        "deepObsBind":function(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver){
            var type = args.type
            var watchPath , propPath;
            if(rec._bindings){
                var newArgs = Object.assign({},args);
                var objbind = rec._bindings.toArrayLyte();
                for (var _i65 = 0; _i65 < objbind.length; _i65++) {
                    propPath = aPath;
                    var binding = objbind[_i65], obj = undefined;
                    watchPath = objbind[_i65]._path
                    if(isRec){
                        if(binding.hasOwnProperty(attr) && binding[attr].hasOwnProperty("*")){
                            obj = binding[attr]["*"];
                            watchPath = binding[attr]._path;
                        } 
                    }
                    else if(binding.hasOwnProperty("*")){
                        obj = binding["*"];
                    }
                    if(obj){
                        var obsbind = obj._observers ? obj._observers.toArrayLyte() : [], path;
                        if(property){
                            if(pathArr.length > 1){
                                var len = pathArr.length, nPathArr = [];
                                for(var i=0;i<len;i++){
                                    nPathArr.push(pathArr[i] ? pathArr[i]+"."+property : property);
                                }
                                propPath = nPathArr;
                            }
                            else if(pathArr.length == 1){
                                propPath = aPath ? aPath.concat("." + property) : property;
                            }
                        }
                        for (var j = 0; j < obsbind.length; j++) {
                            var observer = obsbind[j];
                            newArgs.path = propPath;
                            newArgs.type = "deepChange";
                            newArgs.data = rec;
                            var argPath = obj._path.split('.');
                            argPath.pop();
                            newArgs.item = argPath.join('.'); 
                            var exactPath = newArgs.index!=undefined?(propPath!=""?propPath+".":propPath)+newArgs.index:propPath
                            if(observer.callee && observer.callee.component){
                                //  observer.observer.value.call(observer.callee.component, newArgs);
                                var calldeep = true;
                                var _data = observer.callee.component.__data[newArgs.item];
                                var _watch = _data ? _data.watch : undefined;
                                if(_data && typeof _watch != "boolean"){
                                    var watchArr = obsbind[j].observer.Jpath[watchPath];
                                    calldeep = Lyte.checkWatchPath(exactPath , watchArr);
                                }
                                if(calldeep){
                                    observer.observer.value.call(observer.callee.component, newArgs);
                                }
                            }
                            else{
                                var scope = data._setterScope ? data._setterScope : window;
                                if(Array.isArray(scope)){
                                    var sLen = scope.length;
                                    for(var k=0;k<sLen;k++){
                                        var itm = scope[k];
                                        var calldeep = true;
                                        if(newArgs.data && newArgs.hasOwnProperty("item")){
                                            var watchArr = newArgs.data.$.model._fldGrps.watch[newArgs.item].watch
                                            if(Array.isArray(watchArr)){
                                                watchArr = obsbind[j].observer.Jpath[watchPath];
                                                calldeep = Lyte.checkWatchPath(exactPath , watchArr);
                                            }
                                        }
                                        if(calldeep){
                                            observer.observer.value.call(itm, newArgs);
                                        }
                                    }
                                }
                                else{
                                    var calldeep = true;
                                    if(newArgs.data && newArgs.hasOwnProperty("item")){
                                        var watchArr = newArgs.data.$.model._fldGrps.watch[newArgs.item].watch
                                        if(Array.isArray(watchArr)){
                                            watchArr = obsbind[j].observer.Jpath[watchPath];
                                            calldeep = Lyte.checkWatchPath(exactPath , watchArr);
                                        }
                                    }
                                    if(calldeep){
                                        observer.observer.value.call(scope, newArgs);
                                    }
                                }
                            }
                        }
                    }
                    if (!callLengthObserver && type == "array" && binding.length) {
                        this.affectChanges(binding.length,undefined,initialArrLength,undefined,array.length,callLengthObserver);
                    }
                }
            }
        },
        "callArrayObservers" : function(array, args ,callLengthObserver ,initialArrLength) {
            if(array._scp && array._scp.size){
                this.callDeepObservers(array, Object.assign({},args) ,undefined, true);          
            }
            if(array._bindings) {
                let objbind = array._bindings.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let binding = objbind[i];
                    let path = objbind[i]._path;
                    if(binding._observers) {
                        let obsbind = binding._observers.toArrayLyte();
                        for(let j=0;j<obsbind.length;j++){
                            let observer = obsbind[j];
                            if(observer.isArrayObserver) {
                                if(args){
                                    args.item = path;
                                }
                                if(observer.callee && observer.callee.component){
                                    observer.observer.value.call( observer.callee.component, args);
                                }
                                else{
                                    var scope = array._setterScope ? array._setterScope : window;
                                    if(Array.isArray(scope)){
                                        var sLen = scope.length;
                                        for(var k=0;k<sLen;k++){
                                            var itm = scope[k];
                                            observer.observer.value.call( itm, args);                                                        
                                        }
                                    }
                                    else{
                                        observer.observer.value.call(scope, args);
                                    }
                                }
                            }
                        }
                    }
                    if(binding.length) {
                        this.affectChanges(binding.length,undefined,initialArrLength,undefined,array.length,callLengthObserver);
                    }
                }
            }
        },
        "bindWatchObj" : function(watch, data, insItems, remItems, pos){
            if(watch && watch.length){
                watch.forEach(function(wObj){
                    if(wObj.isRec){
                        store.$.deepValueChange(wObj.rec, wObj.attr, data, wObj);
                    }
                    if(remItems){
                        remItems.forEach(function(itm){
                            Lyte.removeNestScp(itm, wObj.id, undefined, undefined, undefined, undefined, wObj.reInit ? wObj.data : undefined);
                        });
                    }
                    if(insItems){
                        insItems.forEach(function(itm,idx){
                            if(itm && ( Array.isArray(itm) || typeof itm == "object" )){
                                var pth = wObj.path.split(',');
                                pth.push(pos+idx);
                                Lyte.bindObj(itm, undefined, wObj.id,  pth && pth.length ? pth : [],undefined,undefined,undefined,true);
                            }
                        });
                    }
                    if(pos !== undefined){
                        var nestObj = Lyte.nestScp[wObj.id];
                        if(nestObj && nestObj.cyclic){
                            Lyte.removeNestScp(nestObj._data, wObj.id);
                            Lyte.bindObj(nestObj._data, undefined, wObj.id, [],undefined,undefined,undefined,true);
                        }
                        else{
                            var insLen = insItems ? insItems.length : 0, newInd = pos+insLen;
                            var arr = data.slice(newInd);
                            arr.forEach(function(itm){
                                Lyte.removeNestScp(itm, wObj.id);
                            });
                            arr.forEach(function(itm,idx){
                                if(itm && ( Array.isArray(itm) || typeof itm == "object" )){
                                    var pth = wObj.path.split(',');
                                    pth.push(newInd+idx);
                                    Lyte.bindObj(itm, undefined, wObj.id,  pth && pth.length ? pth : [],undefined,undefined,undefined,true);
                                }
                            });
                        }
                    }
                });
            }
        },
        "establishUpdateBindings" : function(bindings, property, actualData) {
            let objbind = bindings.toArrayLyte();
            for(let i=0;i<objbind.length;i++){
                let item = objbind[i];
                if(item[property]) {
                    // makeSet(actualData, "_bindings");
                    addBindings(actualData,item[property]);
                    this.establishBindings(item[property], actualData);
                }

            }
        },
        "establishSelectedBinding" : function(property, actualData,node) {
            if(!property) {
                return;
            }
            let propName = property._path;
            let props = propName.split('.');
            let currentProp = node.getProperty(props[0]);
            let currentValue = actualData[props[0]];
            for(let i=0;i<props.length;i++) {
                if(!currentValue || typeof currentValue !== "object") {
                    break;
                } 
                // makeSet(currentValue, "_bindings");
                    addBindings(currentValue,currentProp);
                    currentProp = currentProp[props[i+1]];
                    currentValue = currentValue[props[i+1]];
            }
        },
        "establishBindings": function(properties, actualData) {
            if(properties._helperNodes) {
                let path = properties._path;
                let arr = properties._helperNodes.toArrayLyte();
                for(let s=0;s<arr.length;s++) {
                    let nodes = arr[s]._dynamicProperty ? arr[s]._dynamicProperty[path]: undefined;
                    if(nodes) {
                        for(let j=0;j<nodes.length;j++) {
                            let node = nodes[j];
                            let helper = node.ownerElement;
                            if(helper && helper.tagName === "TEMPLATE" && helper.getAttribute("is") === "for") {
                                if(helper._items) {
                                    let item = helper.getAttribute("item");
                                    for(let i=0;i<helper._items.length;i++) {
                                        let data = actualData[i];
                                        let item = helper.getAttribute("item");
                                        if(data) {
                                            if(typeof helper._items[i] === "object") {
                                                this.establishBindings(helper._items[i].itemProperty, {[item] : data});
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            for(let i in properties) {
                let actData = actualData[i];
                if(!actData || typeof actData === "string" || typeof actData === "number" || typeof actData === "boolean") {
                    // if(!actualData._bindings) {
                    // 	makeSet(actualData, "_bindings");
                    // }
                    addBindings(actualData,properties);
                } else {
                    // if(!actData._bindings) {
                    // 	makeSet(actData, "_bindings");
                    // }
                    addBindings(actData,properties[i]);
                    if(typeof properties[i] === "object") {
                        this.establishBindings(properties[i], actData);
                    }
                }
            }
        },
        "removeSelectedBindingDeep" : function(binding, actualData, fromDisConnect) {
            var del = "delete";
            if(!actualData && !fromDisConnect) {
                return;
            }
            if(actualData && actualData._bindings) {
            	deleteBindingCheckSize(actualData, "_bindings", binding);
            }
            for(let i in binding) {
                let actData;
                if(actualData){
                    actData = actualData[i];
                }   
                if(actData && actData._bindings) {
                    deleteBindingCheckSize(actData, "_bindings", binding[i]);
                }
                if(typeof binding[i] === "object") {
                    this.removeSelectedBindingDeep(binding[i], actData ,fromDisConnect);
                }
            }
            if(fromDisConnect){
                let dynNodes = binding._dynamicNodes;
                let helperNodes = binding._helperNodes;
                if(dynNodes && dynNodes.length){
                    binding._dynamicNodes.splice(0,dynNodes.length);   
                }
                if(helperNodes && helperNodes.size){
                    helperNodes.clear();
                }
            }
            if(binding && binding._forHelpers) {
                let objbind = binding._forHelpers.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let fH = objbind[i];
                    if(fH.getAttribute("is") === "for") {
                        let item = fH.getAttribute("item");
                        let items = fH._attributes.items;
                        let itemCases = fH._items;
                        for(let i=0;i<itemCases.length;i++) {
                            this.removeSelectedBindingDeep(itemCases[i].itemProperty, items[i], fromDisConnect);
                        }
                    } else {
                        if(fH._propBindingObject) {
                            if(actualData && actualData._bindings) {
                            	deleteBindingCheckSize(actualData, "_bindings", fH._propBindingObject);
                                this.removeSelectedBindingDeep(fH._propBindingObject, actualData, fromDisConnect);
                            }
                        }
                    }
                }
            }
        },
        "removeAllBindings" : function(properties, data) {
            var del = "delete";
            for(let key in properties) {
                if(data[key] && data[key]._bindings) {
//                    data[key]._bindings[del](properties[key]);
//                    if(!data[key]._bindings.size) {
//                        delete data[key]._bindings;
//                    }
                	deleteBindingCheckSize(data[key], "_bindings", properties[key]);
                }
                if(data[key] && typeof data[key] !== "string") {
                    _LC.removeAllBindings(properties[key], data[key]);
                }
            }
        },
        "affectChanges" : function(item, contextAlreadySwitched,oldValue,setterScope,newValue,callLengthObserver,options) {
            if(item._dynamicNodes) {
                for(let i=0;i<item._dynamicNodes.length;i++) {
                    item._dynamicNodes[i]._callee.updateNode(item._dynamicNodes[i], item._path, options);
                }
            }
            let propPath = item._path;
            if(item._helperNodes) {
                let nodes = [],itemHelperNodes = item._helperNodes.toArrayLyte();
                for(let s=0;s<itemHelperNodes.length;s++){
                    if(!item._helperNodes.has(itemHelperNodes[s])) {
                        continue;
                    }
                    if(itemHelperNodes[s].getAttribute("is") === "for" && itemHelperNodes[s]._items) {
                        let innerContextSwitchArray = [];
                        _LC.adCx(itemHelperNodes[s], innerContextSwitchArray);
                        let  indexValue = itemHelperNodes[s].getAttribute("index");
                        let itemValue = itemHelperNodes[s].getAttribute("item");
                        let callee = itemHelperNodes[s]._callee;
                        let cmpData = LyteComponent.getCmpData(callee.component.data);
                        let initialItemValue = cmpData[itemValue];
                        let initialIndexValue = cmpData[indexValue];
                        let initialItemProp = callee._properties[itemValue];
                        let initialIndexProp = callee._properties[indexValue];
                        let items = itemHelperNodes[s]._attributes.items;
                        var dirObjData = {data : {},prop : {}};
                        var dirObjProp = {data : {},prop : {}};
                        _LCSV.beforeDirObj(itemHelperNodes[s], dirObjData, dirObjProp);
                        for(let i=0;i<itemHelperNodes[s]._items.length;i++) {
                            cmpData[itemValue] = items[i];
                            cmpData[indexValue] = i;
                            callee._properties[itemValue] = itemHelperNodes[s]._items[i].itemProperty;
                            if(itemHelperNodes[s]._items[i]._dynamicProperty[propPath]) {
                                nodes = itemHelperNodes[s]._items[i]._dynamicProperty[propPath];
                                for(let i=0;i<nodes.length;i++) {
                                    nodes[i]._callee.updateNode(nodes[i], propPath,options);
                                }
                            }
                        }
                        cmpData[itemValue] = initialItemValue;
                        cmpData[indexValue] = initialIndexValue;
                        callee._properties[itemValue] = initialItemProp;
                        callee._properties[indexValue] = initialIndexProp;
                        _LCSV.afterDirObj(itemHelperNodes[s], dirObjData, dirObjProp)
                        _LC.rmCx(itemHelperNodes[s], innerContextSwitchArray);                                    
                    } else if(itemHelperNodes[s].getAttribute("is") === "forIn" && itemHelperNodes[s]._items) {
                        let innerContextSwitchArray = [];
                        _LC.adCx(itemHelperNodes[s], innerContextSwitchArray);
                        let  indexValue = itemHelperNodes[s].getAttribute("key");
                        let itemValue = itemHelperNodes[s].getAttribute("value");
                        let callee = itemHelperNodes[s]._callee;
                        let cmpData = LyteComponent.getCmpData(callee.component.data);
                        let initialItemValue = cmpData[itemValue];
                        let initialIndexValue = cmpData[indexValue];
                        let initialItemProp = callee._properties[itemValue];
                        let initialIndexProp = callee._properties[indexValue];
                        let object = itemHelperNodes[s]._attributes.object;
                        for(let key in itemHelperNodes[s]._items) {
                            cmpData[itemValue] = object[key];
                            cmpData[indexValue] = key;
                            callee._properties[itemValue] = itemHelperNodes[s]._items[key].itemProperty;
                            if(itemHelperNodes[s]._items[key]._dynamicProperty[propPath]) {
                                nodes = itemHelperNodes[s]._items[key]._dynamicProperty[propPath];
                                for(let i=0;i<nodes.length;i++) {
                                    nodes[i]._callee.updateNode(nodes[i], propPath,options);
                                }
                            }
                        }
                        cmpData[itemValue] = initialItemValue;
                        cmpData[indexValue] = initialIndexValue;
                        callee._properties[itemValue] = initialItemProp;
                        callee._properties[indexValue] = initialIndexProp;
                        _LC.rmCx(itemHelperNodes[s], innerContextSwitchArray);    
                    } else {
                        nodes = itemHelperNodes[s]._dynamicProperty[item._path] || [];
                        let contextSwitchArray = [];
                        if(nodes.length) {
                            _LC.adCx(itemHelperNodes[s], contextSwitchArray);
                            for(let i=0;i<nodes.length;i++) {
                                nodes[i]._callee.updateNode(nodes[i], item._path, options);
                            }
                            _LC.rmCx(itemHelperNodes[s], contextSwitchArray);    
                        }
                        
                    }
                    _LCSV.affectChangesComp(itemHelperNodes[s]);
                }
            }
            if(item._observers) {
                let objbind = item._observers.toArrayLyte();
                let cond = callLengthObserver == false ? false : oldValue != undefined || newValue != undefined;
                if(cond){
                    for(let i=0;i<objbind.length;i++){
                        let observer = objbind[i];
                        let obsObj = {type:"change",oldValue:oldValue,newValue:newValue, item: item._path};
                        if(observer.callee && observer.callee.component){
                            observer.observer.value.call(  observer.callee.component, obsObj);                      
                        }
                        else{
                            var scope = setterScope ? setterScope : window;
                            if(Array.isArray(scope)){
                                var sLen = scope.length;
                                for(var k=0;k<sLen;k++){
                                    var itm = scope[k];
                                    observer.observer.value.call( itm, obsObj);
                                }
                            }
                            else{
                                observer.observer.value.call( scope, obsObj);                      
                            }
                        }
                    }
                }
            }
            if(Array.isArray(item)){
                for(var i=0;i<item.length;i++){
                    for(let key in item[i]) {
                        this.affectChanges(item[i][key], true,oldValue?(oldValue[i]?oldValue[i][key]:oldValue[i]):oldValue,setterScope,newValue?(newValue[i]?newValue[i][key]:newValue[i]):newValue);
                    }
                }
            }
            else{
                for(let key in item) {
                    var oldV = oldValue ? oldValue[key] : oldValue, newV = newValue ? newValue[key] : newValue;
                    if(key == "*" && item[key].hasOwnProperty("_observers")){
                        oldV = oldValue;
                        newV = newValue
                    }
                    this.affectChanges(item[key], true, oldV, setterScope, newV);
                }
            }
        },
        "skipArgProcessing" : function(cloneActObj,ev,target) {
            if(cloneActObj.skipArgProcessing) {
                let args = cloneActObj.args = cloneActObj.actArgs;
                args.shift();
                var eventIndex = args.indexOf("__lyteEvent__");
                var nodeIndex = args.indexOf("__lyteNode__");
                if(eventIndex !== -1) {
                    args[eventIndex] = ev;
                } 
                if(nodeIndex !== -1) {
                    args[nodeIndex] = target;
                }
            } else {
                cloneActObj.args.shift();
            }
        },
        // getDV added
        "getDV" : function(value){    
            var result = [],ref = result,arr = [],data = "",strStack = [],arrayStack = [],refStack = [],strLast,str;
            for(var i=0;i<value.length;i++){
                if(value[i] === "."){
                    if(data.length){
                        ref.push(data);
                    }
                    data = "";
                    continue;
                }
                else if(value[i] === "["){
                    arrayStack.push(i)
                    if(data.length){
                        ref.push(data);
                    }
                    while(value[i+1] === "\s"){
                        i++;
                    }
                    if(value[i+1] === "\"" || value[i+1] === "'"){
                        strStack.push(value[i+1]);
                        strLast = value[i+1];
                        i++;
                    }
                    else if(arr.length){
                        ref.push([]);
                        refStack.push(ref);
                        ref = ref[ref.length-1];
                    }else{
                        arr.push([]);
                        refStack.push(ref);
                        ref = arr[arr.length-1];
                    }
                    data = "";
                    continue;
                }
                else if((value[i] === "\"" || value[i] === "'" ) && value[i++] === strLast){
                    while(value[i] === "\s" && value[i] != "]"){
                        i++;
                    }
                    strStack.pop();
                    str = true;
                }
                if(value[i] === "]"){
                    arrayStack.pop();
                    if(data.length){
                        if(str === true){
                            ref.push(data);    
                        }
                        else if(!isNaN(parseInt(data))){
                            if(refStack.length){
                                ref = refStack.pop();
                                if(arr.length && Array.isArray(ref[ref.length-1]) && !ref[ref.length-1].length){
                                    ref.pop();
                                }
                                ref.push(data);
                                if(!arrayStack.length && arr.length){
                                    arr.shift();
                                }
                            }
                        }
                        else{
                            ref.push(data);
                        }
                    }
                    if(!arrayStack.length && arr.length){
                        result.push(arr.shift());
                        ref = result;
                    }
                    else if(refStack.length && !arr.length){ 
                        ref = refStack.pop();
                    }
                    data = "";
                    str = "";
                    continue;
                }
                data = data.concat(value[i]);
            }
            if(data.length){
                result.push(data);
            }
            if(strStack.length || arrayStack.length){
                console.log("check the syntax",strStack,arrayStack);
            }
            return result;
        },
        "ccDelay" : [],
        "callCC" : function() {
            this.ccDelay.forEach(function(item) {
                if(item.component) {
                    item.actualConnectedCallback();
                }
            });
            this.ccDelay = [];
        },
        "getDD":function(context,dataArr){
            var self = context;
            dataArr.forEach(function(item,index){
                if(Array.isArray(item)){
                    if(context == undefined){
                        return undefined;
                    }
                    var inner = _LC.getDD(self,item);
                    if(inner == undefined){
                        return undefined;
                    }
                    context = context[inner];
                }else{
                    if(context == undefined){
                        return undefined;
                    }
                    context = context[item];
                }
            });
            return context;
        },

        "processStatic" : function(temp) {
            let arr = temp.innerHTML.split("__**");
            let newArr = [];
            for(var i=0;i<arr.length;i++) {
                if(arr[i].startsWith("--Lyte")) {
                    newArr.push(parseInt(arr[i].substring(6)));
                } else {
                    newArr.push(undefined);
                }
            }
            arr.cc = newArr;
            return arr;
        },
        "findLastNodeL" : function(lastNode1,count,node){
            var totalNodeIndex = 0;
            if(count != undefined){
                totalNodeIndex = count; 
            }
            var helperNode;
            switch(node.getAttribute("is")) {
                case "for" : 
                    if(node._helpers[totalNodeIndex]){
                        helperNode = node._helpers[totalNodeIndex][0];   
                    }
                    if(!lastNode1) {
                        if(node._forContent[0]){
                            lastNode1 = node._forContent[0][0];
                        }
                    }
                    break;
                case "forIn" : 
                    if(node._helpers[node._keysArray[0]]){
                        helperNode = node._helpers[node._keysArray[0]][0];
                    }
                    if(!lastNode1) {
                        if(node._forContent[node._keysArray[0]]){
                            lastNode1 = node._forContent[node._keysArray[0]][0];
                        }
                    }                   
                    break;
                case "if" : 
                case "switch" : 
                    helperNode = node._helpers[totalNodeIndex];
                    if(!lastNode1) {
                        lastNode1 = node._caseContent[0];
                    }
                break;
                case "component" : 
                    lastNode1 = lastNode1._renderedComponent[lastNode1._currentComponent] || lastNode1;
                    return lastNode1;
            }
            if(!lastNode1){
                lastNode1 = node._placeHolder;
            }
            if(helperNode && (lastNode1 == helperNode._placeHolder)) {
                lastNode1 =  this.findLastNodeL(undefined, undefined, helperNode);
            }
            return lastNode1;
        },
        "processAction" : function(node) {
            Array.from(node.querySelectorAll('[lyteaction]')).forEach(function(item) { 
                let locIndex = item.attributes.lyteaction.value;
                item._boundEvents = _LC.fRP[locIndex];
                delete _LC.fRP[locIndex];
                // _LC.pushFrc(locIndex);
                // item._boundEvents = JSON.parse(item.attributes.lyteaction.value);
                var _cx = item._boundEvents._cx;
                let boundEvents = item._boundEvents;
                delete boundEvents._cx;
                let componentName = boundEvents.componentName;
                delete boundEvents.componentName;
                for(var key in item._boundEvents) {
                    if(key.indexOf("-") !== -1) {
                        item._actions = item._actions || {};
                        item._actions[key] = new CustomEvent(key);
                        item._actions[key].processAction = item._boundEvents[key];
                        item._boundEvents[key].actArgs.shift();
                        let nodeIndex = item._boundEvents[key].actArgs.indexOf("__lyteNode__");
                        if(nodeIndex !== -1) {
                        	item._boundEvents[key].actArgs[nodeIndex] = item;
                        }
                        item._boundEvents[key].args = item._boundEvents[key].actArgs;
                        delete item._boundEvents[key];
                    } else {
                        let actArgs = _Lyte.deepCopyObject(item._boundEvents[key].args);
                        let actName = actArgs.splice(0,1)[0];
                        actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                        let actString = getArgString(actName, actArgs);
                        item.setAttribute(key.startsWith("on") ? key.substr(2) : key ,componentName+" => "+ actString);
                        if(!item._boundEvents[key].globalEvent) {
                            item.addEventListener(key,globalEventHandler);
                        }
                    }
                }
                item._boundEvents._cx = _cx;
                item.removeAttribute("lyteaction");
                //item._boundEvents = item.
            });
        },
        /* disable async function */
        "getCtxVal" : function(context,val,self){
            if(context != undefined){
                if(window.isLyteWidget || window.__lyteEnablePromise) {
                    if(context && context[val] instanceof Promise && !context[val].__lyte){
                        _LC.listenPromise(context, val, context[val]);
                    }
                }
                return context[val];
            }else{
                return undefined;
            }
        },
        "listenPromise" : function(context, key, actVal){
            actVal.then(function(resolvedData){
                actVal.__lyteUserResolved = true;
                actVal.__lyte.status = "resolved";
                Lyte.Component.set(context,key,resolvedData);
            },function(){
                actVal.__lyteUserRejected = true;
                actVal.__lyte.status = "rejected";
                Lyte.Component.set(context,key,context[key],{force : true , skipTypeCast : true, skipValidation : true});
            });
            defProp(actVal ,"__lyte", { value : { status : "init" }});
        },
        /* disable async function */
        "get" : function(context, path, ac,cache, comp) {
            if(!ac) {
                ac = [];
            }
            if(cache && cache.hasOwnProperty(path)){// cache.cacheData[path]
                nodeValue = cache[path]._data;
                if(cache[path]._dyn){
                    cache[path]._dyn.forEach(function(item){
                        ac.push(item);
                    });
                }
                return nodeValue;
            }
            else{
            try{
                let arr = path.match(/([^[\]]+|\[\])/g);
                let initialContext = context;
                ac.push(arr[0]);
                let locArr = arr[0].split('.'); 
                for(let k=0;k<locArr.length;k++) {
                    context = _LC.getCtxVal(context,locArr[k],comp)
                }
                for(let i=1;i<arr.length;i++) {
                    let locVal = arr[i];
                    //this is context switching
                    if(locVal.startsWith(".")) {
                        //direct context switching
                        let locArr = locVal.substring(1).split('.');
                        for(let k=0;k<locArr.length;k++) {
                            context = _LC.getCtxVal(context,locArr[k],comp)
                        }
                        // ac[ac.length -1] = ac[ac.length - 1] + locVal;
                        ac[0] = ac[0] + locVal;
                    } else if(locVal.startsWith("'") || locVal.startsWith('"') || !isNaN(locVal)) {
                        if(!isNaN(locVal)) {
                            // ac[ac.length-1] = ac[0] + "." + locVal;
                            ac[0] = ac[0] + "." + locVal;
                            context = _LC.getCtxVal(context,locVal,comp)
                        } else {
                            // ac[ac.length-1] = ac[0] + "." + locVal.substring(1, locVal.length -1);
                            ac[0] = ac[0] + "." + locVal.substring(1, locVal.length -1);
                            context = _LC.getCtxVal(context,locVal.substring(1, locVal.length -1),comp)
                        } 
                    } else {
                        let length = ac.length;
                        let val = _LC.get(initialContext, locVal, ac);
                        ac[0] = ac[0] + "." + val;
                        context = _LC.getCtxVal(context,val,comp)
                    }
                    }
                    if(cache){
                        cache[path] = {};
                        cache[path]._data = context;  
                        cache[path]._dyn = ac;
                    }
                return context;
            } catch(e) {
                return undefined;
            }
            }
        },
        "getNew" : function(context, path) {
            try{
                let arr = path.match(/([^[\]]+|\[\])/g);
                let initialContext = context;
                let locArr = arr[0].split('.'); 
                if(arr.length < 2) {
                    if(locArr.length <2) {
                        return {"context": initialContext, "lastKey" : locArr[0]};
                    } else {
                        for(var k=0;k<locArr.length-1;k++) {
                            context = context[locArr[k]];
                        }
                        return {"context" : context, "lastKey" : locArr[k]}
                    }
                }
                for(let k=0;k<locArr.length;k++) {
                    context = context[locArr[k]];
                }
                for(var i=1;i<arr.length - 1;i++) {
                    let locVal = arr[i];
                    //this is context switching
                    if(locVal.startsWith(".")) {
                        //direct context switching
                        let locArr = locVal.substring(1).split('.');
                        for(let k=0;k<locArr.length;k++) {
                            context = context[locArr[k]];
                        }
                    } else if(locVal.startsWith("'") || locVal.startsWith('"') || !isNaN(locVal)) {
                        context = context[locVal.substring(1, locVal.length -1)];
                    } else {
                        let val = this.get(initialContext, locVal);
                        context = context[val];
                    }
                    }
                let lastKey = arr[i];
                if(lastKey.startsWith(".")) {
                    //direct context switching
                    let locArr = lastKey.substring(1).split('.');
                    let k=0
                    for(;k<locArr.length - 1;k++) {
                        context = context[locArr[k]];
                    }
                    lastKey = locArr[k];
                } else if(lastKey.startsWith("'") || lastKey.startsWith('"') || !isNaN(lastKey)) {
                    lastKey = lastKey.substring(1, lastKey.length -1);
                } else {
                    lastKey = this.get(initialContext, lastKey);
                }
                return {"context" : context, "lastKey" : lastKey };
            } catch(e) {
                return undefined;
            }
        },
        /* disable async function */
        "componentGetData" : function(key){
            if(key && key.match(/^\$\./g)){
                if($L && $L.Jwalk){
                    return $L.Jwalk(this.data ,key)
                }
                else{
                    _Lyte.warn("For using JSON path synatx , include the Jwalk file from the lyte-plugins")
                }
            }
            if(key) {
                return this.get(key);
            } else {
                return this.data;
            }
        },
        "componentSetData" : function(arg0, arg1 ,options) {
            if(typeof arg0 === "string") {
                this.set(arg0, arg1 ,options);
            } else if(typeof arg0 === "object") {
                for(let key in arg0) {
                    this.set(key, arg0[key],arg1);
                }
            }
        },
        "componentToggleData" : function(dataName) {
            this.set(dataName,!this.get(dataName));
        },
        "componentGetMethods" : function(key) {
            let node = this.$node;
            if(node){
                if(key && node._methods) {
                    return node._methods[key];
                } else {
                    return node._methods;
                }
            }
        }, 
        "componentHasAction" : function(key) {
            let node = this.$node;
            if(node){
                if(key && node._actions[key]) {
                    return true;
                } else {
                    return false;
                }
            }
        }, 
        "componentsetActions" : function(arg0,arg1) {
            let actions = this.$node._actions;
            if(typeof arg0 === "string") {
                actions[arg0] = arg1;
            } else if(typeof arg0 === "object") {
                for(let key in arg0) {
                    actions[key] = arg0[key];
                }
            }
        },
        "componentSetMethods" : function(arg0, arg1) {
            let node = this.$node;
            if(node){
                if(typeof arg0 === "string") {
                    node._methods[arg0] = arg1;
                } else if(typeof arg0 === "object") {
                    for(let key in arg0) {
                        node._methods[key] = arg0[key];
                    }
                }
            }
        },
        "render" : function(componentName, data, outlet, options) {
            var component
            _LC.fromV3Render = true;
            var actDocument = document;
			if(Lyte.isWidgetBuild){
				actDocument = window._widgetDocument;
			}else{
				actDocument = document;
			}
            if(ltCf && _Lyte.isWidgetBuild){
                ltCf.fromWidgetRender = true;
            }            
            if(componentName) {
                if(typeof componentName == "string") {
                    component = createElement(componentName);
                } else if(componentName.compName) {
                    component = createElement(componentName.compName);
                } else {
                    _Lyte.error("LC007"); 
                    _LC.fromV3Render = false;
                    if(ltCf && _Lyte.isWidgetBuild){
                        ltCf.fromWidgetRender = false;
                    }   
                    return;
                }
            } else {
                _Lyte.error("LC007");
                _LC.fromV3Render = false;
                if(ltCf && _Lyte.isWidgetBuild){
                    ltCf.fromWidgetRender = false;
                }
                return;
            }
            
            if(data){
                component.setData(data);
            }
            if(options && options.methods){
                component.setMethods(options.methods);
            }
            if(options && options.attributes){
                options.attributes.forEach(function(attr){
                    if(typeof attr == "object"){
                        component.setAttribute(attr.name,attr.value);
                    }else{
                        component.setAttribute(attr,"");
                    }
                })
            }
            if(outlet) {
                let actOutlet;
                if(typeof outlet == "string"){
                    actOutlet = actDocument.querySelector(outlet);
                }else{
                    actOutlet = outlet;
                }
                if(actOutlet) {
                    if(options && options.dataType){
                        component.component.__data = options.dataType;
                    }
                    actOutlet.appendChild(component);
                    component._callee = component.getCallee ? component.getCallee(actOutlet) : undefined;
                } else {
                    _Lyte.error("LC008", outlet);
                }
            }
            _LC.fromV3Render = false;
            if(ltCf && _Lyte.isWidgetBuild){
                ltCf.fromWidgetRender = false;
            }
            return component;
        },
        "String" : {
            "cache_c":{},
            "cache_d":{},
            /*disable async function*/
            "upperCaseFirstLetter" : function(string) {
                return string.charAt(0).toUpperCase() + string.slice(1);
            },
            /*disable async function*/
            "lowerCaseFirstLetter" : function(string) {
                return string.charAt(0).toLowerCase() + string.slice(1);
            }, 
            /*disable async function*/
            "toCamelCase" : function(string) {
                if(!this.cache_c[string]){
                    this.cache_c[string] = _stringReplacer.call(string, /(-\w)/g, function(m){return m[1].toUpperCase();});
                }
                return this.cache_c[string];
            }, 
            /*disable async function*/
            "dasherize" : function(string) {
                if(!this.cache_d[string]){
                    this.cache_d[string] = _stringReplacer.call(string, /([a-z])([A-Z])/g, '$1-$2').toLowerCase();
                }
                return this.cache_d[string];
            }
        },
        "appendChild" : function(outlet, component) {
            _LyteComponent._setIgnoreDisconnect(true)
            outlet.appendChild(component);
            _LyteComponent._setIgnoreDisconnect(false)
        },
        "replaceWith" : function() {
            var argumentsArr = Array.from(arguments);
            var oldNode = argumentsArr.shift();
            _LyteComponent._setIgnoreDisconnect(true)
            var parentNode = oldNode.parentNode;
            for(var i=0,node;node=argumentsArr[i];i++) {
                parentNode.insertBefore(node,oldNode);
            }
            oldNode.remove();
            _LyteComponent._setIgnoreDisconnect(false)
        },	
        "insertBefore" : function(referenceNode, newNode, parentNode) {
            _LyteComponent._setIgnoreDisconnect(true)
            if(!parentNode) {
                if(!referenceNode) {
                    _Lyte.error("LC010");
                    _LyteComponent._setIgnoreDisconnect(false)
                    return;
                } else {
                    parentNode = referenceNode.parentNode;
                }
            }
            insertBefore(parentNode , newNode, referenceNode ? referenceNode : null);
            _LyteComponent._setIgnoreDisconnect(false)
        },
        "insertAfter" : function() {
            var argumentsArr = Array.from(arguments);
            var referenceNode = argumentsArr.shift();
            _LyteComponent._setIgnoreDisconnect(true)
            referenceNode.after.apply(referenceNode, argumentsArr);
            _LyteComponent._setIgnoreDisconnect(false)
        },
        "executeMethod" : function() {
            let node = this.$node;
            if(node){
                let args = Array.prototype.slice.call(arguments, 1);
                var methodName = _LC.String.toCamelCase(arguments[0]);
                if(!node._methods[methodName]) {
                    _Lyte.error("LC009", methodName, this.$node.tagName);
                    return;
                }
                return node._methods[methodName].apply(this, args);
            }
        },
        "getProperData" : function(obj) {
            var dataType = obj.dataType;
            var attr = obj.attr;
            var newValue = obj.newValue;
            var tagName = obj.tagName;
            switch(dataType) {
            case "boolean" : 
                {
                    if(!newValue || newValue === "false") {
                        newValue= false;
                    } else {
                        newValue = true;
                    }
                }
                break;
            case "object" : 
                try{
                    newValue = JSON.parse(newValue);
                    if(!(newValue instanceof Object)) {
                        _Lyte.warn("data type of the value provided for attribute "+ attr + " of " + tagName + " is not valid");
                    }
                } catch(e) {
                    _Lyte.warn("attribute "+attr+ " is not a valid JSON string.");
                    return;
                }
                break;
            case "array":
                try{
                    newValue = JSON.parse(newValue);
                    if(!(newValue instanceof Array)) {
                        _Lyte.warn("data type of the value provided for attribute "+ attr + " of " + tagName + " is not valid");
                    }
                } catch(e) {
                    _Lyte.warn("attribute "+attr+ " is not a valid JSON string.");
                    return;
                }
                break;
            case "number":
                {
            let numValue = +newValue;
                if(newValue === numValue+"") {
                    newValue = numValue;
                } else {
                    _Lyte.warn("data type of the value provided for attribute "+ attr + " of " + tagName + " is not valid");
                    return;
                }
            }
                break;
            }
            obj.newValue = newValue;
            return true;
        }, 
        "cssEscape" : function(string) {
            if(string) {
                return string.replace(/['"]/g, "\\$&");    
            } else {
                return string;
            }
            
        },
        "shadow" : {
            "shadowList" : [],
            "toAddEvents" : [],
            "attachEvents" : function(thisRef){
                var bodyEvents = LyteComponent.globalDOMEvents;
                for (var _i = 0; _i < bodyEvents.length; _i++) {
                    var evnt = bodyEvents[_i];
                    window.__lyteEnableDelayAction && thisRef.addEventListener(evnt, LyteComponent.docCaptureGlobalEventHandler, true);
                    thisRef.addEventListener(evnt, LyteComponent.globalEventHandler, true);
                    window.__lyteEnableDelayAction && thisRef.addEventListener(evnt, LyteComponent.docBubbleGlobalEventHandler);
                }
                //lc.addedevents
                var toAddEvents = this.toAddEvents;
                var len = toAddEvents.length
                for(let i=0;i<len;i++){
                    thisRef.addEventListener(toAddEvents[i].eventName ,toAddEvents[i].listener ,toAddEvents[i].options);
                }
                //lbind event
                thisRef.addEventListener("change", LyteComponent.changeEventHandler);
            },
            "createLessDiv" : function(shadow,comp){
                var div = document.createElement("div");
                div.setAttribute("id","lessDiv");
                shadow.appendChild(div)
                comp._lessDiv = div;
                comp._lessDiv._impNames = [];
            },
            "insertInLessDiv" : function(shadowParent,lessDiv){
                var self = this;
                if(shadowParent && shadowParent._lessDiv._impNames){
                    shadowParent._lessDiv._impNames.forEach(function(item){
                        lessDiv._impNames.$push(item);
                        var sty = document.createElement("style")
                        sty.setAttribute("placeHolder",self.importStyle[item].src);
                        sty.setAttribute("id",item);
                        lessDiv.appendChild(sty);
                    })
                }
            },
            "updateLessDiv" : function(lessDiv,compNames){
                var self = this;
                lessDiv._impNames.forEach(function(id){
                    compNames.forEach(function(tagName){
                        if(self.importStyle[id] && self.importStyle[id].status == "resolved" && self.importStyle[id].response[tagName]){
                            var a = document.createElement("style");
                            a.setAttribute("lyte-id-imported","shadow-style-"+tagName)
                            a.setAttribute("impSrc",id);
                            a.innerHTML = self.importStyle[id].response[tagName];
                            var ele = lessDiv.querySelector("[id="+id+"]");
                        //   lessDiv.insertBefore(a,ele);
                            LyteComponent.insertBeforeNative(lessDiv,a,ele);
                        }
                    })
                })
            },
            "getHostElement" : function(node){
                if(node){
                    let host = node.host;
                    if(host && host.tagName){
                        return host;
                    }
                }
            },
            "appendChild" : function(outlet, ele, obj){
                let componentParent;
                if(obj && obj instanceof Object && obj.referenceNode){
                    componentParent = obj.referenceNode;
                }else{
                    componentParent = undefined;
                }
                let igDisconnect = false;
                if(!obj || !obj.native){
                    _LyteComponent._setIgnoreDisconnect(true)
                    igDisconnect = true;
                }
                var shadowParent = componentParent ? componentParent.getRootNode(): ele?ele.getRootNode():undefined;
                var nonShadowParent = ele;
                let hostEleParent = this.getHostElement(shadowParent);
                if(shadowParent && hostEleParent){
                    nonShadowParent = this.looping(nonShadowParent);
                }
                
                if(Lyte.isWidgetBuild & shadowParent && hostEleParent && outlet && hostEleParent != (outlet.lastElementChild ? this.getHostElement(outlet.lastElementChild.getRootNode()):this.getHostElement(outlet.getRootNode()))){
                    var a = {"type":"appendChild", "shadowParent":hostEleParent ,"outlet":outlet ,"element":ele,"nonShadowParent":nonShadowParent}
                    this.addElements(a);//registryInstance
                }
                else{
                    outlet.appendChild(ele);
                }
                if(igDisconnect){
                    _LyteComponent._setIgnoreDisconnect(false)
                }
            },
            "looping" : function(parent){
                while(parent){
                    if(parent.component && parent.tagName != "LYTE-YIELD"){
                        return parent;
                    }
                    parent = parent.parentNode;
                }
            },
            "addElements" : function(obj,registryInstance){//type ,shadowParent,outlet,ele,refNode
                // var type = obj.type;
                var ele = obj.element;
                // var outlet = obj.outlet;
                // // var shadowParent = obj.shadowParent;
                // var refNode = obj.refNode;
                // // var nonShadowParent = obj.nonShadowParent;
                // var success;//,finalshadow;
                // var self = this;
                // var argumentsArr = argumentsArr;
                // if(nonShadowParent){
                    // var parentInstance = nonShadowParent;
                    // var id = nonShadowParent._id;
                    // var sw = nonShadowParent._sw;
                    // var tagName = nonShadowParent.tagName;
                // }
                // else{
                    // var parentInstance = shadowParent;
                    // if(shadowParent.tagName == "SHADOW-WRAPPER"){
                    //     parentInstance = shadowParent.shadowRoot._swParent;
                    // }
                    // var id = shadowParent.shadowRoot._id;
                    // var sw = shadowParent.shadowRoot._sw;
                    // var tagName = shadowParent.tagName;
                // }
                // switch(type){
                //     case "appendChild":
                //         var pos = outlet.lastElementChild;
                //         if(pos && pos.shadowRoot  && pos.tagName == "SHADOW-WRAPPER"){
                //             outlet.lastElementChild.shadowRoot.appendChild(ele);
                //             success = true;
                //             // finalshadow = outlet.lastElementChild.shadowRoot;
                //         }
                //         break;
                //     case "insertBefore":
                //         var pos = refNode.previousElementSibling;
                //         if(pos && pos.shadowRoot && pos.tagName == "SHADOW-WRAPPER"){
                //             refNode.previousElementSibling.shadowRoot.appendChild(ele);
                //             success = true;
                //             // finalshadow = refNode.previousElementSibling.shadowRoot;
                //         }
                //         break;
                //     case "insertAfter":
                //         var pos = refNode.nextElementSibling;
                //         if(pos && pos.shadowRoot  && pos.tagName == "SHADOW-WRAPPER"){
                //             refNode.nextElementSibling.shadowRoot.lastElementChild.after.apply(refNode.nextElementSibling.shadowRoot.lastElementChild, ele);
                //             success = true;
                //             // finalshadow = refNode.nextElementSibling.shadowRoot;
                //         }
                //         break;
                // }
                // if(!success){
                    // var wrapper = document.createElement("shadow-wrapper");
                    // if(shadowParent.tagName == "LYTE_YIELD"){
                    // }
                    // wrapper.attachShadow({"mode":"open"});//af
                    var wrapper = Lyte.$.widgetWrapper;
                    // if(!wrapper.instantiated){
                    //     if(window.docEventListenerHandler) {
                    //         window.docEventListenerHandler.attachShadow(wrapper.shadowRoot);
                    //     }
                    //     this.shadowList.push(wrapper.shadowRoot);
                    //     wrapper.shadowRoot._shadowChild = [];
                    //     wrapper.shadowRoot._lyteShadow = true;
                    //     wrapper.shadowRoot._compList = [];
                    //     // wrapper.shadowRoot._id = id;
                    //     wrapper.shadowRoot._duplicateStyle = [];
                    //     wrapper.shadowRoot._linkRef = [];
                        
                    //     wrapper.instantiated = true;
                    //     this.attachEvents(wrapper.shadowRoot);
                    // }
                    if(Array.isArray(ele)){
                        ele.forEach(function(item,index){
                            wrapper.shadowRoot.appendChild(item);
                        });
                    }else{
                        wrapper.shadowRoot.append(ele);
                    }
                //     switch(type){
                //     case "appendChild":
                //         // var pos = outlet.lastElementChild;
                //         // if(pos && pos.shadowRoot  && pos.tagName == "SHADOW-WRAPPER"){
                //             wrapper.shadowRoot.appendChild(ele);
                //             // success = true;
                //             // finalshadow = outlet.lastElementChild.shadowRoot;
                //         // }
                //         break;
                //     case "insertBefore":
                //         // var pos = refNode.previousElementSibling;
                //         // if(pos && pos.shadowRoot && pos.tagName == "SHADOW-WRAPPER"){
                //         //     refNode.previousElementSibling.shadowRoot.appendChild(ele);
                //         //     success = true;
                //         //     // finalshadow = refNode.previousElementSibling.shadowRoot;
                //         // }
                //         break;
                //     case "insertAfter":
                //         // var pos = refNode.nextElementSibling;
                //         // if(pos && pos.shadowRoot  && pos.tagName == "SHADOW-WRAPPER"){
                //         //     refNode.nextElementSibling.shadowRoot.lastElementChild.after.apply(refNode.nextElementSibling.shadowRoot.lastElementChild, ele);
                //         //     success = true;
                //         //     // finalshadow = refNode.nextElementSibling.shadowRoot;
                //         // }
                //         break;
                // }
                    // if(shadowParent.tagName == "SHADOW-WRAPPER"){
                    //     var shadowParentComp = shadowParent.shadowRoot._swParent;
                    //     shadowParentComp.shadowRoot ? shadowParentComp.shadowRoot._sw.push(wrapper) :shadowParentComp._sw.push(wrapper);
                    //     wrapper.setAttribute("lyte-id",shadowParentComp.tagName);
                    //     wrapper.shadowRoot._swParent = shadowParentComp;
                    // }
                    // else{
                    //     // sw.push(wrapper);
                    //     wrapper.setAttribute("lyte-id",tagName);
                    //     wrapper.shadowRoot._swParent = parentInstance;
                    // }
                    // wrapper.setAttribute("widget-shadow-wrapper",true);
                    // if(type == "appendChild"){
                    //     outlet.appendChild(wrapper);    
                    // }else if(type == "insertBefore"){
                    //     LyteComponent.insertBeforeNative(outlet ,wrapper, refNode); 
                    // }
                    // else{
                    //     refNode.after.apply(refNode, [wrapper]);
                    // }
                    // finalshadow = wrapper.shadowRoot;
                    // shadowParent.shadowRoot._compList.forEach(function(compName){
                    //     wrapper.shadowRoot._compList.push(compName);
                    // })
                    //lessdiv
                    // let hostEle = this.getHostElement(finalshadow);
                    // this.createLessDiv(finalshadow,hostEle,shadowParent,shadowParent.shadowRoot._compList)
                    // this.insertInLessDiv(shadowParent,hostEle._lessDiv)
                    // this.updateLessDiv(hostEle._lessDiv,shadowParent.shadowRoot._compList);
                // }
                //attach style tag from .css
                // var parentStyleList = shadowParent.shadowRoot._duplicateStyle;
                // if(parentStyleList &&parentStyleList.length > 0){
                //     parentStyleList.forEach(function(item,index){
                //         // var compIns = LyteComponent._registeredComponents[item.toLowerCase()];
                //         var compIns = registryInstance._registeredComponents[item.toLowerCase()];//af check which registry?
                //         if(finalshadow._duplicateStyle.indexOf(item) == -1 && compIns._style){
                //             var sty = self.stringToStyle(compIns._style);
                //             sty.setAttribute("lyte-id","shadow-style-"+item);//update less style
                //             finalshadow._duplicateStyle.push(item);
                //             // sty._id = id;
                //             self.prependStyle(finalshadow, sty);
                //         }
                //     })
                // }
                // //get custom style tag in hmtl file
                // var customStyle = shadowParent.shadowRoot.querySelectorAll("style");
                // customStyle.forEach(function(item,index){
                //     if(!item.getAttribute("lyte-id") && !item.getAttribute("lyte-id-imported") &&!item.getAttribute("placeHolder")){
                //         self.prependStyle(finalshadow, item.cloneNode(true));
                //     }
                // });
                // var customLink = shadowParent.shadowRoot.querySelectorAll("link");
                // customLink.forEach(function(item,index){
                //     finalshadow.appendChild(item.cloneNode(true));
                //         // this.prependStyle(finalshadow, item.cloneNode(true));
                // });
            },
            "prependStyle"(shadowParent ,style){
                var nodes = shadowParent.querySelectorAll("[lyte-id^='shadow-']");
                var last = nodes[nodes.length- 1];
                if(last){
                    _LC.insertBeforeNative(shadowParent,style,last.nextSibling)
                }else{
                    _LC.insertBeforeNative(shadowParent,style,shadowParent.childNodes[0])
                }
            }
        },
        "V3" : {
            pendingComp : {
                remove : function(node){
                    let found;
                    let ltCfPend = window.__lyteConfig._pendingV3Components;
                    if(ltCfPend[node.localName]){
                        let ind = ltCfPend[node.localName].indexOf(node);
                        if(ind != -1){
                            ltCfPend[node.localName].splice(ind,1);
                            found = true;
                        }
                    }
                    return found;
                },
                add : function(node){
                    let ltCfPend = window.__lyteConfig._pendingV3Components;
                    if(ltCfPend[node.localName]){
                        if(ltCfPend[node.localName].indexOf(node) == -1){
                            ltCfPend[node.localName].push(node);
                        }
                    }else{
                        ltCfPend[node.localName] = [node];
                    }
                },
                find : function(name){
                    return window.__lyteConfig._pendingV3Components[name];
                },
                execute : function(arr){
                    arr.forEach(function(item){
                        delete item.__v3lyteIgnore 
                        item.decideConstructor();
                        var arr = Array.from(item.attributes);
                        arr.forEach(function(attr) {
                            if(item.constructor.observedAttributes.indexOf(attr.name) != -1) {
                                item._attributeChangedCallback(attr.name, null, attr.value);
                            }
                            
                        });
                        item._connectedCallback();
                    })
                    arr.splice(0,arr.length);
                },
                firstRegister : function(name,v){
                    let firstObj = window.__lyteConfig._firstRegisteredComp;
                    if(!firstObj[name]){
                        firstObj[name] = v;
                    }
                }
            }
        },
        "directive" : {
            "save" : {
                triggerMap : {
                    "input" : ["value","checked","disabled"],
                    "select" : ["value","selectedIndex"],
                    "textarea" : ["value"],
                    "div" : ["id"],
                    "span" : ["id"]
                },
                addNode : function(self, attr, dynamicN, gonnaSave, node, staticProp , helperNode, options){
                    let nodeVal = _LC.directive.getExactTransitionArg(attr,dynamicN) || dynamicN.id;
                    if(nodeVal){
                        self.setData(nodeVal, gonnaSave);
                        _LC.object.initalize(dynamicN,"__updateProp");
                        _LC.array.initalize(dynamicN.__updateProp,attr.hookName);
                        if(dynamicN.__updateProp[attr.hookName].indexOf(nodeVal) == -1){
                            dynamicN.__updateProp[attr.hookName].push(nodeVal);
                        }
                        if(node){
                            node._saveNode = nodeVal;
                        }
                        attr._saveNode = nodeVal;
                        if(attr.hookName == "prop"){
                            this.addData(gonnaSave, attr);
                        }
                        let cxObj = dynamicN._cx;
                        let forHelperNode = cxObj ? cxObj.node : false;
                        if(staticProp){
                            if(forHelperNode){
                            dynamicN._helperNode = forHelperNode
                            if(options){
                                let type = cxObj.type;
                                let ind = cxObj.itemIndex;
                                switch(type){
                                    case "forIn" :
                                    case "for" : {
                                            if(helperNode._dirObj){
                                                if(helperNode._dirObj.prop){
                                                    if(helperNode._dirObj.prop.indexOf(nodeVal) != -1){
                                                        this.estBndPrevNode(self, helperNode, nodeVal, gonnaSave, cxObj);
                                                    }
                                                }
                                                if(helperNode._dirObj.data){
                                                    if(helperNode._dirObj.data.indexOf(nodeVal) != -1){
                                                        this.estBndPrevNode(self, helperNode, nodeVal, gonnaSave, cxObj);
                                                    }
                                                }
                                            }
                                        _LC.array.initalize(forHelperNode,"_currentProp");
                                        _LC.array.checkAndPush(forHelperNode._currentProp, nodeVal);
                                        if(!forHelperNode._propNodes[nodeVal]){
                                            if(forHelperNode.getAttribute("is") == "forIn"){
                                                forHelperNode._propNodes[nodeVal] = {};    
                                            }else{
                                                forHelperNode._propNodes[nodeVal] = [];
                                            }
                                        }
                                        if(forHelperNode._propNodes[nodeVal][ind]){
                                            this.for.beforeUpdateSpecific(forHelperNode, [ind, 1], [gonnaSave], nodeVal,true);
                                            this.for.afterUpdateSpecific(forHelperNode, [ind, 1], [gonnaSave], nodeVal);
                                        }else{
                                            forHelperNode._propNodes[nodeVal][ind] = gonnaSave; //make it as set so that parent propnodes will be udpated
                                        }
                                    }
                                }
                            }
                            }else{
                                //af check //does it needed really ccehck
                                let beforeProp = self.getProperty(nodeVal);
                                _LC.array.initalize(self._propNodes,nodeVal);
                                self._propNodes[nodeVal].push(beforeProp);
                            }
                        }
                    }else{
                        Lyte.error("No value provided for save directive");
                    }
                },
                addData : function(element, attr){
                    if(!element.$data){
                        let listenerArr = this.triggerMap[element.localName];
                        if(listenerArr){
                            element.$data = {};
                            listenerArr.forEach(function(prop){
                                element.$data[prop] = element[prop];
                            })
                        }
                        else if(Lyte.Component.registeredComponents[element.localName]){
                            let directiveName = attr.hookName;
                            let directiveVal = _LC.directive.getExactTransitionArg(attr,element) || element.id;
                            element.$data = {};
                            Object.defineProperty(element.$data, "__lyteDirective", {
                                "enumerable" : false, 
                                "value" : {
                                    name : directiveName,
                                    value : directiveVal,
                                    node : element
                                }
                            });
                        }else{
                            element.$data = {}
                            // for(let attr in element.attribute){
                            //     let name = _LC.String.toCamelCase(attr.nodeName);
                            //     if(!element.$data[name]){
                            //         element.$data[name] = attr.nodeValue;
                            //     }
                            // }
                        }
                        for (var i = 0; i < element.attributes.length; i++) {
                            var attrib = element.attributes[i];
                            let name = _LC.String.toCamelCase(attrib.name);
                            if(!element._attributeDetails[attrib.name] && !element.$data[name]){
                                element.$data[name] = attrib.value;
                            }
                        }
                    }
                },
                updateName : function(self, node, nodeValue){
                    let oldSave = node._saveNode;
                    let fullDirectiveName = node.nodeName;
                    let actualData;
                    if(fullDirectiveName == "@data"){
                        actualData = node.ownerElement.$data
                    }else{
                        actualData = node.ownerElement;
                    }
                    if(self.getData(oldSave) == actualData){
                        self.setData(oldSave, null);
                    }
                    node._saveNode = nodeValue;
                    self.setData(nodeValue, actualData);
                    let spAttr = node.ownerElement._specialAttributeDetails;
                    spAttr.forEach(function(attr){
                        if(attr.hookName == "prop"){
                            attr._saveNode = nodeValue;
                        }else if(attr.hookName == "data"){
                            attr._saveNode = nodeValue;
                        }
                    })
                },
                removeNode : function(self,dynamicN){
                    if(dynamicN._specialAttributeDetails){
                        dynamicN._specialAttributeDetails.forEach(function(attr){
                            if(attr.hookName == "prop" || attr.hookName == "data" ){
                                let dataName = _LC.directive.getActualTransitionArg(attr,dynamicN);
                                self.component.data[dataName] = null;
                            }
                        })
                    }
    
                },
                removeAllNode : function(isType, self,spNodes){ //af can we remove // need for if and switch and normal
                    _LC.iterator(isType, spNodes, function(dynamicN){
                        if(Array.isArray(dynamicN)){
                            dynamicN.forEach(function(dynN){
                                _LCSV.removeNode(self,dynN);
                            })
                        }else{
                            _LCSV.removeNode(self,dynamicN);
                        }
                    });
                },
                getAttr : function(spAttr){
                    let saveAttr = false;
                    if(spAttr){
                        spAttr.forEach(function(attr){
                            if(attr.hookName == "prop"){
                                saveAttr = attr;
                            }else if(attr.hookName == "data"){
                                saveAttr = attr;
                            }
                        });
                    }
                    return saveAttr;
                },
                triggerAllListeners : function(self,directiveName,target,switchContext){
                    let saveNodeName = target.localName;
                    let listenerArr = this.triggerMap[saveNodeName];
                    if(listenerArr){
                        listenerArr.forEach(function(prop){
                            _LCSV.setData(prop, target);
                        })
                        if(self._cx){
                            _LCSV.updateCxNodes(self);
                        }
                    }
                },
                setData : function(eleProp, target){
                    Lyte.Component.set(target.$data , eleProp, target[eleProp]);
                },
                addNodeLazy : function(arr, comp, info, dynamicN, helperNode, yieldComp ,options){
                    arr.forEach(function(obj){
                        let attr = obj.attr;
                        let node = obj.node;
                        let staticProp;
                        if(attr && attr.stringValue){
                            staticProp = true;
                        }
                        if(attr.hookNode){
                            _LC.directive.infoA(comp,info,dynamicN,helperNode,attr,yieldComp,options);
                            if(attr.hookName == "prop" || attr.hookName == "data" ){
                                if(options && options.node) {
                                    dynamicN._cx = options;
                                }
                                else if(helperNode) {
                                    dynamicN._cx = helperNode._cx;
                                }
                                let gonnaSave = dynamicN;
                                _LCSV.addData(dynamicN, attr);
                                if(attr.hookName == "data" ){
                                    gonnaSave = dynamicN.$data;
                                }
                                _LCSV.addNode(comp,attr, dynamicN, gonnaSave,node,staticProp,helperNode,options);
                            }else if(attr.hookName == "class"){
                                if(staticProp){
                                    _LC.directive.class.addStaticValue(dynamicN);
                                }else{
                                    _LC.directive.class.addValue(node.ownerElement);
                                }
                            }
                        }
                    })
                },
                updateCxNodes : function(comp){
                    let cx = comp._cx;
                    let initial = true;
                    while(cx){
                        if(cx.type == "for" || cx.type == "forIn"){
                            let forNode = cx.node;
                            let ind = cx.itemIndex;
                            if(comp.__updateProp.data){
                                comp.__updateProp.data.forEach(function(propVal){ //eslint-disable-line no-loop-func
                                    if(forNode._propNodes[propVal]){
                                        if(initial){
                                            Lyte.Component.set(forNode._propNodes[propVal],ind, comp.$data,{force : true});
                                        }
                                        _LCSV.affectChangesArr(forNode._items[ind].propProperty[propVal]);
                                        _LCSV.establishBindingsArr(forNode._items[ind].propProperty[propVal] ,forNode._propNodes[propVal][ind]);
                                    }
                                    _LCSV.affectChangesComp(forNode)
                                })
                            }else if(comp.__updateProp.prop){
                                comp.__updateProp.prop.forEach(function(propVal){ //eslint-disable-line no-loop-func
                                    if(forNode._propNodes[propVal]){
                                        if(initial){
                                            Lyte.Component.set(forNode._propNodes[propVal][ind], "$data",comp.$data, {force : true});
                                        }
                                        _LCSV.affectChangesArr(forNode._items[ind].propProperty[propVal] ,forNode._propNodes[propVal]);
                                    }
                                })
                            }
                        }
                        initial = false;
                        cx = cx.node._cx;
                    }
                    if(comp.__updateProp.data){
                        comp.__updateProp.data.forEach(function(propVal){
                            if(comp._callee && comp._callee._propProperty && comp._callee._propProperty[propVal] && comp._callee._propProperty[propVal].length){
                                _LCSV.affectChangesArr(comp._callee._propProperty[propVal]); // it is ctx switcing ??
                                _LCSV.establishBindingsArr(comp._callee._propProperty[propVal] ,comp._callee.$data[propVal], true);
                            }
                        })
                    }
                },
                setDataInParentComp : function(comp){
                    if(comp.__updateProp.data){
                        comp.__updateProp.data.forEach(function(propVal){
                            Lyte.Component.set(comp._callee.component.data, propVal, comp.$data, {force : true});
                        })
                    }else if(comp.__updateProp.prop){
                        comp.__updateProp.prop.forEach(function(propVal){
                            Lyte.Component.set(comp._callee.component.data,propVal, comp,{force : true});
                        })
                    } 
                },
                affectChangesArr : function(bindingArr){
                    if(bindingArr){
                        bindingArr.forEach(function(binding){
                            binding && _LC.affectChanges(binding);
                        })
                    }
                },
                establishBindingsArr : function(bindingArr, data, addBinding){
                    if(bindingArr){
                        bindingArr.forEach(function(binding){
                            _LC.establishBindings(binding, data);
                            if(addBinding){
                                addBindings(data, binding)
                            }
                        })
                    }
                },
                afterRender : function(node,comp,dirObjProp,options,initialRender){
                    for(let key in node._propNodes){
                        let cxObj = node._cx;
                        let parentForNode = node;
                        while(cxObj){
                            if(cxObj.type == "for" || cxObj.type == "forIn"){
                                parentForNode = cxObj.node;
                                let parentPropNodes = cxObj.node._propNodes[key];
                                if(cxObj.node._propNodes[key]){
                                    if(options.type != "default" && node.getAttribute("is") == "for"){
                                        let oldbindings = parentPropNodes[cxObj.itemIndex]._bindings;
                                        if(oldbindings){
                                            let bindArr = oldbindings.toArrayLyte();
                                            this.establishBindingsArr(bindArr ,node._propNodes[key]);
                                        }
                                    }
                                    parentPropNodes[cxObj.itemIndex] = node._propNodes[key];
                                    this.affectChangesArr(parentForNode._items[cxObj.itemIndex].propProperty[key]);
                                    if(node.getAttribute("is") == "for"){
                                        this.establishBindingsArr(parentForNode._items[cxObj.itemIndex].propProperty[key] ,parentForNode._propNodes[key][cxObj.itemIndex]);
                                    }
                                }
                                else if(!cxObj.node._propNodes[key]){
                                    if(cxObj.node.getAttribute("is") == "forIn"){
                                        parentPropNodes = cxObj.node._propNodes[key] = {};
                                    }else{
                                        parentPropNodes = cxObj.node._propNodes[key] = [];
                                    }
                                    parentPropNodes[cxObj.itemIndex] = node._propNodes[key];
                                }
                                if(!cxObj.node._childProp){
                                    cxObj.node._childProp = [key];
                                }else if(cxObj.node._childProp.indexOf[key] == -1){
                                    cxObj.node._childProp.push(key);
                                }
                            }
                            cxObj = cxObj.node._cx;
                            node = parentForNode;
                        }
                        if(parentForNode){
                            comp.$data[key] = parentForNode._propNodes[key];
                            if(!comp._propProperty[key]){
                                comp._propProperty[key] = [];
                            }
                            if((options.type == "update" || options.type == "default")){
                                if(options.type == "update"){
                                    let bind = comp.$data[key]._bindings;
                                    if(bind){
                                        let bindArr = bind.toArrayLyte();
                                        bindArr.forEach(function(bind){
                                            if(comp._propProperty[key].indexOf(bind) == -1){
                                                comp._propProperty[key].push(bind);
                                                comp._propProperty[key].push([]);
                                            }
                                            if(node.getAttribute("is") == "forIn"){
                                                _LCSV.establishBindingsArr(bindArr ,parentForNode._propNodes[key]);
                                            }
                                        })
                                    }
                                }else{
                                    let compProp = dirObjProp.data[key];
                                    if(initialRender && compProp && Object.keys(compProp).length && comp._propProperty[key].indexOf(compProp) == -1){ //af proper alternative ??????
                                        if(Array.isArray(compProp)){
                                            compProp.forEach(function(bind){
                                                comp._propProperty[key].push(bind);
                                            })
                                        }else{
                                            comp._propProperty[key].push(compProp);
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                estBndPrevNode : function(self, helperNode, nodeVal, gonnaSave, cxObj){
                    this.addFlagInData(helperNode);
                    let hpNode = helperNode;
                    let savedNode = gonnaSave;
                    let childInd = cxObj.itemIndex;
                    let beforeProp = hpNode._items[childInd].propProperty[nodeVal];
                    if(beforeProp){
                        beforeProp.forEach(function(prop){
                            if(prop._path == nodeVal && !savedNode._establish){
                                _LC.establishBindings({[nodeVal] : prop} ,{[nodeVal] : savedNode});    
                                savedNode._establish = true; // af check
                            }
                        })
                    }
                    self._properties[nodeVal] = {};
                },
                removeAll : function(isType, self, node, index, destroyChild,  updateIndex, parentNode, type){
                    //removeing this specialnodes check we can remove beforeudpateprop method 
                    if(/^(if|switch|for)$/.test(isType)){
                        node._specialNodes && node._specialNodes.length && this.removeAllNode("for", self, node._specialNodes);
                    }
                    else if(isType == "forIn"){
                        node._specialNodes && Object.keys(node._specialNodes).length && this.removeAllNode("forIn" ,self, node._specialNodes);
                    }
                    if(node._propNodes && Object.keys(node._propNodes).length){ //af check bug change removed esle in the starting
                        for(let propName in node._propNodes){
                            if(index != undefined){
                                this.removeInIndex(self, node, propName, index, node._propNodes[propName][index], true, destroyChild, updateIndex, parentNode, type);
                            }else{
                                _LC.iterator(isType, node._propNodes[propName], function(index, item){
                                    _LCSV.removeInIndex(self, node, propName, index, item, true, destroyChild, updateIndex, parentNode, type);
                                });
                                node._propNodes[propName] = {};
                            }
                        }
                    }
                },
                addFlagInData : function(node){
                    while(node){
                        if(node.getAttribute("is") == "forIn"){
                            makeVal(node._currentObject, "_propNodes", true);
                        }
                        node = node._cx && node._cx.node;
                    }
                },
                removeInIndex : function(comp, node, propName ,index, data, destroy, destroyChild, updateIndex, updateNode , type){
                    if(node._items[index]){
                        let propPropertyArr = node._items[index].propProperty[propName];
                        if(propPropertyArr){
                            propPropertyArr.forEach(function(binding){
                                _LC.removeSelectedBindingDeep(binding,data);
                            })
                            node._items[index].propProperty[propName] = [];
                            node._items[index].propPropertyDyn[propName] = [];
                        }
                        if(type && type == "update" && updateNode == node){
                            return;
                        }
                        let parentStarted;
                        if(node == updateNode){
                            parentStarted = true;
                        }
                        let cx = node._cx; //asumme one array is splicing so need to update all parent helpers propProperty
                        while(cx){
                            if(cx.type == "for" || cx.type == "forIn"){
                                let ind = cx.itemIndex;
                                let node = cx.node;
                                if(node._items[ind]){
                                    let propPropertyArr = node._items[ind].propProperty[propName];
                                    let propPropertyDynArr = node._items[ind].propPropertyDyn[propName];
                                    if(propPropertyArr){
                                        this.affectChangesArr(propPropertyArr);
                                        propPropertyArr.forEach(function(binding,ix){ //eslint-disable-line no-loop-func
                                            let removePropNodes = node._propNodes[propName][ind];
                                            let remove;
                                            let arr = propPropertyDynArr[ix].split(".");
                                            arr.forEach(function(dynName){ //eslint-disable-line no-loop-func
                                                if(dynName.indexOf(updateIndex) != -1){
                                                    remove = true;
                                                }
                                            })
                                            if(remove || !parentStarted){
                                                _LC.removeSelectedBindingDeep(binding,removePropNodes);   
                                            }
                                        })
                                        if(destroyChild){
                                            node._items[ind].propProperty[propName] = [];
                                        }
                                    }
                                }
                                if(node == updateNode){
                                    parentStarted = true;
                                }
                            }
                            cx = cx.node._cx;
                        }
                        if(comp && comp._propProperty[propName]){
                            if(comp._propProperty[propName].indexOf(propName) != -1){
                                let propNode = this.getActualPropData(node, propName);
                                if(propNode._bindings){
                                    let bindArr = propNode._bindings.toArrayLyte();
                                    bindArr.forEach(function(bnd){
                                        _LC.removeSelectedBindingDeep(bnd,propNode);
                                    })
                                }
                            }
                        }
                    }
                },
                removeInParent : function(comp, node, propName ,index, data, destroy){
                    let cx = node._cx; //asumme one array is splicing so need to update all parent helpers propProperty
                    while(cx){
                        if(cx.type == "for" || cx.type == "forIn"){
                            let ind = cx.itemIndex;
                            let node = cx.node;
                            let propPropertyArr = node._items[ind].propProperty[propName];
                            if(propPropertyArr){
                                propPropertyArr.forEach(function(binding){ //eslint-disable-line no-loop-func
                                    _LC.removeSelectedBindingDeep(binding,node._propNodes[propName][ind]);
                                })
                            }
                        }
                        cx = cx.node._cx;
                    }
                    if(comp && comp._propProperty[propName]){
                        if(comp._propProperty[propName].indexOf(propName) != -1){
                            let propNode = this.getActualPropData(node, propName);
                            if(propNode._bindings){
                                let bindArr = propNode._bindings.toArrayLyte();
                                bindArr.forEach(function(bnd){
                                    _LC.removeSelectedBindingDeep(bnd,propNode);
                                })
                            }
                        }
                    }
                },
                removeInChild : function(comp, node, propName ,index, data, destroy){

                    if(node._helpers) {
                        for(let i=0;i<node._helpers.length;i++) {
                            for(let j=0;j<node._helpers[i].length;j++) {
                                let currentNode = node._helpers[i][j];
                                this.removeInChild(comp, currentNode, propName ,i, data, destroy);
                                let propPropertyArr = node._items[i].propProperty[propName];
                                if(propPropertyArr){
                                    propPropertyArr.forEach(function(binding){ //eslint-disable-line no-loop-func
                                        _LC.removeSelectedBindingDeep(binding,node._propNodes[propName][i]);
                                    })
                                }
                            }
                        }
                    }
                },
                addInParent : function(comp, node, propName){
                    let cx = node._cx;
                    if(cx){
                        let ind = cx.itemIndex;
                        let forNode = cx.node;
                        while(cx){
                            if(cx.type == "for" || cx.type == "forIn"){
                                forNode = cx.node;
                                ind = cx.itemIndex;
                                this.affectChangesArr(forNode._items[ind].propProperty[propName]);
                                this.establishBindingsArr(forNode._items[ind].propProperty[propName] ,forNode._propNodes[propName][ind]);
                            }
                            cx = cx.node._cx;
                        }
                    }
                },
                addInChild : function(comp, node, propName,i){
                    if(node._helpers) {
                        for(let i=0;i<node._helpers.length;i++) {
                            for(let j=0;j<node._helpers[i].length;j++) {
                                let currentNode = node._helpers[i][j];
                                this.addInChild(comp, currentNode, propName);
                                let ind = currentNode._cx.itemIndex;
                                this.establishBindingsArr(currentNode._items[ind].propProperty[propName] ,currentNode._propNodes[propName][ind]);
                            }
                        }
                    }
                },
                affectChangesComp : function(node){
                    let arr = node._currentProp ? node._currentProp : node._childProp
                    if(arr){
                        arr.forEach(function(propName){
                            let comp = node._callee;
                            if(comp._propProperty[propName]){
                                comp._propProperty[propName].forEach(function(binding){
                                    _LC.affectChanges(binding);
                                })
                            }
                        })
                    }
                },
                getActualPropData : function(node,propName){
                    let parentMostNode = node;
                    let cx = node._cx;
                    while(cx){
                        parentMostNode = cx.node;
                        cx = cx.node._cx;
                    }
                    return parentMostNode._propNodes[propName];
                },
                forIn : {
                    delete : function(node, options){
                        if(node._propNodes && Object.keys(node._propNodes).length){
                            for(let propName in node._propNodes){
                                let propArr = node._propNodes[propName];
                                propArr[options.property] = null;
                                delete propArr[options.property];
                                if(propArr._bindings){
                                    let bindings = propArr._bindings.toArrayLyte()
                                    _LCSV.affectChangesArr(bindings);
                                }
                            }
                        }
                    },
                    add : function(node, options, keysArray, replace){
                        let self = node._callee;
                        let lastNode;
                        if(node._propNodes && Object.keys(node._propNodes).length){
                            if(replace){
                                keysArray.forEach(function (itemKey, index, array) {
                                    self.removeHelpersSpecificIndex(node, itemKey, undefined, options.type);
                                });
                            }
                            if(node._forContent[options.property]){
                                let ind = node._keysArray.indexOf(options.property);
                                if(node._forContent[node._keysArray[ind+1]]){
                                    lastNode = node._forContent[node._keysArray[ind+1]][0];
                                }else{
                                    lastNode = node;
                                }
                            }
                        }
                        return lastNode;
                    },
                    update : function(node){
                        if(node._propNodes && Object.keys(node._propNodes).length){
                            for(let key in node._items) {  
                                for(let propName in node._propNodes){
                                    let propArr = node._propNodes[propName];
                                    // propArr.shift();
                                    propArr[key] = null;
                                    delete propArr[key];
                                    if(node._cx && (node._cx.type == "for" || node._cx.type == "forIn")){
                                        _LCSV.addInParent(node._callee, node, propName);
                                    }
                                    if(propArr._bindings){
                                        let bindings = propArr._bindings.toArrayLyte()
                                        _LCSV.affectChangesArr(bindings);
                                    }
                                }
                            }
                        }
                    }
                },
                for : {
                    update : function(node){
                        if(node._propNodes && Object.keys(node._propNodes).length){
                            for(let propName in node._propNodes){
                                let propArr = node._propNodes[propName];
                                propArr.shift();
                                if(node._cx && (node._cx.type == "for" || node._cx.type == "forIn")){
                                    _LCSV.addInParent(node._callee, node, propName);
                                }
                                if(propArr._bindings){
                                    let bindings = propArr._bindings.toArrayLyte()
                                    _LCSV.affectChangesArr(bindings);
                                }
                            }
                        }
                    },
                    beforeUpdate : function(node, spliceArr, newPropObj, newItemObj){
                        if(node._propNodes && Object.keys(node._propNodes).length){
                            for(let propName in node._propNodes){
                                newItemObj.forEach(function(obj, index){
                                    if(obj){
                                        if(!obj.propProperty){
                                            obj.propProperty = {}
                                        }
                                        if(!obj.propProperty[propName]){
                                            if(node.getAttribute("is") == "forIn"){
                                                obj.propProperty[propName] = {};
                                            }else{
                                                obj.propProperty[propName] = [];
                                            }
                                        }
                                    }
                                })
                                this.beforeUpdateSpecific(node, spliceArr, newPropObj, propName)
                            }
                        } 
                    },
                    beforeUpdateSpecific : function(node, spliceArr, newPropObj, propName, addNode){
                        let gonnaInsertPos = spliceArr[0];
                        if(newPropObj.length){
                            if(node.getAttribute("is") == "for"){
                                // inserting
                                if( spliceArr[1] == 0){
                                    // inserting bt no deletion
                                    // so need to update all next indexes
                                    for(let i=gonnaInsertPos; i<node._propNodes[propName].length; i++){ //af check for forin
                                        _LCSV.removeInParent(node._callee, node, propName, i, node._propNodes[propName][i]);
                                        // _LCSV.removeInChild(node._callee, node, propName, i, node._propNodes[propName][i]);
                                    }
                                }else if(newPropObj.length != spliceArr[1]){
                                    // inserting different val and deletion different val
                                    // so need to update all next indexes
                                    for(let i=gonnaInsertPos; i<node._propNodes[propName].length; i++){
                                        _LCSV.removeInParent(node._callee, node, propName, i, node._propNodes[propName][i]);
                                    }
                                }
                            }
                        }
                        let comp = node._callee;
                        if(!addNode && comp && comp._propProperty[propName]){
                            let propNode = _LCSV.getActualPropData(node, propName);
                            if(propNode._bindings){
                                let bindArr = propNode._bindings.toArrayLyte();
                                bindArr.forEach(function(bnd){
                                    _LC.removeSelectedBindingDeep(bnd,propNode);
                                })
                            }
                        }
                        let propArr = node._propNodes[propName];
                        if(node.getAttribute("is") == "forIn"){
                            if(newPropObj.length){
                                propArr[gonnaInsertPos] = newPropObj[0];
                            }else{
                                propArr[gonnaInsertPos] = null;
                                delete propArr[gonnaInsertPos];
                            }
                        }else{
                            propArr.splice.apply(propArr, spliceArr.concat(newPropObj));
                        }  
                    },
                    afterUpdate : function(node, spliceArr, newPropObj){
                        if(node._propNodes && Object.keys(node._propNodes).length){ //af check for forin
                            for(let propName in node._propNodes){
                                this.afterUpdateSpecific(node, spliceArr, newPropObj, propName)
                            }
                        } 
                    },
                    afterUpdateSpecific : function(node, spliceArr, newPropObj, propName){
                        let gonnaInsertPos = spliceArr[0];

                        if( spliceArr[1] == 0){
                            // inserting bt no deletion
                            // so need to update all next indexes
                            for(let i=gonnaInsertPos+newPropObj.length; i<node._propNodes[propName].length; i++){ // afcheck forincase
                                _LCSV.addInParent(node._callee, node, propName, i, node._propNodes[propName][i]);
                                _LCSV.addInChild(node._callee, node, propName, i, node._propNodes[propName][i]);
                            }
                        }else if(newPropObj.length){
                            if( newPropObj.length != spliceArr[1]){
                                // inserting different val and deletion different val
                                // so need to update all next indexes
                                for(let i=gonnaInsertPos+newPropObj.length; i<node._propNodes[propName].length; i++){
                                    _LCSV.addInParent(node._callee, node, propName, i, node._propNodes[propName][i]);
                                    _LCSV.addInChild(node._callee, node, propName, i, node._propNodes[propName][i]);
                                }
                            }
                        }else{
                            //deletion alone so need to update parent alone
                            _LCSV.addInParent(node._callee, node, propName);
                            _LCSV.addInChild(node._callee, node, propName);
                        }
                        let comp = node._callee;
                        if(comp && comp._propProperty[propName]){
                            let propNode = _LCSV.getActualPropData(node, propName);
                            _LCSV.affectChangesArr(comp._propProperty[propName]);
                            _LCSV.establishBindingsArr(comp._propProperty[propName] ,propNode, true);
                        }
                    }
                },
                beforeDirObj : function(node, dirObjData, dirObjProp){
                    if(node._dirObj){
                        if(node._dirObj.data){
                            let callee = node._callee;
                            node._dirObj.data.forEach(function(dataPropName){
                                dirObjData.data[dataPropName] =  callee.component.data[dataPropName];
                                callee.component.data[dataPropName] = null;
                                dirObjProp.data[dataPropName] =  callee._properties[dataPropName];
                                callee._properties[dataPropName] = null;
                            })
                        }
                    }
                },
                afterDirObj : function(node, dirObjData, dirObjProp){
                    if(node._dirObj){
                        if(node._dirObj.data){
                            let callee = node._callee;
                            node._dirObj.data.forEach(function(dataPropName){
                                callee.component.data[dataPropName] = dirObjData.data[dataPropName];
                                callee._properties[dataPropName] = dirObjProp.data[dataPropName];
                            })
                        }
                    }
                },
                updateMulProp : function(node, multipleProp, boundName, totalProp, prop){
                    if(node._cx && multipleProp.helperNode && multipleProp.helperNode._items[node._cx.itemIndex].propProperty[boundName]){
                        multipleProp.helperNode._items[node._cx.itemIndex].propProperty[boundName].push(totalProp);
                        multipleProp.helperNode._items[node._cx.itemIndex].propPropertyDyn[boundName].push(prop._path);
                    }
                },
                lazyProp : {
                    add : function(lazyProp, node, helperNode, forIndex, boundValue, dynamicValuesArray,  dynamicValues){
                        lazyProp.push({
                            node : node,
                            helperNode : helperNode,
                            forIndex : forIndex,
                            boundValue : boundValue,
                            dynamicValuesArray : dynamicValuesArray,
                            dynamicValues : dynamicValues
                        })
                    },
                    iterate : function(self, lazyProp){
                        lazyProp.forEach(function(obj){
                            let node = obj.node;
                            let helperNode = obj.helperNode;
                            let boundValue = obj.boundValue;
                            let forIndex = obj.forIndex;
                            let dynamicValuesArray = obj.dynamicValuesArray;
                            let dynVals = obj.dynamicValues;
                            node._propNode = true
                            let propPropertyDyn = helperNode._items[forIndex].propPropertyDyn;
                            if(!propPropertyDyn[boundValue]){
                                propPropertyDyn[boundValue] = [];
                            }
                            propPropertyDyn[boundValue].push(dynVals);
        
                            let propProperty = helperNode._items[forIndex].propProperty;
                            if(!propProperty[boundValue]){
                                propProperty[boundValue] = [];
                            }
                            let prop = self.getProperty(boundValue);
                            propProperty[boundValue].push(prop);
                            let dta = _LC.get(self.component.data,boundValue);
                            if(dta && dta._establish){ //af check
                                _LC.establishBindings({[boundValue] : prop} ,{[boundValue] : dta});      
                            }
                            self._properties[boundValue] = {};
                        })
                    }
                },
                afterConnect : function(comp){
                    if(comp._callee){
                        let propSave = comp.hasAttribute("lyte-directive-prop");
                        let dataSave = comp.hasAttribute("lyte-directive-data");
                        if((propSave || dataSave) && !comp.__updateProp){
                            let obj = {
                                attr : {
                                    hookName : propSave ? "prop" : "data",
                                    hookNode : true,
                                    stringValue : propSave ? comp.getAttribute("lyte-directive-prop") : comp.getAttribute("lyte-directive-data")
                                },
                                node : comp
                            }
                            this.addNodeLazy([obj], comp._callee, undefined , comp, comp._cx ? comp._cx.node : undefined, undefined, comp._cx);
                        }
                    }
                },
                setDirObj : function(node){
                    if(node.hasAttribute("dir-obj")){   
                        node._dirObj = JSON.parse(node.getAttribute("dir-obj"));
                    }
                },
                connect : function(comp){
                    if(comp.__updateProp && comp._callee && comp._callee.component){
                        if(comp._cx){
                            this.updateCxNodes(comp);
                        }else{
                            this.setDataInParentComp(comp);
                        }
                    }  
                },
                removeData : function(comp){
                    if(comp._propProperty){
                        for (let key in comp._propProperty){
                            comp._propProperty[key] = null;
                        }
                    }
                }
            },
            "hide" : {
                appendTemp : function(){
                    document.body.appendChild(_LC.hiddenComponentsDiv);
                    document.body.appendChild(_LC.hiddenYieldsDiv);
                },
                triggerGlobalEvent : function(target, eventName, ev, hasHandled, ignore){
                    if(target && target._hiddenBoundEvents && target._hiddenBoundEvents[eventName] && !ev.cancelBubble && (ignore || ev.currentTarget == document.body)){
                        let actObj = target._hiddenBoundEvents[eventName];
                        let cloneActObj = _Lyte.deepCopyObject(actObj);
                        _LC.skipArgProcessing(cloneActObj, eventName, target);
                        _LC.throwAction.call(target.parentElement._callee, target.parentElement._callee, eventName, cloneActObj, undefined, undefined, target, ev, hasHandled);
                    }
                },
                connect : function(comp, content){
                    let tempParent = comp._callee;
                    if(tempParent){
                        _LCHD.template(comp, _LC.hiddenComponentsDiv ,content)
                    }else{
                        console.error(' Error:Parent node of current template is not of type TEMPLATE . Cannot hide this template');
                    }
                },
                yield : {
                    connect : function(comp){
                        if(comp._callee && _LC.directive.getTransitionArg(comp._callee, "hide-tag")){
                            _LCHD.template(comp, _LC.hiddenYieldsDiv);
                        }
                    },
                    disConnect : function(comp){
                        if(Array.from(_LC.hiddenYieldsDiv.content.childNodes).indexOf(comp)!=-1){
                            _LC.hiddenYieldsDiv.content.removeChild(comp)
                        }
                        if(comp._hiddenTemplate && comp._hiddenTemplate.length){
                            _LCHD.callDisconnectedCallback(comp);
                        }
                    }
                },
                rmHelpersSpecificIndex : function(node, index){
                    if(typeof index=='number' && node._hiddenTemplate[index] && node._hiddenTemplate.length){
                        for(let i in node._hiddenTemplate[index]){
                            node._hiddenTemplate[index][i].disconnectedCallback();
                        }
                        if(node.getAttribute("is") == "for"){
                            node._hiddenTemplate.splice(index, 1); 
                        }else{
                            delete node._hiddenTemplate[index];
                        }
                    }
                },
                forRmHelpers : function(node){
                    if(node._hiddenTemplate && node._hiddenTemplate.length) {
                        for(let i=0;i<node._hiddenTemplate.length;i++) {
                            for(let j=0;j<node._hiddenTemplate[i].length;j++) {
                                node._hiddenTemplate[i][j].disconnectedCallback();
                            }
                            node._hiddenTemplate[i] = [];
                        }
                        node._hiddenTemplate = [];
                    }
                },
                ifRmHelpers : function(node){
                    if(node._hiddenTemplate && node._hiddenTemplate.length){
                        _LCHD.callDisconnectedCallback(node);
                    }
                },
                setTxtNode : function(comp, yld){
                    if(_LC.directive.getTransitionArg(comp, "hide-tag")){
                        var emptyTextNode = document.createTextNode("");
                        _LC.replaceWithPf(yld, emptyTextNode);
                    } 
                },
                shouldStop : function(node, event){
                    let stopBubble = false;
                    if(node._hiddenBoundEvents && node._hiddenBoundEvents[event.type] && node._hiddenBoundFlag){
                        stopBubble = true;
                        node._hiddenBoundFlag = false;
                    }
                    return stopBubble;
                },
                define : {
                    remove : function(classDef){
                        const $remove = Element.prototype.remove;
                        Object.defineProperty(classDef.prototype,"remove",{
                            configurable : true,
                            writable : true,
                            value : function(){
                                if(this._firstChild == undefined || this._firstChild.parentElement == null){
                                    $remove.call(this);
                                    this._firstChild = undefined;
                                    this._lastChild = undefined;
                                    return;
                                }
                                firstNode = this._firstChild;
                                parent = firstNode.parentElement;
                                lastNode = this._lastChild;
                                while(firstNode.nextSibling != lastNode){
                                    parent.removeChild(firstNode.nextSibling);
                                }
                                this._firstChild = undefined;
                                this._lastChild = undefined;
                                parent.removeChild(firstNode);
                                parent.removeChild(lastNode);
                                return;
                            }
                        })
                    },
                    getContent : function(customCrmComponent){
                        Object.defineProperty(customCrmComponent.prototype,"getContent",{
                            configurable : true,
                            writable : true,
                            value : function(){
                                arr = [];
                                if(this._firstChild == undefined){
                                    console.error("Cannot access template through getContent");
                                }
                                firstNode = this._firstChild;
                                lastNode = this._lastChild;
                                firstNode = firstNode.nextSibling;
                                while(firstNode!=lastNode){
                                    arr.push(firstNode);
                                    firstNode=firstNode.nextSibling;
                                }
                                return arr;
                            }
                        });
                    }
                },
                addHiddenBoundEvents : function(compNode, content){
                    if(!compNode._boundEvents){return;}
                    for(let i=0; i<content.childNodes.length ;i++){
                        if(compNode._boundEvents){
                            content.childNodes[i]._hiddenBoundEvents = compNode._boundEvents;
                            if(content.childNodes[i]._boundEvents){
                                content.childNodes[i]._hiddenBoundFlag = true;
                            }
                        }
                    }
                },
                callDisconnectedCallback : function(node){
                    for(let i=0; i<node._hiddenTemplate.length; i++){
                        node._hiddenTemplate[i].disconnectedCallback();
                    }
                    node._hiddenTemplate=[];
                },
                template : function(compNode, hiddenDomDiv, content){
                    _LyteComponent._setIgnoreDisconnect(true);
                    compNode._ignoreDisconnect=true;
                    compNode.__lyteIgnore=true;
                    let parentElement=compNode._callee;
                    let parentEle=compNode.parentElement;
                    let domContent=document.createDocumentFragment();
                    let len=compNode.childNodes.length;
                    let firstChild=document.createTextNode("");
                    let lastChild=document.createTextNode("");
                    compNode._firstChild=firstChild;
                    compNode._lastChild=lastChild;
                
                    for(let i=0;i<len;i++){
                        compNode.childNodes[0]._hiddenBoundEvents=compNode._boundEvents;
                        if(compNode.childNodes[0]._boundEvents){
                            compNode.childNodes[0]._hiddenBoundFlag=true;
                        }
                        domContent.append(compNode.childNodes[0]);
                    }
                    let elePos=Array.from(parentEle.childNodes).indexOf(compNode);
                    parentEle.insertBefore(firstChild,parentEle.childNodes[elePos]);
                
                
                    elePos=Array.from(parentEle.childNodes).indexOf(compNode);
                    if(domContent.childNodes.length){
                        parentEle.insertBefore(domContent,parentEle.childNodes[elePos]);
                        elePos=Array.from(parentEle.childNodes).indexOf(compNode);
                    }
                
                    if(content){
                        this.addHiddenBoundEvents(compNode, content);
                        parentEle.insertBefore(content,parentEle.childNodes[elePos]);
                    }
                
                    elePos=Array.from(parentEle.childNodes).indexOf(compNode);
                    parentEle.insertBefore(lastChild,parentEle.childNodes[elePos]);
                    let parentHelper = compNode._parentHelper;
                    if(parentHelper){
                        if(parentHelper.tagName == "LYTE-YIELD"){
                            parentHelper._hiddenTemplate.push(compNode);
                        }
                        else if(parentHelper._forContent){
                            if(compNode._cx){
                                let ind = compNode._cx.itemIndex;
                                // let eleArr = parentHelper._forContent[ind];
                                // eleArr.push(content.childNodes[i]);
                                if(!parentHelper._hiddenTemplate[ind]){
                                    parentHelper._hiddenTemplate[ind] = [];
                                }   
                                parentHelper._hiddenTemplate[ind].push(compNode);
                            }
                        } else if(parentHelper._caseContent) {
                            // compNode._parentHelper._caseContent.push(content.childNodes[i]);
                            parentHelper._hiddenTemplate.push(compNode);
                        } 
                        // else if(parentHelper._yieldContent) {
                        //     compNode._parentHelper._yieldContent.push(content.childNodes[i]);
                        // } else if(parentHelper._renderedComponent) {
                
                        // }
                    } 
                    else if(compNode._callee){
                        compNode._callee._hiddenTemplate.push(compNode);
                    }
                    hiddenDomDiv.content.appendChild(compNode);
                    compNode._ignoreDisconnect=false;
                    _LyteComponent._setIgnoreDisconnect(false);
                    compNode.__lyteIgnore=false;
                }
            },
            "class" : {
                addStaticValue : function(node){
                    if(node.hasAttribute("lyte-directive-class")){
                        let classVal = node.getAttribute("lyte-directive-class")
                        node.setAttribute("class", classVal);
                        node._initialClassValue = classVal;
                    }
                },
                addValue : function(node){
                    if(node._transitionArgs && node._transitionArgs.class){
                        node.setAttribute("class", node._transitionArgs.class);
                        node._initialClassValue = node._transitionArgs.class;
                    }
                },
                updateValue : function(node){
                    if(node._transitionArgs && node._transitionArgs.class){
                        let currentClassVal = node.getAttribute("class");
                        let oldClassVal = node._initialClassValue;
                        let externalClassVal = currentClassVal.substr(oldClassVal.length);
                        let newClassValue = node._transitionArgs.class;
                        let finalclassVal = newClassValue + externalClassVal;
                        node.setAttribute("class", finalclassVal);
                        node._initialClassValue = newClassValue;
                    }
                }//,
                // addNodeLazy : function(arr, comp, info, dynamicN, helperNode, yieldComp ,options){
                //     arr.forEach(function(obj){
                //         let attr = obj.attr;
                //         let node = obj.node;
                //         if(attr.hookNode){
                //             _LC.directive.infoA(comp,info,dynamicN,helperNode,attr,yieldComp,options);
                //             if(attr.hookName == "class"){
                //                 if(staticProp){
                //                     _LC.directive.class.addStaticValue(dynamicN);
                //                 }else{
                //                     _LC.directive.class.addValue(node.ownerElement);
                //                 }
                //             }
                //         }
                //     })
                // },
            },
            registeredProp : {},
            compileNode : function(node, attr, toBeRemoved, toBeAdded, i, componentName){
                // let specialAttr;
                // add = true;
                node._special = true;
                let attrToPush = {};
                attrToPush.name = node.attributes[i].name;
                if(attr[attrToPush.name] && attr[attrToPush.name].dynamicValue){
                    attrToPush.dynamicValue = attr[attrToPush.name].dynamicValue;
                }else if(attr[attrToPush.name] && attr[attrToPush.name].helperInfo){
                    attrToPush.helperInfo = attr[attrToPush.name].helperInfo;
                }else{
                    attrToPush.stringValue = node.attributes[i].nodeValue;
                    let ndName = node.attributes[i].nodeName
                    toBeRemoved.push(ndName);
                    toBeAdded.push({name : "lyte-directive-" + ndName.slice(1,ndName.length), value : attrToPush.stringValue});
                    if(this.registeredProp[componentName].indexOf(attrToPush.stringValue) == -1){
                        this.registeredProp[componentName].push(attrToPush.stringValue);
                    }
                }
                attr[attrToPush.name] = attrToPush;
                attrToPush.hookNode  = true;
                let hookName = node.attributes[i].name.slice(1,node.attributes[i].name.length);
                attrToPush.hookName = hookName;
                return {
                    add : true,
                    specialAttr : true,
                    attrToPush : attrToPush
                }
            },
            isDirectiveNode : function(node){
                if(node.hookNode || (node.nodeName && node.nodeName.startsWith("@")) || node._isDirectiveNode){
                    return true;
                }
                return false;
            },
            getActualTransitionArg : function(attr,node){
                if(attr.hasOwnProperty("dynamicValue") || attr.hasOwnProperty("helperInfo")){
                    if(node.hasOwnProperty("_transitionArgs")){
                        if(node._transitionArgs.hasOwnProperty(attr.hookName)){
                            return node._transitionArgs[attr.hookName];
                        }
                    }
                }else if(attr.hasOwnProperty("stringValue")){
                    if(attr.hasOwnProperty("stringValue")){
                        if(attr.stringValue === ""){
                            return true
                        }if(attr.stringValue === "true"){
                            return true
                        }else if(attr.stringValue === "false"){
                            return false
                        }else{
                            return attr.stringValue;
                        }
                    }
                }
            },
            getExactTransitionArg : function(attr,node){
                if(attr.hasOwnProperty("dynamicValue") || attr.hasOwnProperty("helperInfo")){
                    if(node.hasOwnProperty("_transitionArgs")){
                        if(node._transitionArgs.hasOwnProperty(attr.hookName)){
                            return node._transitionArgs[attr.hookName];
                        }
                    }
                }else if(attr.hasOwnProperty("stringValue")){
                    if(attr.hasOwnProperty("stringValue")){
                        if(attr.stringValue === ""){
                            if(node.id){
                                attr.stringValue = node.id;
                            }
                        }
                        return attr.stringValue;
                    }
                }
            },
            getTransitionArg : function(node,directiveName,returnAttr){
                let transitionArg;
                if(node.component && node.component.constructor._options){
                    this.setAttrFromRender(node);
                }
                var self = this;
                if(node._specialAttributeDetails){
                    node._specialAttributeDetails.forEach(function(attr){
                        if(directiveName == attr.hookName){
                            transitionArg = returnAttr ? attr : self.getActualTransitionArg(attr,node);
                            return;
                        }
                    })
                }
                return transitionArg;
            },
            setNodeArgs : function(node,nodeValue,comp){
                // node.ownerElement._transitionArgs = nodeValue;
                let nodeName = node.nodeName;
                node.ownerElement.removeAttribute(nodeName);
                // node.nodeName = node.nodeName.slice(1,node.nodeName.length);
                if(!node.ownerElement._transitionArgs){
                    node.ownerElement._transitionArgs = {};
                }
                let actNodeName = nodeName
                if(nodeName.startsWith("@")){
                    actNodeName = nodeName.slice(1,nodeName.length);
                }
                node.ownerElement._transitionArgs[actNodeName] = nodeValue;
                node.ownerElement.setAttribute("lyte-directive-" + actNodeName,actNodeName == "prop" || actNodeName == "data" ? nodeValue : "");
            },
            infoA : function(comp,info,dynamicN,helperNode,attr,yieldComp,options){
                this.setSpecialNodes(comp,helperNode,dynamicN,info,options);
                if(dynamicN._specialAttributeDetails && dynamicN._specialAttributeDetails.length){
                    dynamicN._specialAttributeDetails.push(attr);
                }else{
                    dynamicN._specialAttributeDetails = [attr];
                }
                // if(yieldComp){
                //     yieldComp._transitionAppend.push(dynamicN);
                // }
                // else if(comp._transitionAppend.indexOf(dynamicN)==-1 && dynamicN && dynamicN.getAttribute("is") != "component"){
                //     comp._transitionAppend.push(dynamicN);
                // }
            },
            setSpecialNodes : function(comp,helperNode,dynamicN,info,options){
                if(helperNode && (helperNode._hooksPresent || helperNode._defaultSetSpecialNode || dynamicN.hasAttribute("lyte-directive-prop") || dynamicN.hasAttribute("lyte-directive-data"))){
                    if(helperNode._specialNodes){
                        if(helperNode.getAttribute("is") == "for"){
                            helperNode._specialNodes[options.itemIndex].push(dynamicN);
                        }else if(helperNode.getAttribute("is") == "forIn"){
                            helperNode._specialNodes[options.itemIndex].push(dynamicN);
                        }
                        else if(helperNode && /if|switch/g.test(helperNode.getAttribute("is"))){
                            helperNode._specialNodes.push(dynamicN);
                        }
                        else if(helperNode && helperNode.tagName == "LYTE-YIELD"){
                            helperNode._specialNodes.push(dynamicN);
                        }
                    }
                }else if(dynamicN && dynamicN._hooksPresent && comp._specialNodes){
                    comp._specialNodes.push(dynamicN);
                    comp._hooksPresent = true;
                    comp.hc = true;
                }else if(dynamicN && dynamicN._defaultSetSpecialNode && comp._specialNodes){
                    comp._specialNodes.push(dynamicN);
                    comp._defaultSetSpecialNode = true;
                }
                // if(info.chld){
                //     dynamicN._chld = info.chld;
                // }
                // if(info.dc){
                //     dynamicN.dc = info.dc;
                //     dynamicN.hc = info.hc;
                // }
                // if(info.sibl){
                //     dynamicN._sibl = info.sibl;
                // }
            }
        },
        "iterator" : function(isType, data, def){
            if(isType == "for"){
                data.forEach(function(item , index){
                    def.apply(this,[item,index]);
                })
            }else if(isType == "forIn"){
                for(let index in data){
                    let item = data[index];
                    def.apply(this,[item,index]);
                }
            }
        },
        "array" : {
            initalize : function(data, key){
                if(!data[key]){
                    data[key] = [];
                }
            },
            checkAndPush : function(arr, val){
                if(arr.indexOf(val) == -1){
                    arr.push(val);
                }
            }
        },
        "object" : {
            initalize : function(data, key){
                if(!data[key]){
                    data[key] = {};
                }
            }
        },
        "styleSheet" : {
            "preload" : function(href){
                var link = document.createElement('link');
                link.rel = 'preload';
                link.href = href;
                link.as = "style";
                let _res,_rej;
                var promise = new Promise(function(res,rej){
                    _res = res;
                    _rej = rej;
                });
                link.onload = function(){
                    _res();
                }
                link.onerror = function(){
                    _rej();
                }
                _Lyte.$.assetsDiv.appendChild(link);
                return promise;
            }
        }
}
let _LCSV = LyteComponent.directive.save;
let _LCHD = LyteComponent.directive.hide;
_Lyte.Component.appendChild = function() {return LyteComponent.shadow.appendChild.apply(LyteComponent.shadow, Array.from(arguments))};
LyteComponent.appendChild = _Lyte.Component.appendChild;
LyteComponent.globalEventHandler = globalEventHandler;
LyteComponent.docCaptureGlobalEventHandler = docCaptureGlobalEventHandler;
LyteComponent.docBubbleGlobalEventHandler = docBubbleGlobalEventHandler;
LyteComponent.globalDOMEvents = globalDOMEvents;
LyteComponent.changeEventHandler = changeEventHandler;
if(window.isLyteWidget){
    window.Component = LyteComponent.baseCompClass;
    window.Component.registerHelper = function() {
        return _LC.registerHelper.apply(_LC, arguments);
    }
}
_Lyte.typeCast = LyteComponent.typeCast;
_Lyte.getDataType = LyteComponent.getDataType;
_Lyte.Component._get = LyteComponent.get;
_LyteComponent.chromeBugFix = function() {
    var version = userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);;
    version = version ? parseInt(version[2], 10) : 0;
    if(version > 62) {
        this.chI = [];
        document.addEventListener("focus", function(event) {
            var target = event.target;
            if(target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "DIV") {
                if(Lyte.Component.chI.indexOf(target) == -1) {
                    Lyte.Component.chI.push(target);
                }
            }
        } , true);
        this.chromeBugFix = function() {
            var tags = Lyte.Component.chI;
            var tagsL = tags.length;
            var toRemove = ["_callee", "_attributeDetails", "_attributes", "_removedAttributes", "_yields" , "_rA", "_cx"];//no i18n
            var toBeRemoved = [];
            var keepAliveInputs = [];
            document.querySelectorAll("[lyte-keep-alive]").forEach(function(item,index){
                for(var key in item._renderedComponent) {
                    keepAliveInputs.push.apply(keepAliveInputs, Array.from(item._renderedComponent[key].querySelectorAll("input")));
                }
            });
            _LC.tDiv.content.querySelectorAll("[lyte-keep-alive]").forEach(function(item,index){
                for(var key in item._renderedComponent) {
                    keepAliveInputs.push.apply(keepAliveInputs, Array.from(item._renderedComponent[key].querySelectorAll("input")));
                }
            });
            for(var i= tagsL-1, item;item=tags[i];i--) {
                if((document.compareDocumentPosition(item) % 2) && (keepAliveInputs.indexOf(item) == -1)) {
                    tags.splice(i,1);
                    item.remove();
                    toBeRemoved.push(item);
                    item._rA = item._rA || [];
                    item._rA.forEach(function(remAttr) { //eslint-disable-line no-loop-func
                        remAttr.ownerElement = undefined;
                    });
                    toRemove.forEach(function(key) {//eslint-disable-line no-loop-func
                        item[key] = undefined;
                    });
                    Array.from(item.attributes).forEach(function(itemVal) {//eslint-disable-line no-loop-func
                        item.removeAttribute(itemVal.nodeName);
                    });
                }
            }
        }
        Lyte.addEventListener("afterRouteTransition", function() {
            Lyte.Component.chromeBugFix();
        });
        Lyte.addEventListener("beforeRouteTransition", function() { 
            Lyte.Component.viewPortSettings.resetLazy();
        });
        if(!Lyte.Router) {
            setInterval(function() {
                // Lyte.Component.chromeBugFix();
                LyteComponent.String.cache_c = {};
                LyteComponent.String.cache_d = {};
            },300000)
        }
    }
}
LyteComponent.__data = [];
LyteComponent.__dataNames = [];
_LyteComponent.defineData = function(def){
    _LC.__data.push(def);
    let dataNames = Object.keys(def);
    dataNames.forEach(function(name){
        _LC.__dataNames.push(name);
    });
}
_Lyte.__lc = LyteComponent;
let _LC = LyteComponent;
_LCHD.define.remove(LyteYield);
ltCf.instanciateBridge();
var someFlag = false;

customElements.define("lyte-safari-test-component", Test, undefined, _Lyte.isWidgetBuild ? { "widget" : true} : {v3 : true});
var divTest = document.createElement("div");
divTest.innerHTML = "<lyte-safari-test-component t></lyte-safari-test-component>";

_LyteComponent.render = _LC.render;
//Change it in v3.0 - Remove from LyteComponent scope. 
_LyteComponent.insertBefore = _LC.insertBefore;
_LyteComponent.insertAfter = _LC.insertAfter;
_LyteComponent.replaceWith = _LC.replaceWith;
_LyteComponent.appendChild = _LC.appendChild;
_LC.tDiv=createElement("template");
// _LC.tDiv = createElement("div");
_LC.tDiv.setAttribute("id", "dummy-templates-div");
// _LC.tDiv.setAttribute("style", "display:none");
_LC.hDiv=createElement("template");

// _LC.hDiv = createElement("div");
_LC.hDiv.setAttribute("id", "keep-alive-div");
// _LC.hDiv.setAttribute("style", "display:none");
_LC.h1Div=createElement("template");

// _LC.h1Div = createElement("div");
_LC.h1Div.setAttribute("id", "lyte-helper-div");
// _LC.h1Div.setAttribute("style", "display:none");
Lyte.Compile.componentsDiv = _LC.lyteComponentsDiv = createElement("div");
_LC.lyteComponentsDiv.setAttribute("id", "lyte-components-div");

_LC.hiddenComponentsDiv=createElement("template");
_LC.hiddenComponentsDiv.setAttribute("id","hidden-component-div");

_LC.hiddenYieldsDiv=createElement("template");
_LC.hiddenYieldsDiv.setAttribute("id","hidden-yields-div");

Set.prototype.toArrayLyte = function() {
    if(this.constructor.name === "Set"){
        return Array.from(this);
    }
    else{
        return Array.from(this._values);
    }
}
//_LC.registerListener(function() {
//  
//});

if(document.readyState === "complete" || document.readyState === "interactive") {
    onDomContentForLyte();
} else {
    document.addEventListener("DOMContentLoaded", function(e){
        onDomContentForLyte();
    },true);
}
function createSvgDepth(actualTemplate,type){
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    for(var s=0; s<actualTemplate.childNodes.length; s++){
        svg.appendChild(actualTemplate.childNodes[s].cloneNode(true));
    }
    var depthTemp = document.createElement("template");
    depthTemp.setAttribute("is", type);
    for(var s=0; s<svg.childNodes.length; s++){
        depthTemp.content.appendChild(svg.childNodes[s]);
        s--;
    }
    return depthTemp;
}
function createDepth(actualTemplate,type){
    var depthTemp = document.createElement("template");
    depthTemp.setAttribute("is", type);
    depthTemp.innerHTML = actualTemplate.innerHTML;
    return depthTemp;
}
function appendDepth(depthTemp,constr){
    constr.splitTextNodes(depthTemp);
    constr.component._depthTemp.content.appendChild(depthTemp);
}
function setHT(dynN,info,dynNewCompile,constr){
    var flag  = true;
    if(dynN.tagName == "TEMPLATE") {
        info._ht = dynN.innerHTML;
        flag = false;
    }
    if(info._ht) {
        if(flag){
            dynN.innerHTML = info._ht;
            constr.splitTextNodes(dynN);
        }
        if(dynNewCompile && dynNewCompile.innerHTML !== info._ht) {
            dynNewCompile.innerHTML = info._ht;
            constr.splitTextNodes(dynNewCompile);
        }
    }
}

function doCompileHandling(dynamicN, dynamicNodes, componentName, constr, newCompile, j) {
    let lastUsedAttrPosition ;
        let info = dynamicNodes[j], type = info.type, pos = info.position, helperInfo;
        let dynN = getDynamicNode(dynamicN,pos);
        let dynNewCompile;
        if(newCompile) {
            dynNewCompile = getDynamicNode(newCompile,pos);
        }
        switch(type) {
        case "text" : {
            let mustache = Lyte.Compile.getMustache(dynN.nodeValue),dynamicValue,helperFunc;
            if(mustache){
                    helperFunc = Lyte.Compile.getHelper(mustache);
            }   
            let dynamic = mustache;
            if(helperFunc){
                info.helperInfo = helperFunc;
                if(dynNewCompile) {
                    info.newHelperInfo = Lyte.Compile.getHelper(mustache,true);
                    _LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
                }                 
            }
            else if(dynamic){
                //deepNodes.push({type: "text", position:deepN.slice(), dynamicValue: dynamic});
                info.dynamicValue = dynamic;
                info.newDynamicValue = _LC.getDV(dynamic);
                if(dynNewCompile) {
                    _LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
                }
//              LN to do
//              deepNodes.push({type: "text", position:deepN.slice(), dynamicValue: getDV(dynamic)});                    
            }
        }
        break;
        case "insertYield" : {
            if(dynNewCompile) {
                dynNewCompile.appendChild(document.createTextNode("__**--Lyte"+j+"__**"));
                let yieldAttr = dynNewCompile.attributes["yield-name"];
                info.yieldName = yieldAttr ? yieldAttr.nodeValue : undefined;
            }
        }
        break;
        case "componentDynamic" : {
            if(_Lyte.isWidgetBuild) {
                dynN.setAttribute("lyte-widget", "");
            }
            if(dynNewCompile) {
                if(_Lyte.isWidgetBuild) {
                    dynNewCompile.setAttribute("lyte-widget", "");
                }
                dynNewCompile.appendChild(document.createTextNode("__**--Lyte"+j+"__**"));
                info.componentName = dynNewCompile.localName;
                var attrs = Array.from(dynNewCompile.attributes);
                info.staticAttrs = {};
                for(var i=0;i<attrs.length;i++) {
                    info.staticAttrs[_LC.String.toCamelCase(attrs[i].nodeName)] = attrs[i].nodeValue;
                }
                delete info.staticAttrs._lyteprop;
            }
        }
        break;
        case "attr" : {
            let add = false, toBeRemoved = [],toBeAdded = [];
            let node = dynN;
            let attr = info.attr = info.attr || {};
            for(let i=0;i<node.attributes.length;i++) {
                if(node.attributes[i].nodeValue.indexOf("{{") !== -1) {
                    let val = node.attributes[i].nodeValue;
                    let actValue = Lyte.Compile.getMustache(val), actObj ;
                    if(actValue){
                        actObj = Lyte.Compile.getHelper(actValue);  
                    }
                    else if(/{{.*}}/.test(val) && !(/\\{{.*}}/.test(val))){
                        actObj = Lyte.Compile.splitMixedText(val);
                    }
                    if( actObj && (actObj.name === "action" || actObj.name === "method") && /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|__focus|__focusin|__focusout|__resize|__scroll|__click|__dblclick|__mousedown|__mouseup|__mousemove|__mouseover|__mouseout|__change|__select|__submit|__keydown|__keypress|__keyup|__contextmenu)$/.test(node.attributes[i].name)){
                            attr[node.attributes[i].name.substr(2)] = {name:node.attributes[i].name.substr(2),camelCase : _LC.String.toCamelCase(node.attributes[i].name.substr(2)), helperInfo: actObj, newHelperInfo : Lyte.Compile.getHelper(actValue, true), globalEvent: true};

                            let actArgs = _Lyte.deepCopyObject(actObj.args);
                            let actName = actArgs.splice(0,1)[0];
                            actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                            let actString = getArgString(actName, actArgs);
                            node.setAttribute(node.attributes[i].name.substr(2),componentName+" => "+ actString);
                            if(dynNewCompile) {
                                dynNewCompile.setAttribute(node.attributes[i].name.substr(2),componentName+" => "+ actString);
                            }
                            toBeRemoved.push(node.attributes[i].name);                            
                    }
                    else{
                        if(actObj || actValue) {
                            let attrToPush = {};
                            
                            if(node.attributes[i].name.startsWith("lbind:")) {
                                toBeRemoved.push(node.attributes[i].name);
                                toBeAdded.push({"name" : node.attributes[i].name.substring(6), "value": node.attributes[i].nodeValue});
                                attrToPush.isLbind = true;
                                attrToPush.name = node.attributes[i].name.substring(6);
                                attrToPush.camelCase = _LC.String.toCamelCase(attrToPush.name);
                            }
                            else {
                                attrToPush.name = node.attributes[i].name;
                                attrToPush.camelCase = _LC.String.toCamelCase(attrToPush.name);
                            }
                            if(actObj) {
                                if(actObj.name === "lbind") {
                                    attrToPush.dynamicValue = actObj.args[0];
                                    attrToPush.newDynamicValue = _LC.getDV(actObj.args[0]);
                                    attrToPush.isLbind = true;
                                }
                                else {
                                    attrToPush.helperInfo = actObj;
                                    attrToPush.newHelperInfo = Lyte.Compile.getHelper(actValue, true);
                                }
                            } 
                            else {
                                attrToPush.dynamicValue = actValue;
//                              LN to do
                                attrToPush.newDynamicValue = _LC.getDV(actValue);
                            }
                            add = true;
                            attr[attrToPush.name] = attrToPush;
                        }                  
                    }
                }
                if(node.attributes[i].name.startsWith("@")){
                    let rt = _LC.directive.compileNode(node, attr, toBeRemoved, toBeAdded, i, componentName)
                    add = rt.add;
                    attrToPush = rt.attrToPush;
                }
            }
            if(toBeRemoved.length){
                for(let i=0; i<toBeRemoved.length;i++){
                    node.removeAttribute(toBeRemoved[i]);
                    if(dynNewCompile) {
                        dynNewCompile.removeAttribute(toBeRemoved[i]);
                    }
                }
            }
            if(dynNewCompile) {
                for(let key in attr) {
                    dynNewCompile.removeAttribute(key);
                }
                dynNewCompile.setAttribute("_lyteAttr" , "__**--Lyte" + j + "__**", "");
            }
            if(toBeAdded.length) {
                for(let i=0;i<toBeAdded.length;i++) {
                    node.setAttribute(toBeAdded[i].name, toBeAdded[i].value);
                }
            }
        } 
        break;
        case "for" : 
        case "forIn" : 
        case "registerYield" : 
            setHT(dynN,info,dynNewCompile,constr);
        case "component" : {
            var actualTemplate = _Lyte._ie ? dynN : dynN.content;
            if(!dynNewCompile && (type == "registerYield" || dynN.hasAttribute("unbound"))) {
                if(_Lyte._ms) {
                    dynNewCompile = document.createElement("div");
                    dynNewCompile.innerHTML = info.actualTemplate ? info.actualTemplate : dynN.outerHTML;
                    dynNewCompile = dynNewCompile.childNodes[0];
                    constr.splitTextNodes(dynNewCompile);
                } else {
                    dynNewCompile = dynN.cloneNode(true);
                }
            }
            let depthTemp;
            let dnNode;
            var actualTemplateNewCompile = dynNewCompile ? (_Lyte._ie ? dynNewCompile : dynNewCompile.content) : undefined;
            let args = {};
                if(info.actualTemplate) {
                    actualTemplate = _LC.getContentForIE(info.actualTemplate, constr, undefined, _Lyte._ms? info : undefined);
                if(dynNewCompile) {
                    actualTemplateNewCompile = _LC.getContentForIE(info.actualTemplate, constr);
                }
                }
                if((window.isLyteWidget || window.__lyteEnablePromise) && dynN.hasAttribute("has-child")){
                    var dynNContent = dynN.content || dynN;
                    for(let key in info.cases) {
                        let contentNewCompile;
                        var content = _LC.getContentForIE(actualTemplate.querySelector("[case='"+_LC.cssEscape(key)+ "']"), undefined, true);
                        setHT(content,info.cases[key],contentNewCompile,constr);
                        var gen = doCompile(content.tagName === "TEMPLATE" ? content.content : content, info.cases[key].dynamicNodes,componentName, constr, contentNewCompile);
                        var gnxt = gen.next(), gval;
                        while(gnxt.done == false){
                            gval = gnxt.value;
                            if(typeof gval == "function"){
                                gval();
                            }
                            gnxt = gen.next()
                        }
                        if(info.cases[key]._ht) {
                            info.cases[key]._ht = content.cloneNode(true);
                            constr._helperTemplate.content.append(info.cases[key]._ht)
                            content.innerHTML = "";
                        }
                    }
                }else{
                    var gen = doCompile(actualTemplate, info.dynamicNodes, componentName, constr, actualTemplateNewCompile, info);
                    var gnxt = gen.next(), gval;
                    while(gnxt.done == false){
                        gval = gnxt.value;
                        if(typeof gval == "function"){
                            gval();
                        }
                        gnxt = gen.next()
                    }
                }
                    if(actualTemplateNewCompile) {
                    let staticTemp = info.actualTemplate ? actualTemplateNewCompile : dynNewCompile;
                    info._sta = _LC.processStatic(staticTemp);                      
                    }
                if(_Lyte._ms) {
                    if(info.actualTemplate) {
                        info.templateContent = actualTemplate.outerHTML;
                        if(info._content) {
                            info.actualTemplate = info._content.innerHTML;
                            delete info._content;
                        }
                    } else {
                        info.templateContent = dynN.outerHTML;
                    }
                    dynN.innerHTML = "";  
                }
                if(info.actualTemplate) {
                    depthTemp = type;
                    if(!_Lyte._ie ) {
                        if(info.svg){
                            depthTemp = createSvgDepth(actualTemplate,type)
                        }else{
                            depthTemp = createDepth(actualTemplate,type)
                        }
                        appendDepth(depthTemp,constr);
                    }
                    if(dynamicNodes[j-1] && (dynamicNodes[j-1].position.toString() === dynamicNodes[j].position.toString())) {
                        dnNode = dynamicNodes[j-1];
                    } else {
                        dnNode = dynamicNodes[j];
                    }
                    dnNode._depthTemp = depthTemp;
                }
            
                if(dynNewCompile) {
                    info._args = {};
                    if(type === "registerYield") {
                        //dynNewCompile.parentNode.parentNode.insertBefore(document.createTextNode("__**--Lyte"+j+"__**"), dynNewCompile.parentNode);
                        //dynNewCompile.parentNode.setAttribute("_lyteyield", "");
                        //_LC.replaceWithPf(dynNewCompile, document.createTextNode(""));
                        _LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
                    } else if(type === "component") {
                        _LC.replaceWithPf(dynNewCompile, document.createTextNode((dynNewCompile.hasAttribute("_lyteattr") ? dynNewCompile.getAttribute("_lyteattr"): "" )+ "__**--Lyte"+j+"__**"));
                    } else {
                        //dynNewCompile.replaceWith(document.createTextNode("__**--Lyte"+j+"__**"))
                        _LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
                    }
                    /* disable async function */
                    Array.from(dynNewCompile.attributes).forEach(function(item) { //eslint-disable-line no-loop-func
                        info._args[item.nodeName] = item.nodeValue;
                    });
                }
                if(info._ht) {
                    info._ht = dynN.cloneNode(true);
                    constr._helperTemplate.content.append(info._ht)
                    dynN.innerHTML = "";
                }
                //  When a registerYield is present inside another registerYield, in fastRender, we will not be able to get the template using the positions and parentComponent alone, since the insertYield is present inside the insertYield of the parent component. 
                // info.actYield = dynN;
            }
        break;
        case "if" : 
        case "switch" : {
            setHT(dynN,info,dynNewCompile,constr);
            var oldDyn = dynN;
            let depthTemp;
            var actualTemplateNewCompile = dynNewCompile ? (_Lyte._ie ? dynNewCompile : dynNewCompile.content) : undefined;
            if(info.actualTemplate) {
                dynN = _LC.getContentForIE(info.actualTemplate, constr, undefined);
                if(dynNewCompile) {
                    let dummy = _LC.getContentForIE(info.actualTemplate, constr);
                    actualTemplateNewCompile = _Lyte._ie ? dummy : dummy.content;
                }
            }
            var def = "default";
            if(_Lyte._ms) {
                var cases = {};
                var defCase;
                var dynNchildNodes = _Lyte._ed ? dynN.content.childNodes : dynN.childNodes;
                for(var i=0;i<dynNchildNodes.length;i++) {
                if(dynNchildNodes[i].tagName === "TEMPLATE"){
                    if(dynNchildNodes[i].getAttribute("case")) {
                        cases[dynNchildNodes[i].getAttribute("case")] = dynNchildNodes[i];
                    } else if(dynNchildNodes[i].hasAttribute("default")) {
                        defCase = dynNchildNodes[i];
                    }
                }
                }
                for (let key in info.cases) {
                    let contentNewCompile;
                    content = _LC.getContentForIE(cases[key], undefined, true);
                    if(actualTemplateNewCompile) {
                        contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector("[case='"+LyteComponent.cssEscape(key)+ "']"));
                    }
                    setHT(content,info.cases[key],contentNewCompile,constr);
                    var gen = doCompile(content, info.cases[key].dynamicNodes, componentName, constr, contentNewCompile ? _LC.getContentForIE(contentNewCompile) : undefined);
                    var gnxt = gen.next(), gval;
                    while(gnxt.done == false){
                        gval = gnxt.value;
                        if(typeof gval == "function"){
                            gval();
                        }
                        gnxt = gen.next()
                    }
                    cases[key].remove();
                    if(actualTemplateNewCompile) {
                        info.cases[key]._sta = _LC.processStatic(contentNewCompile);
                    }
                    info.cases[key].templateContent = cases[key].outerHTML;
                }
                if (info[def].dynamicNodes) {
                    let contentNewCompile;
                    content = _LC.getContentForIE(defCase, undefined, true);
                    if(actualTemplateNewCompile) {
                        contentNewCompile = actualTemplateNewCompile.querySelector("[default]");
                    }
                    setHT(content,info[def],contentNewCompile,constr);
                    var gen = doCompile(content, info[def].dynamicNodes, componentName, constr, contentNewCompile? _LC.getContentForIE(contentNewCompile) : undefined);
                    var gnxt = gen.next(), gval;
                    while(gnxt.done == false){
                        gval = gnxt.value;
                        if(typeof gval == "function"){
                            gval();
                        }
                        gnxt = gen.next()
                    }
                    defCase.remove();
                    info[def].templateContent = defCase.outerHTML;
                    if(actualTemplateNewCompile) {
                        info[def]._sta = _LC.processStatic(contentNewCompile);
                    }
                }
            } else {
                var dynNContent = dynN.content || dynN;
                for(let key in info.cases) {
                    let contentNewCompile;
                    if(actualTemplateNewCompile) {
                        contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector("[case='"+LyteComponent.cssEscape(key)+ "']"));
                    }
                    var content = _LC.getContentForIE(dynNContent.querySelector("[case='"+_LC.cssEscape(key)+ "']"), undefined, true);
                    setHT(content,info.cases[key],contentNewCompile,constr);
                    var gen = doCompile(content.tagName === "TEMPLATE" ? content.content : content, info.cases[key].dynamicNodes,componentName, constr, contentNewCompile);
                    var gnxt = gen.next(), gval;
                    while(gnxt.done == false){
                        gval = gnxt.value;
                        if(typeof gval == "function"){
                            gval();
                        }
                        gnxt = gen.next()
                    }
                    if(actualTemplateNewCompile) {
                    info.cases[key]._sta = _LC.processStatic(contentNewCompile);
                    }
                    if(info.cases[key]._ht) {
                        info.cases[key]._ht = content.cloneNode(true);
                        constr._helperTemplate.content.append(info.cases[key]._ht)
                        content.innerHTML = "";
                    }
                }
                if(info[def].dynamicNodes) {
                    let contentNewCompile
                    if(actualTemplateNewCompile) {
                        contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector("[default]"));
                    }
                    var content = _LC.getContentForIE(dynNContent.querySelector("[default]"), undefined, true);
                    setHT(content,info[def],contentNewCompile,constr);
                    var gen = doCompile(content.tagName === "TEMPLATE" ? content.content : content, info[def].dynamicNodes,componentName, constr, contentNewCompile);
                    var gnxt = gen.next(), gval;
                    while(gnxt.done == false){
                        gval = gnxt.value;
                        if(typeof gval == "function"){
                            gval();
                        }
                        gnxt = gen.next()
                    }
                    if(actualTemplateNewCompile) {
                    info[def]._sta = _LC.processStatic(contentNewCompile);
                    }
                    if(info[def]._ht) {
                        info[def]._ht = content.cloneNode(true);
                        constr._helperTemplate.content.append(info[def]._ht)
                        content.innerHTML = "";
                    }
                }
                
            }

            if(info.actualTemplate) {
                depthTemp = type;
                if(!_Lyte._ie ) {
                    if(info.svg){
                        depthTemp = createSvgDepth(dynN.content,type)
                    }else{
                        depthTemp = createDepth(dynN,type)
                    }
                    appendDepth(depthTemp,constr);
                }
                if(dynamicNodes[j-1] && (dynamicNodes[j-1].position.toString() === dynamicNodes[j].position.toString())) {
                    dynamicNodes[j-1]._depthTemp = depthTemp;
                } else {
                    dynamicNodes[j]._depthTemp = depthTemp;
                }
            }

            if(dynNewCompile) {
                _LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
            }
            if(info._ht) {
                info._ht = dynN.cloneNode(true);
                constr._helperTemplate.content.append(info._ht)
                dynN.innerHTML = "";
            }
        }
        break;    
        }
}

function* doCompile(dynamicN, dynamicNodes, componentName, constr, newCompile) {
    let lastUsedAttrPosition ;
    if(dynamicNodes && dynamicNodes.length){
        for(let j=0;j<dynamicNodes.length;j++) {
            // yield doCompileHandling(dynamicN, dynamicNodes, componentName, constr, newCompile, j); 
            yield () => {
                doCompileHandling(dynamicN, dynamicNodes, componentName, constr, newCompile, j)
            };
        }
    }
    else{
        yield "";
    }
}

_LC.doCompile = doCompile;
//This is the function where the actual rendering takes place. 
    //It takes the template, finds the actual dynamic nodes uwing dynamicNodes argument and then binds each node with the associated
    //property by calling bindNode. 

function getDynamicNode(content, positions){
    let dynamicN = content;
    for(var i=0; i<positions.length; i++){
        dynamicN = (dynamicN.tagName != "TEMPLATE" || _Lyte._ie) ? dynamicN.childNodes[positions[i]] : dynamicN.content.childNodes[positions[i]];
    }
    return dynamicN;
}

function getArgString(name, array) {
    let retString;
    for(let i=0;i<array.length;i++) {
        if(array[i] && typeof array[i] === "object") {
            array[i] = getArgString(array[i].value.name, array[i].value.args);
        }
    }
    if(name) {
        retString = name +  "(" + array.toString() + ")";
    } else {
        retString = array.toString();
    }
    return retString;
}

_LC[registerHelperStr]("unbound",function(value){
     return value;
});

_LC[registerHelperStr]("action",function(parentNode,attrName,isCustom,actObj){
    if(isCustom){
        parentNode._actions = parentNode._actions? parentNode._actions : {};
        if(!parentNode._actions[attrName]){
            this.createCustomEvent(attrName, parentNode, actObj); 
            parentNode.removeAttribute(attrName);
        }
    }
    else{
        
        this.createEventListeners(parentNode,attrName,actObj);    
    }
});

_LC[registerHelperStr]("lbind",function(name){
	return this.getData(name);
});

_LC[registerHelperStr]("method", function(parentComponent, attributeNode, functionName) {
    var parentComponent = arguments[0];
    var attributeNode = arguments[1];
    var functionName = arguments[2];
    var self = arguments[0].component;
    var childComponent = attributeNode? attributeNode.ownerElement : null;
    var attributeName = arguments[1].nodeName;
    attributeNode = null;
    var args = Array.prototype.slice.call(arguments, 2);
    var newFunc = function() {
        let node = this.$node;
        let contextSwitchArray = [];
        _LC.adCx(node, contextSwitchArray);
        let processedArgs = this.$node._callee.processArgs(this.$node._callee,{"helperInfo" : {"args" : args}}, [], undefined, this.$node);
        let functionName1 = processedArgs.splice(0,1)[0];
        _LC.rmCx(node, contextSwitchArray);
        let customArgs = Array.from(arguments);
        let mainArgs = processedArgs.concat(customArgs);
        if(self.$node._methods[functionName1]) {
            return self.$node._methods[functionName1].apply(self, mainArgs);
        }
        _Lyte.error("LC009", functionName, self.$node.tagName);
    }
    if(childComponent) {
        if(!childComponent.set) {
            childComponent.setMethods(_LC.String.toCamelCase(attributeName), newFunc);
        } else {
            childComponent._methods[_LC.String.toCamelCase(attributeName)] = newFunc;
        }
    } else {
        return newFunc;
    }
});

_LC[registerHelperStr]("stringifyHTML",function(){// unescapeAttr renderString printHTML showString showHTML returnHTML stringifyHTML
    return Lyte.Component.registeredHelpers.unescape.apply(this,arguments).innerHTML;
});

_LC[registerHelperStr]("unescapeAttr",function(){
    // debugger
    return Lyte.Component.registeredHelpers.unescape.apply(this,arguments).innerHTML;
});
_LC[registerHelperStr]("unescape",function(value,additionalObject,userInstance,options){
    if(_LC.ffr) {
        return value;
    }
    if(window.isLyteWidget) {
        Lyte.Security.ignoreSanitizer = true; 
    }
    if(Lyte.Security.ignoreSanitizer && !(options && options.force)){
        let divEle = document.createElement("div");
        divEle.innerHTML = value;
        return divEle;
    }
    else{
        if(additionalObject && Object.keys(additionalObject) && Object.keys(additionalObject).length >0){
            if(Object(additionalObject.GLOBAL_TAGS).length>0){
                var index = additionalObject.GLOBAL_TAGS.indexOf("link-to");
                if(index != -1){
                    additionalObject.GLOBAL_TAGS.splice(index,1);
                }
            }
            if(additionalObject && additionalObject.GLOBAL_ATTRIBUTES && Object.keys(additionalObject.GLOBAL_ATTRIBUTES).length>0){
                var arr = ["is","yield-name","lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target","lt-prop-td","lt-prop-custom","lt-prop-target","lt-prop-id","lt-prop-class","lt-prop-style","lt-prop-rel","lt-prop-title"];
                for(var i=0;i<arr.length;i++){
                    var index =additionalObject.GLOBAL_ATTRIBUTES.indexOf(arr[i]);
                    if(index != -1){
                        additionalObject.GLOBAL_ATTRIBUTES.splice(index,1);
                    }
                }
            }
        }
        if(additionalObject && additionalObject.GLOBAL_TAGS){//this if check is inorder to getobserved attributes given in globaltags
            if(additionalObject.GLOBAL_ATTRIBUTES == undefined){
                additionalObject.GLOBAL_ATTRIBUTES = [];
            }
            var globalTagArr = Array.from(additionalObject.GLOBAL_TAGS);
            var attr = [];
            for(var a=0; a<globalTagArr.length; a++){
                if(LyteComponent._registeredComponents[globalTagArr[a]]){
                    attr = LyteComponent._registeredComponents[globalTagArr[a]].observedAttributes;
                }else if(Lyte.registeredCustomComponent[globalTagArr[a]]){
                    if(Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes){
                        attr = Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes;
                    }else{
                        attr = [];
                    }
                }
                for(var i=0; i<attr.length; i++){
                    if(additionalObject.GLOBAL_ATTRIBUTES.indexOf(attr[i]) == -1){
                        additionalObject.GLOBAL_ATTRIBUTES.push(attr[i]);
                    }
                }
            }
        }
        var divEle = document.createElement("div");
        if(userInstance && Object.keys(userInstance).length){
            if(additionalObject && Object.keys(additionalObject).length){
                Lyte.Security.addGlobalObject(userInstance,additionalObject);
                var clean = userInstance.sanitize(value);
                Lyte.Security.removeGlobalObject(userInstance,additionalObject);
            }
            else{
                var clean = userInstance.sanitize(value);
            }
        }
        else{
            if(additionalObject && Object.keys(additionalObject).length){
                Lyte.Security.addGlobalObject(Lyte.Security._ourSanitizerInstance_,additionalObject);
                var clean = Lyte.Security._ourSanitizerInstance_.sanitize(value);
                Lyte.Security.removeGlobalObject(Lyte.Security._ourSanitizerInstance_,additionalObject);
            }else{
                var clean;
                if(window.isLyteWidget) {
                    clean = value;
                } else {
                    clean = Lyte.Security._ourSanitizerInstance_.sanitize(value);
                }
            }
        }
        divEle.innerHTML = clean;
        return divEle;
    }
});
if(!window.isLyteWidget) {
_LC[registerHelperStr]("escape",function(value,type){
    if(type == 'url'){
        return ZWAF['7_0_0'].Encoder.encodeForHTMLAttribute(value);	
    }
    else if(type == 'js'){
        return ZWAF['7_0_0'].Encoder.encodeForJavaScript(value);
    }
    else if(type == 'css'){
        return ZWAF['7_0_0'].Encoder.encodeForCSS(value);	
    }
    else{
        return value;
    }
});
}

_LC[registerHelperStr]("debugger", function() {
    debugger;
});

_LC[registerHelperStr]("log", function() {
    console.log.apply(window, Array.from(arguments));
});

_LC[registerHelperStr]("ifEquals", function(arg1, arg2) {
    if(arg1 === arg2) {
        return true;
    } else {
        return false;
    }
});

_LC[registerHelperStr]("if", function(value, trueValue, falseValue) {
    if(value) {
        return trueValue;
    } else {
        return falseValue;
    }
});

_LC[registerHelperStr]("negate", function(arg1) {
    return !arg1;
});


_LC[registerHelperStr]("ifNotEquals", function(arg1, arg2) {
    if(arg1 === arg2) {
        return false;
    } else {
        return true;
    }
});

_LC[registerHelperStr]('concat',function(){
	var resp = '';
	var argLength = arguments.length;
	for(var i=0;i<argLength;i++){
		if(arguments[i] != undefined){
			resp += arguments[i];
		}
	}
	return resp;
});
_LC[registerHelperStr]('toString',function(obj){
    if(obj === null || obj === undefined){
        return "";
    }
    else if(typeof obj == "object"){
        return JSON.stringify(obj);
    }
    return obj;
});


defProp(HTMLElement.prototype, 'setData', {
    writable : true,
    configurable : true, 
    enumerable: false, 
    value : function(arg0, arg1) {
        this._initProperties = this._initProperties || {};
        if(typeof arg0 === "string") {
            if(window.isLyteWidget && this.tagName != "TEMPLATE") {
                DataBindingLayer.updateInitProperties(this, arg0, arg1);
            }
            this._initProperties[arg0] = arg1
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                if(window.isLyteWidget && this.tagName != "TEMPLATE") {
                    DataBindingLayer.updateInitProperties(this, key, arg0[key]);
                }
                this._initProperties[key] = arg0[key];
            }
        }
    }
});

defProp(HTMLElement.prototype, 'setMethods', {
    configurable : true, 
    writable : true,
    enumerable: false, 
    value : function(arg0, arg1) {
        this._initMethods = this._initMethods || {};
        if(typeof arg0 === "string") {
            this._initMethods[arg0] = arg1
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                this._initMethods[key] = arg0[key];
            }
        }
    }
});

if(!window.isLyteWidget) {
_LC[registerHelperStr]('encAttr', function(val) {
    return ZWAF['7_0_0'].Encoder.encodeForHTMLAttribute(encodeURIComponent(val));
})
}

_LC[registerHelperStr]('expHandlers',function(leftOperand,operator,rightOperand,nextOperand){
    var argLen = arguments.length;
    if(operator == '++' ){
    	if(rightOperand == "postfix"){
    	   return (leftOperand++);
    	} else if(rightOperand == "prefix"){
    		return (++leftOperand);
    	}
    } else if(operator == "--"){
    	if(rightOperand == "postfix"){
    	   return (leftOperand--);
    	} else if(rightOperand == "prefix") {
    		return (--leftOperand);
    	}
    } else if((operator == "==")){
    	return leftOperand == rightOperand;
    }
     else if((operator == "===")){
    	return leftOperand === rightOperand;
    }
    
    else if((operator == "!=")) {
        return leftOperand != rightOperand;
    }
    else if((operator =="!==")) {
        return leftOperand !== rightOperand;
    }
    else if( operator == "&&") {
    	return leftOperand && rightOperand;
    } else if(operator == "||") {
    	return leftOperand || rightOperand;
    } else if(operator == "+"){
        if(argLen > 2){
        	return leftOperand+rightOperand;
        }
        return leftOperand;
    } else if(operator == '-'){
         if(argLen > 2){
        	return leftOperand-rightOperand;
        }
        return (-leftOperand);
    } else if(operator == '*'){
    	return leftOperand * rightOperand;
    } else if(operator == "/"){
    	return leftOperand / rightOperand;
    } else if(operator == "%"){
    	return leftOperand % rightOperand;
    } else if(operator == "<"){
    	return leftOperand < rightOperand;
    } else if(operator == ">") {
    	return leftOperand > rightOperand;
    } else if(operator == "<=") {
    	return leftOperand <= rightOperand;
    } else if(operator == ">=") {
    	return leftOperand >= rightOperand;
    } else if(operator == '|') {
        return leftOperand | rightOperand;
    } else if(operator == '&') {
        return leftOperand & rightOperand;
    }
    else if(operator == "!" ){
        return (!leftOperand);
    } else if(operator == '=') {
        leftOperand = rightOperand;
        return leftOperand;
    } else if(operator == "+=") {
        return leftOperand += rightOperand;
    } else if(operator == '-=') {
        return leftOperand -= rightOperand;
    } else if(operator == "*=") {
        return leftOperand *= rightOperand;
    } else if(operator == '/=') {
        return leftOperand /= rightOperand;
    } else if(operator == '?:') {
        return (leftOperand ? rightOperand : nextOperand);
    }
 });


_LyteComponent.register("lyte-event-listener",{
            _template : "<template tag-name=\"lyte-event-listener\"></template>",
            _dynamicNodes : [],
            _observedAttributes : ['eventName'],
            init: function() {
                let self = this;
                let regId = _Lyte.addEventListener(this.get('eventName'), function() {
                    let args = Array.prototype.slice.call(arguments);
                    args.splice(0,0,'on-fire')
                    self.throwEvent.apply(self, args );
                });
                //this.set('regId', regId);
                this.regId = regId;
            },
            data: function(){
                return {
                    "eventName" : _Lyte.attr("string")
                }
            }, 
            didDestroy : function() {
                _Lyte.removeEventListener(this.regId);
            }
        });

_LyteComponent.registerCustomPropHandler("ltProp");

_LyteComponent.shouldIgnoreDisconnect = function() {
    return _LC.ignoreDisconnect || ltCf.ignoreDisconnect;
}
_LyteComponent._setIgnoreDisconnect = function(val) {
    _LC.ignoreDisconnect = ltCf.ignoreDisconnect = val;
}

_LyteComponent.addLyteEventListener = function(element, eventName, func, context) {
  element._lyteEvents = element._lyteEvents || {};
  element._lyteEvents[eventName] = element._lyteEvents[eventName] || []; 
  var ind = element._lyteEvents[eventName].push({"func" : func, "fromEventListener" : true, "context" : context});
  return eventName + "-" + ind; 
}

_LyteComponent.removeLyteEventListener = function(element, listenerId) {
    if(!listenerId) {
        _Lyte.error("No listenerId provided");
        return;
    }
    var split = listenerId.split('-');
    var eventName = split[0];
    var index = parseInt(split[1]);
    if(!element._lyteEvents || !element._lyteEvents[split[0]] || isNaN(index)) {
        _Lyte.error("Invalid listenerId / listener is not available");
        return;
    }
    element._lyteEvents[split[0]][split[1] - 1] = {};
}

_LyteComponent.throwEvent = _LC.throwEvent;

_LC.hasLyteEvents = function(element, eventName) {
    if(element._lyteEvents && element._lyteEvents[eventName]) {
        return true;
    } else {
        return false;
    }
}

_LC.handleLyteEvents = function(element, event) {
    var funcs = element._lyteEvents[event.type];
    var ret;
    var eventStopped;
    for(var i=0;i<funcs.length;i++) {
        if(funcs[i].func) {
            ret = funcs[i].func.call(funcs[i].context ? funcs[i].context : window, event);
            if(ret === false || event.cancelBubble) {
                eventStopped = true;
                break;
            } 
        }
    }
    if(eventStopped) {
        event.stopPropagation();
    }
    return eventStopped;
}

if(!window.LyteComponent){
    Object.defineProperty(window, "LyteComponent", {
        get : function() {
            _Lyte.warn("Usage of LyteComponent is deprecated. Use Lyte.Component instead");
            return LyteComponent;
        }
    })
}
_LyteComponent.chromeBugFix();
_LC.booleanAttrList = ["async","autocomplete","autofocus","autoplay","border","challenge","checked1","compact","contenteditable","controls","default","defer","disabled","formNoValidate","frameborder","hidden","indeterminate","ismap","loop","multiple","muted","nohref","noresize","noshade","novalidate","nowrap","open","readonly","required","reversed","scoped","scrolling","seamless","selected","sortable","spellcheck","translate"]
Lyte.$.requiredMixins.component = function (mix, compDetails){
    var mixinsToBeUsed=[];
    var actionsFromMixin = {}; 
    var methodsFromMixin = {};
    var newDefinition = {};
    mixinsToBeUsed.push(mix);
    compDetails.forEach(ele => {
        var componentName = ele;
        var customCrmComponent = LyteComponent._registeredComponents[componentName];
        if(mixinsToBeUsed.length){
            LyteComponent.dataFromMixin(mixinsToBeUsed,actionsFromMixin,methodsFromMixin,newDefinition);
        }
        customCrmComponent._actions = Object.assign(customCrmComponent._actions, actionsFromMixin);
        customCrmComponent.component._actions = Object.assign(customCrmComponent._actions, actionsFromMixin);        
        var methods = Object.assign(customCrmComponent._methods, methodsFromMixin);
        delete newDefinition.methods;
        LyteComponent.updateCustomCrmComponent(newDefinition,customCrmComponent);
        customCrmComponent._methods = methods;
        customCrmComponent.component._methods = methods;
        LyteComponent._registeredComponents[componentName] = customCrmComponent; 
    });
}

Lyte.$.injectServices.component = function(key, name, type, ins, compClass, data){
    if(compClass){
        var obj = {};
        obj[compClass.compName] = compClass;
    }
    var registeredComponents = compClass ? obj : _LC._registeredComponents;
    if(registeredComponents){
        var arr = Object.keys(registeredComponents);
        arr.forEach(function(comp){
            var component = registeredComponents[comp];
            // obj = {};
            // obj[key] = name;
            // component._serviceToBeUsed = Object.assign(obj, component._serviceToBeUsed);
            if(ins && Lyte.__gS[key]){
                component.component.prototype[key] = ins;
            }
            else{
                Lyte.$.requiredServices(key,name,function(serviceData,serviceKey){
                    component.component.prototype[serviceKey] = serviceData;
                },undefined,undefined, true, data);
            }
        });
    }
}
    //security
    Lyte.Security.addGlobalObject = function(instanceObj,additionalObj){
        for (var property in additionalObj) {
                if(Array.isArray(additionalObj[property])){
                    additionalObj[property].forEach(function(item){
                        if(instanceObj["_"+property].indexOf(item) == -1){
                            instanceObj["_"+property].push(item);
                        }
                    });
            }
        }
    }
    Lyte.Security.removeGlobalObject = function(instanceObj,additionalObj){
        for (var property in additionalObj) {
            if(Array.isArray(additionalObj[property])){
                additionalObj[property].forEach(function(item){
                    var index = instanceObj["_"+property].indexOf(item);
                    if(index != -1){
                        instanceObj["_"+property].splice(index,1);
                    }
                });
        }
        };
    };

    

    Lyte.Compile.getTrimmedContent = function(content, position, node) {
        let dummyContent = content;
        if(node) {
            position = [];
            let parentNode = node.parentNode;
            while(true) {
                position.unshift(this.getArrayIndex(parentNode.childNodes,node));
                parentNode = parentNode.parentNode;
                node = node.parentNode;
                if(!parentNode) {
                    break;
                }
            }
        }
        for(let i=0;i<position.length;i++) {
            for(let j=content.childNodes.length-1;j>position[i];j--) {
                content.childNodes[j].remove();
            }
            content = content.childNodes[position[i]];
        }
        return dummyContent;
    }
    Lyte.Compile.getArrayIndex = function(array,value) {
        for(let i=0;i<array.length;i++) {
            if(array[i] === value) {
                return i
            };
        }
    }

    Lyte.Compile.splitMixedText = function(str){
        var stack=[], start=0, helper = { name:"concat", args: []}, strStack = [],lastAdded,helperStarted;
        for(var i=0;i<str.length;i++){
          var j = i;
            if(helperStarted && str[i] === "'"){
                if(lastAdded === "'" && str[i-1] !== "\\"){
                    strStack.pop();
                    lastAdded = undefined;
                }
                else if(!strStack.length){
                    lastAdded = str[i];
                    strStack.push(lastAdded);
                }
            }
            else if(helperStarted && str[i] === "\""){
                if(lastAdded === "\"" && str[i-1] !== "\\"){
                    strStack.pop();
                    lastAdded = undefined;
                }
                else if(!strStack.length){
                    lastAdded = str[i];
                    strStack.push(lastAdded);
                }
            }
          else if( ((helperStarted && !strStack.length) || !helperStarted) && str[i-1] !== "\\" && str[i] === "{" && str[++i] === "{"){
            stack.push('{{');
            helper.args.push("'"+str.substr(start,j-start)+"'");
            start = i + 1;
            helperStarted = true;
          }
          else if( ((helperStarted && !strStack.length) || !helperStarted) && str[i] === "}" && str[++i] === "}" && stack.length){
            stack.pop(start);
            helperStarted = false;
            var toPush = str.substr(start,j-start);
            var actObj = this.getHelper(toPush);  
            if(actObj){
                toPush = actObj;
            helper.args.push({type:"helper",value:toPush});
            }
            else{
                helper.args.push(toPush);
            }
            start = i + 1;
         }
    
        }
        // if(stack.length){
            // return false;
        // }
        if(start<str.length){
            helper.args.push("'"+str.substr(start,str.length-start)+"'");
        }
        return helper;
    }
    
    Lyte.Compile.getHelper = function(dynamicValue, newCompile){
        let helperValue = /\((?:[^)]*|(?:(?:"(?:[^"\\]|\\.)*?")|(?:'([^'\\]|\\.)*?')|[\w\s!@#$%^&*)([\]+=.,_-]*?)*?)\)$/.exec(dynamicValue);
        if(helperValue){
            return this.getHelperInfo(dynamicValue,helperValue, newCompile);
        }
        return undefined;
    }
    
    
    Lyte.Compile.getHelperInfo = function(dynamicValue, helperValue, newCompile){
        let helperFunc = {};
        helperFunc.name = dynamicValue.substr(0,helperValue.index).replace(/\s/g,'');
        helperValue = (helperValue) ? helperValue[0].trim() : helperValue;
        if(helperFunc.name == "lyteViewPort" && helperValue == "()"){
            helperFunc.args = [];
            return helperFunc;
        }
        let args = this.getHelperArgs(helperValue.substr(1,helperValue.length-2), newCompile);
        if(args === false){
            return false;
        }
        helperFunc.args = args;
        return helperFunc;
    }
    
    Lyte.Compile.getHelperArgs = function(str, newCompile){
        let stack = [], args = [] , from=0;
        let lastPushed; 
        for(let i=0; i<str.length; i++){
            if(!stack.length && str.charAt(i) === ","){
                let toPush = str.substr(from,i-from);
                toPush = toPush.trim();
                if(toPush && toPush.startsWith("\"") && toPush.endsWith("\"")){
                    toPush = toPush.slice(1,-1);
                    toPush = "'" + toPush + "'";
                }
                toPush = this.getHelperArgValue(toPush, newCompile);
                args.push(toPush);
                from = i + 1;
            }
            else if(str.charAt(i) === "("){
                if(stack[stack.length - 1] != "'" && stack[stack.length - 1] != "\""){
                    stack.push(str.charAt(i));
                    lastPushed = str.charAt(i);
                }
            }
            else if(str.charAt(i) === ")"){
                if(stack[stack.length-1] === "("){
                    stack.pop();
                }
            } else if (str.charAt(i) === "'" && str.charAt(i - 1) !== "\\") {
                if (stack[stack.length - 1] === "'") {
                    stack.pop();
                } else if (stack[stack.length - 1] !== "\"") {
                    stack.push(str.charAt(i));
                    lastPushed = str.charAt(i);
                }
            } else if (str.charAt(i) === "\"" && str.charAt(i - 1) !== "\\") {
                if (stack[stack.length - 1] === "\"") {
                    stack.pop();
                    //                  str.replaceAt(i, "'");
                } else if (stack[stack.length - 1] !== "'") {
                    stack.push(str.charAt(i));
                    lastPushed = str.charAt(i);
                    //                  str.replaceAt(i, "'");
                }
            }
        }
        if (stack.length) {
            return false;
        }
        var toPush = str.substr(from, str.length - from);
        toPush = toPush.trim();
        if (toPush && toPush.startsWith("\"") && toPush.endsWith("\"")) {
            toPush = toPush.slice(1, -1);
            toPush = "'" + toPush + "'";
        }
        try {
            toPush = this.getHelperArgValue(toPush, newCompile);
        } catch (err) {
            //console.log("errr",err);
            return false;
        }
    
        args.push(toPush);
        if(newCompile) {
            var newArgs = [];
            args.forEach(function(item) {
                if(typeof item === "string" && item[0] !== "'" && item !== "event" && item !== "this") {
                    newArgs.push(_LC.getDV(item));
                } else {
                    newArgs.push(item);
                }
            });
            args = newArgs;
        }
        return args;
    };
        
    Lyte.Compile.getHelperArgValue = function(argValue, newCompile) {
        switch(argValue) {
            case "undefined" : 
                return undefined
            case "true" : 
                return true;
            case "false" : 
                return false;
            case "null" : 
                return null;
            case "" : 
                return undefined;
            default :
                if(argValue && argValue.startsWith("'") && argValue.endsWith("'")){
                    //escaping
                    argValue = argValue.replace(/\\\'/g, "'")
                    argValue = argValue.replace(/\\\"/g, '"');
                    return argValue;
                }
                else if(/\([\w\s,')(]*/.test(argValue)) {
                    return {"type" : "helper" , "value" : this.getHelper(argValue, newCompile)}
                } else if(!isNaN(argValue)) {
                    return parseInt(argValue);
                } else {
                    return argValue;
                }
        }
    }
    Lyte.Compile.getMustache = function(value){
        value=(value && typeof value === "string") ? value.trim() : value;
        if(/^{{(?=[\s]*[\w-_\(\$)]+)/.test(value)){
            let arr = value.match(/{{[a-zA-Z0-9_.[\]()]*(?![\\])}}/g);
            if(arr && arr.length > 1){
                //console.log("length>1",value)
                return undefined;
            }
            if(!this.syntaxCheck(value) || !(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}$/.test(value))){ //'
                return undefined;
            }
            let dynamic = value.match(/[\w!@#$%^&*)(+=.,_-]+[\s]*[(]{0,1}(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#$%^&*)([\]+=.,_-]*?)*?[)]{0,1}[\s]*(?=}})/g); //'
            if(dynamic && dynamic.length > 1){
                return undefined;
            }
            else{
                dynamic = (dynamic) ? dynamic[0].trim(): dynamic;                
            }
    //        let dynamic = /[\w!@#\$%\^\&*\)\(+=.,_-]+(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#\$%\^\&*\)\(\[\]+=.,_-]*?)*?(?=}}$)/.exec(value);
            return dynamic;
        }
        return undefined;
    }
    Lyte.Compile.syntaxCheck = function(value){
        var stack = [],lastAdded;
        for(var i=0;i<value.length;i++){
            if(value[i] === "'"){
                if(lastAdded === "'" && value[i-1] !== "\\"){
                    stack.pop();
                    lastAdded = undefined;
                }
                else if(!stack.length){
                    lastAdded = value[i];
                    stack.push(lastAdded);
                }
            }
            else if(value[i] === "\""){
                if(lastAdded === "\"" && value[i-1] !== "\\"){
                    stack.pop();
                    lastAdded = undefined;
                }
                else if(!stack.length){
                    lastAdded = value[i];
                    stack.push(lastAdded);
                }
            }
        }
        if(stack.length){
            return false;
        }
        return true;
    }
    LyteComponent.replaceWithOrigTemplate = function(node){
        node._origTemplate._fakeTemp = node;
        return node._origTemplate;
    }
    LyteComponent.pendingViewPortElements = [];
    LyteComponent.isInViewPort = function(el,lazy) {
        if(lazy){
            return true;
        }
        var rect = el.getBoundingClientRect();
        if(rect.width == 0 && rect.height == 0 && rect.top == 0 && rect.bottom == 0 && el.localName != "dummy-port-element"){
            // hidden Element
            return false;
        }
        let innerHeight = window.innerHeight || document.documentElement.clientHeight;
        let innerWidth = window.innerWidth || document.documentElement.clientWidth;
        return (((rect.top >= 0 && rect.top <= innerHeight) || (rect.bottom >= 0 && rect.bottom <= innerHeight) || (rect.top <= 0 && rect.bottom >= 0))
        &&
        ((rect.left >= 0 && rect.left <= innerWidth) || (rect.right >= 0 && rect.right <= innerWidth) || (rect.left <= 0 && rect.right >= 0)) );
    }
    _LC._doneRaf = {};
    Lyte.Component.registerHelper("lyteViewPort",function(node,config){    
        let compName = this.localName;
        let self = this;
        let actNode = _LC.getActViewPortTemplate(node);
        if(actNode._viewPortRendered){
            return false;
        }
        let disableViewPort = config;
        let pve = _LC.pendingViewPortElements;
        let promise;
        actNode._disable = {};
        if(config && typeof config == "object"){
            actNode._lazy = node._lazy = config.lazy;
            actNode._custom = true;
            disableViewPort = config.disableViewPort;
            if(config.viewIn || config.viewOut){
                promise = true;
                actNode._viewIn = config.viewIn ? Object.assign(config.viewIn) : undefined;
                actNode._viewOut = config.viewOut ? Object.assign(config.viewOut) : undefined;

                // actNode._inView = config.inView;
                // actNode._didRender = config.didRender;
                // actNode._isLoading = config.isLoading;
                let _res,_rej;
                actNode._renderPromise = new Promise(function(res,rej){
                    _res = res;
                    _rej = rej;
                });
                actNode._promiseObject = {
                    resolvedByLyte : false,
                    spouse : actNode._viewIn,
                    resolve : function(){
                        if(!actNode._viewOut._afterAppendCalled && actNode._viewOut.beforeRemove && actNode._renderPromise && !actNode._viewOut._beforeRemoveCalled){
                            actNode._viewOut.beforeRemove.apply(actNode._viewOut,[node._promiseObject]);
                            actNode._viewOut._beforeRemoveCalled = true;
                        }
                        if(actNode._renderPromise){
                            // let config = actNode._promiseObject.options;
                            // if(config && config.disable){
                            //     if(config.disable.inView === true){
                            //         actNode._disable.inView = true; 
                            //     }
                            //     if(config.disable.didRender === true){
                            //         actNode._disable.didRender = true;
                            //     }
                            // }
                            _res();
                        }
                    },
                    reject : function(){
                        actNode._renderPromise._reject = true;
                        // actNode._disable.inView = true;
                        // actNode._disable.didRender = true;
                        _rej();
                    },
                    // options : {
                    //     disable : {
                    //         inView : false,
                    //         didRender : false
                    //     }
                    // }
                }
                // actNode._renderPromise.resolve = _res;
                // actNode._renderPromise.reject = _rej;

                actNode._renderPromise.then(function(){ //fix observers issue ember
                    if(!actNode._callee.component){
                        return;
                    }
                    let waitInd = _LC.waitingForResolve.indexOf(node._renderPromise);
                    if(waitInd != -1){
                        _LC.waitingForResolve.splice(waitInd,1);
                    }
                    actNode._renderPromise._resolved = true;
                    let ind = pve.indexOf(actNode);
                    if(ind != -1){
                        pve.splice(ind,1)
                    }
                    let viewInIns = actNode._viewIn;
                    if(viewInIns && viewInIns.beforeAppend){
                        viewInIns.beforeAppend.apply(viewInIns);
                    }
                    _LC._executeIfTemplates(actNode);
                    if(viewInIns && viewInIns.afterAppend){
                        viewInIns.afterAppend.apply(viewInIns);
                    }
                    actNode._renderPromise = null;
                },function(){
                    Lyte.error("Promise rejected - Viewport cannot be toggled.");
                })
            }
        }
        if(!disableViewPort){
            // if(!LyteComponent._pendingAnimationFrame){
            if(!_LC._doneRaf[compName]){
                requestAnimationFrame(function () {
                    setTimeout(function () {
                        let inViewTemplates = [];
                        var arr = Array.from(pve);
                        let beforeRemoveHook = [];
                        for(var i=arr.length-1;(i >= 0);i--) {
                            let temp = arr[i];
                            var actTemp = _LC.getActViewPortTemplate(temp);
                            let viewOutIns = actTemp._viewOut;
                            //var loaderAfterAppend = actTemp._viewOut.afterAppend;
                            if(viewOutIns && viewOutIns.afterAppend){
                                viewOutIns.afterAppend.apply(viewOutIns,[actTemp._promiseObject]);
                                viewOutIns._afterAppendCalled = true;
                            }
                        }
                        for(var i=arr.length-1;(i >= 0);i--) {
                            let temp = arr[i];
                            var actTemp = _LC.getActViewPortTemplate(temp);
                            // let viewOutIns = actTemp._viewOut;
                            //var loaderAfterAppend = actTemp._viewOut.afterAppend;
                            // if(viewOutIns && viewOutIns.afterAppend){
                            //     viewOutIns.afterAppend.apply(viewOutIns,[actTemp._promiseObject]);
                            //     viewOutIns._afterAppendCalled = true;
                            // }
                            if(_LC.isViewPortTemplate(temp) && !temp._callee._destroyed){
                                let obj = {};
                                if(_LC._isInViewPort(actTemp,actTemp._callee,beforeRemoveHook,undefined,obj)){
                                    let nd = pve.splice(i,1)[0];
                                    temp._inPve = false;
                                    temp._viewPortRendered = true;
                                    !obj.beforeRemoveHook && inViewTemplates.push(nd);
                                }
                                actTemp._inPve = temp._inPve;
                                actTemp._viewPortRendered = temp._viewPortRendered;
                            }
                        }
                        for(let i=0; i<beforeRemoveHook.length; i++){
                            beforeRemoveHook[i].viewOutIns.beforeRemove.apply(beforeRemoveHook[i].viewOutIns,beforeRemoveHook[i].arg);
                            _LC.waitingForResolve.push(beforeRemoveHook[i].node._renderPromise);
                        }
                        for(let i=0; i<inViewTemplates.length; i++){
                            _LC._executeIfTemplates(inViewTemplates[i]);
                        }
                        // LyteComponent._pendingAnimationFrame = false;
                        _LC._doneRaf[compName] = false;
                        if(inViewTemplates.length) {
                            requestAnimationFrame(function() {
                                setTimeout(function() {
                                    _LC.executePendingViewPort();
                                },1);
                            });    
                        }
                        !window.isLyteWidget && _LC.resolveLazy();
                    },1);
                });
                // LyteComponent._pendingAnimationFrame = true;
                _LC._doneRaf[compName] = true;
            }
            if(pve.indexOf(_LC.getFakeTemplate(node)) == -1){
                node._inPve = true;
                pve.push(node);
            }
            return true;
        }else if(pve.length){
            let fakeTemp = _LC.getFakeTemplate(node);
            let ind = pve.indexOf(fakeTemp);
            node._inpve = fakeTemp._inPve = false;
            node._viewPortRendered = fakeTemp._viewPortRendered = true;
            if(ind != -1){
                // pve[ind]._inpve = node._inPve = false;
                // pve[ind]._viewPortRendered = node._viewPortRendered = true;
                pve.splice(ind,1);
            }
        }
    });
    LyteComponent.waitingForResolve = [];
    LyteComponent._isInViewPort = function(node,comp,beforeRemoveHook,lazyForce,obj){
        var fchild = node._caseContent[0];
        if(fchild && _LC.isInViewPort(fchild,lazyForce)) {
            node._isInView = true;
            if(node._custom){
                let viewOutIns = node._viewOut;
                if(viewOutIns && !node._renderPromise._resolved && viewOutIns.beforeRemove && !viewOutIns._beforeRemoveCalled){
                    node._promiseObject.resolvedByLyte = true;
                    viewOutIns._beforeRemoveCalled = true;
                    beforeRemoveHook.push({
                        viewOutIns : viewOutIns,
                        arg : [node._promiseObject],
                        node : node
                    });
                    if(obj){
                        obj.beforeRemoveHook = true;
                        return true;
                    }
                    // viewOutIns.beforeRemove.apply(viewOutIns,[node._promiseObject]);
                }else if(!node._renderPromise._reject){
                    if(obj){
                        obj.beforeRemoveHook = true;
                    }
                    return true;
                }    
            }
            // if(node._inView && !node._renderPromise._resolved && !node._disable.inView){
            //     node._inView.apply(this,[node._promiseObject]);
            // }
            else{
                return true;
            }
        }
    }
    LyteComponent.__preLazyRender = false;
    LyteComponent.resolveLazy = function(){
        if(LyteComponent.pendingViewPortElements){
            requestAnimationFrame(function () {
                setTimeout(function () {
                    let waitingForViewportProcess = false;
                    for(let key in _LC._doneRaf){
                        if(_LC._doneRaf[key]){
                            waitingForViewportProcess = true;
                        }
                    }
                    if(_LC.waitingForResolve.length){
                        Promise.all(_LC.waitingForResolve).then(function(){
                            LyteComponent.resolveLazy();
                        },function(){
                            Lyte.error("Promise rejected - Viewport cannot be toggled.");
                        })
                    }else if(waitingForViewportProcess){
                        LyteComponent.resolveLazy();
                    }
                    else{
                        // iterate pending and resolve
                        !_LC.__preLazyRender && Lyte.triggerEvent("preLazyRender");
                        _LC.__preLazyRender = true;
                        _LC.executePendingViewPort({lazy : true});
                    }
                },1);
            })
        }
    }
    LyteComponent._executeIfTemplates = function(node){
        let actNode = _LC.getActViewPortTemplate(node);
        // actNode._renderPromise = null;
		actNode._attributes.value = false;
        var isYieldContext,contextSwitchInfo;
        if (actNode._cx || actNode.nodeType === 2 && actNode.ownerElement._cx) {
            contextSwitchInfo = actNode._cx || actNode.ownerElement._cx;
            var contextSwitchArray = [];
            _LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo);
        } else if (actNode.tagName === "LYTE-YIELD" && actNode._callee._cx) {
            isYieldContext = true;
            contextSwitchInfo = actNode._callee._cx;
            var contextSwitchArray = [];
            _LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, true);
        }
        // if(!actNode._callee.component){
        //     // debugger
        // }
        actNode._callee.updateSwitchHelper("if", actNode, actNode._cx, true, true);
        if (contextSwitchInfo) {
            _LC.removeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, isYieldContext);
        }
        // node._isViewPortPending = false;
	}
    LyteComponent.isViewPortTemplate = function(node){
        if((node.tagName == "TEMPLATE" || node._origTemplate) && node.getAttribute("is") == "if"){
            return true;
        }
    }
    LyteComponent.getActViewPortTemplate = function(node){
        return node._origTemplate ? node._origTemplate : node;
    }
    LyteComponent.getFakeTemplate = function(node){
        return node._fakeTemp ? node._fakeTemp : node;
    }
    LyteComponent.executePendingViewPort = function(options) {
        var pve = _LC.pendingViewPortElements;
        if(!pve.length) {
            return;
        }
        var arr = Array.from(pve);
        var inViewPortElements = [];
        let beforeRemoveHook = [];
        let lazyForce = options && options.lazy ? true : undefined;
        let settings = _Lyte.Component.viewPortSettings;
        let lazyToggleCount = settings.lazy.count;
        let lazyToggleByElements = settings.lazy.toggleBy == "elements" ? true : false;
        let lazyToggleByScreen = settings.lazy.toggleBy == "screen" ? true : false;
        if(options && options.lazy && options.lazy.toggleBy){
            lazyToggleCount = options.lazy.count;
            lazyToggleByElements = options.lazy.toggleBy == "elements" ? true : false;
            lazyToggleByScreen = options.lazy.toggleBy == "screen" ? true : false;
            if(lazyToggleByElements){
                _LC._toggleElementsCount = lazyToggleCount;   
            }else if(lazyToggleByScreen == "screen"){
                _LC._toggleScreenCount = lazyToggleCount;   
            }
        }
        let sliceCount = 0;
        _LC.autoRender = _LC.autoRender || (options && options.force == "autoRender");
        if((!options || !options.force) && !_LC.autoRender){
        for(var i=arr.length-1;(i >= 0);i--) {
            let ele = arr[i];
            if(_LC.isViewPortTemplate(ele)){
                let actTemp = _LC.getActViewPortTemplate(ele);
                lazyForce = actTemp._lazy && lazyForce ? lazyForce : false;
                if(lazyForce && lazyToggleByElements){
                    if(lazyToggleCount == 0){
                        requestAnimationFrame(function () { //eslint-disable-line no-loop-func
                            setTimeout(function () { //eslint-disable-line no-loop-func
                                _LC.executePendingViewPort({lazy : true});
                            })
                        })
                        break;
                    }
                    lazyToggleCount--;
                }
                if(_LC._isInViewPort(actTemp,actTemp._callee,beforeRemoveHook,lazyForce)){
                    inViewPortElements.push(pve.splice(i,1)[0]);
                    sliceCount++;
                    ele._inPve = false;
                    ele._viewPortRendered = true;
                }
                actTemp._inPve = ele._inPve;
                actTemp._viewPortRendered = ele._viewPortRendered;
            }
            else if(_LC.isInViewPort(ele._dummyViewPortF) || _LC.isInViewPort(ele._dummyViewPortL)) {
                ele._dummyViewPortF = ele._dummyViewPortL = undefined;
                inViewPortElements.push(pve.splice(i,1)[0]);
                sliceCount++;
            }
        }
        for(let i=0; i<beforeRemoveHook.length; i++){
            beforeRemoveHook[i].viewOutIns.beforeRemove.apply(beforeRemoveHook[i].viewOutIns,beforeRemoveHook[i].arg);
        }
        }else{
            inViewPortElements = arr;
        }

        // _LC.isViewPortPending = false;

        let pveLn = arr.length;
        for(var j=0;j<inViewPortElements.length;j++) {
            let ele = inViewPortElements[j];
            if(_LC.isViewPortTemplate(ele)){
                _LC._executeIfTemplates(ele);
            }else{
                ele.setData("lyteViewPort", false);
                var index = pve.indexOf(ele);
                if(index != -1) {
                    pve.splice(index, 1);
                    sliceCount++;
                }
            }
        }
        _LC.isViewPortPending = false;
        if(inViewPortElements.length && !window.isLyteWidget) {
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    _LC.executePendingViewPort();
                });
            });    
        }else if(pveLn == _LC.pendingViewPortElements.length + sliceCount && (!options || !options.lazy)){
            Lyte.triggerEvent("viewportRendered");
        }
    }

    window.addEventListener("resize", function() {
        requestAnimationFrame(function() {
            requestAnimationFrame(function() {
                _LC.executePendingViewPort();     
            })    
        });
    });
    
    document.addEventListener("scroll", function() {
        if(window.isLyteWidget){
            _LyteComponent.viewPortSettings.debounce = 100
        }
        var debounceTime = _LyteComponent.viewPortSettings.debounce
        if(debounceTime) {
            if(_LC.viewPortScrollDebounce) {
                clearTimeout(_LC.viewPortScrollDebounce);
            }
            _LC.viewPortScrollDebounce = setTimeout(function() {
                    requestAnimationFrame(function() {
                        requestAnimationFrame(function() {
                            _LC.executePendingViewPort();        
                        }) 
                    });
                    _LC.viewPortScrollDebound = undefined;
            },debounceTime);
        } else {
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    _LC.executePendingViewPort();        
                }) 
            });
            
        }
    }, true);
    
    LyteComponent.core = {};
    LyteComponent.core._constructor = customElementPrototype;
    LyteComponent.core._registerComponent = customElementPrototype._registerComponent;
    LyteComponent.core.registerComponent = _LC.registerComponent;
    LyteComponent.core.executeBlockHelpers = customElementPrototype.prototype.executeBlockHelpers;
    LyteComponent.core.updateForHelper = customElementPrototype.prototype.updateForHelper;
    LyteComponent.core.updateForInHelper = customElementPrototype.prototype.updateForInHelper;
    LyteComponent.core.updateSwitchHelper = customElementPrototype.prototype.updateSwitchHelper;

    _LyteComponent.viewPortSettings = {
        debounce : 0,
        lazy : {
            toggleBy : "elements", //or "screen"
            count : 100
        },
        executePendingViewPortElements : function(options) {
            LyteComponent.executePendingViewPort(options);
        },
        resetLazy : function(){
            LyteComponent.__preLazyRender = false;
        }
    }

    LyteComponent.insertBeforeNative = function(parent, newNode, refNode) {
        parent.insertBefore(newNode, refNode);
    }
}(window));
Lyte.registerErrorCodes({
	LD01: "Primary key value might be missing in the response data that is received, {0}",
	LD02: "{0} - {1} is not registered",
	LD03: "Cannot set the error {0} for {1}",
	LD04: "No such record to merge, {0}",
	LD05: "Model( {0} ) of related property - {1} not found in model - {2}",
	LD06: "Backward relation not present in model( {0} ), for the property {1} of model( {2} )",
	LD07: "{0} type not handled in handleArrayOperations",
	LD08: "{0} {1} will be deprecated from next version {2}",
	LD09: "deserializeKey cannot be processed for payload with more than two keys. Please use payloadKey callback instead or try modifying the same in normalizeResponse callback",
	LD10: "Response data not in a format lyte data store expects",
	LD11: "Deprecation Warning! findRecord response payload will not accept an array. It will be deprecated from the next version",
	LD12: "Response ( {0} ) is not in a format, lyte data store expects",
	LD13: "Response processing failed in {0} for model-{1} {2}, since invalid data is received in {1}(modelName) key of the data",
	LD14: "Cannot register {0} - {1}, as it already exists.",
	LD15: "Primary key value might be missing in the response data that is received, {0}",
	LD16: "Record merge failed for the record in model - {0} with primaryKey value - {1}, since either the persisted(saved) primary key value for a newly created record is not received from server or not in the proper structure to merge",
	LD17: "Record with the primary key value already exists",
	LD18: "No { 0 } present",
	LD19: "Deprecation Warning! findAll will not accept response payload values other than an array or any empty value. Current implementation which allows this will be deprecated from the next version",
	LD20: "Record cannot be saved as a state, when it is not either a new or a modified record or in a error state.",
	LD21: "No such state ( {0} ) saved for the record.",
	LD22: "For create / createRecord, response with a primary key value should be received",
	LD23: "PrimaryKey field {1} in {0} cannot have default value",
	LD24: "Response couldn't be parsed, {0}",
	LD25: "Cannot create record for the data - {0}",
	LD26: "Only one baseKey is allowed for a model",
	LD27: "Record merge failed, since the data passed is invalid - {0}",
	LD28: "Record merge failed for the model - {0}, since a valid primary key value is not found in the data to be merged - {1}",
	LD29: "Unloaded record-{0} of the model-{1} is being saved",
	LD30: "Variable value in query is mandatory for {0}",
	LD31: "Datatype defined for {0} is mismatch with the value's datatype",
	LD32: "Query '{0}' was not registered for the model '{1}"
});
var $Record = function $Record(){
	Object.assign(this, {inIDB : false, isPersisted:true, isUnloaded : false, isModified : false, isNew : false, isDeleted : false, isError : false, events : [], validatedOnCreate : true, error : {}});
}
/* Record Constructor
Steps Done: 
* Assign data
* Assign $Record -> Maintaining Record state
* Assign ref of model,record to act independently
***
*/
var Record = function Record(modelName,data,opts,clone){
	var model = store.modelFor(modelName), delayPers = opts ? opts.delayPersistence : store.$.getFromCB("adapter", modelName, "delayPersistence");
	Object.assign(this, data);
	Object.defineProperties(this, {
		$ :{
			writable : true,
			value : new $Record()
		}
	});
	var pkVal = store.$.getpKVal(this, model);
	if(clone){
		Object.defineProperties(this.$,{
			isCloned : {
				value : true,
				writable : false
			},
			donor : {
				value : store.$.peekRecord(modelName , pkVal)
			}
		})
	}
	Object.defineProperties(this.$, {
		pK:{
			value: pkVal,
			writable: true
		},
		model : {
			value : model
		},
		_attributes : {
			value : {} ,
			writable : true
		},
		_relationships : {
			value : {},
			writable : true
		},
		isDirty: {
			value: function value(){
				var result = [];
				var record = this.record;
				if(record.$.isModified){
					return true;
				}
				result = store.$.isDirty(record, this.model.relations);
                if(result.length){
					return result;
				}
				return false;
			}
		},
		undoStack : {
			value : store.$.genUnRedoStack(),
			writable : true
		},
		redoStack : {
			value : store.$.genUnRedoStack(),
			writable : true
		},
		delayPersistence : {
			value : delayPers
		}
	});
	this.$.record = this;
	if(model.sort && !clone){
		store.$.defProp(this.$ , "created_Time" , store.$.getCreatedTime(model.cT))
	}
	var parent = store.$.saveParent;
	if(parent && this !== parent){
		store.$.defProp(this.$, "parent", parent);
	}
	var defF = model._fldGrps.default;
	var watchF = model._fldGrps.watch;
	var hasManyF = model._fldGrps.hasMany;
	var nested = model._fldGrps.nested_prop;
	for(var dKey in defF){
		var dFld = defF[dKey];
		var fldVal = data[dKey];
		if(fldVal === undefined || fldVal === ""){
			this[dKey] = store.$.getDefaultVal(this, dFld.default);
		}
	}
    for(var wKey in watchF){
		Lyte.establishObjectBinding(this,wKey,true,undefined,undefined,true);
	}
	for( var k in nested){
		Lyte.establishObjectBinding(this,k,true,undefined,undefined,(k && k.watch)?k.watch:undefined);
	}
	for(var hKey in hasManyF){
		var hFld = hasManyF[hKey];
		if(this.hasOwnProperty(hKey)){
			this[hKey] = Array.isArray(this[hKey]) ? Array.from(this[hKey]) : this[hKey];
		}else if(store.modelFor(hFld.relatedTo) && !clone){
			var toInit = store.$.getFromCB("serializer", hFld.relatedTo, "initHasManyRelation");
			if(toInit){
				this[hKey] = [];
			}
		}
	}
	var props = model._properties;
	if(Object.keys(props).length){
		if(!this._bindings){
			store.$.defProp(this, '_bindings', new Set(), false, true);
		}
		this._bindings.add(props);
		store.$.establishObserverBindings(this,props);
	}
	if(model.deprecate && model.deprecate.size && Lyte.__config && Lyte.__config.deprecateModelFields){
		var prx = new Proxy(this, {
			get:function(target, prop, receiver){
				if(model.deprecate.has(prop)){
					Lyte.warn("Property - '"+prop+"' of Model-'"+model._name+"' has been deprecated. ");
				}
				return target[prop];
			},
			set: function(target, prop, value){
				if(model.deprecate.has(prop)){
					Lyte.warn("Property - "+prop+" of Model-"+model._name+" has been deprecated.");
				}
				return Reflect.set(...arguments);
			}
		});
		this.$.record = prx;
		return prx; 
	}
}
/* Assigning the following in $record.prototype 
So it will be available to all record.$
*/

Object.defineProperties($Record.prototype,{
	get: {
		value:function value(attr){
			var data = this.record[attr];
			if(Lyte.Component && Lyte.Component._get){
				data = Lyte.Component._get(this.record,attr);
			}
			if(Lyte.getConfig("mutable")){
				if(Lyte.isRecord(data) || (Array.isArray(data) && data.model)){
					return Lyte.mut(data);
				}
			}
			return data;
		}
	},
	set: {
		value : function value1(attr, value, opts){
			if(this.isDeleted){
				store.$.setRecErr(this, this.model._pK, "ERR17");
			}
			else{
				store.$.setData(this, attr, value,opts);
			}
			return this.record;
		}
	},
	getDirtyAttributes : {
		value : function value(){
			var ret = [];
			var attributes = this._attributes;
			if(Object.keys(attributes).length){
				for(var key in attributes){
					ret.push(key);
				}
			}
			return ret;
		}
	},
	// getProxy: {
	// 	value: function value(){
	// 		var model = this.model;
	// 		if(store.$ && !store.$.mutable){
	// 			// Lyte.warn("Mutable option not enabled in store");
	// 			return;
	// 		}
	// 		model.__prx = model.__prx || new Map();
	// 		if(!model.__prx.has(this.record)){
	// 			model.__prx.set(this.record, Lyte.mut(this.record));
	// 		}
	// 		return model.__prx.get(this.record);
	// 	}
	// },
	rollBackAttributes : {
		value : function value(attr,inherit){
			if(!Array.isArray(attr)){
				attr = [attr];
			}
			var record = this.record.$.record, changed = [], model = this.model, _attrs = this._attributes;
			for(var i=0; i<attr.length; i++){
				var key = attr[i];
				if(_attrs.hasOwnProperty(key)){
					var field = model.fieldList[key], oldVal = _attrs[key];
					if(field.type == "relation"){
						store.$.rllBckRecArr(oldVal, record, model, field);
						var obj = record.$.dN && record.$.dN.hasOwnProperty(key) ? record.$.dN[key] : new Map();
						obj.forEach(function(item, mKey){
							store.$.deleteDeepNest(record, key, mKey);
						});
					}
					else{
						store.$.cmpSet( record, key, oldVal,undefined, true );
					}
					changed.push(key);
					delete _attrs[key];
				}
				store.$.clrRecErr(this, key);
			}
			if(!Object.keys(this._attributes).length){
				if((!this.hasOwnProperty("dN") || ( this.dN && !Object.keys(this.dN).length )) && !record.$.isNew){
					store.$.removeParentNesting(record, "modified");
				}
				store.$.cmpSet(this, "isModified", false);
				store.$.changePersist(record, true);
				if(!this.isNew){
					store.$.deleteFromArray(model.dirty, this.get(model._pK));
				}
			}
			if(changed.length > 0){
                var arr = [record,changed];
				this.emit("change", arr);
				model.emit("change", arr);
				this.undoStack = store.$.genUnRedoStack();
				this.redoStack = store.$.genUnRedoStack();
			}
		}
	},
	rollBack : {
		value : function value(state,inherit){
			var model = this.model, pK = model._pK,recmp =new Map(); 
			inherit=(inherit===false)?false:model._fldGrps.inherit && Object.keys(model._fldGrps.inherit).length;
			if(state){
				this.rollBackState(state,inherit);
				store.$.removeOnSave(this.model._name, this.record.$.pK);
			}
			else {
				if(inherit){
					store.$.rBinherit(this,recmp,"");
				}
				store.$.rollBackRecord(this);
			}
		}
	},
	deleteRecord : {
		value : function value(delayPers){
			var model = this.model, record = this.record.$.record, 
			delayPers = ( delayPers !== undefined ) ? delayPers : (record.$.delayPersistence ? record.$.delayPersistence.delete : undefined); 
			store.$.removeFromStore(model, record.$.pK, undefined, undefined, delayPers);
		}		
	},
	destroyRecord : {
		value:function value(customData,qP,delayPers,mutationName){
			this.deleteRecord(delayPers);
			return this.save(customData,qP,"destroyRecord",undefined,mutationName);
		}				
	},
    addEventListener : {
		value : function value(type, func){
            return store.$.eventListeners.add(this, type, func);
        }
 	},
	removeEventListener : {
		value : function value(id){
            store.$.eventListeners.remove(this,id);
		}
	},
	emit : {
		value : function value(type, args){
            store.$.eventListeners.emit(this,type,args);
        }
	},
	triggerAction: {
		value : function value(actionName,customData,qP,method,data){
			var model = this.model, actions = model.actions, action = (actions) ? actions[actionName] : undefined;
			if(action){
				return store.adapter.$.handleAction(actionName,model,this.record.$.record,customData,qP,method,data);
			}
			return Promise.reject({code : "ERR18", message : Lyte.errorCodes.ERR18, data : actionName});
 		}
	},
	save: {
		value : function value(customData,qP,options,destroy,mutationName){
			var self = this;
			if(this.isCloned){
				if(this.isUnloaded){
					return Promise.resolve();
				}
				else{
					self = store.$.savingDonorRecord(this);
				}
			}
			var model = self.model, record = self.record, dirty = self.isDirty(), validateOnSave = options && options.validateOnSave, skipValidation = options && options.skipValidation, clear, fields = model.fieldList, ret;
            if(self.isUnloaded !== true){
				if(self.isDeleted){
					if(!self.isNew){
						return store.adapter.$.del(model._name, record, true,destroy,customData,qP,mutationName);
					}
					// store.adapter.$.handleResponse(record, record, undefined, undefined, model);
				}
				else if(self.isNew){
					var err = self;
					if(!skipValidation && (!record.$.validatedOnCreate || validateOnSave)){
						ret = store.$.validateRecord(self.record, fields);
					}
					if(!skipValidation && (ret == false || (err && err.error && Object.keys(err.error).length > 0))){
						return Promise.reject(err.error);
					}
					return store.adapter.$.create(model._name, record, true ,customData,qP,mutationName);
				}
				else if(self.isModified || (dirty && dirty.length) ){
					var data = {};
					if(!skipValidation && (options && validateOnSave)){
						ret = store.$.validateRecord(self.record, fields);
					}
					if(!skipValidation){
						if(ret == false || (record && record.$ && record.$.isError)){
							return Promise.reject(record.$.error);
						}
					}
					var data = store.$.updateJSON(self.record, model, dirty);
					return store.adapter.$.put(model._name, data, record, true, customData,qP,mutationName);
				}
			}
			else{
				Lyte.warn("LD29", typeof record.$.pK == "object" ? JSON.stringify(record.$.pK) : record.$.pK, model._name)
				var rejectUnloadRecordSave = store.$.getFromCB("adapter", model._name, "rejectUnloadRecordSave");
				if(rejectUnloadRecordSave){
					return Promise.reject({code: "ERR28", message: Lyte.errorCodes.ERR28, data: record});
				}
			}
			return Promise.resolve();
		}
	},
	getInitialValues : {
		value : function(attr){
			var isAttrPassed = false;
			if(attr){
				if(!Array.isArray(attr)){
					attr = [attr];
				}
				isAttrPassed = true;
			}
			else{
				attr = this.getDirtyAttributes();
			}
			var ret = {}, rec = this.record.$.record, _attrs = this._attributes;
			for(var i=0; i<attr.length; i++){
				if(rec[attr] == undefined || !rec[attr[i]].add){
					ret[attr[i]] = _attrs[attr[i]];					
				}
				else{
					ret[attr[i]] = rec[attr[i]].slice(0);
					var arr = _attrs[attr[i]], pK = rec[attr[i]].model._pK;
					for(var j=arr.length-1; j>=0; j--){
						if(arr[j]._type == "added"){
							for(var k=0; k<arr[j].records.length; k++){
								var index = store.$.getIndex(ret[attr[i]], pK, arr[j].records[k].$.pK);
								if(index == -1){
									continue;
								}
								ret[attr[i]].splice(index, 1);
							}
						}
						else if(arr[j]._type == "removed"){
							for(var k=arr[j].records.length-1; k>=0; k--){
								ret[attr[i]].splice(arr[j]._indices[k], 0, arr[j].records[k]);
							}
						}
						else if(arr[j]._type == "changed"){
							ret[attr[i]] = Array.isArray(arr[j].records) ? Array.from(arr[j].records) : arr[j].records;
						}
					}
				}
			}
			if(isAttrPassed){
				return ret[attr[0]];
			}
			return ret;
		}
	},
    toJSON:{
        value: function(type,addNotDefinedFields){
			var inherit=true;
			addNotDefinedFields = addNotDefinedFields?true:false
			if(typeof(type)=="object" && type.inherit==false){
				inherit=type.inherit;
			}
            return Object.assign({}, store.$.toJSON(this.model._name, this.record.$.record, !type ? true : type,undefined,undefined,inherit,addNotDefinedFields));
        }
	},
	undo:{
		value: function(attr, state){
			var currentState = this.undoStack._order_.length;
			state = state || (currentState ? currentState - 1 : currentState);
			// state = state || 0;
			while(currentState-- > state){
				store.$.unredoOp(1, this, attr);
			}
		}
	},
	getCurrentState:{
		value: function(){
			return this.undoStack._order_.length;
		}
	},
	redo:{
		value:function(attr){
			store.$.unredoOp(2,this,attr);
		}	
	},
	validate : {
		value : function(field,validateCallBack){
			var fields = {};
			var model = this.model;
			var fieldList = model.fieldList;
			if(Array.isArray(field)){
				field.forEach(function(item, index){
					if(fieldList[item]){
						fields[item] = fieldList[item];
					}
				});
			}
			else if(typeof field == "object"){
				fields = field;
			}
			if(Object.keys(fields).length == 0 || field == true){
				fields = fieldList;
			}
			var record = this.record;
			var err = store.$.validateRecord(record, fields ,validateCallBack);
			if(validateCallBack && err && typeof err == "object"){
				return err;
			}				
		}
	},
	saveState : {
		value : function(state){
			if(!this.isNew && !this.isModified){
				Lyte.warn("LD20");
				return;
			}
			var savedState = this._savedState = this._savedState || {}, currentState = state, randomState;
			while(!currentState){
				randomState = Math.floor(Math.random()*100000 + 1);
				currentState = !savedState.hasOwnProperty(randomState) ? randomState : currentState;
			}
			var obj = this.toJSON("state");
			store.$.defProp(obj, "$", {}, false, true);
			var pK = this.model._arrPk;
			pK.forEach(function(val){
				delete obj[val];
			});
			var undoStack = this.undoStack;
			var redoStack = this.redoStack;
			var _attributes = this._attributes;
			var old_dN = this.dN;
			// var dN = this.record.$.dN;
			if(undoStack && Object.keys(undoStack).length){
				var _order = undoStack._order_;
				undoStack = obj.$.undoStack = store.$.deepCopyStack(undoStack);
				store.$.defProp(undoStack, "_order_", Lyte.deepCopyObject(_order), false, true);
			}
			if(redoStack && Object.keys(redoStack).length){
				var _order = redoStack._order_;
				redoStack = obj.$.redoStack = store.$.deepCopyStack(redoStack);
				store.$.defProp(redoStack, "_order_", Lyte.deepCopyObject(_order), false, true);
			}			
			if(_attributes && Object.keys(_attributes).length){
				obj.$._attributes = store.$.deepCopyAttrs(this.model, _attributes);
			}
			if(old_dN && Object.keys(old_dN).length){
				obj.$.dN = store.$.deepCopyAttrs(this.model,old_dN);
			}
			this._savedState[currentState] = obj; 
			return currentState;
		}
	},
	clearState: {
		value: function(state){
			if(!state){
				this._savedState = {};
				return;
			}
			delete this._savedState[state];
		}
	},
	rollBackState:{
		value: function(state,inherit){
			var savedSt = this._savedState
			var obj = savedSt ? savedSt[state] : undefined;
			if(!obj){
				Lyte.warn("LD21", state);
				return;
			}
			this.dN ? this.dN = {} : undefined;
			store.$.setData(this, obj, undefined, undefined, {}, true,inherit,obj.$.dN);
			store.$.updateDn(this.record.$.record);
			this.undoStack = obj.$.undoStack || store.$.genUnRedoStack();
			this.redoStack = obj.$.redoStack || store.$.genUnRedoStack();
			this._attributes = obj.$._attributes || {};
			store.$.checkAttrs(this.record.$.record);
			delete this._savedState[state];
		}
	},
	hasSavedState:{
		value: function(state){
			return this._savedState && this._savedState.hasOwnProperty(state) ? true : false;
		}
	},
	persist:{
		value: function(obj){
			var mName = this.model._name, rec = this.record.$.record, partialObj = {obj:new Map()}, type, dirty;
			if(this.isNew){
				type = "create";
				store.$.toJSON(mName, rec, undefined, type, partialObj);
			}
			else if(dirty = this.isDirty()){
				var data = store.$.updateJSON(rec, this.model, dirty);
				store.$.toJSON(mName, data, undefined, undefined, partialObj);
			}
			var pObj = partialObj.obj.get(this.pK);
			store.adapter.$.mergeResponse(rec, this.model, undefined, this.pK, pObj, true);
			store.adapter.$.updateIDB(mName, type ? type : rec.$.isDeleted || rec.$.isUnloaded ? "deleteRecord" : rec.$.isModified || dirty ? "updateRecord" : undefined, rec);
		}
	},
	clone:{
		value : function(){
			var parent = this.record.$.record , data = this.record.$.toJSON({type : "isClone"});
			var clonedData = store.$.insertIntoStore(parent.$.model._name,data,undefined,undefined,undefined,undefined,undefined,{type:"isClone"})
			return clonedData
		}
	}
});
/* Model Object Constructor 
*/
var Model = function Model(name,fields){
	Object.assign(this, {_name : name, fieldList : {id : {type : "string", primaryKey : true, defined : false}}, relations : {}, _properties : {},deprecate: {}, _fldGrps : { default : {}, hasMany: {}, watch: {}, inherit:{} ,nested_prop: {}, inverse:{} , JsonPathWatch : {}}, data : [], dirty : [], _deleted : new Map(),
		events : {}});
	store.$.defProp(this.data, "_recMap", new Map());
	var obs = [];
	for(var key in fields){
		store.$.registerField(this,key,fields[key],obs);
	}
	if(!this._pK){
		this._pK = 'id';
	}
	this.isComp = false;
	var splt = this._pK.split(',');
	if(splt.length > 1){
		this.isComp = true;
	}
	this._arrPk = splt;
	if(typeof Lyte != "undefined"){
		Lyte.establishObserverBindings(obs,true,this._properties,this);
		Lyte.establishWatchScope(this._fldGrps.JsonPathWatch,this)
	}
	store.$.defArrUtls(this.data);
	store.$.defUtls(this.data,this);
	store.$.defProp(this, "extends", store.$.extendModel);
}
Model.prototype.addEventListener = function(type, func){
    return store.$.eventListeners.add(this,type,func);
}
Model.prototype.removeEventListener = function(id){
    store.$.eventListeners.remove(this,id);
}
Model.prototype.emit = function(type, args){
    store.$.eventListeners.emit(this,type,args);
}
Model.prototype.on = function(type,func){
    return this.addEventListener(type,func);
}
Model.prototype.setGql=function value(type,key,Query){
	store.$.setQuery(this,key,type,Query);
}
var store = {
	model : {},
	$:{ 
		idbOpen : true,
		request: {},
		toRelate: {},
		idbQueue:[],
		idbQ:{},
		idbQ2:{},
		nestScp : {},
		nestScpId : 1, 
		getAdapter: function(obj){
			if(obj.name == "application"){
				return store.adapter[obj.name];
			}
			if(obj.model || obj.name){
				var model = obj.model || store.model[obj.name];
				if(model && model.extend){
					if(!store.adapter.hasOwnProperty(model._name)){
						return store.adapter[model.extend];
					}
				}
				var name = model ? model._name : obj.name;
				return store.adapter[name];
			}
		},
		registerModel: function(name,fields,options){
			if(store.model.hasOwnProperty(name)){
				Lyte.warn("LD14", "Model", name);
				Lyte._postRegister();
				return { error : Lyte.getErrorMessage("LD14","Model",name)  , extends : function(){}}
			}
			try{
				var extend,actions,idb,gql,sort,deprecate;
				if(options && typeof options == "object"){
					extend = options.extends || undefined;
					actions = options.actions || undefined;
					idb = options.idb || undefined;
					gql = options.gql || undefined;
					sort = options.sort || undefined;
					deprecate = options.deprecate || undefined;
				}
				if(extend){
					var parentFields = Object.assign({},store.model[extend].fieldList);
					for(var key in parentFields){
						if(parentFields[key].type == "relation"){
							delete parentFields[key];
						}
					}
					fields = Object.assign(fields, parentFields);
				}
				var model = store.model[name] = new Model(name, fields);
				if(extend){
					store.$.extendModel(extend, model);
				}
				if(actions){
					model.actions = actions;
				}
				if(idb){
					model.idb = idb;
				}
				if(gql){
					model.gql=gql;
				}
				if(sort){
					model.sort=sort
					model.cT = new Map();
				}
				if(deprecate){
					if(!Array.isArray(deprecate)){
						deprecate = [deprecate];
					}
					var mp = new Map();
					deprecate.forEach(function(itm){
						if(!mp.has(itm)){
							mp.set(itm, 1);
						}
					});
					model.deprecate = mp;
				}
				Lyte._postRegister();
			}
			catch(e){
				Lyte._postRegister();
			}
			return model;
		},
		changePersist: function(record, value){
			if(!record.$.isUnloaded || record.$.isPeristed !== value){
				switch(value){
					case true: {
						if(!record.$.isNew && !record.$.isModified && !record.$.isDeleted){
							store.$.cmpSet(record.$, "isPersisted", true);
						}
						break;
					}
					case false: {
						if(record.$.isNew || record.$.isModified || record.$.isDeleted || (record.$.dN && Object.keys(record.$.dN) && Object.keys(record.$.dN).length)){
							store.$.cmpSet(record.$, "isPersisted", false);
						}
						break;
					}
				}
			}
		},
		getFromCB: function(type, name, key){
				var scp = store[type], extend; 
				if(/^(adapter|serializer)$/.test(type) && store.model.hasOwnProperty(name) && store.model[name].extend){
					extend = store.model[name].extend;
				}
				var obj = scp && scp.hasOwnProperty(name) ? scp[name] : (extend && scp.hasOwnProperty(extend) ? scp[extend] : undefined), 
				result = obj ? obj[key] : undefined;
				while(result === undefined){
					if(obj && obj.$super){
						obj = obj.$super;
						result = obj ? obj[key] : undefined;
					}
					else{
						if(!obj){
							obj = scp.application;
						}
						if(obj && obj.hasOwnProperty(key)){
							result = obj[key];
						}
						else{
							if(type == "adapter"){ 
								switch(key){
									case "host":{
										result = window.location.origin ? window.location.origin : window.location.protocol+"//"+window.location.host;
										break;
									}
									case "namespace": {
										result = "";
										break;
									}
									case "actionNamespace":{
										result = "action";
										break;
									}
									case "batchNamespace":{
										result = "batch";
										break;
									}
									default:
										result = undefined;	
								}
								break;
							}
							else{
								break;
							}							
						}
						if(!obj && !result){
							break;
						}
					}
				}
				return result;
		},
		newCB : function(type, self, name, attrs, opts){
			self.__extendedBy = [];
			for(var key in attrs){
				self[key] = attrs[key];
			}
			store.$.extendOptions(opts, type, name, self, store);
			store.$.lazyExtend(type, self, name);
			store.$.defProp(self, "is", type);
			store.$.defProp(self, "__name", name);
		},
		extendOptions : function(opts, type, name, self, scope){
			if(opts && opts.mixins && opts.mixins.length){
				opts.mixins.forEach(function(item){
					if(Lyte.Mixin.exists(item)){
						var mixin = Lyte.registeredMixins[item];
						for(var key in mixin){
							self[key] = mixin[key];
						}
					}
					else{
						Lyte.$.requiredMixins(item,{"name":name,"scope":scope}, type);
					}
				});
			}
			var services = opts ? opts.services : [];
			store.$.extendService(services, type, name, self, scope);
			if(Lyte.toBeInjectedServices){
				var tbServ = Lyte.toBeInjectedServices, arr = [];
				for(var key in tbServ){
					arr.push({as:key, service: tbServ[key]});
				}
				store.$.extendService(arr, type, name, self, scope, true);				
			}
		},
		extendService : function(services, type, name, self, scope, isGlobal, data){
			Lyte.extendService({services: services, type:type, name:name, ins: self, isGlobal:isGlobal, data:data, callback : function(serv, key, name, sname){
				Lyte.$.lazyRegisterService(isGlobal?serv: Lyte.$.instantiateService(sname), {scope: scope, type:type, name:name, key:key});
			}});
		},
		lazyExtend : function(type, self, name){
			var scope = store[type];
			if(scope.__toAddSuper && scope.__toAddSuper.hasOwnProperty(name)){
				var addSuper = scope.__toAddSuper[name];
				for(var i=0; i<addSuper.length; i++){
					var child = scope[addSuper[i]];
					if(child && child.is == type){
						child.$super = self;
						self.__extendedBy.push(addSuper[i]);
						var index;
						if(name != "application")
						{	
							if(scope.__toAddSuper.application)
							{
								index = scope.__toAddSuper.application.indexOf(child.__name);
								if(index > -1)
								{
									scope.__toAddSuper.application.splice(index,1);
								}
							}
							if(scope.application)
							{
								index = scope.application.__extendedBy.indexOf(child.__name);
								if(index > -1)
								{
									scope.application.__extendedBy.splice(index,1);
								}
							}
						}
					}
				}
				delete scope.__toAddSuper[name];
			}
		},
		cbDef: function(cls, type){
			Object.defineProperties(cls.prototype, {
				"super" : {
					value: function value(){
						return store.$.super.call(this,arguments);
					}
				},
				"extends" : {
					value: function value(name){
						store.$.extendCallback.call(this,store,type,name);
					}
				}
			});
		},
		changeRelPkMaps : function(data, oldPk, newPk, type, changedField){
			var model = data.$.model;
			var relations = model.relations;
			for(var key in relations){
				var rels = relations[key], relsLen = rels.length;
				for(var i=0; i<relsLen; i++){
					var itm = rels[i];
					var attr = itm.relKey, relType = itm.relType, inv;
					if(data.hasOwnProperty(attr)){
						var relRec = data[attr], 
						bMod = store.model[itm.relatedTo], 
						inv, 
						isSortDef;
						if(bMod){
							inv = store.$.getBackwardRel(model,itm,bMod);
							if(inv && inv.relType == "hasMany"){
								isSortDef = inv.opts && inv.opts.sort && inv.opts.sort.sortFn && inv.opts.sort.observes;
								if(relType == "belongsTo" && Lyte.isRecord(relRec)){
									switch(type){
										case "sort":
										case "srtObsChk": {
											if(relRec && Array.isArray(relRec[inv.relKey])){
												if(type == "sort"){
													if(isSortDef && inv.opts.sort.observes.indexOf(changedField) != -1){
														store.$.handleArrOp(relRec[inv.relKey], "sort");
													}
												}
												else if(changedField !== inv.relKey){
													return true;
												}
											}
											break;
										}
										default: {
											relRec[inv.relKey] && relRec[inv.relKey]._recMap && relRec[inv.relKey]._recMap.delete(oldPk) ? relRec[inv.relKey]._recMap.set(newPk, data) : undefined;
										}
									}
								}
								else if(relType == "hasMany" && Array.isArray(relRec)){
									var relRecLen = relRec.length;
									for(var l=0;l<relRecLen;l++){
										var rec = relRec[l];
										switch(type){
											case "sort":
											case "srtObsChk": {
												if(rec && Array.isArray(rec[inv.relKey])){
													if(type == "sort"){
														if(isSortDef && inv.opts.sort.observes.indexOf(changedField) != -1){
															store.$.handleArrOp(rec[inv.relKey], "sort");
														}
													}
													else if(changedField !== inv.relKey){
														return true;
													}
												}
												break;
											}
											default: {
												Lyte.isRecord(rec) && rec[inv.relKey] && rec[inv.relKey]._recMap && rec[inv.relKey]._recMap.delete(oldPk) ? rec[inv.relKey]._recMap.set(newPk, data) : undefined;
											}
										}
									}
								}
							}
						}
					}
				}
			}
			var _rels = data.$._relationships;
			for(var md in _rels){
				var mdObj = _rels[md];
				var mdlIns = store.modelFor(md);
				for(var attr in mdObj){
					var arr = mdObj[attr];
					var fldObj = mdlIns.fieldList[attr];
					var isSortDef = fldObj.opts && fldObj.opts.sort && fldObj.opts.sort.sortFn && fldObj.opts.sort.observes;
					var arrLen = arr.length;
					for(var j=0; j<arrLen; j++){
						var rec = arr[j];
						var relData = rec[attr];
						if(Array.isArray(relData)){
							switch(type){
								case "sort":
								case "srtObsChk": {
									if(Array.isArray(relData)){
										if(type == "sort"){
											if(isSortDef && fldObj.opts.sort.observes.indexOf(changedField) != -1){
												store.$.handleArrOp(relData, "sort");
											}
										}
										else if(changedField !== fldObj.relKey){
											return true;
										}
									}
									break;		
								}
								default : {
									relData._recMap && relData._recMap.delete(oldPk) ? relData._recMap.set(newPk, data) : undefined;
								}
							}
						}
					}
				}
			}
		},
		updateNestScp:function(record, oldPk){
			if(Lyte.isRecord(record)){
				var scpObj = record.$.__scpObj || {};
				for(var key in scpObj){
					var val = scpObj[key];
					val = val.split("_")[0];
					if(Lyte.nestScp && Lyte.nestScp.hasOwnProperty(val) && Lyte.nestScp[val].model){
						var mp1 = Lyte.nestScp[val].model.get(record.$.model._name);
						if(mp1.has(oldPk)){
							var val = mp1.get(oldPk);
							mp1.delete(oldPk);
							mp1.set(record.$.pK, val);
						}
						// Lyte.nestScp[val].pK = record.$.pK;
					}
				}
			}
		},
		getDefaultVal : function(rec, defVal){
			if(typeof defVal != "function"){
				return defVal;
			}
			else{
				return defVal.call(rec);
			}
		},
		deepValueChange:function(rec, attr, value, changeObj){
			var toEmit = {emit : false, attr : [], oldRec : {}};
			store.$.estAttrs(rec, attr, value, toEmit, changeObj);
			store.$.checkAttrs(rec);
			store.$.changeCallbck(rec, toEmit);
		},
		updateDn:function(record){
			var model = record.$.model;
			var relations = model.relations;
			for(var key in relations){
				var rels = relations[key];
				rels.forEach(function(itm){
					var options = itm.opts, attr = itm.relKey, relType = itm.relType ;
					if(options && options.deepNest){
						if(record.hasOwnProperty(attr)){
							var relRec = record[attr];
							if(relType == "belongsTo" && (relRec.$.isModified || (relRec.$.dN && Object.keys(relRec.$.dN).length ))){
								store.$.setDeepNest(record, attr, relRec.$.pK, "updated")
							}
							else if(relType == "hasMany" && Array.isArray(relRec)){
								relRec.forEach(function(rec){
									if(rec.$.isModified || (rec.$.dN && Object.keys(rec.$.dN).length)){
										store.$.setDeepNest(record, attr, rec.$.pK, "updated")
									}
								});
							}
						}
					}
				});
			}
		},
		genUnRedoStack : function(){
			var obj = {};
			store.$.defProp(obj, "_order_", [], false);
			return obj;
		},
		deepCopyStack : function(stack){
			if(stack && typeof(stack) == "object"){
				stack = Object.assign({},stack);
				for(var attr in stack){
					if(Array.isArray(stack[attr])){
						var arr = stack[attr] = Array.from(stack[attr]);
						arr.forEach(function(itm,idx){
							arr[idx] = Object.assign(itm);
						});
					}
				}
			}
			return stack;
		},
		deepCopyAttrs:function(model,obj){
			var fields = model.fieldList;
			var obj = Object.assign({},obj);
			for(var attr in obj){
				var _attr = obj[attr];
				if(fields[attr] && fields[attr].type == "relation" && Array.isArray(_attr)){
					_attr = obj[attr] = Array.from(_attr);
					_attr.forEach(function(itm, idx){
						_attr[idx] = Object.assign({}, itm);
						itm.hasOwnProperty("records") && itm.records ? (itm.records = Array.from(itm.records)) : undefined;
						itm.hasOwnProperty("_indices") && itm._indices ? (itm._indices = Array.from(itm._indices)) : undefined;
					});
				}
			}
			return obj;
		},
		// 1 index -> delete [0,2,a,4,5,6,7,8,9,10] '1' -> 1 index            
		// 2 index -> delete [0,2,4,5,6,7,8,9,10]   'a' -> 2 index
		// a index -> delete [0,2,4,6,7,8,9,10]	  	'5' -> a index
		// 2 index -> delete [0,2,4,7,8,9,10]	   	'6' -> a index 
		// 1 index -> delete [0,4,7,8,9,10]		  	'2' -> 1 index
		// 5 index -> delete [0,4,7,8,9]         	'10' -> 5 index
		// insert -> 5 -> add [0,4,7,8,9,11]

		// algo 
		// 1) to find the current index -> check the later items for lesser index. Minus the current index when the below item's index is less than it
		// 2) after rollbacking, check the later items for the same or higher index and increment it

		// case 1) rollback number 5 -> it should go in position 2
		// a - 1 - 1 = 1 
		// [ 0,4,5,7,8,9,11 ] 
		// 1 -> 1 , a -> 2, 6 -> a + 1, 2 -> 1 , 10 -> 5 + 1

		// case 2) rollback number a -> it should go in position 1
		// 2 - 1 = 1   
		// [ 0,a,4,5,7,8,9,11 ]
		// 1 -> 1 , 6 - > 4 + 1 , 2 -> 1 , 10 -> 6 + 1

		// case a) rollback number 6 -> it should go in position 4
		// 5 - 1
		// [ 0,a,4,5,6,7,8,9,11 ]
		// 1 -> 1 , 2 -> 1, 10 -> 7 + 1
		
		// case 4) rollback 10 -> it should go in position 8 
		// 8 
		// [ 0,a,4,6,7,8,9,10,11 ]

		addTo_Del: function(model, data, ind){
			var deleted = model._deleted = model._deleted || new Map();
			var obj = { index : ind , data : data };
			deleted.set(data.$.pK, obj);
 		},
		scExtd: function(type, name, opts, parent){
			var scope = type == "adapter" ? store.adapter : store.serializer;
			if(!name){
				return;
			}
			if(scope.hasOwnProperty(name)){
				Lyte.warn("LD14",type,name);
				return { error : Lyte.getErrorMessage("LD14",type,name)  , extends : function(){}}
			}
			if(type == "adapter"){
				scope[name] = new Adapter(opts,parent,name);
			}
			else{
				scope[name] = new Serializer(opts,parent,name);
			}
			if(scope.application && name != "application")
			{
				scope[name].$super = scope.application;
				scope.application.__extendedBy.push(name);
			}
			if(!scope.application && name != "application")
            {
                scope.__toAddSuper = scope.__toAddSuper || {};
                     if(!scope.__toAddSuper.hasOwnProperty("application")){
                        scope.__toAddSuper.application = [];   
                     }
                     scope.__toAddSuper.application.push(name);
            }
			return scope[name];
		},
		initCB : function(type, modelName, key, obj){
			var scope =  store.$.cbScp(modelName, key, type), args = obj.args, ret = {};
			if(scope){
				ret.data = store.$.cB(scope, args);
				return ret;
			}
		},
		cB:function(callback,args){
			return callback.func.apply(callback.scope, args.concat(callback.name));
 		},
		cbScp:function(name, key, type){
			var scope = store[type], 
		 	callback, 
			application = scope.application,
			extend;
			if(/^(adapter|serializer)$/.test(type) && store.model.hasOwnProperty(name) && store.model[name].extend){
				extend = store.model[name].extend;
			}
			var layer = scope && scope.hasOwnProperty(name) ? scope[name] : (extend && scope.hasOwnProperty(extend) ? scope[extend] : undefined);
			while(callback == undefined){
				if(layer && layer[key] && typeof layer[key] == "function"){
					return {scope : layer, func : layer[key], name: key};
				}
				else if(layer && layer.$super){
					layer = layer.$super;
				}
				else if(application && application[key] && typeof application[key] == "function"){
					return {scope : application, func : application[key] , name : key};
				}
				else{
					return undefined;
				}
			}
		},
		comparePk : function(rec, pkVal){
			var pK = rec.$.pK;
			var pkType = typeof pK;
			if(pkType == "string" || pkType == "number"){
				return pK === pkVal;
			}
			else if(typeof pK == "object"){
				var len = Object.keys(pK).length, i=0;
				for(var key in pK){
					if(pK[key] === pkVal[key]){
						i++;
					}
				}
				return len === i;
			}
		},
		getpKVal : function(record, model){
			var model = model ? model : record.$.model;
			var arr = model._arrPk;
			if(arr.length == 1){
				return record[arr[0]];
			}
			else{
				var obj = {};
				arr.forEach(function(item){
					obj[item] = record[item];
				});
			}
			return obj;
		},
		unredoOp: function(type,rec,attr){
			var stack, revStack;
			if(type == 1){
				stack = rec.undoStack;
				revStack = rec.redoStack;
			}
			else{
				stack = rec.redoStack;
				revStack = rec.undoStack;
			}
			var attrs=[], obj, revObj = {};
			if(attr){
				if(!Array.isArray(attr)){
					attrs=[attr];
				}
				else{
					attrs = attr;
				}
				attrs.forEach(function(item){
					if(stack[item].length){
					var len = stack._order_.length;
					for (var index=len-1;index>=0;index--){
						var order = stack._order_[index];
						var attrIndex = order.indexOf(item);
						if(attrIndex > -1){
							order.splice(attrIndex,1);
								if(!order.length){
									stack._order_.splice(index,1);
								}
								break;
							}
						}
					}
				});
			}
			else{
				attrs = stack._order_ && stack._order_.length ? stack._order_.pop() : attrs;
			}
			if(attrs.length){
				for(var index=0;index<attrs.length;index++){
					var key=attrs[index], obj = stack[key].pop();
					if(obj._type == "update"){
						if(obj.hasOwnProperty("val")){
							store.$.setData(rec,key,obj.val,undefined,revObj);
							// redoObj[key] = undo;
						}
						else if(obj.hasOwnProperty("records")){
							store.$.setData(rec,key,obj.records,undefined,revObj)	
						}
					}
					else if(type == 1 && obj._type == "propAdd"){
						if(typeof Lyte != "undefined"){
							revObj[key] = {_type:"propDelete", val:rec.record[key]};
							if(obj.hasOwnProperty("val")){
								store.$.setData(rec,key,obj.val,undefined,{});
								// redoObj[key] = undo;
							}
							if(Lyte.objectUtils){
								Lyte.objectUtils(rec.record, "delete", key);
							}
							else{
								delete rec.record[key];
							}
						}
						else{
							delete rec.record[key];
						}
					}
					else if(type == 2 && obj._type == "propDelete"){
						revObj[key] = {_type:"propAdd"}
						store.$.setData(rec,key,obj.val,undefined,revObj);
					}
					else if(obj._type == "added"){
						rec.record.$.get(key).remove(obj.records,undefined,revObj);
					}
					else if(obj._type == "removed"){
						store.$.rllBckRecArr([obj], rec.record, rec.model, rec.model.fieldList[key])
						obj._type = "added";
						revObj[key] = obj;
					}
				}
				var keys = Object.keys(revObj);
				for(var index=0;index<keys.length;index++){
					var key = keys[index];
					revStack[key] = revStack[key] || [];
					revStack[key].push(revObj[key]);
				}
				if(keys.length){
					// rec.redoStack._order_ = rec.redoStack._order_ || [];
					revStack._order_.push(keys);
				}
			}
		},
		// undo: function(rec){
		// 	var obj = rec.undoStack.pop(),undo, redoObj = {};
		// 	if(obj){
		// 		for(var key in obj){
		// 			var undo = obj[key];
		// 			if(undo._type == "update"){
		// 				if(undo.hasOwnProperty("val")){
		// 					store.$.setData(rec,key,undo.val,redoObj)
		// 				}else if(undo.hasOwnProperty("records")){
		// 					store.$.setData(rec,key,undo.records,redoObj)	
		// 				}
		// 			}
		// 			else if(undo._type == "propAdd"){
		// 				if(typeof Lyte != "undefined"){
		// 					redoObj[key] = {type:"propDelete", val:rec.record[key]};
		// 					Lyte.objectUtils(rec.record, "delete", key);
		// 				}
		// 				else{
		// 					delete rec.record[key];
		// 				}
		// 			}
		// 			else if(undo._type == "added"){
		// 				rec.record.$.get(key).remove(undo.records,undefined,redoObj);
		// 			}
		// 			else if(undo._type == "removed"){
		// 				store.$.rllBckRecArr([undo], rec.record, rec.model, rec.model.fieldList[key])
		// 				undo._type = "added";
		// 				redoObj[key] = undo;
		// 			}
		// 		}
		// 		rec.redoStack.push(redoObj);				
		// 	}
		// },
		unregisterModel : function(name,inherit){
			var model = store.modelFor(name);
			if(!model){
				Lyte.warn("LD02","Model ",name);
				return;
			}
			if(model.data.length){
				store.unloadAll(name,undefined,inherit);
			}
			var extendedBy = model.extendedBy;
			if(extendedBy && Object.keys(extendedBy).length){
				for(var ext in extendedBy){
					store.unregisterModel(ext,inherit);
				}
			}
			var extend = model.extend;
			if(extend){
				var extMod = store.modelFor(extend);
				delete extMod.extendedBy[name];
			}
			delete store.model[name];  
			store.__mdlPrx ? delete store.__mdlPrx[name] : undefined;
		},
		getDsrzEmpData : function(field, modelName){
			if(field.hasOwnProperty("deserializeEmptyData")){
				return field.deserializeEmptyData;
			}
			else{
				var desrz = store.$.getFromCB("serializer", modelName, "deserializeEmptyData");
				if(desrz !== undefined){
					return desrz;
				}
			}
			return false;
		},
		updateFieldValidation:function(model, key, deserialize, ignoreValidation){
			var records = model.data;
			var fields = model.fieldList;
			records.forEach(function(item){
				var field = fields[key];
				if(deserialize){
					var empD = store.$.getDsrzEmpData(field, model._name);
					var boolChk = !empD && item[key]
					if(item.hasOwnProperty(key) && (boolChk || empD) && Lyte.Transform.hasOwnProperty(field.type) && Lyte.Transform[field.type].hasOwnProperty("deserialize")){
						item[key] = Lyte.Transform[field.type].deserialize(item[key],key,model._name,store.$.getpKVal(item,model));
					}
				}
				if(!ignoreValidation){
					var isOldVal = item.$.error && item.$.error.hasOwnProperty(key) && item.$.error[key].hasOwnProperty("value") ? true : false;
					var oldVal = isOldVal ? item.$.error[key].value : undefined;
					store.$.clrRecErr(item.$, key);
					isOldVal ? store.$.validateField(item, key, field, undefined, {old:true, value:oldVal}) : store.$.validateField(item, key, field, undefined)
				}
				if(isOldVal && item.$.error && Object.keys(item.$.error) === 0){
					item.$.set(key, oldVal);
				}
			});
		},
		validateRelatedRecord:function(record, key, field){
			var fields = store.model[field.relatedTo].fieldList;
			if(field && field.opts && record && record.hasOwnProperty(key)){
				if(field.opts && field.opts.serialize == "record"){
					if(field.relType == "belongsTo" && Lyte.isRecord(record[key])){
						return this.validateRecord( record[key], fields);
					}
					else if(field.relType == "hasMany"){
						if(Array.isArray(record[key])){
							var ret = true, result, self = this;
							record[key].forEach(function(item, index){
								if(Lyte.isRecord(item)){
									result = self.validateRecord(item, fields);
									if(result === false){
										ret = false;
									}
								}
							});
							return ret;
						}
					}
				}
			}
		},
		validateRecord:function(record, fields , validateCallBack){
			var result, ret = true, returnVal , validationErrors ={};
			for(var field in fields){
				returnVal = this.validateField(record, field, fields[field], result ,undefined,validateCallBack , validationErrors);
				if(ret === true && returnVal === false){
					ret = false;
				}
			}
			if(validateCallBack){
				var res = validateCallBack.apply(record.$ ,[validationErrors])
				if(res && typeof res == "object"){
					for (var e in res){
						store.$.setRecErr(record.$ , e , res[e])
					}
				}
				else if (res == true){
					return true;
				}
			}
			if(ret === false || (record.$.isError === true && record.$.error && Object.keys(record.$.error).length)){
				return false;
			}
			return true;
		},
		validateField : function(record, key, field, result, obj ,validateCallBack,validationErrors){
			var val = obj && obj.old ? obj.value : record[key], ret, err = record.$, clear , opts;
			if(validateCallBack && err.error[key]){
				val = obj = err.error[key].value;
				opts = { 
					skipValidation : true
				};
			}
			if(field.type == "relation"){
				ret = this.validateRelatedRecord(record, key, field);
				if(ret === false){
					result = false;
					return result;
				}
			}
			else if(field.mandatory && !record.$.error.hasOwnProperty(key) && (val === undefined || val === "" || (Array.isArray(val) && val.length === 0) )){
				if(validateCallBack){
					validationErrors[key] = {code : "ERR02", message : Lyte.errorCodes.ERR02, value : val}
				}
				else{
					store.$.setRecErr(err, key, {code : "ERR02", message : Lyte.errorCodes.ERR02, value : val});
				}
			}
			else{
				clear = true;
				if( obj || (record.hasOwnProperty(key) && !record.$.error.hasOwnProperty(key))){
					var _field = field;
					if(!(_field.any && Array.isArray(_field))){
						_field = [_field];
					}
					var fldLen = _field.length, _ret = true;
					for(var i=0; i<fldLen; i++){
						var _fld = _field[i];
						for(var property in _fld){
							var resp = Lyte.checkProperty(property, val, key, _fld[property], _fld, record, undefined, Lyte.isRecord(record) ? record.$.model._name : undefined);
							if(resp !== true){
								if(_ret === true){
									if(typeof resp == "object"){
										resp.value = val; 
									}
									_ret = resp; 
									// store.$.setRecErr(err,key,resp);
									// clear = false;
								}
								//err[field] = resp;
								break;
							}
						}   
					}
					if(_ret !== true){
						if(validateCallBack){
							validationErrors[key] = _ret;
						}
						else{
							store.$.setRecErr(err,key,_ret);
						}
						clear = false;
					}
					if(obj && clear){
						store.$.setData(record.$ , key , val , opts)
					}
					if(clear){
						store.$.clrRecErr(err, key);
					}		
				}
			}
		},
		partialData:function(rec, key, pK, type, polymorphicType, partRemoveOnly){
			var arr = rec[key];
			if(!arr || !Array.isArray(arr)){
				return true;
			}
			if(!arr.partial){
				store.$.defPar(arr);
			}
			var partial = arr.partial = arr.partial || new Map();
			if(!partial.get(pK)){
				partial.set(pK, {});
			}
			var revert = false;
			var obj = partial.get(pK);
			var objType = obj.type;
			switch(objType){
				case "added":{
					if(type == "removed"){
						partial.delete(pK);
						revert = true;
					}
					break;
				}
				case "removed":{
					if(type == "added"){
						if(rec[key]._recMap){
							var relRec = rec[key]._recMap.get(pK);
						} 
						if(!relRec || (Lyte.isRecord(relRec) && !relRec.$.isDirty())){
							partial.delete(pK);
							revert = true;
						}
						else{
							var obj = partial.get(pK);
							obj.type = "modified";
						}
					}
					break;
				}
				case "modified":
				case "updated":{
					if(type == "added"){
						//this case mostly won't come. if at all it comes, break
						break;
					}
				}
				default:{
					if(!partRemoveOnly){
						var pObj = { type : type };
						polymorphicType ? pObj.polymorphicType = polymorphicType : undefined;
						partial.set(pK, pObj);
					}
					else{
						partial.delete(pK);
						revert = true;
						
					}
				}
			}
			if(revert && !partial.size){
				if(!partial.size){
					store.$.deleteDeepNest(rec, key, pK);
				}
				return true;
			}
		},
		removeParentNesting:function(rec, type, ignorePartial){
			var model = rec.$.model;
			var pkVal = rec.$.pK;
			var rels = model.relations;
			for(var key in rels){
				var relations = rels[key];
				relations.forEach(function(item){
					var inv, deep, part, invRecs;
					//store.$.getRelations(model, item.relKey, store.model[item.relatedTo], rel);
					var bMod = store.model[item.relatedTo];
					if(bMod){
						inv = store.$.getBackwardRel(model, item, bMod);
						//inv = rel.backward;
						if(inv && inv.opts){
							deep = inv.opts.deepNest;
							part = inv.opts.hasOwnProperty("serialize");
							if(!item.relKey || (item == inv)){
								invRecs = store.$.getRelatedRecord(rec,item.relatedTo,item.dummy?item.dummy:item.relKey);
							}
							else{
								invRecs = rec[item.relKey];
							}
						}
						// if(deep){
						// 	if(Array.isArray(invRecs)){
						// 		invRecs.forEach(function(item){
						// 			if(Lyte.isRecord(item)){
						// 				store.$.deleteDeepNest(item, inv.relKey, pkVal);
						// 			}
						// 		});
						// 	}
						// 	else if(Lyte.isRecord(invRecs)){
						// 		store.$.deleteDeepNest(invRecs, inv.relKey, pkVal);
						// 	}
						// }
						if(part && !ignorePartial){
							if(invRecs && !Array.isArray(invRecs)){
								invRecs=[invRecs];
							}		
							if(Array.isArray(invRecs)){
								invRecs.forEach(function(invItm){
									if(inv.relKey){	
										if(inv.relType == "belongsTo" && invItm && invItm.$){
											if(invItm.$.partial && invItm.$.partial[inv.relKey] && invItm.$.partial[inv.relKey].has(pkVal)){
												invItm.$.partial[inv.relKey].delete(pkVal);
												if(!invItm.$.partial[inv.relKey].size){
													delete invItm.$.partial[inv.relKey]; 
												}
											}
											deep ? store.$.deleteDeepNest(invItm, inv.relKey, pkVal) : undefined;
										}
										else if(inv.relType == "hasMany"){
											var invArr = invItm[inv.relKey];
											if(Array.isArray(invArr)){
												if(invArr.partial && invArr.partial.has(pkVal)){
													var _ptype = invArr.partial.get(pkVal).type;
													if(type == "modified"){
														if(/^(modified|updated)$/.test(_ptype)){
															invArr.partial.delete(pkVal);
														}	
													}
													else{
														invArr.partial.delete(pkVal);
													}
													// else{
													// 	if(!/^added$/.test(_ptype) && !invItm[inv.relKey]._recMap.get(pkVal)){
													// 		invArr.partial.delete(pkVal);
													// 	}
													// }
												}
												deep ? store.$.deleteDeepNest(invItm, inv.relKey, pkVal) : undefined;
											}
										}
									}
								});
							}

							// if(invRecs && !Array.isArray(invRecs)){
							// 	invRecs=[invRecs];
							// }
							// if(Array.isArray(invRecs)){
							// 	invRecs.forEach(function(item){
							// 		var partData = inv.relKey ? item[inv.relKey] : undefined; 
							// 		if(partData && partData.partial && partData.partial.get(pkVal)){
							// 			var _ptype = partData.partial.get(pkVal).type;
							// 			if(type == "modified"){
							// 				if(/^(modified|updated)$/.test(_ptype)){
							// 					partData.partial.delete(pkVal);
							// 				}
							// 			}
							// 			else{
							// 				partData.partial.delete(pkVal);
							// 			}
							// 		}
							// 	});
							// }	
						}
					}
				});
			}
		},
		deleteDeepNest:function(rec, key, pkVal){
			var deepNest = rec.$.dN;
			if(deepNest){
				if(deepNest[key] && pkVal === undefined){
					delete deepNest[key];
				}
				else if(deepNest[key] && deepNest[key].get(pkVal)){
					deepNest[key].delete(pkVal);
					if(!deepNest[key].size){
						delete deepNest[key];
					}
				}
				if(!Object.keys(deepNest).length){
					delete rec.$.dN;
					if(!rec.$.isModified && !rec.$.isNew){
						store.$.removeParentNesting(rec);
					}
					store.$.changePersist(rec, true);
				}
			}
		},
		// createJSON:function(record, fields, err, validateOnSave){
		// 	for(var field in fields){
		// 		var val = record[field], fieldKeys = fields[field];
		// 		if(fieldKeys.type == "relation"){
		// 			continue;
		// 		}
		// 		if(!record.$.validatedOnCreate || validateOnSave){
		// 			if(fieldKeys.mandatory && !record.$.error.hasOwnProperty(field) && (val == null || val == undefined || val === "" || (Array.isArray(val) && val.length == 0) )){
		// 					store.$.setRecErr(err,field,{code : "ERR02", message : Lyte.errorCodes.ERR02});
		// 					//err[field] = {code : "ERR02", message : Lyte.errorCodes.ERR02};
		// 			}
		// 			else{
		// 				clear = true;
		// 				if(record.hasOwnProperty(field) && !record.$.error.hasOwnProperty(field)){
		// 					for(var property in fieldKeys){
		// 						var resp = Lyte.checkProperty(property, record[field], field, fieldKeys[property]);
		// 						if(resp != true){
		// 							store.$.setRecErr(err,field,resp);
		// 							clear = false;
		// 							//err[field] = resp;
		// 							break;
		// 						}
		// 					}
		// 					if(clear){
		// 						store.$.clrRecErr(err, field);
		// 					}		
		// 				}
		// 			}							
		// 		}
		// 	}
		// },
		updateJSON:function(record, model, dirty){
			var data = {};
			var arrPk = model._arrPk;
			var dirtyAttr = record.$._attributes;
			for(var field in dirtyAttr){
					data[field] = record[field];
			}
			var attrs = dirty;
			if(dirty == true){
				attrs = store.$.isDirty(record, model.relations) || [];
			}
			for(var i=0;i<attrs.length;i++){
				data[attrs[i]] = record[attrs[i]];
			}
			arrPk.forEach(function(item){
				data[item] = record[item];
			});
			return data;
		},
		removeDeepNest:function(record){
			if(!Lyte.isRecord(record)){
				return;
			}
			var bool1 = record.$.dN && Object.keys(record.$.dN).length;
			if(bool1){
				record.$.dN = {};
				var model = record.$.model;
				var relations = model.relations;
				for(var key in relations){
					var rels = relations[key];
					rels.forEach(function(item){
						var opts = item.opts;
						if(opts && (opts.deepNest || opts.serialize == "partial")){
							var data = record[item.relKey];
							if(Array.isArray(data)){
								data.forEach(function(itm){
									if(Lyte.isRecord(itm)){
										store.$.removeDeepNest(itm);
										if(!itm.$.isNew && !itm.$.isModified && (!itm.$.dN || ( itm.$.dN && Object.keys(itm.$.dN).length == 0 ))){
											store.$.removeParentNesting(itm);
										}
									}
								});
							}
							else if(Lyte.isRecord(data)){	
								store.$.removeDeepNest(data);
								if(!data.$.isNew && !data.$.isModified && (!data.$.dN || ( data.$.dN && Object.keys(data.$.dN).length == 0))){
									store.$.removeParentNesting(data);
								}																			
							}
						}
					});
				}			
			}
		},
		addDeepNest:function(record, extended, type, ignoreRel, mp, processOnlySrzPart){
			var relatedRecord, 
			mp = mp || new Map(),
			model = extended ? store.model[record.$.model.extend] : record.$.model,
			pK = record.$.pK,
			type = type || "updated",
			relations = model.relations;
			for(var key in relations){
				var rels = relations[key];
				rels.forEach(function(item){
					var inv , deep, part, serz, bMod = store.model[item.relatedTo];
					if(bMod){
						inv = store.$.getBackwardRel(model,item,bMod);
						if(!item.relKey || (inv === item)){
							relatedRecord = store.$.getRelatedRecord(record,item.relatedTo,item.dummy ? item.dummy: item.relKey);
						}
						else{
							relatedRecord = record[item.relKey];
						}
						if(relatedRecord){
							var mppass = false, nmp, ignoreDn;
							if(!mp.get(inv)){
								var nmp = mp.set(inv, new Map());
								mppass = true;
							}
							nmp = mp.get(inv);
							if(mppass || !nmp.get(relatedRecord)){
								nmp.set(relatedRecord, true);
								if(inv && inv.opts){
									deep = inv.opts.deepNest;
									part = inv.opts.serialize == "partial" ? true : false; 
									serz = inv.opts.serialize ? inv.opts.serialize : false;
								}
								if((type == "updated" && serz == "id")){
									ignoreDn = true;
								}
								if((!processOnlySrzPart || ( processOnlySrzPart && part)) && !ignoreDn){
									if(deep){
					//					if(deep || part){
										store.$.makeDirty("dirty",relatedRecord, type, inv, pK, mp);
									}
									if((serz && record && relatedRecord && (!ignoreRel || !(ignoreRel && ignoreRel.model === item.relatedTo && inv.relKey === ignoreRel.relKey)))){
										var data = relatedRecord;
										if(inv.relType == "hasMany"){
											if(Array.isArray(data)){
												data.forEach(function(item){
													store.$.partialData(item, inv.relKey, pK , /^(added|removed)$/.test(type) ? type : "modified");								
												});
											}
											else if(Lyte.isRecord(data)){
												store.$.partialData(data, inv.relKey, pK, /^(added|removed)$/.test(type) ? type : "modified");	
											}
										}
										else{
											if(Array.isArray(data)){
												data.forEach(function(item){
													if(type == "added" && item && item.$ && item.$.partial && item.$.partial[inv.relKey] && item.$.partial[inv.relKey].has(pK)){
														delete item.$.partial;
													}
												});
											}
											else if(Lyte.isRecord(data)){
												if(type == "added" && data && data.$ && data.$.partial && data.$.partial[inv.relKey] && data.$.partial[inv.relKey].has(pK)){
													delete data.$.partial;
												}
											}
										}
										//store.$.partialData(record[item.relKey], inv.relKey, pK , "modified");
									} 
								}
							}
						}
					} 
				});
			}
			if(model.extend){
				this.addDeepNest(record, true);
			}
		},
		getRelatedRecord:function(record,modelName,key){
			if(record){
				var relationship = record.$._relationships;
				if(relationship[modelName] && relationship[modelName][key]){
					return relationship[modelName][key];
				}
			}
		},
		makeDirty:function(name, records, type, rel, pK, mp){
			if(!(rel.opts.serialize =='id' && type =="updated")){
				var relKey = rel.relKey;
				if(Array.isArray(records)){
					records.forEach(function(item){
						store.$.setDeepNest(item, relKey, pK, type, mp);
					});
				}
				else if(Lyte.isRecord(records)){
					store.$.setDeepNest(records, relKey, pK, type, mp);
				}
			}
		},
		setDeepNest:function(item, relKey, pK, type, mp){
			var deepN = item.$.dN = item.$.dN || {};
			var deepRel = deepN[relKey] = deepN[relKey] || new Map();
			if(!deepRel.has(pK)){
				deepRel.set(pK, {});
			}
			var obj = deepRel.get(pK);
			switch(obj.type){
				case "added": {
					if(type == "removed"){
						store.$.deleteDeepNest(item, relKey, pK);
					}
					break;
				}
				case "removed": {
					if(type == "added"){
						store.$.deleteDeepNest(item, relKey, pK);
					}
					if(type == "modified"){
						obj.type = "updated";
					}
					break;
				}
				default : {
					obj.type = type;
					store.$.changePersist(item, false);
					store.$.addDeepNest(item, undefined, undefined, undefined, mp);		
				}
			}
		},
		isDirty:function(record, relations, parent, fMod){
			var result = [];
			for(var rel in relations){
				var rel_model = relations[rel];
				for(var j=0;j<rel_model.length;j++){
					var rel = rel_model[j];
					if(rel.opts && rel.opts.serialize){
						var key = rel.relKey, 
						type = rel.relType, 
						records = record[key],
						bMod = store.model[rel.relatedTo];
						if(parent && bMod){
							var child = store.$.getBackwardRel(fMod,rel,store.model[rel.relatedTo]);
							if(parent == child && fMod._name != rel.relatedTo){
								continue;
							}
						}
						if(rel.opts.serialize == "record"){
							var res = store.$.isRelDirty(rel, records, rel);
							if(res){
								result.push(key);
								continue;
							}							
						}
						else if(rel.opts.serialize == "partial"){
							if(type == "hasMany"){
								if(records && records.partial && records.partial.size){
									result.push(key);
									continue;
								}
							}
							else{
								if((Lyte.isRecord(records) && records.$.isModified) || (record && record.$ && record.$.partial && record.$.partial.hasOwnProperty(key))){
									result.push(key);
									continue;
								}
							}
						}
						if(rel.opts.deepNest){	
							if(record.$.dN && record.$.dN[key]){
								result.push(key);
							}
						}
					} 
				}
			}
			return result;
		},
		isRelDirty:function(rel, records, parent){
			var type = rel.relType;
			var fMod = store.model[rel.relatedTo];
			var relations = fMod.relations; 
			if(!store.$.isEmpty(records)){
				if(type == "hasMany" && Array.isArray(records) && records.length){
					var len = records.length;
					for(var i=0; i<len; i++){
						if(records[i].$.isModified == true){
							return true;
						}
					}
					for(var j=0; j<len; j++){
						var rec = records[j];
						var arr = this.isDirty(rec, relations, parent, fMod);
						if(arr.length){
							return true;
						}
					}
				}
				else if(type == "belongsTo" && Lyte.isRecord(records)){
					if(records.$.isModified == true){
						return true;
					}
					var arr = this.isDirty(records, relations, parent, fMod);
					if(arr.length){
						return true;
					}
				}
			}
			return false;
		},
		handleCachedResponse:function(batch,resp){
			var cached = store.$.cachedBatch = store.$.cachedBatch || {}
			var arr = cached[batch] || [], count = 0;
			arr.forEach(function(item,index){
				resp.splice((item.ind+count++),0,item.data);
			});
			delete cached[batch];
			return resp;
		},
		addToCachedBatch:function(data){
			var curr = store.$.currentBatch;
			var cached = store.$.cachedBatch = store.$.cachedBatch || {};
			var cachedB = cached[curr] = cached[curr] || [];
			var arr = store.$.batch[curr] || [];
			var ind = arr.length;
			cachedB.push({ind:ind, data:data});
		},
		establishToRelated:function(record, relArr){
			var bModel = record.$.model, rel = {};
			relArr.forEach(function(item){
				var rec = store.$.peekRecord(item.model, item.pkVal);
				if(rec){
					var fModel = rec.$.model;
					store.$.getRelations(fModel, item.key, bModel, rel);
					store.$.establishLink(rel.forward, rel.backward, rec, record, undefined, true);
				}
			});
		},
		checkObjAndAddToArr:function(arr, obj, keys){
			var len = Object.keys(keys).length, res = -1, arrLen = arr.length;
			for(var k=0; k<arrLen; k++){
				var item = arr[k];
				var i=0;
				for(var key in keys){
					if(item[key] == obj[key]){
						i++;
					}	
				}
				if(i == len){
					res = k;
					arr.splice(k,1,obj);
					return;
				}
			}
			if(res == -1){
				arr.push(obj);
			}
			return res;
		},
		addToRelate:function(modelName, data, rel, key){
			var relMod = rel.forward.relatedTo;
			var toRelMod = store.$.toRelate[relMod] = store.$.toRelate[relMod] || new Map();
			if(!toRelMod.has(key)){
				toRelMod.set(key, []);
			}
			var toRel = toRelMod.get(key);
			var pkVal = data.$.pK;
			var obj = {model : modelName, pkVal : pkVal, key : rel.forward.relKey};
			toRel.push(obj);
			// this.checkObjAndAddToArr(toRel, obj, ["record","key"]);
		},
		addOnSave:function(modelName,record,attr,field,pK,relPk){
			store.$.onSave = store.$.onSave || {};
			var saveMod = store.$.onSave[modelName] = store.$.onSave[modelName] || {};
			var saveQ = saveMod[record[pK]] = saveMod[record[pK]] || {} 
			var recs = record[attr] || [];
			if(field.relType == "belongsTo"){
				recs = !Array.isArray(record[attr]) ? [record[attr]] : record[attr]; 
			}
			recs.forEach(function(item){
				var q = saveQ[field.relKey] = saveQ[field.relKey] || [];
				store.$.checkAndAddToArray(q, item[relPk]);
			});
		},
		addToIDBonSave:function(modelName, rec){
			var model = store.model[modelName];
			var fields = model.fieldList;
			var saveMod = store.$.onSave ? store.$.onSave[modelName] : undefined;
			if(saveMod){
				var pK = store.model[modelName]._pK;
				var saveQ = rec && pK ? saveMod[rec[pK]] : undefined;
				if(saveQ){
					for(var key in saveQ){
						var ids = saveQ[key];
						var relMod = fields[key].relatedTo;
						ids.forEach(function(item){
							var rec = store.$.peekRecord(relMod,item);
							if(rec){
								var parent = rec.$.parent;
								if(Lyte.isRecord(parent)){
									var mod = parent.$.model;
									var modName = mod._name;
									var modPk = mod._pK;
									store.$.checkAndAddToIDBQ(modName, "updateRecord", store.$.peekRecord(modName,parent[modPk]).$.toJSON(true));
								}
								else{
									store.$.checkAndAddToIDBQ(relMod, "updateRecord", store.$.peekRecord(relMod,item).$.toJSON(true));
								}
							}
						});
					}
					store.$.removeOnSave(modelName, rec[pK]);
				}
			}
		},
		removeOnSave:function(modelName, pkVal){
			var saveMod = store.$.onSave ? store.$.onSave[modelName] : undefined;
			if(saveMod && saveMod[pkVal]){
				delete saveMod[pkVal];
			}
		},
		checkAndAddToIDBQ:function(modelName, type, data){
			var obj = {model: modelName, type:type, data:data};
			var q = store.$.idbQ2[modelName] = store.$.idbQ2[modelName] || [];
			q.push(obj);
		},
		checkAndRemoveKey:function(rawData, fields, deserializeKeys){
			for(var key in rawData){
				var field = fields[key];
				if(field && field.type == "relation"){
					if(deserializeKeys && !this.checkPresenceInArray(deserializeKeys,key)){
						delete rawData[key];
					}
					else{
						this.removeNotNeededKeys(field.relatedTo, rawData[key]);
					}
				} 
			}
		},
		removeNotNeededKeys:function(modelName, rawData, idbObj){
			var model = store.model[modelName];
			var fields = model.fieldList;
			var deserializeKeys = idbObj ? idbObj.deserializeKeys : undefined;
			if(model){
				var self = this;
				if(Array.isArray(rawData)){
					rawData.forEach(function(item){
						self.checkAndRemoveKey(item, fields, deserializeKeys);
					});
				}
				else{
					this.checkAndRemoveKey(rawData, fields, deserializeKeys)
				}
			}
			return rawData;
		},
		getIDBObj : function(model, queryParams, type, key, customData, modelName){
			if(model && model.hasOwnProperty('idb')){
				if(typeof model.idb == "function"){
					return model.idb.apply(model, [{model:modelName ? modelName : model._name, type:type, queryParams:queryParams, key:key, customData:customData}]);
				}
				return model.idb;
			}
		},
		idbQ2Push:function(modelName,rawData,queryParams,type,key,meta,customData){
			try{
				var model = store.model[modelName], idb = store.$.getIDBObj(model, queryParams, type, key, customData);
				if(idb){
					// if(type !== "pushPayload"){
					// 	rawData = Lyte.deepCopyObject(rawData);
					// }
					var qObj = {model:modelName,type:type,customData:customData};
					qObj.queryCache = idb.queryCache;
					var pK = model._pK;
					var q =	store.$.idbQ2[modelName] = store.$.idbQ2[modelName] || [];
					switch(type){
						case "action":{
							delete q[type];
							return;
						}
						case "update":
						case "create":{
							qObj.data = []
							rawData.forEach(function(item){
								qObj.data.push(Lyte.isRecord(item)?item.$.toJSON(undefined,true):item);
							});
							break;
						}
						case "updateRecord":
						case "createRecord":{
							qObj.data = rawData;
							break;
						}
						case "delete":{
							qObj.data = rawData;
							break;
						}
						case "destroyRecord":
						case "deleteRecord":{
							qObj.id = rawData;
							break;
						}
						case "findRecord":
							qObj.key = key;		
							var newRawData = rawData[0].$.toJSON("idb");	
							var nObj = {};
							nObj[modelName] = newRawData;
							if(meta){
								nObj.meta = meta;
							}	
							if(idb.queryCache === true){
								qObj.queryParams = queryParams;
							}
							qObj.data = nObj;
							break;
						case "findAll": {
							var newRawData = [];
							rawData.forEach(function(itm){
								newRawData.push(itm.$.toJSON("idb"));
							});
							var nObj = {};
							nObj[modelName] = newRawData;
							if(meta){
								nObj.meta = meta;
							}
							// rawData[modelName] = this.removeNotNeededKeys(modelName, rawData[modelName], idb);
							if(idb.queryCache === true){
								qObj.queryParams = queryParams;
							}
							qObj.data = nObj;
							break;
						}
						case "pushPayload": {
							if(Lyte.isRecord(rawData)){
								rawData = rawData.$.toJSON("idb");
							}
							// rawData = this.removeNotNeededKeys(modelName, rawData, idb);
							qObj.data = rawData;
							break;
						}
					}
					q.push(qObj);
				}	
			}
			catch(err){
				Lyte.error("Error while adding to IDBQueue ",err);
			}
		},
		isEmpty:function(val){
			if(val != undefined && val !== "" && val != null){
				return false;
			}
			return true;
		},
		isEmptyObj: function(obj){
			if(obj !== null && typeof obj == "object" && Object.keys(obj).length == 0){
				return true;
			}
			return false;
		},
		isEmptyArray: function(arr){
			if(Array.isArray(arr) && arr.length == 0){
				return true;
			}
			return false;
		},
		registerField:function(model,key,field,obs){
			var oldField = model.fieldList[key] ? Object.assign({},model.fieldList[key]) : undefined;
			if(field.type == "observer"){
				obs.push(field);
			}
			else if(field.type == "callBack"){
				if(field.observes){
					obs.push(field.observes);
				}
				var props = field.properties;
				for(var i=0;i<props.length;i++){
					if(props[i] === "didLoad" || props[i] === "init"){
						if(!model.didLoad){
							model.didLoad = [];
						}
						model.didLoad.push(field.value);	
					}
					else if(props[i] === "add" || props[i] === "change"){
						model.on(props[i],field.value);
					}
				}
				if(key == "didLoad"){
					if(!model.didLoad){
						model.didLoad = [];
					}
					model.didLoad.push(field.value);
				}
			}
			else if(key == "didLoad"){
				if(!model.didLoad){
					model.didLoad = [];
				}
				model.didLoad.push(field);
			}
			else if(Object.keys(field).length){
				if(field.primaryKey){
					if(model.fieldList.id && model.fieldList.id.defined == false){
						delete model.fieldList.id;
					}
					if(field.hasOwnProperty("default")){
						Lyte.warn("LD23",model._name,key);
						delete field.default;
					}
					if(model._pK != undefined){
						model._pK = model._pK + "," + key;
						model.isComposite = true; 
					}
					else{
						model._pK = key;
					}
					if(field.baseKey){
						if(model.bK){
							Lyte.warn("LD26");
							return;
						}
						model.bK = key
					}	
				}
				if(model.fieldList.hasOwnProperty(key)){
					var alrPresent = true;
				}
				model.fieldList[key] = field;
				if(oldField && model._fldGrps){
					if(oldField.hasOwnProperty("default")){
						delete model._fldGrps.default[key];
					}
					if(oldField.hasOwnProperty("watch")){
						delete model._fldGrps.watch[key];
					}
					if(oldField.opts && oldField.opts.hasOwnProperty("inherit")){
						delete model._fldGrps.inherit[key];
					}
					// if(oldField.hasOwnProperty("deprecate")){
					// 	delete model._fldGrps.deprecate[key]
					// }
				}
				if(field.hasOwnProperty("default")){
					model._fldGrps.default[key] = field;
				}
				if(field && field.opts && field.opts.hasOwnProperty("inherit")){
					model._fldGrps.inherit[key] = field;
				}
				if(field.hasOwnProperty("watch") && (field.watch == true || Array.isArray(field.watch)) && /^(array|object)$/.test(field.type)){
					model._fldGrps.watch[key] = field;
				}
				if(Lyte.Transform[field.type]){
					var customDatatype = Lyte.Transform[field.type]
					if(/^(array|object)$/.test(customDatatype.extends) && customDatatype.hasOwnProperty("properties") || customDatatype.hasOwnProperty("items")){
						model._fldGrps.nested_prop[key] = field;
					}
				}
				// if(field.hasOwnProperty("deprecate")){
				// 	model._fldGrps.deprecate[key] = field;
				// }	
			}
			if(field.type === "relation"){
				field.relKey = key;
				var relTo = field.relatedTo;
				var relObj = model.fieldList[key];
				if(!model.relations[relTo]){
					model.relations[relTo] = [];
				}
				var chkObj = {};
				chkObj.relKey = relObj.relKey; 
				store.$.checkObjAndAddToArr(model.relations[field.relatedTo], relObj, chkObj);
				if(field.relType == "hasMany"){
					model._fldGrps.hasMany[key] = field;
				}
				if(field.hasOwnProperty("opts") && field.opts.hasOwnProperty("inverse")){
					model._fldGrps.inverse[relTo] = field;
				} 
			}	
		},
        setError:function(err,attr,codeObj){
            if(err.$.hasOwnProperty("error")){
				if(Array.isArray(attr)){
					attr.forEach(function(itm){
						store.$.cmpSet(err.$.error, itm, codeObj);
					});
				}
				else{
					store.$.cmpSet(err.$.error,attr,codeObj);
				}
            }
            else{
                Lyte.error("LD03",err,attr);
            }
		},  
		unRegCb:function(type,name){
			var callback = store[type][name];
			if(!callback){
				Lyte.error("LD02",type,name);
				return;
			}	
			var extendedBy = callback.__extendedBy;
			if(extendedBy.length)
			{
				store[type].__toAddSuper = store[type].__toAddSuper || {};
				if(!store[type].__toAddSuper[name])
				{
					store[type].__toAddSuper[name] = extendedBy.slice();
				}
				else
				{
					extendedBy.forEach(function(item){
						store[type].__toAddSuper[name].push(item);
					});
				}
				extendedBy.forEach(function(item){
					store[type][item].$super = undefined;
				});
				if(store[type].application && name != "application")
				{	
					var application = store[type].application;
					extendedBy.forEach(function(item){
						store[type][item].$super = application;
						store[type].application.__extendedBy.push(item);
					});
				}
				if(!store[type].application)
				{
					if(!store[type].__toAddSuper.application)
					{
						store[type].__toAddSuper.application = extendedBy.slice();
					}
					else
					{
						extendedBy.forEach(function(item){
							store[type].__toAddSuper.application.push(item);
						});
					}
				}
			}
			if(callback.$super){
				callback.$super.__extendedBy.splice(callback.$super.__extendedBy.indexOf(name),1);
			}
			delete store[type][name];
		},
        eventListeners : {
          add: function(scope,type,func){
            scope.events = scope.events || {};
            scope.events[type] = scope.events[type] || [];
            scope.events[type].push({f : func});
            return  type+"-"+(scope.events[type].length-1);              
          },
          remove: function(scope,id){
            var type;
            if(id){
                if(/^(add|remove|change)$/.test(id)){
                    type = id;
                    (scope.events && scope.events[type]) ? delete scope.events[type] : undefined;   
                }
                else{
                    var arr = id ? id.split("-") : undefined;
                    if(arr){
                        var listeners = scope.events[arr[0]];
                        if(listeners && arr[1]){
                            listeners[arr[1]] = null;
                        }   
                    }            
                }
            }else{
                var ev = scope.events;
                for(var evType in ev){
                    (ev && ev[evType]) ? delete ev[evType] : undefined;
                }
            }
          },
          emit:function(scope,type,args){
            var listeners = (scope.events && scope.events[type]) ? scope.events[type] : [];
            for(var i=0; i<listeners.length; i++){
                (listeners[i]) ? listeners[i].f.apply(null, args) : undefined;
            }            
          }
        },
        extendCallback:function(scope,type,parent){
            var callback = scope[type],addsuper;
            var res;
            if(parent && typeof parent === "string"){
                res = callback[parent];
                if(!res){
					callback.__toAddSuper = callback.__toAddSuper || {};
                     if(!callback.__toAddSuper.hasOwnProperty(parent)){
                        callback.__toAddSuper[parent] = [];   
                     }
                     callback.__toAddSuper[parent].push(this.__name);
                }
            }	
            if(res && res.is == type && (!this.$super || this.$super.__name == "application")) {
				this.$super = res;
				res.__extendedBy.push(this.__name);
				if(callback.application)
				{
					var application_extarr = callback.application.__extendedBy;
					var index = application_extarr.indexOf(this.__name);
					if(index > -1)
					{
						callback.application.__extendedBy.splice(index,1);
					}
				}
				addsuper = callback.__toAddSuper;
				if(addsuper)
				{	
					if(addsuper.application)
					{	
						var addsuper_arr =  addsuper.application;
						var index1 = addsuper_arr.indexOf(this.__name);
						if(index1 > -1)
						{
							callback.__toAddSuper.application.splice(index1,1);
						}
					}
				}
            }
            return this;            
        },
        super:function(){
        	// console.log(arguments);
        	var scope = this, parent= this.$super, name = arguments[0][0][arguments[0][0].length-1], arr=[],arg=arguments[0][0];
    		var parent_type = parent[name];
    		if(typeof parent_type == "function")
    		{	
    			delete arg[arg.length-1];
    			for (var key in arg) {
				    if (arg.hasOwnProperty(key)) {
				        arr.push(arg[key]);
				    }
				}
    			return parent_type.apply(parent,arr);
    		}
    		if(parent_type)
    		{
    			return parent_type;
    		}
        },
		extendModel:function(extend, mdl){
			var scp = mdl || this;
			if(!extend || !store.model[extend]){
				return;
			}
			var parentFields = Object.assign({},store.model[extend].fieldList);
			for(var key in parentFields){
				if(parentFields[key].type == "relation"){
					delete parentFields[key];
				}
			}
			var pkObj = {};
			var extendParentPks = scp._pK == "id" && scp.fieldList.id.defined == false ? true : false;
			for(var key in parentFields){
				var fld = parentFields[key];
				var custPk = extendParentPks && fld.primaryKey && fld.defined != false;
				if(scp.fieldList.hasOwnProperty(key) && scp._fldGrps){
					var oldField = scp.fieldList[key];
					if(oldField.hasOwnProperty("default")){
						delete scp._fldGrps.default[key];
					}
					if(oldField.hasOwnProperty("watch")){
						delete scp._fldGrps.watch[key];
					}
				}
				if(fld.hasOwnProperty("default")){
					scp._fldGrps.default[key] = fld;
				}
				if(fld.hasOwnProperty("watch") && fld.watch == true && /^(array|object)$/.test(fld.type)){
					scp._fldGrps.watch[key] = fld;
				}
				if(!fld.primaryKey){
					scp.fieldList[key] = fld;
				}
				else {
					pkObj[key] = fld;
				}				
			}
			var pkObjKeys = Object.keys(pkObj), pkObjLen = pkObjKeys.length;
			if(extendParentPks && pkObjLen){
				delete scp.fieldList.id;
				for(var key in pkObj){
					scp.fieldList[key] = pkObj[key];
				}
				if(pkObjLen == 1){
					scp._pK = pkObjKeys[0];
					scp._arrPk = Array.from(pkObjKeys);
				}
				else{
					scp.isComp = true;
					scp._arrPk = Array.from(pkObjKeys);
					scp._pK = scp._arrPk.toString();
				}
			}
			var name = scp._name;
			store.model[name].extend = extend;
			store.model[extend].extendedBy = store.model[extend].extendedBy || {};
			store.model[extend].extendedBy[name] = true;
			// if(!store.adapter[name] && store.adapter[extend]){
			// 	store.adapter[name] = store.adapter[extend];
			// }
			// if(!store.serializer[name] && store.serializer[extend]){
			// 	store.serializer[name] = store.serializer[extend];
			// }
			if(store.model[extend].actions){
				var actions = scp.actions = scp.actions || {};
				for(var key in store.model[extend].actions){
					if(!actions.hasOwnProperty(key)){
						actions[key] = store.model[extend].actions[key]; 							
					}
				}					
			}
		},
		demoLishObserverBindings: function(obj,prop,record){
			if(!record){
				record = obj;
			}
			for(key in prop){
				if(obj[key] instanceof Object){
					if(record && obj[key]._setterScope){
						var ind = obj[key]._setterScope.indexOf(record);
						ind != -1 ? obj[key]._setterScope.splice(ind, 1) : undefined;
					}
					if(Object.keys(prop[key]).length){
						this.demoLishObserverBindings(obj[key],prop[key],obj);
					}
				}
				if(obj._setterScope && obj != record){
					var inx = obj._setterScope.indexOf(record);
					inx != -1 ? obj._setterScope.splice(inx, 1) : undefined;
				}
			}
		},
		establishObserverBindings:function(obj,prop,record){
			if(!record){
				record = obj;
			}
			for(key in prop){
				if(obj[key] instanceof Object){
					if(!obj[key]._bindings){
						store.$.defProp(obj[key], '_bindings', new Set(), false, true);
                    }
					if(record && !obj[key]._setterScope){
						store.$.defProp(obj[key],'_setterScope',[]);
					}
					var ind = obj[key]._setterScope.indexOf(record);
					ind == -1 ? obj[key]._setterScope.push(record) : undefined;
					obj[key]._bindings.add(prop[key]);
					if(Object.keys(prop[key]).length){
						this.establishObserverBindings(obj[key],prop[key],obj);
					}
				}
				if(!obj._setterScope){
					store.$.defProp(obj, '_setterScope', []);
					obj._setterScope.push(obj);
				}
			}
		},
		setData:function(self, attr, value, opts, redoObj, ignoreChange,inherit,oldDN){
			var toEmit = {emit : false, attr : [], oldRec : {}};
			var model = self.model, _estObsBind = false, record = self.record, attrData;
			if(inherit && attr){
				var mfl = self.model._fldGrps.inherit;
				for(var v in mfl){
					if(self.record[mfl[v].relKey] && attr[mfl[v].relKey]){
						if(mfl[v].relType == "belongsTo" ){
							self.model._arrPk.forEach(function(_key){
								delete attr[mfl[v].relKey][_key]
							})
							this.setData(self.record[mfl[v].relKey].$,attr[mfl[v].relKey],undefined,undefined,undefined,ignoreChange,true);
							attr[mfl[v].relKey] = self.record[mfl[v].relKey].$.pK;
						}
						else{
							var len = attr[mfl[v].relKey].length
							for(var j=len-1; j>=0; j--){
								self.model._arrPk.forEach(function(_key){
									delete attr[mfl[v].relKey][j][_key];
								})
								this.setData(self.record[mfl[v].relKey][j].$,attr[mfl[v].relKey][j],undefined,undefined,undefined,ignoreChange,true);
								attr[mfl[v].relKey][j] = self.record[mfl[v].relKey][j].$.pK;
							}
						}
						//delete attr[mfl[v].relKey];
					}
				}
			}
			if(attr && typeof attr === "object"){
				attrData = [];
				opts = value;
				for(var key in attr){
					attrData.push(key);
					this.setValue(self, key, attr[key], opts, toEmit, ignoreChange,undefined,oldDN);
					model && model._properties && model._properties.hasOwnProperty(key) ? _estObsBind = true : undefined;
				}
			}
			else{
				attrData = attr;
				this.setValue(self, attr, value, opts, toEmit, ignoreChange);
				model && model._properties && model._properties.hasOwnProperty(attr) ? _estObsBind = true : undefined;
			}
			self.emit("set", [self.record, attrData]);
			self.model.emit("set", [model._name, self.record, attrData]);
			store.emit("set", [model._name, self.record, attrData]);
			if(_estObsBind){
				store.$.establishObserverBindings(record, model._properties);
			}
			if( !ignoreChange && toEmit.emit){
				store.$.changeCallbck(record, toEmit, redoObj)
			}
			return record;
		},
		changeCallbck : function(record, toEmit, redoObj){
			var arr = [record, toEmit.attr];
			var self = record.$;
			self.emit("change", arr);
			self.model.emit("change", arr);
			store.emit("change", [self.model._name,self.record, toEmit.attr]);
			if(redoObj){
				for(var key in toEmit.oldRec){
					redoObj[key] = toEmit.oldRec[key];
				}
			}
			else{
				for(var index=0;index<toEmit.attr.length;index++){
					var key = toEmit.attr[index];
					self.undoStack[key] = self.undoStack[key] || [];
					self.undoStack[key].push(toEmit.oldRec[key]);
				}
				// self.undoStack._order_ = self.undoStack._order_ || store.$.defProp(self.undoStack, "_order_", [], false, true);
				self.undoStack._order_.push(toEmit.attr); 
			}
		},
		setValue:function(self,attr,value,opts,toEmit,ignoreChange,deepChange,oldDN){
			var model = self.model, oldAttrVal, hasAttr, pK = model._pK, record = self.record;
			if(attr != model._pK){
				var field = model.fieldList[attr], watch = field && field.opts ? field.opts.watch == true : undefined;
			    var hasAttr = record.hasOwnProperty(attr),oldAttrVal = record[attr];
				if(!field){
					store.$.cmpSet( record, attr, value, undefined, true );
					return;
				}
				else if(field.mandatory && (value == undefined || value == null || value === "")){
					store.$.setRecErr(self, attr, {code : "ERR02", message : Lyte.errorCodes.ERR02, value : value});
				}
				else if(field.relType){
					var relType = field.relType;
					var rel ={},relRec, oldVal, relMod = store.modelFor(field.relatedTo), bModel = relMod, bPk = bModel._pK, relPk = relMod._pK, isComp = relMod.isComp, bPkType = isComp ? "object" : relMod.fieldList[bPk].type, relRec;
					var isComp = relMod.isComp, bPk = relMod._pK, bPkType = isComp ? "object" : relMod.fieldList[bPk].type, isPoly = field && field.opts ? field.opts.polymorphic : undefined;
					this.getRelations(model, field.relKey, relMod, rel);
					if(record[attr] && relType == "hasMany"){
						oldVal = [];
						record[attr].forEach(function(item){
							oldVal.push(item.$.pK);
						});
						if(record[attr] === value){
							return;
						}
						if(Array.isArray(value) && value.length === record[attr].length){
							var valLen = value.length,j=0, val;
							for(var i=0;i<valLen;i++){
								val = value[i];
								if(Lyte.isRecord(val)){
									relRec = val;
								}
								else {
									if(val && typeof val == bPkType){
										relRec = store.$.peekRecord((val._type) ? val._type : field.relatedTo, val);
									}else if( val && ((isComp || (isPoly && val._type )))){
										relRec =  store.$.peekRecord((val._type) ? val._type : field.relatedTo , store.$.getpKVal(val , store.modelFor((val._type) ? val._type : field.relatedTo) ))
									}
								}
								if(Lyte.isRecord(relRec) && relRec.$.record === record[attr][i]){
									j++;
								}
								else{
									break;
								}
							}
							if(j && j == valLen){
								// if(oldDN && oldDN[attr]){
								// 	if(record.$.dN == undefined){
								// 		record.$.dN = {};
								// 	}
								// 	record.$.dN[attr]=oldDN[attr];
								// }
								return;
							}
						}
						// oldVal = record[attr].slice(0);
						// oldVal1 = record[attr].mapBy(relMod._pK);
						store.$.addOnSave(model._name,record,attr,field,pK,relPk);
						var relData = Array.from(record[attr]);
						relData.forEach(function(rec){
							store.$.demolishLink(rec, relPk, record, rel.forward.relKey, undefined, undefined, undefined, true);
							if(rel.backward !== null){
								store.$.demolishLink(record, model._pK, rec, rel.backward.relKey, rel.forward);
							}
						});
						// // record[attr].splice(0, record[attr].length);
						// if(Array.isArray(record[attr]) && record[attr].length){
						// 	this.handleArrOp(record[attr], "removeAt", undefined, 0, record[attr].length);
						// }
					}
					else if(record[attr] && Lyte.isRecord(record[attr]) && relType == "belongsTo"){
						oldVal = record[attr].$.pK;
						if(Lyte.isRecord(value)){
							relRec = value;
						}
						else {
							if(value && typeof value == bPkType){
								relRec = store.$.peekRecord((value._type) ? value._type : field.relatedTo, value);
							}else if( value && ((isComp || (isPoly && value._type )))){
								relRec =  store.$.peekRecord((value._type) ? value._type : field.relatedTo , store.$.getpKVal(value , store.modelFor((value._type) ? value._type : field.relatedTo) ))
							}
						}
						if(Lyte.isRecord(relRec) && relRec.$.record === record[attr]){
							// if(oldDN && oldDN[attr]){
							// 	if(record.$.dN == undefined){
							// 		record.$.dN = {};
							// 	}
							// 	record.$.dN[attr]=oldDN[attr];
							// }
							return;
						}
						// oldVal = this.createCopy(record[attr]);
						store.$.addOnSave(model._name,record,attr,field,pK,relPk);
						// oldVal1 = record[attr][relMod._pK];
						var relRef = record[attr];
						store.$.demolishLink(relRef, relPk, record, rel.forward.relKey, undefined, undefined, undefined, true);
						if(rel.backward !== null){
							store.$.demolishLink(record, model._pK, relRef, rel.backward.relKey, rel.forward);
						}
						// record[attr] = undefined;
						store.$.cmpSet(record, attr, {}, opts, true);
					}
					if(relType == "hasMany" && store.$.isEmpty(value)){
						var partial = record[attr] && record[attr].partial ? record[attr].partial : undefined;  
						store.$.cmpSet(record, attr, [], opts, true);
						partial ? store.$.defProp(record[attr], "partial", partial) : undefined;
						store.$.establishObserverBindings(record, record.$.model._properties);
						store.$.defArrUtls(record[attr]);
						store.$.defPolyUtls(record[attr]);
						store.$.defUtls(record[attr], relMod, record, attr);	
					}
					if(!Array.isArray(value)){
						value = [value];
					}
					else if(relType == "belongsTo"){
						this.revertToOldVal(record, attr, oldVal, rel);
						store.$.setRecErr(self, attr, "ERR21", value);
						return;
					}
					var err = [];
					for(var i=0; i<value.length; i++){
						if(this.isEmpty(value[i]) || (relType == "belongsTo" && this.isEmptyObj(value[i])) || (relType == "hasMany" && this.isEmptyArray(value[i]))){
							continue;
						}
						var relRecord = value[i], relMod1 = (value[i] && value[i]._type) ? value[i]._type : field.relatedTo;
						if(!isComp && value[i] && typeof value[i] === bPkType){
							relRecord = store.$.peekRecord((value[i]._type) ? value[i]._type : field.relatedTo, value[i]);
							if(relRecord == undefined){
								this.addToRelate(model._name, record, rel, value[i]);
							}
							else if(relRecord.$ && relRecord.$.isError){
								err.push({code : "ERR15", message : Lyte.errorCodes.ERR15, error : Object.assign({}, relRecord)});
								continue;
							}
						}
						else if(value[i] && typeof value[i] == "object"){
							if(relRecord.$ && relRecord.$.isError){
								err.push({code : "ERR15", message : Lyte.errorCodes.ERR15, error : Object.assign({}, relRecord)});
								continue;
							}
							else if(!Lyte.isRecord(relRecord)){
								if(isPoly && value[i] && value[i]._type){
									relRecord = store.$.peekRecord(value[i]._type, store.$.getpKVal(value[i], store.modelFor(value[i]._type)));
								}
								else if(isComp){
									relRecord = store.$.peekRecord((value[i]._type) ? value[i]._type : field.relatedTo, value[i]);
									if(!relRecord){
										relRecord = this.newRecord(relMod1, value[i], opts? opts.skipValidation : undefined);
									}
								}
								else{
									relRecord = this.newRecord(relMod1, value[i], opts? opts.skipValidation : undefined);
								}
								if(relRecord.$.isError){
									err.push({code : "ERR15", data : value[i], message : Lyte.errorCodes.ERR15, error : Object.assign({}, relRecord)});
									continue;
								}
							}
							else{
								relRecord = relRecord.$.record;
							}
						}
						var changed = this.establishLink(rel.forward, rel.backward, record, relRecord , undefined, ignoreChange ? true : undefined);
						if(changed != true){
							err.push({code : changed, data : value[i], message : Lyte.errorCodes[changed]});
						}
						else{
							store.$.addOnSave(model._name,record,attr,field,pK,relPk);
						}
					}
					if(err.length && (err.length == value.length)){
						this.revertToOldVal(record, attr, oldVal, rel);
						if(field.relType == "belongsTo"){
							store.$.setRecErr(self, attr, err[0]);
						}
						else{
							store.$.setRecErr(self, attr, err);
						}
						return;
					}
					else{
						if(err.length > 1){
							store.$.setRecErr(self, attr, err);
						}
						else{
							store.$.clrRecErr(self, attr);
						}
						if(!ignoreChange){
							var _attrs = record.$._attributes; 
							if(!_attrs.hasOwnProperty(attr)){
								_attrs[attr] = [];
							}
							_attrs[attr].push({_type : "changed", records : oldVal});
							toEmit.emit = true;
							toEmit.attr.push(attr);
							var obj = {}; obj.records = oldVal; obj._type = "update";
							toEmit.oldRec[attr] = obj;
							var arr = record.$.getInitialValues(attr), changed = true;
							if(arr && Array.isArray(record[attr]) && arr.length == record[attr].length){
								changed = false;
								for(var i=0; i<arr.length; i++){
									if(!store.$.comparePk(record[attr][i], arr[i])){
										changed = true;
										break;
									}
								}
							}
							if(!changed){
								delete _attrs[attr];
							}
						}
					}
				}
				else{
					if(value !== record[attr]){
						// if(field && field.type !== Lyte.getDataType(value) && (value !== undefined  || field.type === "boolean")) {
						// 	value = Lyte.typeCast(value, field.type);
						// }
						if(!opts || (opts && opts.skipValidation !== true)){
							var _field = field;
							if(!(_field.any && Array.isArray(_field))){
								_field = [_field];
							}
							var fldLen = _field.length, _ret = true;
							for(var i=0; i<fldLen; i++){
								var _fld = _field[i];
								for(var property in _fld){
									var resp = Lyte.checkProperty(property, value, attr, _fld[property], _fld, record, undefined, model._name);
									if(resp !== true){
										if(_ret === true){
											if(typeof resp == "object"){
												resp.value = value;
											} 
											_ret = resp;
										}
									}
								}
							}
							if(_ret !== true){
								store.$.setRecErr(self, attr, _ret);
								return;
							}
						}		
						if(!ignoreChange){
							store.$.estAttrs(record, attr, value, toEmit, deepChange, opts);
						}
						else{
							var customDtype = false;
							if(Lyte.Transform[field.type]){
								var customDatatype = Lyte.Transform[field.type]
								if(customDatatype.hasOwnProperty("properties") || customDatatype.hasOwnProperty("items")){
									customDtype=true;
								}
							}
							if((watch && /^(array|object)$/.test(field.type)) || customDtype ){
								Lyte.establishObjectBinding(record, attr, true);
							}
							store.$.cmpSet(record,attr,value,opts, true);
						}
					}
					else if(value === record[attr] && record.$.isError && record.$.error[attr]){
						var valid = true, _field = field;
						if(!(_field.any && Array.isArray(_field))){
							_field = [_field];
						}
						var fldLen = _field.length, _ret = true;
						for(var i=0; i<fldLen; i++){
							var _fld = _field[i];
							for(var property in _fld){
								var resp = Lyte.checkProperty(property, value, attr, _fld[property], _fld, record, undefined, model._name);
								if(resp !== true){
									_ret = false;
								}
							}
						}
						if(_ret !== true){
							valid = false;
						}
						if(valid){
							store.$.clrRecErr(self,attr);
						}
					}
				}
				store.$.checkAttrs(record);
			}
			else{
				if(record[attr] !== value){
					store.$.setRecErr(self, attr, "ERR01", value);
				}
			}
		},
		estAttrs: function(record, attr, value, toEmit, deepChange, opts){
			var _attrs = record.$._attributes; 
			var model = record.$.model;
			var attribute = _attrs[attr];
			var isAttrPres = _attrs.hasOwnProperty(attr);
			if( !isAttrPres){
				_attrs[attr] = deepChange ? deepChange.data : this.createCopy(record[attr]);
			}
			else if((( deepChange && Lyte.cmpData(isAttrPres ? attribute : deepChange.data, record[attr])) || (value && typeof value == "object" && ( !deepChange && store.adapter.$.compareObjects(attribute, value))) || (attribute == value))){
				delete _attrs[attr];
			}
			var hasAttr = record.hasOwnProperty(attr);
			var oldAttrVal = deepChange ? deepChange.data : record[attr];
			if(!deepChange){
				var isPropPresent = model._properties && model._properties.hasOwnProperty(attr), propObj = {};
				if(isPropPresent){
					propObj[attr] = model._properties[attr];
					store.$.demoLishObserverBindings(record, propObj);
				}
				store.$.cmpSet(record,attr,value,opts, true);
			}
			store.$.clrRecErr(record.$, attr);
			if(record.$.srtObs){
				store.$.changeRelPkMaps(record, undefined, undefined, "sort", attr);
			}
			var obj = {};
			obj._type = "update";
			obj.val = oldAttrVal;
			if(!hasAttr){
				obj._type = "propAdd";
			}
			toEmit.emit = true;
			toEmit.attr.push(attr);
			toEmit.oldRec[attr] = obj;
		},
		checkAttrs:function(record){
			var model = record.$.model;
			if( Object.keys(record.$._attributes).length ){
				store.$.cmpSet(record.$, "isModified", true);
				store.$.changePersist(record, false);
				store.$.addDeepNest(record);
				this.checkAndAddToArray(model.dirty, record.$.pK);
			}
			else{
				store.$.cmpSet(record.$, "isModified", false);
				store.$.changePersist(record, true);
				if(!record.$.isNew && (!record.$.hasOwnProperty("dN") || (record.$.dN && !Object.keys(record.$.dN).length))){
					store.$.removeParentNesting(record);                    
				}
				if(!record.$.isNew){
					this.deleteFromArray(model.dirty, record.$.pK);
				}
			}
		},
		checkForCorrectRelation:function(rel,record){
			var relatedTo = rel.relatedTo;
            if(!Lyte.isRecord(record)){
                return false;
            }
			if(rel.opts && rel.opts.polymorphic){
				return (record.$.model.extend ? rel.relatedTo === record.$.model.extend : false);
			}
			return (rel && record ? relatedTo === record.$.model._name : false);
		},
        removeKeys:function(fieldList,record){
            for(var key in record){
                if(!fieldList.hasOwnProperty(key)){
                    delete record[key];
                }
                else{
                    var field = fieldList[key];
                    if(field.type === "belongsTo" || field.type === "hasMany" && record[key]){
                        this.removeNotDefinedKeys(field.relatedTo,record[key], (field.opts && field.opts.polymorphic) ? true: undefined);
                    }
                }
            }
        },
		removeNotDefinedKeys:function(model,records,polymorphic){
			var fieldList = model.fieldList;
			if(Array.isArray(records)){
				for(var i=0; i<records.length; i++){
					var record = records[i];
					this.removeKeys((polymorphic)?(Lyte.isRecord(record)?record.$.model.fieldList:fieldList):fieldList,record);
				}				
			}
			else{
                this.removeKeys((polymorphic)?(Lyte.isRecord(records)?records.$.model.fieldList:fieldList):fieldList,records);
			}
		},
		add:function(value,type,opts,redoObj){
			var record= this.record.$.record, model = record.$.model, attr = this.key, field = model.fieldList[attr], rel = {};
			var oldArr;
			store.$.getRelations(model, field.relKey, store.modelFor(field.relatedTo), rel);
			if(!Array.isArray(value)){
				value = [value];
			}
			var relMod = store.modelFor(rel.forward.relatedTo);
			var pK = relMod._pK, err = [], arr = [], isComp = relMod.isComp;
			if(record.$._attributes.hasOwnProperty(attr) && record.$._attributes[attr].length){
				oldArr = record.$.getInitialValues(attr);
			}
			for(var i=0; i<value.length; i++){
				var rec = value[i];
				if(isComp){
					if(typeof rec == "object" && Object.keys(rec).length === relMod._arrPk.length){
						if(this.polymorphic && !type){
							err.push({code : "ERR22", data : value[i], message : Lyte.errorCodes.ERR22});
							continue;
						}
						rec = store.$.peekRecord((type) ? type : rel.forward.relatedTo, rec);	
					}
				}
				if((!isComp && relMod.fieldList[pK].type.toLowerCase() == typeof rec) || (isComp && typeof rec == "object" && Object.keys(rec).length === relMod._arrPk.length) ){
					if(this.polymorphic && !type){
						err.push({code : "ERR22", data : value[i], message : Lyte.errorCodes.ERR22});
						continue;
					}
					rec = store.$.peekRecord((type) ? type : rel.forward.relatedTo, rec);
				}
				else if(typeof rec == "object" && !Lyte.isRecord(rec)){
					rec = store.$.newRecord((rec._type) ? rec._type : type ? type : field.relatedTo, rec, opts?opts.skipValidation:undefined);
				}
				var polyType = this.polymorphic && type ? type : ((rec && rec._type) ?rec._type: undefined);
				if(rec == undefined){
					err.push({code : "ERR13", data : value[i], message : Lyte.errorCodes.ERR13});
				}
				else if(rec.$ && rec.$.isError){
					err.push({code : "ERR15", data : value[i], message : Lyte.errorCodes.ERR15, error : rec});
				}
				else if(Lyte.isRecord(rec) && !store.$.hasDuplicateRelation(rec, record[attr], pK, polyType, relMod)){
					rec = rec.$.record;
					var resp = store.$.establishLink(rel.forward, rel.backward, record, rec);
					if(resp != true){
						err.push({code : resp, data : value[i], message : Lyte.errorCodes[resp]});
					}
					else{
						arr.push(rec);
					}
				}
			}
			if(arr.length){
				var _attrs = record.$._attributes; 
                if(!_attrs[attr]){
					_attrs[attr] = [{_type : "added", records : arr}];
					store.$.cmpSet(record.$, "isModified", true);
					store.$.changePersist(record, false);
					// record.$.isModified = true;
					store.$.checkAndAddToArray(model.dirty, record[model._pK]);
				}
				else if(store.$.hasRecordsArrayChanged(record, attr, oldArr)){
					_attrs[attr].push({_type : "added", records : arr});
				}
				else{
					delete record.$._attributes[attr];
					if(!Object.keys(record.$._attributes).length){
						store.$.cmpSet(record.$, "isModified", false);
						store.$.changePersist(record, true);

						// record.$.isModified = false;
						delete _attrs[attr];
						if(!record.$.isNew){
							store.$.deleteFromArray(model.dirty, record.$.pK);
							if(!record.$.dN || (record.$.dN && !Object.keys(record.$.dN).length)){
								store.$.removeParentNesting(record);
							}			
						}
					}
				}
                store.$.emit("change", record, [attr]);
				var obj = {_type:"added", records: arr};
				if(redoObj){
					redoObj[attr] = obj; 
				}
				else{
					var stackObj = {};
					stackObj[attr] = obj;
					record.$.undoStack[attr] = record.$.undoStack[attr] || [];
					record.$.undoStack[attr].push(obj);
					// record.$.undoStack._order_ = record.$.undoStack._order_ || [];
					record.$.undoStack._order_.push([attr]);
				}
			}
			if(err.length > 0){
				store.$.setRecErr(record.$, attr, err);
			}
			else{
				store.$.clrRecErr(record.$, attr);
			}
			return record;
		},
		remove:function(key,type,redoObj){
			var record = this.record.$.record, model = record.$.model, attr =  this.key, field = model.fieldList[attr], rel = {};
			var oldArr;
			store.$.getRelations(model, field.relKey, store.modelFor(field.relatedTo), rel);
			if(!Array.isArray(key)){
				key = [key];
			}
			var relMod = store.modelFor(rel.forward.relatedTo);
			var pK = relMod._pK, isComp = relMod.isComp, err = [], relatedRecord, arr = [], indices = [];
			if(record.$._attributes.hasOwnProperty(attr) && record.$._attributes[attr].length){
				oldArr = record.$.getInitialValues(attr);
			}
			for(var i=0; i<key.length; i++){
				var rec = key[i], polyType;
				if((!isComp && relMod.fieldList[pK].type.toLowerCase() == typeof key[i]) || (isComp && typeof rec == "object" && Object.keys(rec).length === relMod._arrPk.length)){
					if(this.polymorphic == true && !type){
						err.push({code : "ERR22", data : key[i], message : Lyte.errorCodes.ERR22});
						continue;
					}
					relatedRecord = store.$.peekRecord((type)?type:rel.forward.relatedTo,key[i]);
					polyType = type;
				}
				else if(Lyte.isRecord(key[i])){
					relatedRecord = key[i].$.record;
					polyType = type ? type : ((relatedRecord && relatedRecord._type) ? relatedRecord._type : undefined);
				}
				if(relatedRecord){
					var index = store.$.getIndex(record[attr], pK, relatedRecord.$.get(pK),polyType);
					store.$.demolishLink(relatedRecord, pK, store.$.peekRecord(model._name, record.$.pK), rel.forward.relKey, undefined, undefined, undefined, true);
					if(rel.backward != null){
						store.$.demolishLink(record, model._pK, store.$.peekRecord((polyType)?polyType:rel.forward.relatedTo, relatedRecord.$.pK), rel.backward.relKey, rel.forward);
					}
					arr.push(relatedRecord);
					indices.push(index);
				}
			}
			if(arr.length){
				var _attrs = record.$._attributes; 
				if(!_attrs[attr]){
					_attrs[attr] = [{_type : "removed", records : arr, _indices : indices}];
					store.$.cmpSet(record.$, "isModified", true);
					store.$.changePersist(record, false);

					// record.$.isModified = true;
					store.$.checkAndAddToArray(model.dirty, record[model._pK]);
				}
				else if(store.$.hasRecordsArrayChanged(record, attr, oldArr)){
					_attrs[attr].push({_type : "removed", records : arr, _indices : indices});
				}
				else{
					delete record.$._attributes[attr];
					if(!Object.keys(record.$._attributes).length){
						store.$.cmpSet(record.$, "isModified", false);
						store.$.changePersist(record, true);

						// record.$.isModified = false;
						delete _attrs[attr];
						if(!record.$.isNew){
							store.$.deleteFromArray(model.dirty, record.$.pK);								
							if(!record.$.dN || (record.$.dN && !Object.keys(record.$.dN).length)){
								store.$.removeParentNesting(record);
							}			
						}
					}
				}
				store.$.emit("change", record, [attr]);
				var obj = {_type:"removed", records: arr, _indices : indices};
				if(redoObj){
					redoObj[attr] = obj; 
				}
				else{
					var stackObj = {};
					stackObj[attr] = obj;
					// record.$.undoStack.push(stackObj);
					record.$.undoStack[attr] = record.$.undoStack[attr] || [];
					record.$.undoStack[attr].push(obj);
					// record.$.undoStack._order_ = record.$.undoStack._order_ || [];
					record.$.undoStack._order_.push([attr]); 
				}
			}
			if(err.length > 0){
				store.$.setRecErr(record.$, attr, err);
			}
			else{
				store.$.clrRecErr(record.$, attr);
			}
		},
		filter:function(record,filObj,len){
			var j=0;
			for(var key in filObj){
				if(record[key] === filObj[key]){
					j++;
				}
			}
			if(j === len){
				return true;
			}
		},
		filterBy : function(obj){
			var len = Object.keys(obj).length, j = 0, arr = [];
			for(var i=0; i<this.length; i++){
				if(store.$.filter(this[i],obj,len)){
					arr.push(this[i]);
				}
			}
			if(!arr.filterBy){
				store.$.defArrUtls(arr);
				store.$.defUtls(arr,this.model);
			}
			return arr;
		},
		idbSerialize: function(data, rel, model, bModel, pkVal, expose){
			var relTo = rel.forward.relatedTo, pK = model._pK, bPk = bModel._pK;
			if(Array.isArray(data)){
				data.forEach(function(item, index){
					if(Lyte.isRecord(item) && item.$.inIDB){
						data[index] = item[bPk];										
					}
					else if(!store.$.checkPresenceInArray(store.$.recStack[relTo],item[bPk])){
						store.$.removeBackwardRel(item, rel, pK, pkVal, true);
						store.$.removeSelfCircularReference(bModel._name, item, expose);
					}
					else{
						data[index] = item[bPk];										
					}
				});
			}
			else if(data && Lyte.isRecord(data)){
				if(Lyte.isRecord(data) && data.$.inIDB){
					data[rel.relKey] = data[bPk];
				}
				else if(!this.checkPresenceInArray(store.$.recStack[relTo],data[bPk])){
					this.removeBackwardRel(data, rel, pK, pkVal, true);
					this.removeSelfCircularReference(bModel._name, data,expose);
				}else{
					data[rel.relKey] = data[bPk];
				}
			}
		},
		idSerialize: function(obj, rel, expose, partialObj, partialRef){
			var polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined, relKey = rel.forward.relKey, relKey = rel.forward.relKey;
			var data = obj[relKey], model = store.model[rel.backward.relatedTo], bModel = store.model[rel.forward.relatedTo], pkVal = store.$.getpKVal(obj,model), modName;
			if(Array.isArray(data)){
				if(polymorphic){
					obj[relKey] = this.polymorphicToJSON(rel.forward,data);
				}
				else{
					var arr = [];
					if(partialObj){
						var partial = partialObj[relKey] = partialObj[relKey] || [], anyNew = false;
					}
					data.forEach(function(item){
						if(item.$ && item.$.isNew && expose != true && expose != "state"){
							anyNew = true;
							store.$.rSerialize(item, rel, bModel, model._pK, pkVal, expose, partial, partialRef);
							arr.push(item);													
						}
						else{
							if(partial){
								var pObj = {}, pType = "related";
								if(item.$.isDeleted){
									pType = "removed";
								}
								store.$.defProp(pObj, "$", {});
								var nPartial = 	pObj.$, nModel = rel.forward.relatedTo;
								Object.defineProperties(nPartial, {
									pkVal : {
										value : item.$.pK
									},
									type : {
										value : pType
									},
									model : {
										value : nModel
									},
									record : {
										value : store.$.peekRecord(nModel, item.$.pK)
									}
								});		
								if(item.$.isDeleted){
									pObj.$.onlyDetach = true;
								}
								partial.push(pObj);
							}
							if(item.$ && !item.$.isDeleted){
								arr.push(item.$.pK && typeof item.$.pK == "object" ? Object.assign({}, item.$.pK) : item.$.pK);
							}
						}
					});
					obj[relKey] = arr;
				}
			}
			else if(data && Lyte.isRecord(data)){
				if(data.$.isNew && expose != true && expose != "state"){
					if(partialObj){
						var partial = partialObj[relKey] = partialObj[relKey] || {};
					}
					partial = store.$.rSerialize(data, rel, bModel, model._pK, pkVal, expose, partial, partialRef);
					partialObj[relKey] = partial;
				}
				else{
					if(polymorphic){
						obj[relKey] = this.polymorphicToJSON(rel.forward,data);								
					}
					else if(!data.$.isDeleted){
						obj[relKey] = (data.$.pK && typeof data.$.pK == "object" ? Object.assign({}, data.$.pK) : data.$.pK);
					}
				}
			}
		},
		recordSerialize: function(obj, key, val, rel, model, bModel, pkVal, expose, partialObj, partialRef){
			var pK = model._pK;
			if(Array.isArray(val)){
				if(val.length == 0){
					delete obj[key];
					return 0;
				}
				val = Array.from(val);
				var partial = partialObj[key] = partialObj[key] || [];
				if(val.length){
					var toRem = [];
					for(var j=0; j<val.length; j++){
						if(val[j] && Lyte.isRecord(val[j])){
							// if(val[j].$.isDeleted){
							// 	toRem.push(j);
							// }
							// else{
								this.rSerialize(val[j], rel, bModel, pK, pkVal, expose, partial, partialRef);
							// }
							if(val[j].$.isDeleted){
								partial[j] && partial[j].$ ? partial[j].$.onlyDetach = true : undefined; 
								val.splice(j,1);
								j--;
							}
						}
					}
					if(toRem.length){
						for(var k=0; k<toRem.length; k++){
							val.splice(k, 1);
						}
					}
				}
			}
			else if(val && Lyte.isRecord(val)){
				var partial = partialObj[key] = partialObj[key] || {};
				partial = this.rSerialize(val, rel, bModel, pK, pkVal, expose, partial, partialRef);
				// if(val.$.isDeleted){
				// 	debugger
				// }
				partialObj[key] = partial;
			}
		},
		rSerialize : function(data, rel, bModel, pK, pkVal, expose, partialObj, partialRef){
			var relTo = rel.forward.relatedTo, partial, model = store.model[rel.backward.relatedTo];
			var polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined; 
			this.removeBackwardRel(data, rel, pK, pkVal);
			if(partialObj){
				var partial = {};
				var pType = data.$.isNew ? "added" : data.$.isModified ? "modified" : data.$.isDeleted ? "removed" : "related", modName;
				if(polymorphic){
					modName = data.$.model._name;
					data.$.polymorphicType = modName;
					bModel = store.model[modName];
				}
				store.$.defProp(partial, "$", {});
				var nPartial = 	partial.$;
				var nModel = polymorphic ? modName : relTo;
				Object.defineProperties(nPartial, {
					pkVal : {
						value : data.$.pK
					},
					type : {
						value : pType
					},
					model : {
						value : nModel
					},
					record : {
						value : store.$.peekRecord(nModel, data.$.pK)
					}
				});
				if(Array.isArray(partialObj)){
					partialObj.push(partial);
				}
			}
			this.removeSelfCircularReference(bModel._name, data, expose, undefined, partial, partialRef);
			return partial;
		},
		partialSerialize : function(obj, key, val, rel, model, bModel, pkVal, expose, partialObj, partialRef){
			var field = rel.forward, pK = model._pK, relTo = rel.forward.relatedTo;
			var polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined;
			if(field.relType == "hasMany"){
				if(val && val.partial){
					var part = val.partial;
					var bpK = bModel._pK;
					if(partialObj){
						partial = partialObj[key] = partialObj[key] || [];
						store.$.defProp(partial, "partial", true);
					}
					if(part){
						var pObj, pKey, newPartial,result = [], self = this;
						part.forEach(function(value , partKey){
							pObj = value, pKey = partKey , newPartial;
							if(/^(added|modified)$/.test(pObj.type)){
								var pType = "related";
								var ind = store.$.getIndex(val, bpK, pKey, undefined, store.model[relTo]);
								if(ind != -1){
									var rec = val[ind], updVal, rec$; 
									if(rec && rec.$){
										rec$ = Object.assign({}, rec.$);
										rec = Object.assign({}, rec);
										store.$.defProp(rec, '$', rec$);
									}
									updVal = rec;
									var polyType;
									if(polymorphic && rec){
										polyType =  rec._type ? rec._type : rec.$.model._name;
										bModel = store.model[polyType];
									}
									var record = store.$.peekRecord(bModel._name, pKey);
									self.removeBackwardRel(rec, rel, pK, pkVal);
									if(rec.$.isNew){
										pType = "added";
									}
									else if(rec.$.isModified){
										pType = "modified";												
										var valDir = store.$.isDirty(record, bModel.relations);
										updVal = store.$.updateJSON(rec, bModel, valDir);				
									}
									else{
										var valDir = store.$.isDirty(record, bModel.relations);
										updVal = store.$.updateJSON(rec, bModel, valDir);											
									}
									if(partial){
										var newPart = {};
										store.$.defProp(newPart, "$", {});
										var newPart$ = newPart.$; 
										var newPartModel = polymorphic ? polyType : relTo;
										Object.defineProperties(newPart$, {
											pkVal : {
												value : pKey
											},
											type : {
												value : pType
											},
											model : {
												value : polymorphic ? polyType : relTo
											},
											record : {
												value :  store.$.peekRecord(newPartModel, pKey)
											}																										
										});
										// if(partialRef){
										// 	var refId = "rec"+(++partialRef.size), refKey = partialRef.refKey;
										// 	updVal[refKey] = refId;
										// 	partialRef.set(refId, newPart);
										// }
										partial.push(newPart);
									}
									self.removeSelfCircularReference(bModel._name, updVal, expose, undefined, newPart, partialRef);			
									// var resObj = {type: pObj.type, data: updVal};
									if(Lyte.isRecord(updVal)){
										updVal.$.partialType = pObj.type;
									}
									else{
										store.$.defProp(updVal, "$", {});
										store.$.defProp(updVal.$, "partialType", pObj.type);
										if(!updVal.$.hasOwnProperty("pK")){
											store.$.defProp(updVal.$, "pK", pKey);
										}
									}
									if(polymorphic){
										updVal.$.polymorphicType = polyType;
									}
									result.push(updVal);
								}
							}
							else if(pObj.type == "removed"){
								var dObj = {};
								if(pKey && typeof pKey == "object"){
									Object.assign(dObj, Object.assign({},pKey));
								}
								else{
									dObj[bpK] = pKey;
								}
								var record = store.$.peekRecord(bModel._name, pKey) || store.$.peekRecord(bModel._name, pKey, true);
								if(partial){
									var newPart = {}; 
									store.$.defProp(newPart, "$", {});
									var newPart$ = newPart.$;
									Object.defineProperties(newPart$, {
										pkVal : {
											value : pKey
										},
										type : {
											value : "removed"
										},
										model : {
											value : polymorphic && pObj.polymorphicType ? pObj.polymorphicType : relTo
										},
										record: {
											value : record
										}																										
									});
									if(partialRef){
										var refId = "rec"+(++partialRef.size), refKey = partialRef.refKey;
										dObj[refKey] = refId;
										partialRef.set(refId, newPart);
									}
									partial.push(newPart);
								}
								store.$.defProp(dObj, "$", {});
								dObj.$.partialType = "removed";
								if(polymorphic && pObj.polymorphicType){
									dObj.$.polymorphicType = pObj.polymorphicType;
								} 
								if(!dObj.$.hasOwnProperty('pK')){
									dObj.$.pK = pKey;
								}
								// result.push({type:"removed", data: dObj})

								result.push(dObj);
							}
						});
						if(result.length){
							val = obj[key] = result;
						}
						else{
							delete obj[key];
						}
					}
				}
				else{
					delete obj[key];
				}
			}
			else if(field.relType == "belongsTo" && val && Lyte.isRecord(val)){
				var polyType;
				if(polymorphic && val){
					polyType =  val._type ? val._type : val.$.model._name;
					bModel = store.model[polyType];
				}
				this.removeBackwardRel(val, rel, pK, pkVal);
				var updVal = val, valDir;
				if(val.$.isNew){
					this.removeBackwardRel(val, rel, pK, pkVal);
				}
				else{
					valDir = store.$.isDirty(val, bModel.relations);
					updVal = store.$.updateJSON(val, bModel, valDir);
				}
				if(partialObj){
					var partial = partialObj[key] = partialObj[key] || {};
					var pType = val.$.isNew ? "added" : val.$.isModified ? "modified" : "related";
					store.$.defProp(partial, "$", {});
					var partial$ = partial.$;
					var partMod = polymorphic ? polyType : relTo;
					Object.defineProperties(partial$, {
						pkVal : {
							value : val.$.pK
						},
						type : {
							value : pType
						},
						model : {
							value : partMod
						},
						record : {
							value : store.$.peekRecord(partMod, val.$.pK)
						}
					});
					// if(partialRef){
					// 	var refId = "rec"+(++partialRef.size), refKey = partialRef.refKey;
					// 	updVal[refKey] = refId;
					// 	partialRef.set(refId, partial);
					// }
				}
				if(polymorphic){
					updVal.$ || store.$.defProp(updVal, "$", {});
					updVal.$.polymorphicType = polyType;
				}
				this.removeSelfCircularReference(bModel._name, updVal, expose, undefined, partial, partialRef);
				val = obj[key] = updVal;
			}
		},
		removeSelfCircularReference : function(modelName, obj, expose, type, partialObj, partialRef,inherit,addNotDefinedFields){
			var model = store.model[modelName], 
			fieldList = model.fieldList, 
			extended = model.extend ? true : false, 
			pkVal = store.$.getpKVal(obj,model);
			store.$.recStack[modelName] = store.$.recStack[modelName] || []; 
			var ret = store.$.checkAndAddToArray(store.$.recStack[modelName], pkVal),
			record = store.$.peekRecord(modelName, pkVal), 
			partObj = Lyte.isRecord(record) ? record.$.partial : undefined,
			polymorphicType = obj && obj.$ ? obj.$.polymorphicType : undefined,
			recmp=new Map(),
			refId;
			recmp.set(obj,pkVal);
			if(partialRef){
				refId = "rec"+(++partialRef.size);
				var refObj = {};
				store.$.defProp(refObj, "$", {pkVal: record.$.pK, model:record.$.model._name});
				partialRef.set(refId, refObj);
			}
			var unlinkedKeys = store.$.getFromCB("serializer", modelName, "serializeEmptyRelation");
			for(var key in obj){
				var field = fieldList[key], extMod, swap = false, relTo , bModel, relType,relSlave;
				var removePk = ((type == "create"|| (Lyte.isRecord(obj) && obj.$.isNew)) && model._pK == key) ? true: false;
				if(removePk && expose != true){
					delete obj[key];
					continue;
				}
				if(!field){
					if(polymorphicType){
						extMod = store.modelFor(polymorphicType);
						field = extMod.fieldList[key];
						swap = true;
					}
					if(!addNotDefinedFields){
						delete obj[key];
					}
					continue;
				}
				if(field && field.type != "relation" && !expose  && Lyte.Transform[field.type] && Lyte.Transform[field.type].serialize && obj.hasOwnProperty(key)){			
					obj[key] = Lyte.Transform[field.type].serialize(obj[key],key,record);
					continue;
				}
				if(partObj && partObj.hasOwnProperty(key)){
					var partPload = {}, 
					bPk = store.model[field.relatedTo]._pK, doCont = false;
					partObj[key].forEach(function(item, partPk){
						if((unlinkedKeys === true || (Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey))) && field.opts && /^(id|record)$/.test(field.opts.serialize)){
							obj[key] = null;
							doCont = true;
						}
						else if(field.opts.serialize == "partial"){
							partPload[bPk] = partPk;
							store.$.defProp(partPload, "$", {});
							store.$.defProp(partPload.$, "partialType", "removed");
							store.$.defProp(partPload.$, "pK", partPk);
							obj[key] = partPload;
							doCont = true;
						}
						if(partialObj){
							var partial = partialObj[key] = partialObj[key] || {};
							store.$.defProp(partial, "$", {});
							var partial$ = partial.$;
							Object.defineProperties(partial$, {
								pkVal : {
									value : partPk
								},
								type : {
									value : "removed"
								},
								model : {
									value : field.relatedTo
								},
								parent : {
									value : record
								},
								record: {
									value: store.$.peekRecord(field.relatedTo, partPk)
								}
							});
							if(field && field.opts && /^(id|record)$/.test(field.opts.serialize)){
								Object.defineProperties(partial$, {
									onlyDetach:{
										value: true
									},
									relKey: {
										value: key
									}
								});
							}
						}
					});	
					if(doCont){
						continue;
					}
				}
				if((expose == true || expose == "state") && obj[key] && typeof obj[key] == "object" && field && field.type != "relation"){
					obj[key] = Lyte.deepCopyObject(obj[key]);
					continue;
				}
				if(expose && expose.type == "isClone"){
					if(obj[key]  && field && field.type == "relation"){
						relSlave = field.opts && field.opts.inherit?true:false;
						if(!relSlave){
							delete obj[key]
						}
					}
				}
				if(obj[key] && field && field.type == "relation"){
					relTo = field.relatedTo;
					relType = field.relType;
					relSlave = field.opts && field.opts.inherit?true:false;
					bModel = store.modelFor(relTo);
					if(bModel == undefined){
						continue;
					}
					var relKey = field.relKey, rel = {};
					if(swap){
						this.getRelations(extMod, field.relKey, bModel, rel);						
					}
					else{
						this.getRelations(model, relKey, bModel, rel);
					}
					var opts = field.opts;
					var serialize = opts ? opts.serialize : undefined, val = obj[relKey];
					if(expose == "idb"){
						store.$.idbSerialize(val, rel, model, bModel, pkVal, expose);
					}
					else if(inherit && relSlave){
						store.$.toChildJSON(relTo,relType,obj[key],key,modelName,recmp,addNotDefinedFields,expose);
						if(relType == "belongsTo"){
							obj[key]=Object.assign({},obj[key]);
							if(obj[key][store.modelFor(relTo)._pK] == pkVal && relTo == modelName){
								obj[key] = pkVal;
							}
						}
						//store.$.toChildJSON(relTo,relType,obj[key],key,modelName,recmp,modelName+"_"+pkVal);
					}
					else if( (expose && !inherit)|| (inherit && !relSlave) || serialize == "id"){
						store.$.idSerialize(obj, rel, expose, partialObj, partialRef);
					}
					else if(serialize === "record"){
						var ret = store.$.recordSerialize( obj, key, val, rel, model, bModel, pkVal, expose, partialObj, partialRef);
						if(ret == 0){
							if(relType === "hasMany" && (unlinkedKeys === true || (Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey))) && Array.isArray(record[key]) && record[key].partial && record[key].partial.size){
								var emptyArr = true;
								record[key].partial.forEach(function(pobj){
									if(pobj.type !== "removed"){
										emptyArr = false;
									}
								});
								if(emptyArr){
									obj[key] = [];
									continue;
								}
							}
						}
					}
					else if(serialize === "partial"){
						store.$.partialSerialize( obj, key, val, rel, model, bModel, pkVal, expose, partialObj, partialRef)
					}
					else{
						delete obj[relKey];
						continue;
					}
					val = obj ? obj[relKey] : undefined;
					if( val && (relType == "hasMany" && Array.isArray(val) && val.length == 0) || (relType == "belongsTo" && typeof val == "object" && Object.keys(val).length == 0)) {
						if((unlinkedKeys === true || (Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey))) && relType == "hasMany" && field.opts && /^(id|record)$/.test(field.opts.serialize)){
							obj[relKey] = [];
						}
						else{
							delete obj[relKey];
						}
					}
				}
				
			}
			if(expose == "state"){
				var fields = record.$.model.fieldList;
				for(var key in fields){
					if(!record.hasOwnProperty(key)){
						if(fields[key].type == "relation"){
							if(fields[key].relType == "hasMany"){
								obj[key] = [];
							}
							else{
								obj[key] = undefined;
							}
						}
						else{
							obj[key] = undefined;
						}
					}
				}
			}
			if(partialRef){
				var refKey = partialRef.refKey;
				obj[refKey] = refId;
			}
		},
		removeBackwardRel:function(val,rel,pK,pkVal,wholeRelKey){
			if(wholeRelKey){
				delete val[rel.backward.relKey];
				return; 
			}
			if(rel.backward != null){
				var rec = val[rel.backward.relKey];
				if(Array.isArray(rec)){
					for(var i=0; i<rec.length; i++){
						if(this.comparePk(rec[i],pkVal)){
							rec.splice(i,1);
							if(rec.length == 0){
								delete val[rel.backward.relKey];
							}
							return;
						}								
					}
				}
				else if(rec && Lyte.isRecord(rec) && this.comparePk(rec, pkVal)){
					delete val[rel.backward.relKey];
				}
			}
		},
		polymorphicToJSON : function(rel,data){
			var opts = rel.opts;
			if(opts && opts.polymorphic){
				if(Array.isArray(data)){
					var res = [];
					data.forEach(function(item){
						res.push(store.$.polyToJSON(item));
					});
					return res;
				}
				else{
					return store.$.polyToJSON(data);
				}
			}
		},
		polyToJSON : function(data){
			var polyMod = data.$.model;
			if(!polyMod.hasOwnProperty("fieldList") && polyMod._name){
				polyMod = store.model[polyMod._name];
			} 
			var pK = polyMod ? polyMod._pK : undefined, 
			poly = {}, 
			pkVal = data.$.pK;
			if(typeof pkVal == "object"){
				poly = Object.assign({}, pkVal);
			}
			else{
				poly[pK] = pkVal;
			}
			poly._type = data._type ? data._type : data.$.model._name;
			return poly;
		},
		toChildJSON: function(model,reltype,record,relKey,parent,recmp,addNotDefinedFields,expose){
			var mdl=store.modelFor(model),mdlf=mdl.fieldList,rel={},pk;
			if(!Array.isArray(record)){
				record=[record];
			}
			for(var i =0 ;i<record.length; i++){
				if(!recmp.get(record[i])){
					var pval = store.$.getpKVal(record[i],mdl);
					recmp.set(record[i],pval);
				}
				if(!addNotDefinedFields){
					for (var fldKeys in record[i]){
						if(!mdlf.hasOwnProperty(fldKeys)){
							delete record[i][fldKeys];
						}
					}
				}
				for(var s in mdl.relations){
					for(var j=0; j<mdl.relations[s].length; j++){
						var v = mdl.relations[s][j].relKey?mdl.relations[s][j].relKey:undefined;
						if(v && mdlf[v] && mdlf[v].type == "relation" && record[i][mdlf[v].relKey]){
							if(record[i][mdlf[v].relKey] && mdlf[v].opts && mdlf[v].opts.inherit){
								if(mdlf[v].relType =="hasMany" && record[i][mdlf[v].relKey]){
									for (var v1=0; v1<record[i][mdlf[v].relKey].length; v1++){
										pval=store.$.getpKVal(record[i][mdlf[v].relKey][v1],store.modelFor(mdlf[v].relatedTo));
										if(!recmp.get(record[i][mdlf[v].relKey][v1])){
											recmp.set(record[i][mdlf[v].relKey][v1],pval);
											store.$.toChildJSON(mdlf[v].relatedTo,mdlf[v].relType,record[i][mdlf[v].relKey][v1],mdlf[v].relKey,mdlf[v].relatedTo,recmp,addNotDefinedFields);
											if(typeof(record[i][mdlf[v].relKey][v1]) == "object"){
												record[i][mdlf[v].relKey][v1]=Object.assign({},record[i][mdlf[v].relKey][v1]);
											}
										 	//store.$.toChildJSON(mdlf[v].relatedTo,mdlf[v].relType,record[i][mdlf[v].relKey][v1],mdlf[v].relKey,mdlf[v].relatedTo,recmp,str);
										}
										else if(Lyte.isRecord(record[i][mdlf[v].relKey][v1])&&recmp.get(record[i][mdlf[v].relKey][v1])){
											if(typeof pval == "object"){
												record[i][mdlf[v].relKey][v1] = pval;
											}
											else{
												var robj = {};
												robj[store.modelFor(mdlf[v].relatedTo)._pK] = pval;
												record[i][mdlf[v].relKey][v1] = robj;
											}
											var newPk = {};
											newPk[store.modelFor(mdlf[v].relatedTo)._pK] = pval
											record[i][mdlf[v].relKey][v1]=(typeof pval == "object")?pval:newPk;
										}
									}
								}
								else if(mdlf[v].relType =="belongsTo" && record[i][mdlf[v].relKey]){
									pval=store.$.getpKVal(record[i][mdlf[v].relKey],store.modelFor(mdlf[v].relatedTo));
									if(!recmp.get(record[i][mdlf[v].relKey])){
										recmp.set(record[i][mdlf[v].relKey],pval);
										store.$.toChildJSON(mdlf[v].relatedTo,mdlf[v].relType,record[i][mdlf[v].relKey],mdlf[v].relKey,mdlf[v].relatedTo,recmp,addNotDefinedFields);
										record[i][mdlf[v].relKey] = Object.assign({},record[i][mdlf[v].relKey])
									}
									else{
										var newPk = {};
										newPk[store.modelFor(mdlf[v].relatedTo)._pK] = pval; 
										record[i][mdlf[v].relKey]=(typeof pval == "object")?pval:newPk;
									}
								}
								if(Object.keys(record[i][mdlf[v].relKey]).length==0){
									delete record[i][mdlf[v].relKey];
								}
							}
							else if(Lyte.isRecord(record[i][mdlf[v].relKey])||(mdlf[v].relType == "hasMany" && Lyte.isRecord((record[i][mdlf[v].relKey][0])))){
								if(!expose || (expose && expose.type!="isClone")){
									this.getRelations(mdl, mdlf[v].relKey, store.modelFor(mdlf[v].relatedTo), rel);
									store.$.idSerialize(record[i],rel,true);
								}
								else{
									delete record[i][mdlf[v].relKey]
								}
							}
						}
					}
				}
				if(Lyte.isRecord(record[i])){
					record[i]=Object.assign({},record[i]);
				}
			}
		},
		toJSONObj : function(model, data, expose, type, partial,inherit,addNotDefinedFields){
			var copyObj, pkVal, modelName = model._name, pK = model._pK;
			var inhFldLen = model._fldGrps.inherit && Object.keys(model._fldGrps.inherit).length 
			if((expose == true || expose == "state") && ( !inherit || (inherit && !inhFldLen))){
				copyObj = Object.assign({},data);
			}
			else{
				copyObj = Lyte.deepCopyObject(data)
			}
			if(Lyte.isRecord(copyObj)){
				pkVal = copyObj.$.pK;
			}
			else{
				if(store.$.getpKVal(copyObj, model)){
					if(store.$.peekRecord(modelName, store.$.getpKVal(copyObj, model))){
						pkVal = store.$.peekRecord(modelName, store.$.getpKVal(copyObj, model)).$.pK;
					}
					else{
						return;
					}
				}
				else{
					return;
				}
			}
			var partialObj = partial ? partial.obj : undefined, partialMp;
			if(partialObj && !partialObj.has(pkVal)){
				partialObj.set(pkVal,{});
				partialMp = partialObj.get(pkVal); 
			}
			this.removeSelfCircularReference(modelName, copyObj,expose,type, partialMp, partial && partial.ref ? partial.ref : undefined,inherit,addNotDefinedFields);
			if(expose == "idb"){
				this.removeNotNeededKeys(modelName, copyObj, model.idb);
			}
			return copyObj;
		},
		toJSON : function(modelName,obj,expose,type,partialObj,inherit,addNotDefinedFields){
			var copyObj, model = store.model[modelName];
			store.$.recStack = {};
			if(Array.isArray(obj)){
				var arr = [];
				for(var i=0; i<obj.length; i++){
					copyObj = this.toJSONObj(model, obj[i], expose, type, partialObj,inherit,addNotDefinedFields);
					arr.push(copyObj);
				}
				return arr;
			}
			else if(obj && (typeof obj === "object" || Lyte.isRecord(obj))){
				copyObj = this.toJSONObj(model, obj, expose, type, partialObj,inherit,addNotDefinedFields);
			}
			store.$.recStack = {};
			return copyObj;
		},
		createCopy : function(data){
			if(Array.isArray(data)){
				if(data.save){
					var arr = [];
					for(var i=0; i<data.length; i++){
						var rec = Lyte.deepCopyObject(data[i]);
						arr.push(rec);
					}
					return arr;
				}
			}
			else if(data && ( Lyte.isRecord(data) || typeof data == "object")){
				return Lyte.deepCopyObject(data);
			}
			return data;
		},
		compareRecords  : function(a,b,pK,type,model){
			var pK = model._arrPk;
			if(Lyte.isRecord(a) && Lyte.isRecord(b) && pK.length){
				if(type && a._type && type !== a._type){
					return false;
				}
				var pkLen = pK.length;
				for(var i=0;i<pkLen;i++){
					var itm = pK[i];
					if(a[itm] && b[itm] && a[itm] !== b[itm]){
						return false;
					}
				}
				return true;
			}
			return false;
		},
		hasRecordInArray : function(array,record,pK,type,isComp){
			if(Lyte.isRecord(record) && pK){
				var len = array.length;
				for(var i=0; i<len; i++){
					var itm = array[i];
					if(type && itm._type !== type){
						continue;
					}
					if(isComp){
						if(this.compareRecords(itm, record, pK, undefined, record.$.model)){
							return true;
						}
					}
					else{
						if((type && itm._type && type === record._type && itm[pK] === record[pK]) || (itm[pK] === record[pK])){
							return true;
						}
					}
				}
			}
			return false;
		},
		hasDuplicateRelation : function(toRelate,relation,pK,type,model){
			var isComp = model.isComp;
			if(Array.isArray(relation)){
				if(!isComp && !relation.isPolymorphic && relation._recMap){
					return relation._recMap.get(toRelate[pK]);
				}
				else{
					return this.hasRecordInArray(relation, toRelate, pK, type, isComp);
				}
			}
			else if(relation && Lyte.isRecord(relation)){
				return this.compareRecords(toRelate, relation, pK, type, model);
			}
			return false;
		},
		checkPresenceInArray : function(arr,value){
			return arr && arr.some(function(val){
				return val === value;
			});
		},
		checkAndAddToArray : function(arr,value){
			if(!this.checkPresenceInArray(arr,value)){
				arr.push(value);
			}else{
				return -1;
			}
		},
		deleteFromArray : function(arr,value){
			var ind = arr.indexOf(value);
			if(ind != -1){
				arr.splice(ind,1);
			}
		},
		genPk : function(pK, opts, fields){
			var pkType;
			pK.forEach(function(item){
				pkType = fields[item].type;
				var random = opts[item] = Math.floor(Math.random()*100000 + 1);
				if(pkType == "string"){
					opts[item] = random.toString();                    
				}
			});
		},
		generateRandomPk:function(model, opts, pK, fields){
			this.genPk(pK, opts, fields);
			while(this.isDuplicateRecord(model, opts, pK.toString())){
				this.genPk(pK, opts, fields);
			}            
		},      
		pkPresence:function(opts, pK){
			var result = true;
			pK.forEach(function(item){
				if(!opts.hasOwnProperty(item) || !opts[item] ){
					result = false;
					return;
				}
			});
			return result;
		},
		newRecord:function(name, opts, withoutValidation){
			var model = store.modelFor(name);
			if(model === undefined){
				Lyte.warn("LD02", "Model", name);
				var err = new error1(undefined, undefined, Lyte.getErrorMessage("LD02", "Model", name));
				return err;
			}				
			if(opts === undefined){
				opts = {};
			}
			if(opts && typeof opts !== "object"){
				Lyte.warn("LD25", opts);
				var err = new error1(undefined, undefined, Lyte.getErrorMessage("LD25", opts));
				return err;
			}
			var fields = model.fieldList, record = {}, errorObj = new error1();
			var pK = model._arrPk;
			if(!this.pkPresence(opts, pK)){
                this.generateRandomPk(model, opts, pK, fields)
			}
			else if(this.isDuplicateRecord(model, opts, pK)){
                store.$.setError(errorObj, pK, {code : "ERR16", message : Lyte.errorCodes.ERR16})
			}
			for(var field in fields){
				var fieldKeys = fields[field];
				if(fieldKeys.relType == "hasMany"){
					record[field] = [];
				}
				var val = opts[field];     
				var fldType = fieldKeys.type;
				if(fldType != "relation"){
					if(val === undefined || val === ""){
						if(fieldKeys.hasOwnProperty("default")){
							val = record[field] = store.$.getDefaultVal(record, fieldKeys.default);
						}
					}
					// if(fldType !== Lyte.getDataType(val) && (val !== undefined  || fldType === "boolean")) {
					// 	val = Lyte.typeCast(val, fldType);
					// }		
					if(!withoutValidation){
						var _field = fieldKeys;
						if(!(_field.any && Array.isArray(_field))){
							_field = [_field];
						}
						var fldLen = _field.length, _ret = true;
						for(var i=0; i<fldLen; i++){
							var _fld = _field[i];
							for(var property in _fld){
								var resp = Lyte.checkProperty(property, val, field, _fld[property], _fld, opts, record, name);
								if(resp != true){
									if(_ret === true){
										if(typeof resp == "object"){
											resp.value = val;
										}
										_ret = resp;
									}
									// store.$.setError(errorObj,field,resp);
									// break;
								}
							}
						}
						if(_ret !== true){
							store.$.setError(errorObj,field,_ret);
						}
					}	
				}    
			}
			for(var opt_key in opts){
				record[opt_key] = opts[opt_key];
			}
			record = new Record(name, record);
			store.$.cmpSet(record.$, "isNew", true);
			store.$.changePersist(record, false);
			// record.$.isNew = true;
			var relations = model.relations;
			for(var key in relations){
				var relation = relations[key];
				for(var i=0; i<relation.length; i++){
					var relObj = relation[i];
					var relKey = relObj.relKey;
					var polymorphic = relObj.opts ? relObj.opts.polymorphic : undefined; 
					if(record && record[relKey]){
						var optsRelVal = opts[relKey];
						record[relKey] = undefined;
						// Reflect.set(record, relKey, undefined, false);
						var fieldKeys = relation[i], rel = {}, resp = this.getRelations(model, fieldKeys.relKey, store.modelFor(fieldKeys.relatedTo), rel),ingore=false;
						if(resp != true){
							store.$.setError(errorObj,fieldKeys.relKey,{code : resp, data : relation, message : Lyte.errorCodes[resp]});
							continue;
						}
						var bModel = store.modelFor(fieldKeys.relatedTo), bPk = bModel._pK , isComp = bModel.isComp, bPkType = !isComp ? bModel.fieldList[bModel._pK].type : undefined;
						if(!Array.isArray(optsRelVal)){
							optsRelVal = [optsRelVal];
						}
						else if(relation[i].relType == "belongsTo"){
							store.$.setError(errorObj,fieldKeys.relKey,{code : "ERR21", data : optsRelVal, message : Lyte.errorCodes.ERR21});
							continue;
						}
						errorObj[fieldKeys.relKey] = [];
						for(var j=0; j<optsRelVal.length; j++){
							var relRecord = undefined, relMod = fieldKeys.relatedTo, ind;
							if(optsRelVal[j] && Lyte.isRecord(optsRelVal[j])){
								relRecord = optsRelVal[j].$.record;
							}
							else if(isComp && typeof optsRelVal[j] == "object"){
								var ind = store.$.getIndex(bModel.data, bPk, store.$.getpKVal(optsRelVal[j], bModel));
								if(ind != -1){
									relRecord = bModel.data[ind];
								}
								else{
									if(polymorphic){
										if(optsRelVal[j] && optsRelVal[j].hasOwnProperty("_type")){
											relMod =  optsRelVal[j]._type;
										}
										else{
											store.$.setError(errorObj, fieldKeys.relKey, {code : "ERR22", data : optsRelVal[j], message : Lyte.errorCodes.ERR22});
											continue;		
										}
									}
									relRecord = this.newRecord(relMod, optsRelVal[j]);									
								}
							}
							else if(optsRelVal[j] && typeof optsRelVal[j] == bPkType.toLowerCase()){
								relRecord = store.$.peekRecord(relMod, optsRelVal[j]);
							}
							else if(optsRelVal[j] && typeof optsRelVal[j] == "object"){
								if(polymorphic){
									if(optsRelVal[j] && optsRelVal[j].hasOwnProperty("_type")){
										relMod =  optsRelVal[j]._type;
									}
									else{
										store.$.setError(errorObj, fieldKeys.relKey, {code : "ERR22", data : optsRelVal[j], message : Lyte.errorCodes.ERR22});
										continue;		
									}
								}
								relRecord = this.newRecord(relMod, optsRelVal[j]);
								// ingore = true;
							}
							if(relRecord && relRecord.$ && relRecord.$.isError){
								store.$.setError(errorObj, fieldKeys.relKey,{code : "ERR15", data : optsRelVal[j], message : Lyte.errorCodes.ERR15, error : Object.assign({}, relRecord)});
								continue;
							}
							if(relRecord && relRecord.$ && !relRecord.$.isError){
								resp = this.establishLink(rel.forward, rel.backward, record, relRecord, undefined, ingore);
								if(resp != true){
									store.$.setError(errorObj,fieldKeys.relKey,{code : resp, data : optsRelVal[j], message : Lyte.errorCodes[resp]});
								}							
							}
						}
						if(errorObj[fieldKeys.relKey].length == 0){
							delete errorObj[fieldKeys.relKey];
						}
						if(relation[i].relType == "hasMany"){
							var fieldkey = relKey;
							if(record[fieldkey] == undefined){
								// Reflect.set(record, fieldkey, [], false);
								record[fieldkey] = [];
							}
							if(!record[fieldkey].add){
								if(polymorphic){
									store.$.defProp(record[fieldkey], "polymorphic", true);
								}
								store.$.defArrUtls(record[fieldkey]);
								store.$.defUtls(record[fieldkey], store.modelFor(relation[i].relatedTo),record,fieldkey);
								store.$.defPolyUtls(record[fieldkey]);
							}
						}
					}
				}
			}
			if(errorObj && errorObj.$ && Object.keys(errorObj.$.error).length > 0){
				return errorObj;
			}
			var toRel = store.$.toRelate[model._name], pkVal = record.$.pK;
			if(toRel && toRel.has(pkVal)){
				store.$.establishToRelated(record, toRel.get(pkVal));
				toRel.delete(pkVal);
			}
			if(model.didLoad){
				var callBack = model.didLoad;
				for(var i=0;i<callBack.length;i++){
					callBack[i].apply(record);				
				}
			}
			this.handleArrOp(model.data,"push",record);
			this.checkAndAddToArray(model.dirty, record.$.pK);
			model.emit("add",[record]);
            store.emit("add",[model._name,record]);
			if(withoutValidation){
				record.$.validatedOnCreate = false;
			}
			return record;
		},
		toInsertData: function(modelName, payLoad, saveParent,ind){
			var model = store.model[modelName];
			var data = this.insertIntoStore(modelName, payLoad[modelName],saveParent,true, undefined,undefined, undefined, undefined, ind);
			model ? delete model.rel : undefined;
			return data;
		},
		insertIntoStore:function(modelName,data,saveParent,stack,partialObj,temp,checkRelData,clone,index,CustomDeserialize){
			var ret;
			if(Array.isArray(data)){
				ret = [];
				for(var i=0; i<data.length; i++){
					ret[i] = this.insertIntoStore(modelName, data[i], saveParent, stack, partialObj);
                    if(ret[i] && ret[i].$ && ret[i].$.isError){
						ret.$ = ret.$ || store.$.defProp(ret, "$", {}); 
						// ret.$.isError = true;y
						store.$.cmpSet(ret.$, "isError", true);
                    }
				}
			}
			else if(data && typeof data == "object" && Object.keys(data).length){
				var currentModel = store.modelFor(modelName);
				if(data._type && currentModel.extendedBy){
					currentModel = (currentModel.extendedBy[data._type]) ? store.modelFor(data._type) : undefined;
				}
				if(currentModel){
					if(Lyte.isRecord(data) && !clone)
					{
						return undefined;
					}
					if(checkRelData && data && currentModel){
						var rels = currentModel.relations;
						for(var key in rels){
							var relArr = rels[key];
							relArr.forEach(function(rel){
								var key = rel.relKey;
								var type = rel.relType;
								if(type == "hasMany" && data.hasOwnProperty(key) && Array.isArray(data[key]) && data[key].length){
									var arr = data[key], newArr = [];
									arr.forEach(function(itm){
										if(Lyte.isRecord(itm)){
											newArr.push(itm.$.pK);
										}
										else{
											newArr.push(itm);
										}
									});
									data[key] = newArr;
								}
								else if(type == "belongsTo" && data.hasOwnProperty(key) && Lyte.isRecord(data[key])){
									data[key] = data[key].$.pK;
								}
							});
						}
					}
					if(!clone){
						if(!this.isDuplicateRecord(currentModel, data, currentModel._pK)){
							var rec = new Record(currentModel._name, data);
							currentModel.data.push(rec);
							var toRel = store.$.toRelate[currentModel._name], pkVal = rec.$.pK;
							if(saveParent){
								store.$.saveParent = rec;
							}
							ret = this.validateAndPush(currentModel,rec,partialObj,undefined,CustomDeserialize);
							if(toRel && toRel.has(pkVal)){
								store.$.establishToRelated(rec, toRel.get(pkVal));
								toRel.delete(pkVal);
							}
						}
						else{
							ret = this.validateAndMerge(currentModel,data,partialObj,undefined,CustomDeserialize);
							if(ret && ret.data){
								ret = ret.data;
							}
							else if(ret && ret.type){
								Lyte[ret.type].apply(Lyte, ret.args || []);
							}
						}
					}
					else{
						var rec = new Record(currentModel._name,data ,currentModel._pK,clone);
						var ret = this.validateAndPush(currentModel,rec,undefined,clone);
					}
					if(saveParent){
						store.$.saveParent = undefined;
					}
					if(stack){
						store.$.recStack = {};
					}
				}
				else{
					var defobj = store.modelless, 
					def = defobj[modelName] = defobj[modelName] || {};
					if(index){
						if(!typeof index == "string"){
							Lyte.error("Index should be a string");
						}
						if(def._pK){
							if(def._pK !== index){
								Lyte.error("");
								return;
							}
						}
						def._pK = index;
						def._arrPk = [index];
					}
					else{
						def._pK = index = "id";
						def._arrPk = [index];
					}
					def.data = def.data || [];
					if(!def.data.modelless){
						store.$.defProp(def.data,"modelless", true);
						store.$.defProp(def.data, "pK", def._pK);
					}
					var ind = store.$.getInd(def.data, index, data[index]);
					if(ind == -1){
						store.$.handleArrOp(def.data, "push", data);
					}
					else{
						store.$.handleArrOp(def.data, "replaceAt", data, ind);
					}
					return data;
				}
			}
			return ret;
		},
		removeFromStore:function(model,keys,fromStore,ignorePartial,delayPer,onlyRem,partOnlyRem,idbPersist){
			var data = model.data, modelName = model._name;
			if(data.length == 0){
				return;
			}
			if(!Array.isArray(keys)){
				keys = [keys];
			}
			var pKey = model._pK;
			for(var i=0; i<keys.length; i++){
				var index = this.getIndex(data, pKey, keys[i]);
				if(index == -1){
					continue;
				}
				var rec = data[index];
				var pK = rec.$.pK;
				var relations = model.relations;
				if(rec.$.isNew){
					onlyRem = delayPer = undefined;
					fromStore = true;
				} 
				if(Object.keys(relations).length){
					this.toDemolishRelation(model, index, ignorePartial, onlyRem, delayPer, partOnlyRem);
				}
				var deleted;
				if(delayPer !== true && onlyRem !== false){
					deleted = this.handleArrOp(data,"removeAt",undefined,index,1);
					if(model._properties){
						store.$.demoLishObserverBindings(rec, model._properties);
					}
				}
				if(fromStore === true){
					store.$.cmpSet(rec.$, "isUnloaded", true);
					var scpObj = rec.$.__scpObj;
					for(var key in scpObj){
						var sid = scpObj[key];
                        var sidArr = sid.split("_");
						var nestObj = Lyte.nestScp[sidArr[0]];
						nestObj ? Lyte.removeNestScp(nestObj._data, sidArr[0], sidArr[1], undefined, rec, undefined, undefined, {model: modelName, pK:rec.$.pK, attr: key}) : undefined;
					}
					var cqueries = store.model.cachedQueries;
					if(cqueries){
						var Nm = cqueries[modelName],n=modelName;
						if(Nm && Nm.length){
							for(var j=Nm.length-1; j>=0; j--){
								var obj = Nm[j];
								if(obj.hasDeletedRecords){
									if(obj.data){
										var ind = obj.data[modelName].indexOf(rec);
										if(ind !== -1){
											Nm.splice(j,1);					
										}
									}
								}
							}					
						}
					}
					if(idbPersist && !rec.$.isNew){
						rec.$.persist();
					}			
				}
				if(onlyRem == true){
					model.emit("remove", [deleted[0]]);
					store.emit("remove", [model._name,deleted[0]]);	
					continue;
				}
				var remRec = deleted ? deleted[0] : rec;
				if(!fromStore){
					store.$.cmpSet( remRec.$, "isDeleted", true);
					store.$.changePersist(remRec, true);
					// deleted[0].$.isDeleted = true;
					if((delayPer !== true && onlyRem !== false) && (remRec.$.isNew || remRec.$.isModified)){
						store.$.deleteFromArray(model.dirty, remRec.$.pK);
					}
					if(!remRec.$.isNew){
						store.$.addTo_Del(model, remRec, index);
						// model._deleted.push(deleted[0]);
					}
					var cqueries = store.model.cachedQueries;		
					if(cqueries){
						var Nm = cqueries[modelName],n=modelName;
						if(Nm && Nm.length){
							for(var j=Nm.length-1; j>=0; j--){
								var obj = Nm[j];
								if(obj && obj.data){
									var ind = obj.data[modelName].indexOf(rec);
									if(ind != -1){
										obj.hasDeletedRecords = true;
									}							
								}
							}					
						}
					}		
				}
				var ind;
				if(Array.isArray(model.dirty) && (ind = model.dirty.indexOf(pK)) != -1){
					model.dirty.splice(ind, 1);
				}
				if(delayPer !== true && onlyRem !== false){
					model.emit("remove", [deleted[0]]);
					store.emit("remove", [model._name,deleted[0]]);	
				}
			}
		},
		getIndex:function(data,pKey,pkVal,type, model){
			var isComp = model ? model.isComp : (pKey.split(',').length > 1 ? true : false); 
			if(!isComp){
				return this.getInd(data, pKey, pkVal, type)
			}
			else{
				return this.getCompInd(data, pkVal, type, model)
			}
		},
		getCompInd:function(data,pkVal,type,model){
			for(var i=0;data && i<data.length;i++){
				var rec = data[i];
				if(type && data[i]._type !== type){
					continue;
				}
				if(store.adapter.$.compareObjects(store.$.getpKVal(rec,model), pkVal)) {
					return i;
				}
			}
			return -1;
		},
		getInd : function(data,pKey,pkVal,type){
			for(var i=0;data && i<data.length;i++){
				var rec = data[i];
				if(type && rec._type !== type){
					continue;
				}
				if(rec[pKey] == pkVal){
					return i;
				}
				if(pKey && typeof pKey == "string" && pKey.search(/[.]/g)!=-1){
					if(rec && rec.$ && rec.$.record && rec.$.get(pKey) == pkVal){
						return i;
					}
				}
			}
			return -1;
		},
		isDuplicateRecord:function(model,obj){
			var data = model.data, pK = model._pK, isComp = model.isComposite;
			if(data.length){
				if(!isComp && model.data._recMap){
					var pkVal = obj[pK];
					if(pkVal !== undefined){
						return model.data._recMap.get(pkVal.toString()) !== undefined;
					}
					else{
						return false;
					}
				}
				else{
					return data.some(function(record){
						if(store.adapter.$.compareObjects( store.$.getpKVal(obj, model), store.$.getpKVal(record) )){
							return true;
						}
					});
				}
			}
			return false;
		},
		validateAndPush:function(model,data,partialObj,clone,CustomDeserialize){
			if(!model.rel){
				model.rel = {};
			}
			var pkVals = model._arrPk, pkValsLen = pkVals.length, index;
			for(var i=0; i<pkValsLen; i++){
				var item = pkVals[i];
				if(!data.hasOwnProperty(item)){
					index = model.data.indexOf(data);
					model.data.splice(index,1);	
					return new error1(item, {code : "ERR23", data : data, message : Lyte.errorCodes.ERR23});
				}
				else if(data[item] == undefined || data[item] == null){
					index = model.data.indexOf(data);
					model.data.splice(index,1);	
					return new error1(item, {code : "ERR26", data : data, message : Lyte.errorCodes.ERR26});
				}
			}
			if(clone){
				data = this.validateJSON(model,data,undefined,undefined,undefined,clone);
				return data;
			}
			var mapPk = (( data.$.pK == undefined || typeof data.$.pK == "object") ? data.$.pK : data.$.pK.toString());
			model.data._recMap.set(mapPk, data);
			data = this.validateJSON(model, data, undefined, undefined, partialObj , undefined, CustomDeserialize );
			var index = model.data.indexOf(data); //have to check if the removal of these lines, doesn't affect any
			model.data.splice(index,1);
			this.handleArrOp(model.data,"push",data);
			if(model.didLoad){
				var callBack = model.didLoad;
				for(var i=0;i<callBack.length;i++){
					callBack[i].apply(data);	
				}
			}
			model.emit("add",[data]);
			store.emit("add",[model._name,data]);

			return data;
		},
		validateAndMerge:function(model,data,partialObj,mergeError,CustomDeserialize){
            if(!model.rel){
                model.rel  = {};
            }
			// if((data && typeof data !== "object") || Lyte.isRecord(data)){
            //     return { type:"warn", args:["LD27",Lyte.isRecord(data) ? data : JSON.stringify(data)]};
			// }
			var pkVal = store.$.getpKVal(data, model);
			if(pkVal === undefined){
                return { type:"error", args:["LD28", model._name, Lyte.isRecord(data) ? data : JSON.stringify(data)]};				
			}
            var record = store.$.peekRecord(model._name, store.$.getpKVal(data, model));
            if(!record || !Lyte.isRecord(record)){
                return { type:"error", args:["LD04",Lyte.isRecord(data) ? data : JSON.stringify(data)]};
            }
            this.mergeData(record, data, partialObj, mergeError ,CustomDeserialize);
            // record = this.validateJSON(model, record, Object.keys(data), toValidate, partialObj);
			if(model.didLoad){
                var callBack = model.didLoad;
                for(var i=0;i<callBack.length;i++){
                    callBack[i].apply(record);				
                }
                //model.didLoad.apply(record);
            }
            return { data : record };
		},
		mergeData:function(record,data,partialObj,mergeError,CustomDeserialize){
            if(!record || !data){
                return;
            }
            var model = record.$.model, field, _estObsBind = false;
			var deserialize = (CustomDeserialize == false) ? CustomDeserialize : true;
			if(mergeError){
				store.adapter.$.mergeError(model, record, data);
			}
            for(var key in data){
                field = model.fieldList[key];
                if(field){
                    if(field.type != "relation"){
						var empD = store.$.getDsrzEmpData(field, model._name);
						var boolChk = !empD && data[key]
						if(data.hasOwnProperty(key) && (boolChk || empD) && Lyte.Transform.hasOwnProperty(field.type) && Lyte.Transform[field.type].hasOwnProperty("deserialize") && deserialize)	{
							data[key] = Lyte.Transform[field.type].deserialize(data[key],key,model._name,store.$.getpKVal(data,model));
						}
						var isPropPresent = model._properties && model._properties.hasOwnProperty(key), propObj = {};
						if(isPropPresent){
							propObj[key] = model._properties[key];
							store.$.demoLishObserverBindings(record, propObj);
						}
						store.$.cmpSet(record,key,data[key],undefined, true);
						model._properties && model._properties.hasOwnProperty(key) ? _estObsBind = true : undefined;
                    }
                    else if(field && field.type == "relation"){
						var todo = {};
						var rel = {};
						store.$.getRelations(record.$.model, key, store.modelFor(field.relatedTo), rel);
						var bMod = store.model[rel.forward.relatedTo];
						// if new record created and replace (true) , then newly created record will be completely removed form store
						// response recived from the server replaced
						if(field.relType=="hasMany" && partialObj && partialObj[key] && partialObj[key].replace){
							var rec_ar=record[key]._recMap,arr_rec=[];
							rec_ar.forEach(function(rec,key_i){
								arr_rec.push(key_i);
							})
							arr_rec.forEach(function(i){
								if(store.$.peekRecord(field.relatedTo,i).$.isNew){
									store.$.removeFromStore(store.modelFor(field.relatedTo),i,true);
								}
								else{
									store.$.demolishLink(store.$.peekRecord(field.relatedTo,i),store.$.peekRecord(field.relatedTo,i).$.model._pK,record,rel.forward.relKey,undefined,undefined,true,true);
									if(rel.backward != null){
										store.$.demolishLink(record,model._pK,store.$.peekRecord(field.relatedTo,i),rel.backward.relKey,rel.forward,undefined,true,true);
									}
								}
							})
							delete partialObj[key];
						}
						var result = this.compareRelations(record,data,key,field,partialObj ? partialObj[key] : undefined ,todo, mergeError);
						this.mergeRecords(todo, result, model, bMod, record, key, data, rel, partialObj, mergeError);
                    }
                }
                else if(key != "$"){
					store.$.cmpSet( record,key,data[key],undefined, true );
                }
			}
			if(_estObsBind){
				store.$.establishObserverBindings(record, model._properties);
			}
		},
		mergeRecords:function(todo, result, model, bMod, record, key, data, rel, partialObj, mergeError){
			if(!rel){
				var rel = {};
				store.$.getRelations(model, key, bMod, rel);	
			}
			var pK = model._pK;
			if(rel.forward.relType == "hasMany" && (store.$.isEmptyArray(data[key]) && ((Array.isArray(todo.remove) && record && record[key]  &&  todo.remove.length != record[key].length ) )) || (record && !record[key] && Array.isArray(data[key]))){
				store.$.cmpSet(record, key, [], undefined, true);
				store.$.establishObserverBindings(record,record.$.model._properties);
				store.$.defArrUtls(record[key]);
				store.$.defPolyUtls(record[key]);
				store.$.defUtls(record[key],bMod,record,key);
			}
			if(Array.isArray(todo.add)){
				todo.add.forEach(function(item){
					store.$.createAndRelate(model, bMod, record, key, item, rel, partialObj);
				});
			}
			if(Array.isArray(todo.remove)){
				todo.remove.forEach(function(obj){
					var pkVal = obj.pK, model = obj.model;
					store.$.demolishLink(record, pK, store.$.peekRecord(model, pkVal), rel.backward.relKey,  rel.forward, rel.backward, true); 
					store.$.demolishLink(store.$.peekRecord(model, pkVal), store.modelFor(model)._pK, record, rel.forward.relKey, rel.backward, rel.forward, true); 
				});
			}

			if(record && record.hasOwnProperty(key)){
				store.$.deleteDeepNest(record, key);
				if(Array.isArray(record[key]) && record[key].hasOwnProperty("partial")){
					var partObj = record[key].partial, partKeys = [];
					partObj.forEach(function(value, partKey){
						partKeys.push(partKey);
						record[key].partial.delete(partKey);
					});
				}
			}
			switch(result){
				case 0:{
					if(Lyte.isRecord(record[key])){
						store.$.demolishLink(record, pK, record[key], rel.backward.relKey, rel.forward, rel.backward, true); 
						store.$.demolishLink(record[key], bMod._pK, record, rel.forward.relKey, rel.backward, rel.forward, true); 							
					}
					store.$.createAndRelate(model, bMod, record, key, data[key], rel, partialObj);
					break;
				}
				case 1:{
					break;
				}
				case 2:{
					this.mergeData(record[key],data[key],undefined,mergeError);
					break;
				}
				default : break;    
			}
		},
        compareRelations:function(record,data,key,field,partialObj,todo, mergeError){
            //return 0 - not same, 1 -same, 2 - merge, 3 - partial add, 4 - delete and partial add
			var model = store.modelFor(field.relatedTo);
			var pK = model._pK, result = [];
            if(field.relType == "belongsTo"){
				if(partialObj && partialObj.$.type === "removed" && (!data || (data && store.$.comparePk(record, store.$.getpKVal(data, model))))){
					return 1;
				}
                return this.compareRecordWithObj(record[key],data[key],pK, partialObj,mergeError);  
            }else{
				var isPartial = false;
				if((partialObj && partialObj.partial)){
					isPartial = true;
				}
				if(!isPartial && (!record.hasOwnProperty(key) || (record && record.hasOwnProperty(key) && (store.$.isEmpty(record[key]) || store.$.isEmptyArray(record[key]))))){
					if(todo){
						var arr = data[key] || [];
						arr.forEach(function(item){
							var add = todo.add = todo.add || [];
							add.push(item);
						});
						return;
					}
					return 0;
				}
                var len = data[key] ? data[key].length : 0,old=0,status=1,oldPks = [];
                for(var i=0;i<len;i++){
					var obj = data[key][i];
					if(partialObj && partialObj[i] && partialObj[i].$.type == "removed"){
						continue;
					}
                    var ind = this.getIndex(record[key],pK,(typeof obj == "object") ? store.$.getpKVal(obj,model) : obj);
                    if(ind == -1){
						if(todo){
							var add = todo.add = todo.add || [];
							add.push(obj);
						}
                        status = 0;
                        continue;
					}
					oldPks.push(record[key][ind].$.pK);
                    var res = this.compareRecordWithObj(record[key][ind],obj,pK,partialObj ? partialObj[i] : undefined,mergeError);
					if(res == 1){
						old++;
					}
                    if(res == 2){
                        this.mergeData(record[key][ind],obj, partialObj ? partialObj[i] : undefined, mergeError);
                    }
                    else if(res == 0){
                    	status = 0;
                    }
				}
				if(todo && !isPartial){
					var arr = record[key] || [];
					arr.forEach(function(item){
						var pkVal = item.$.pK;
						if(oldPks.indexOf(pkVal) == -1){
							var remove = todo.remove = todo.remove || [];
							remove.push({pK: pkVal, model: item.$.model._name});
						}
					});
				}
            }
        },
        compareRecordWithObj:function(rec,obj,pK,partialObj, mergeError){
            if( !rec || !Lyte.isRecord(rec) ){
                return 0;
            }
			var recModel = rec.$.model;
			var recPk = recModel._pK;
			var isComp = recModel.isComp;
            var recFields = recModel.fieldList;
			if(!isComp) {
				var field = recModel.fieldList[pK];
				if(typeof obj == field.type ){
					if(rec[pK] == obj){
						return 1;
					}
					else{
						return 0;
					}
				}
			}
			if(obj && typeof obj == "object"){
				if(!store.$.comparePk(rec, store.$.getpKVal(obj, recModel))){
					return 0;
				}
				if(Lyte.isRecord(obj) && obj === rec){
					return 1;
				}
				for(var data_key in obj){
					var field = recFields[data_key];
					if(field){
						if(field.type == "relation"){
							var todo = {};
							var res = this.compareRelations(rec, obj, data_key, field, partialObj ? partialObj[data_key] : undefined, todo, mergeError);
							this.mergeRecords(todo, res, recModel, store.modelFor(field.relatedTo), rec, data_key, obj, undefined, partialObj);
						}
						else if(rec[data_key] != obj[data_key]){
							return 2;
						}                    
					}
					else{
						if(rec[data_key] != obj[data_key]){
							return 2;
						}
					}	
				}
				return 1;
			}
			return 0;
        },
		validateJSON:function(model,data,keys,toValidate,partialObj,clone ,CustomDeserialize){
            var validate = (toValidate) ? toValidate.toValidate : undefined;
			var deserialize = (CustomDeserialize == false ) ? CustomDeserialize : true;
            var fields = (validate && Object.keys(validate).length) ? validate : model.fieldList;
			var extended = model.extend ? true : false;
			for(var key in data){
				if(keys && keys.indexOf(key) == -1){
					continue;
				}
				var fld = fields[key];
				if(fld){
					if(fld.type == "relation" && data[key]){
						var partialAdd = (toValidate && toValidate.toPartialAdd) ? toValidate.toPartialAdd[key] : undefined;
						var resp = this.handleRelation(key, model, fld, data, partialAdd, partialObj,clone);
						if(resp != true){
							return new error1(key, {code : resp, data : data, message : Lyte.errorCodes[resp]});
						}
						if(fld.relType == "hasMany" && !data[key].add){
							store.$.defArrUtls(data[key]);
							store.$.defPolyUtls(data[key]);
							store.$.defUtls(data[key],store.model[fld.relatedTo],data,key);
						}
					}
					else if(fld.type){
						var fieldKeys = fld;
						if(data[key] === undefined && fieldKeys.default){
							data[key] = store.$.getDefaultVal(data, fieldKeys.default);
						}
						var empD = store.$.getDsrzEmpData(fld, model._name);
						var boolChk = !empD && data[key]
						if(data.hasOwnProperty(key) && (boolChk || empD) && Lyte.Transform.hasOwnProperty(fieldKeys.type) && Lyte.Transform[fieldKeys.type].hasOwnProperty("deserialize") && deserialize){
							data[key] = Lyte.Transform[fieldKeys.type].deserialize(data[key],key,model._name,store.$.getpKVal(data,model));
						}
					}
				}
				else{
					if(extended){
						var extMod = store.modelFor(model.extend);
						var extKey = extMod.fieldList[key];
						if(extKey && extKey.type == "relation"){
							var partialAdd = (toValidate && toValidate.toPartialAdd) ? toValidate.toPartialAdd[key] : undefined;
							var resp = this.handleRelation(key, extMod, extKey, data, partialAdd);
							if(resp != true){
								return new error1(key, {code : resp, data : data, message : Lyte.errorCodes[resp]});
							}
							if(extKey.relType == "hasMany" && !data[key].add){
								store.$.defArrUtls(data[key]);
								store.$.defPolyUtls(data[key]);
								store.$.defUtls(data[key],extMod,data,key);
							}
						}
					}
				}
			}
			return data;
		},
		handleRelation:function(key,model,field,data,partialAdd, partialObj,clone){
			var rel = {};
			if (!model.rel.hasOwnProperty(key)){
				var relResp = this.getRelations(model,key,store.modelFor(field.relatedTo),rel);	
				if(relResp !== true){
					return relResp;
				}
				model.rel[key] = rel;
			}
			else{
				rel = model.rel[key];
			}
			return this.solveRelation(rel, model, store.modelFor(field.relatedTo), key, data, partialAdd, partialObj,clone);
		},
		getRelations:function(fModel,key,bModel,rel){
			if(bModel == undefined){
				Lyte.error("LD05",fModel.fieldList[key].relatedTo,key,fModel._name)
				return "ERR11";
			}
			rel.forward = fModel.fieldList[key];
			rel.backward = this.getBackwardRel(fModel,rel.forward,bModel);
			if(rel.backward === undefined){
				// Lyte.warn("LD06",fModel._name,key,bModel._name);
				// return "ERR25";
				var temp_backward = {type: "relation",relatedTo:fModel._name, dummy:rel.forward.relKey, relKey:undefined};
				bModel.relations[fModel._name] = bModel.relations[fModel._name] || [];
				bModel.relations[fModel._name].push(temp_backward);
				rel.backward = temp_backward;
			}
			return true;
		},
		getBackwardRel:function(fModel,rel,bModel){
			var inverse, polymorphic;
			if(rel.opts){
				inverse = rel.opts.inverse;
				polymorphic = rel.opts.polymorphic;
				if(inverse === null ){
					return undefined;
				}
				if(polymorphic){
					var extendedModels = bModel.extendedBy;
					if(extendedModels){
						for(var key in extendedModels){
                            var extModel = store.modelFor(key);
							if(extModel.relations[fModel._name]){
								bModel = extModel;
								break;
							}
						}
					}
				}
			}
			var relatedTo;
			if(inverse && inverse != ""){
				relatedTo = inverse;
			}
			else{
				var bRel = bModel.relations[fModel._name];
                var extFmodel = store.modelFor(fModel.extend), checkPoly;
				if(!bRel && extFmodel && bModel.relations[extFmodel._name]){
					bRel = bModel.relations[extFmodel._name];
					checkPoly = true;
				}
				relatedTo = (bRel && bRel.length == 1 && (bRel[0].opts && bRel[0].opts.inverse && bRel[0].opts.inverse !== rel.relKey ? false : true ) && (!checkPoly || (checkPoly && bRel[0].opts && bRel[0].opts.polymorphic))) ? bRel[0].relKey : undefined;
			}
			if(!relatedTo){
				var bRels = bModel.relations[fModel._name];
                var extFmodel_1 = store.modelFor(fModel.extend);
				if(!bRels && extFmodel_1 && bModel.relations[extFmodel_1._name] && bModel.relations[extFmodel_1._name].opts && bModel.relations[extFmodel_1._name].opts.polymorphic){
					bRels = bModel.relations[extFmodel_1._name];
				}
				if(rel.dummy && bRels){
					for(var i=0;i<bRels.length;i++){
						if(bRels[i] && bRels[i].relKey && bRels[i].relKey == rel.dummy)
						{
							 relatedTo = bRels[i].relKey;
							 break;
						}
					}
				}
				else if(bRels){
					for(var i=0;i<bRels.length;i++){
						if(bRels[i] && bRels[i].opts && bRels[i].opts.inverse && bRels[i].opts.inverse === rel.relKey){
							relatedTo = bRels[i].relKey;
							break;
						}
						else if(bRels[i] && bRels[i].dummy && bRels[i].dummy == rel.relKey)
						{
							 relatedTo = bRels[i];
							 break;
						}
					}
				}
			}
			if(relatedTo && relatedTo.dummy){
				return relatedTo;
			}
			if(relatedTo && fModel._fldGrps.inverse.hasOwnProperty(rel.relatedTo) && !rel.dummy){
				if(relatedTo && fModel.relations[rel.relatedTo] && fModel.relations[rel.relatedTo].length>1 && !inverse){
					if((!bModel.fieldList[relatedTo].opts) || bModel.fieldList[relatedTo].opts && !bModel.fieldList[relatedTo].opts.inverse){
						return undefined;
					}
				}
			}
			return relatedTo&&bModel?bModel.fieldList[relatedTo]:undefined;			
		},
		solveRelation:function(rel,fModel,bModel,key,data,partialAdd,partialObj,clone){
			var backward = rel.backward, forward = rel.forward, partial = partialObj ? partialObj[key] : undefined, partialRel = partial && partial.partial;
			var fPk = fModel._pK, val = [];
            if(partialAdd){
                val = partialAdd;
            }
			else if(!partialRel){
                if(data[key] && (data[key].add || Lyte.isRecord(data[key]) ) ){
                    return true;
                }
                if(!Array.isArray(data[key])){
					// Reflect.set(data, key, [data[key]], false);
                    data[key] = [data[key]];
                }
                else if(forward.relType == "belongsTo"){
                    return "ERR21";
				} 
				val = data[key].splice(0, data[key].length);
				if(forward.relType == "belongsTo"){
					// Reflect.set(data, key, undefined);		
					data[key] = undefined;	
				}                
			}
			else if(Array.isArray(data[key])){
				var val = data[key].splice(0, data[key].length);
			}
			for(var i=0; i<val.length; i++){
				var ret;
				ret = this.createAndRelate(fModel, bModel, data, key, val[i], rel, partial,clone);
				if(ret != true){
					return ret;
				}
			}
			return true;
		},
		createAndRelate: function(fModel, bModel, data, key, val, rel, partial,clone){
			if(!rel.backward){
				if(rel.forward.relatedTo === fModel._name){
					rel.backward = rel.forward;
				}
				if(rel.backward === undefined){
					return "ERR12";
				}
			}
			var pK = fModel._pK, isComp = bModel.isComp, isPoly = rel.forward && rel.forward.opts ? rel.forward.opts.polymorphic : undefined;
			var relatedRecord, newPartial = partial && partial.hasOwnProperty(val[pK]) ? partial[val[pK]] : partial;
			if(!isComp && typeof val == bModel.fieldList[bModel._pK].type && !clone){
				relatedRecord = store.$.peekRecord(bModel._name, val);
			}
			else if(typeof val == "object" && !Lyte.isRecord(val)){
				relatedRecord = this.insertIntoStore(bModel._name, val, undefined, undefined, newPartial,undefined,undefined,clone);					
			}
			if(relatedRecord && relatedRecord.$ && relatedRecord.$.isError){
				store.$.cmpSet(data.$, "isError", true);
				// data.$.isError = true;
				var errObj = {code:"ERR24", message: Lyte.errorCodes.ERR24, data: data, error: relatedRecord.$.error};
				store.$.cmpSet( data.$.error, key, errObj );
			}
			else if(relatedRecord){
				if(!this.hasDuplicateRelation(relatedRecord, data[key], bModel._pK, isPoly ? val._type : undefined, bModel)){
					this.establishLink(rel.forward, rel.backward, data, relatedRecord, undefined, true, false);							
				}
			}
			else{
				this.addToRelate(fModel._name, data, rel, val);
			}
			return true;
		},
		singleEstablishLink:function(forward,data,relatedRecord){
			var relation = relatedRecord.$._relationships , fModelName = data.$.model._name , fRelKey = forward.relKey ;
			relation[fModelName] = relation[fModelName] || {};
			relation[fModelName][fRelKey] = relation[fModelName][fRelKey] || [];
			if(!this.hasDuplicateRelation(data,relation[fModelName][fRelKey],data.$.model._pK, undefined, data.$.model)){
				relation[fModelName][fRelKey].push(data);
			}
		},		
		establishLink:function(forward,backward,data,relatedRecord,index,ignorePartial, isDuplicate, partRemoveOnly){
			if(!relatedRecord){
				return "ERR13";
			}
			if( !this.checkForCorrectRelation(forward, relatedRecord) ){
				return "ERR14";
			}
			var fRelKey = forward.relKey, isPoly = forward.opts && forward.opts.polymorphic, type = isPoly ? relatedRecord._type : undefined, ignoreRel = {}, fSet = false;
			if(forward.relType == "belongsTo"){
                if(data[fRelKey] !== relatedRecord){
					store.$.cmpSet( data, fRelKey, relatedRecord, undefined, true );
					if(data.$.partial && Object.keys(data.$.partial).length && data.$.partial[fRelKey]){
						delete data.$.partial[fRelKey];
					}
					fSet = true;
				}
			}
			else if(forward.relType === "hasMany"){
				if(!data[fRelKey]){
					store.$.cmpSet(data,fRelKey,[],undefined, true);
				}
				if(!data[fRelKey].model){
					var relModel = relatedRecord.$.model;
					if(isPoly && type){
						store.$.defProp(data[fRelKey], "polymorphic", true);
						relModel = store.modelFor(relModel.extend);
					}
                    store.$.establishObserverBindings(data,data.$.model._properties);
					store.$.defArrUtls(data[fRelKey]);
					store.$.defPolyUtls(data[fRelKey]);
					store.$.defUtls(data[fRelKey],relModel,data,fRelKey);
				}
				var mdl = forward ? store.modelFor(forward.relatedTo) : undefined;
				if( isDuplicate == false || !this.hasDuplicateRelation(relatedRecord, data[fRelKey], (forward?mdl._pK : undefined),type, mdl) ){
					if(index != undefined){
						this.handleArrOp(data[fRelKey], "insertAt", relatedRecord, index);
					}
					else{
						this.handleArrOp(data[fRelKey],"push",relatedRecord);
					}
					var ret;
					if((!ignorePartial || partRemoveOnly) && forward.opts && forward.opts.serialize){
						ret = store.$.partialData(data, fRelKey, relatedRecord.$.pK, "added", undefined, partRemoveOnly);
						ignoreRel.relKey = fRelKey;
						ignoreRel.model = data.$.model._name;
					}
					fSet = true;
				}
			}
			var fnest = false;
			if(!ignorePartial && fSet == true){
				fnest = ret ? false : true;
			}
			if(backward === null){
				if(relatedRecord.hasOwnProperty(bRelKey)){
					delete relatedRecord[bRelKey];
				}
				return true;
			}
			if(backward.dummy || forward == backward){
				this.singleEstablishLink(forward,data,relatedRecord);
			}
			else{
				var bRelKey = backward.relKey, relRecMod = relatedRecord.$.model, bSet = false;
				if( !this.checkForCorrectRelation(backward, data) ){
					return "ERR14";
				}
				if(backward.relType == "belongsTo"){
					if(relatedRecord[bRelKey] != undefined  && relatedRecord[backward.relKey] !== data){
						this.toDemolishLink(relRecMod, relatedRecord, backward, ignorePartial);
					}
					if(relatedRecord[bRelKey] !== data){
						store.$.cmpSet(relatedRecord, bRelKey, data, undefined, true);
						if(relatedRecord.$.partial && Object.keys(relatedRecord.$.partial).length && relatedRecord.$.partial[bRelKey]){
							delete relatedRecord.$.partial[bRelKey];
						}
						bSet = true;
					}
				}
				else if(backward.relType === "hasMany"){
					if(!relatedRecord[bRelKey]){
						store.$.cmpSet(relatedRecord, bRelKey, [],undefined,  true);
					}
					if(!relatedRecord[bRelKey].model){
						store.$.defArrUtls(relatedRecord[bRelKey]);
						store.$.defPolyUtls(relatedRecord[bRelKey]);
						store.$.defUtls(relatedRecord[bRelKey],data.$.model,relatedRecord,bRelKey);
					}
					var bMdl = backward ? store.modelFor(backward.relatedTo) : undefined, bret, bnest;
					if( !this.hasDuplicateRelation(data, relatedRecord[bRelKey], (backward ? bMdl._pK : undefined), type, bMdl) ){
						this.handleArrOp(relatedRecord[bRelKey],"push",data);
						if((!ignorePartial || partRemoveOnly) && backward.opts && backward.opts.serialize){
							bret = store.$.partialData(relatedRecord, bRelKey, data.$.pK, "added", undefined, partRemoveOnly);
						}
						if(!ignorePartial){
							bnest = bret ? false : true;
						}
					}
				} 
			}
			if(fnest){
				if(forward.opts && forward.opts &&forward.opts.deepNest){
					var type = "added";
					if(data[forward.relKey].partial && data[forward.relKey].partial.get(relatedRecord.$.pK)){
						type = data[forward.relKey].partial.get(relatedRecord.$.pK).type;
					}
					store.$.setDeepNest(data, forward.relKey, relatedRecord.$.pK, type);
					bnest = false;
				}
				// store.$.addDeepNest(relatedRecord, undefined, !ignorePartial ? "added" : undefined, ignoreRel);
				if(bnest){
					if( backward && backward.opts && backward.opts.deepNest ){
						store.$.setDeepNest(relatedRecord, backward.relKey, data.$.pK, "added");
					}
				}
			}
			return true;
		},
		toDemolishRelation:function(model,index,ignorePartial,onlyRem,delayPers,partOnlyRem){
			var record = model.data[index], relations = model.relations, storeUtils = this;
			for(var key in relations){
				var rel = relations[key];
				for(var i=0; i<rel.length; i++){
					var relation = rel[i],
					relatedModel = store.modelFor(relation.relatedTo);
					if(relatedModel){
						var bRel = store.$.getBackwardRel(model, relation, relatedModel);
						// if(model._name == relatedModel._name){
						// 	var data = relatedModel.data,index1,index2;
						// 	for(index1=0 ; index1<data.length; index1++){
						// 		var item=data[index1];
						// 		if(Array.isArray(item[relkey])){
						// 			for(var index2=0;index2<item[relkey].length;index2++){
						// 				var value = item[relkey][index2];
						// 				if(value[relPriKey] == record[relPriKey] && onlyRem !== false && delayPers !== true)
						// 				{
						// 					storeUtils.handleArrOp(item[relkey],"removeAt",undefined,index2,1);
						// 				}
						// 			}
						// 		}
						// 		else if (Lyte.isRecord(item[relkey])){
						// 			if(item[relkey][relPriKey] == record[relPriKey] && onlyRem !== false && delayPers !== true)
						// 				{
						// 					item[relkey] = undefined ;
						// 				}
						// 		}
						// 	}
						// }
						if(!record[relation.relKey] && !relation.dummy && relation !== bRel){
							continue;
						}
						this.toDemolishLink(model, record, relation, ignorePartial, onlyRem, delayPers, partOnlyRem);
					}
				}
			}
		},
		toDemolishLink:function(model,record,relation,ignorePartial,onlyRem,delayPers,partOnlyRem){
			var records = record[relation.relKey], 
			priKey = model._pK, 
			relatedModel = store.modelFor(relation.relatedTo);
			if(!relatedModel){
				return;
			}
			var relPriKey = relatedModel._pK, 
			relatedModelName = relation.relatedTo, 
			bRelation = this.getBackwardRel(model, relation, relatedModel),
			serialize = relation.opts ? relation.opts.serialize : undefined;
			if(relation.dummy || (relation === bRelation)){
				records = this.getRelatedRecord(record,relation.relatedTo,relation.dummy ? relation.dummy : relation.relKey);
			}
			// if(bRelation.dummy){
			// 	bRelation.relKey = undefined;
			// }
			var pKs = [], rec;
			if(bRelation){
				if(Array.isArray(records)){
					for(var i=0; i<records.length; i++){
						this.demolishLink(record, priKey, records[i], bRelation.relKey, relation, bRelation, ignorePartial, undefined, onlyRem, delayPers, partOnlyRem);
					} 
				}
				else if(Lyte.isRecord(records)){
					this.demolishLink(record, priKey, records, bRelation.relKey, relation, bRelation, ignorePartial, undefined, onlyRem, delayPers, partOnlyRem);
				}
			}
		},
		demolishSingleRelation : function(record,fModelName,key,relatedRecord,priKey,onlyRem,delayPers){
			var arr,index;
			if(Lyte.isRecord(record)){
				arr = record.$._relationships;
				if(arr && arr[fModelName] && arr[fModelName][key] && (onlyRem !== false && delayPers !== true)){
					arr = arr[fModelName][key];
					index = this.getIndex(arr,priKey,relatedRecord[priKey]);
					if(index > -1){
						arr.splice(index,1);
					}
				}
			}
		},
		demolishLink : function(record, priKey, relatedRecord, bRelKey, relation, bRelation, ignorePartial, ignoreAttrCheck, onlyRem, delayPers, partOnlyRem){
			var links = relatedRecord[bRelKey], relMod = relatedRecord.$.model, pKs = [];
			var pK = record.$.pK;
			var poly = links ? links.polymorphic : undefined, polymorphicType;
			if(Array.isArray(links)){
				var ind = this.getIndex(links, priKey, pK, poly ? record._type : undefined);
				var _attrs = relatedRecord.$._attributes;
				var initialVal = _attrs.hasOwnProperty(bRelKey) && _attrs[bRelKey] && _attrs[bRelKey].length  ? relatedRecord.$.getInitialValues(bRelKey) : undefined;
				var toRem = links.partial && links.partial.has(pK) && links.partial.get(pK).type == "added" ? true : false;
				if(ind != -1 && (toRem || (onlyRem !== false && delayPers !== true))){
					poly ? polymorphicType = links[ind].$.model._name : undefined;
					this.handleArrOp(relatedRecord[bRelKey],"removeAt",undefined,ind,1);
				}
				if(!ignoreAttrCheck && initialVal){
					if(!store.$.hasRecordsArrayChanged(relatedRecord, bRelKey, initialVal)){
					   	delete relatedRecord.$._attributes[bRelKey];
					   	if(!Object.keys(relatedRecord.$._attributes).length){
						   	store.$.cmpSet(relatedRecord.$, "isModified", false);
							store.$.changePersist(relatedRecord, true);
						   	if(!relatedRecord.$.isNew){
							   	store.$.deleteFromArray(relMod.dirty, relatedRecord[relMod._pK]);
							   	if(!relatedRecord.$.dN || (relatedRecord.$.dN && !Object.keys(relatedRecord.$.dN).length)){
									store.$.removeParentNesting(relatedRecord);
								}			
							}
						}
					}
			   	}
			}
			else if( links && (typeof links == "object" || Lyte.isRecord(links)) && (onlyRem !== false && delayPers !== true) ){
				if(Lyte != undefined && Lyte.objectUtils != undefined){
					Lyte.objectUtils(relatedRecord, "delete", bRelKey, undefined, undefined, true);
				}
				else {
					delete relatedRecord[bRelKey];
				}
			}
			else{
				this.demolishSingleRelation(relatedRecord,record.$.model._name,relation.relKey,record,priKey, onlyRem, delayPers);
			}
			if(!bRelation){
				bRelation = relMod.fieldList[bRelKey];
			}
			if((!ignorePartial || partOnlyRem) && onlyRem !== true){
				var relType, isPartial, ret, nest, serz;
				if(bRelation){
					if(bRelation.opts){
						isPartial = bRelation.opts.serialize == "partial";
						serz = bRelation.opts.serialize ? true : false;
						nest = bRelation.opts.deepNest;
					}
					var relType = bRelation ? bRelation.relType : undefined;
				}
				// if(delayPers && bRelation && bRelation.opts && /^(id|record)$/.test(bRelation.opts.serialize)){
				// 	return;
				// }
				if(relType == "belongsTo" && serz && !record.$.isNew){
					var partObj = relatedRecord.$.partial = relatedRecord.$.partial || {};
					if(partOnlyRem){
						if(partObj && partObj.hasOwnProperty(bRelKey) && partObj[bRelKey].has(pK)){
							partObj[bRelKey].delete(pK);	
						}
						if(nest){
							store.$.deleteDeepNest(relatedRecord, bRelKey, pK);
						}
						nest = false;
					}
					else{
						partObj = partObj[bRelKey] = partObj[bRelKey] || new Map();
						if(!partObj.has(pK)){
							partObj.set(pK, {});
						}
						partObj = partObj.get(pK);
						partObj.type = "removed";					
					}
				}
				if(bRelation && bRelation.opts && bRelation.opts.serialize){
					ret = store.$.partialData(relatedRecord, bRelKey, pK, "removed", polymorphicType, partOnlyRem);
					nest = ret && relType == "hasMany" ? false : nest;
				}
				if(nest){
					store.$.makeDirty("dirty", relatedRecord, "removed", bRelation, pK);
					store.$.addDeepNest(relatedRecord);
				}
			}
		},
		rllBckRecArr : function(oldVal, record, model, field){
			var rel = {}, pK = model._pK, relPK = store.modelFor(field.relatedTo)._pK;
			store.$.getRelations(model, field.relKey, store.modelFor(field.relatedTo), rel);
			for(var i=oldVal.length-1; i>=0; i--){
				var records = oldVal[i].records;
				if(oldVal[i]._type == "added"){
					for(var j=0; j<records.length; j++){
						var relatedRecord = records[j];
						if(relatedRecord && relatedRecord.$ && relatedRecord.$.hasOwnProperty("pK")){ // temp check to know if record exist in store
							this.demolishLink(relatedRecord, relPK, record, rel.forward.relKey);
							if(rel.backward != null){
								this.demolishLink(record, pK, relatedRecord, rel.backward.relKey, rel.forward);
							}
						}
					}
				}
				else if(oldVal[i]._type == "removed"){
					for(var j=records.length-1; j>=0; j--){
						var relatedRecord = records[j];
						if(relatedRecord && relatedRecord.$ && relatedRecord.$.hasOwnProperty("pK")){ // temp check to know if record exist in store
							this.establishLink(rel.forward, rel.backward, record, relatedRecord, oldVal[i]._indices[j]);
						}
					}
				}
				else if(oldVal[i]._type == "changed"){
					var currentRecords = record[field.relKey];
					if(!Array.isArray(currentRecords)){
						currentRecords = [currentRecords]; 
					}
					var self = this;
					var kLen = currentRecords.length;
					for(var k=0; k<kLen; k++){
						var relatedRecord = currentRecords[0];
						if(relatedRecord && relatedRecord.$ && relatedRecord.$.hasOwnProperty("pK")){
							self.demolishLink(relatedRecord, relPK, record, rel.forward.relKey);
							if(rel.backward != null){
								self.demolishLink(record, pK, relatedRecord, rel.backward.relKey,rel.forward);
							}
						}
					}
					if(!Array.isArray(records)){
						records = [records];
					}
					for(var j=0; j<records.length; j++){
						var relatedRecord = records[j];
						if(typeof relatedRecord == "string"){
							relatedRecord = store.$.peekRecord(rel.forward.relatedTo,relatedRecord);
						}
						if(relatedRecord && relatedRecord.$ && relatedRecord.$.hasOwnProperty("pK")){ // temp check to know if record exist in store
							this.establishLink(rel.forward, rel.backward, record, relatedRecord, undefined);
						}
					}						
				}
			}
		},
		sortBy : function(field, order){
			var fieldArr = store.$.mapBy.call(this, field);
            var model = this.model;
            var fie = model.fieldList[field];
            if(fie && fie.type == "string"){
                fieldArr.sort();
                if(order == "desc"){
                    fieldArr.reverse();
                }                
            }
            else{
                fieldArr.sort(function(a,b){return a-b;});
                if(order == "desc"){
                    fieldArr.sort(function(a,b){return b-a;});
                }
            }
			var oldArr = this.slice(0), newArr = [];
			for(var i=0; i<fieldArr.length; i++){
				if(fieldArr[i] == undefined){
					continue;
				}
				var index = store.$.getIndex(oldArr, field, fieldArr[i]);
				newArr.push(oldArr[index]);
				oldArr.splice(index, 1);
			}
			if(oldArr.length > 0){
				if(order == "desc"){
					newArr = newArr.concat(oldArr);
				}
				else{
					newArr = oldArr.concat(newArr);
				}				
			}
			store.$.defArrUtls(newArr);
			store.$.defUtls(newArr,this.model);
			return newArr;
		},
		mapBy : function(field){
			return this.map(function(value){
				return value.$.get(field);
			});
		},
		revertToOldVal : function(record, attr, oldVal, rel){
			if(oldVal == undefined || oldVal.length == 0){
				return;
			}
			else{
				if(!Array.isArray(oldVal)){
					oldVal = [oldVal];
				}
				for(var i =0; i<oldVal.length; i++){
					var fModel = rel.forward.relatedTo;
					var fRec = store.$.peekRecord(fModel, oldVal[i]);
					this.establishLink(rel.forward, rel.backward, record, fRec, undefined);
				}
			}
		},
		removePartial : function(record, key){
			var parObj = record.$.partial;
			if(parObj && parObj[key] ){
				delete parObj[key];
			}
		},
		findCurrentInd : function(model, pkVal){
			var deleted = model._deleted;
			var handle = false, currentInd, finalInd;
			deleted.forEach(function(itm, idx){
				if(handle){
					if(itm.index < currentInd){
						finalInd--;
					}
				}
				if(idx == pkVal){
					handle = true;
					finalInd = currentInd = itm.index;
				}
			});
			return finalInd;
		},
		modifyDelInd:function(model, pkVal){
			var deleted = model._deleted;
			var handle = false, currentInd;
			deleted.forEach(function(itm, idx){
				if(handle){
					if(itm.index >= currentInd){
						itm.index = itm.index+1;
					}
				}
				if(idx == pkVal){
					handle = true;
					currentInd = itm.index;
				}
			});
		},
		rollBackDelete : function(model, pkVal, index , inherit){
			var arr = [], modelName = model._name;
			if(!pkVal){
				model._deleted.forEach(function(itm){
					arr.push(itm);
				});
			}
			else{
				var deleted = model._deleted, obj = deleted.get(pkVal), pK = model._pK;
				arr = [obj];
			}
			var self = this, len = arr.length;
			for(var i=len-1;i>=0;i--){
				var obj = arr[i];
				var rec = obj.data;
				//var currentInd = store.$.findCurrentInd(model, pkVal);
				var isRecInModel = model.data._recMap ? model.data._recMap.get(rec.$.pK) : (model.data.indexOf(rec) !== -1) ;
				if(Lyte.isRecord(rec)){
					store.$.cmpSet(rec.$, "isDeleted", false);
					store.$.changePersist(rec, true);
					var isDuplicate = store.$.isDuplicateRecord(model, rec);
					if(!isRecInModel){
						if(index){
							self.handleArrOp(model.data,"insertAt",rec,obj.index);
							// store.$.modifyDelInd(model, pkVal);
						}
						else{
							self.handleArrOp(model.data,"push",rec);
						}
						model.emit("add", [rec]);
						store.emit("add", [model._name,rec]);	
						var relArr = model.relations;
						if(relArr){
							for(var key in relArr){
								var rel = relArr[key] || [];
								rel.forEach(function(item)
								{
									var key = item.relKey, bRel, bMod, data;
									// if(rec.hasOwnProperty(key)){
										bMod = store.modelFor(item.relatedTo);
										bRel = self.getBackwardRel(model,item,bMod);
										if(!item.relKey || (item == bRel)){
											data = store.$.getRelatedRecord(rec,item.relatedTo,item.dummy?item.dummy:item.relKey);
										}
										else{
											data = rec[item.relKey];
										}
										if(Array.isArray(data)){
											data.forEach(function(itm, ind){
												if(item == bRel){
													self.establishLink(bRel, item,itm,rec,undefined,false);
												}
												else{
													self.establishLink(item,bRel,rec,itm,undefined,false);
												}
											});
										}
										else{
											if(item == bRel){
												self.establishLink(bRel, item,data,rec,undefined,false);
											}
											else{
												self.establishLink(item,bRel,rec,data,undefined,false);
											}
										}
									// }
								});
							}
						}
					}
					else{
						store.$.addDeepNest(rec, undefined, "added");
					}
					// else if (isRecInModel){
					// 	var relArr = model.relations;
					// 	var _rel = isRecInModel.$._relationships;
					// 	for(var r in _rel){
					// 		var mdl_rec = _rel[r]
					// 		for(var _k in mdl_rec){
					// 			var records = mdl_rec[_k]
					// 			var mdl = store.modelFor(r);
					// 			var rel = mdl.fieldList[_k]
					// 			if(rel.opts && rel.opts.serialize && rel.opts.serialize == "partial"){
					// 				if(Array.isArray(records)){
					// 					records.forEach(function(rec){
					// 						var partData = rec[_k].partial;
					// 						partData.delete(pkVal);
					// 					})
					// 				}
					// 			}
					// 		}
					// 	}
					// }
					// else{
					// 	Lyte.error("Cannot rollback record of model, since another instance of same record exists in store");
					// }
					var cqueries = store.model.cachedQueries;	
					if(cqueries){
						var Nm = cqueries[modelName],n=modelName;
						if(Nm && Nm.length){
							for(var j=Nm.length-1; j>=0; j--){
								var obj = Nm[j];
								if(obj && obj.hasDeletedRecords){
									var ind = obj.data[modelName].indexOf(rec);
									if(ind != -1){
										delete obj.hasDeletedRecords;
									}							
								}
							}					
						}
					}
					if(rec.$.isNew || rec.$.isModified){
						this.checkAndAddToArray(model.dirty, rec[model._pK]);
					}
					store.$.clrRecErr(rec.$, pK, "ERR17");
					!isDuplicate ? model.data._recMap.set(typeof rec.$.pK == "object" ? rec.$.pK : rec.$.pK.toString(), rec) : undefined; //old handling
					model._deleted.delete(rec.$.pK);
				}
			}
		},
		rollBackNew : function(model, record, pK,inherit){
			store.$.removeFromStore(model, record.$.pK, true,inherit);
			// var pkVal = record.$.pK;
			// var index = this.getIndex(model.data, pK, pkVal);
			// store.$.toDemolishRelation(model, index);
			// this.handleArrOp(model.data,"removeAt",undefined,index,1);
			// // record.$.isNew = false;
			// store.$.cmpSet(record.$, "isNew", false);
			// store.$.cmpSet(record, "$",  {});
			// model.emit("remove", [record]);
			// store.emit("remove", [model._name,record]);
			// this.deleteFromArray(model.dirty, pkVal);
		},
		emit : function(type, record, attr, err){
			record.$.emit(type, [record,attr,err]);
			record.$.model.emit(type, [record, attr, err]);
			store.emit(type, [record.$.model._name, record, attr, err]);
		},
		hasRecordsArrayChanged : function(record, attr, old){
			var arr = old || record.$.getInitialValues(attr), changed = true, pK = record.$.model._pK;
			if(arr && arr.length == record[attr].length){
				changed = false;
				for(var i=0; i<arr.length; i++){
					if(record[attr].indexOf(arr[i]) == -1){
						return true;
					}
				}
			}
			return changed;
		},
		setRecErr : function($record, field, code, value){
			store.$.cmpSet($record, "isError", true);
            var errObj = code;
			if(typeof errObj == "object"){
				store.$.cmpSet($record.error,field,errObj);
			}
			else{
				if(typeof code == "string"){
					var errMes = Lyte.errorCodes[code];
					if(errMes){
						errObj = {code : code, message : Lyte.errorCodes[code]};
					}
					else{
						errObj = code;
					}
				}
				store.$.cmpSet($record.error, field, errObj);
				if(value){
					store.$.cmpSet($record.error[field],"value",value);
				}				
			}
            store.$.emit("error",$record.record,field,errObj);
		},
		clrRecErr : function($record, field, code){
			var objUtl = Lyte.objectUtils;
			var $err = $record.error;
			if(code){
				if($record.error.code == code){
					if(typeof objUtl != "undefined"){
						objUtl($err,"delete",field);
					}
					else{
						delete $err[field];                        
					}
				}
			}
			else if(field){
				if(typeof objUtl != "undefined"){
					objUtl($err,"delete",field);
                }
                else{
                    delete $err[field];                       
                }
			}
			else{
                if(typeof objUtl != "undefined"){
					for(var err in $err){
						objUtl($err,"delete",err);
					}
				}	
                else{
                    $record.error = {};
                }   
			}
			if(Object.keys($record.error).length == 0){
				store.$.cmpSet($record, "isError", false);
			}
		},
        cacheQuery: function(modelName, cacheQuery, data, status){
			var cq = store.model.cachedQueries;
			cq = store.model.cachedQueries = cq || {};
			cq = cq[modelName] = cq[modelName] || [];
			cq.push({cacheQuery : cacheQuery, data : data, status : status});
		},
		cacheRecordQuery: function(modelName, key, cacheQuery, data, status){
			var crq = store.model.cachedRecordQueries;
			crq = store.model.cachedRecordQueries = crq || {};
			crq = crq[modelName] = crq[modelName] || {};
			crq = crq[key] = crq[key] || [];
			crq.push({cacheQuery : cacheQuery, data : data, status : status});
		},
		isModelDataArray: function(data){
			if(Array.isArray(data) && (data.modelless || data.model && data.model instanceof Model && !data.polymorphic)){
				return true;
			} 
		},
		handleArrOp:function(data,type,obj,pos,len){
			len = len != undefined ? len : 0;
			var toBind = typeof Lyte.arrayUtils != "undefined" ? true : false, ret, sort;
			if(data.key && data.record){
				var fld = data.record.$.model.fieldList[data.key], srtObs = false;
				if(fld && fld.opts && fld.opts.sort){
					if(fld.opts.sort.sortFn){
						sort = fld.opts.sort.sortFn;
						if(fld.opts.sort.observes){
							srtObs = true;
						}
					}
					else{
						sort = { sortBy: fld.opts.sort.sortBy || "$.created_Time" , sortOrder: fld.opts.sort.sortOrder };
					}
				}
			}
			else if(data.model && data.model.sort){
				if(!data.model.sort.sortBy){
					sort = { sortBy : "$.created_Time" , sortOrder : data.model.sort.sortOrder  , defaultSort : true }
				}
				else {
					sort = { sortBy : data.model.sort.sortBy , sortOrder : data.model.sort.sortOrder}
				}
			}
			switch(type){
				case "push": {
					if(this.isModelDataArray(data)){
						// !data.record ? data.model._pkMap.set(obj.$.pK, {pkVal : obj.$.pK}) : undefined; //for push in model data
						data._recMap == undefined ? store.$.defProp(data, "_recMap", new Map()) : undefined;
						if(!data.modelless){
							data._recMap.set(typeof obj.$.pK == "object" ? obj.$.pK : obj.$.pK.toString(), obj);
						}
						else{
							data._recMap.set(obj[data.pK], obj);					
						}
					}
					if(!sort){
						ret = toBind ? Lyte.arrayUtils(data, type, obj) : data.push(obj);
					}
					else{
						ret = toBind ? Lyte.arrayUtils(data, "sort", sort, [obj]) : data.push(obj);
					}
					if(srtObs && obj && obj.$){
						!obj.$.hasOwnProperty("srtObs") ? store.$.defProp(obj.$, "srtObs", true, false, true) : undefined;
					}
					break;
				}
				case "removeAt": {
					if(this.isModelDataArray(data)){
						var cpyLen = len;
						for(var i=0;i<cpyLen;i++){
							var mpKey = undefined;
							if(!data.modelless){
								var pkVal = data[pos+i] ? data[pos+i].$.pK : undefined;
								pkVal = ((typeof pkVal == "object") ? pkVal : pkVal.toString());
								mpKey = pkVal;
							}
							else{
								mpKey = data[pos+i][data.pK];
							}
							mpKey !== undefined && data._recMap ? data._recMap.delete(mpKey) : undefined;
						}
					}
					var _rec = data[pos];
					if(srtObs && _rec && _rec.$ && !store.$.changeRelPkMaps(_rec, undefined, undefined, "srtObsChk", data.key)){
						_rec.$.hasOwnProperty("srtObs") ? _rec.$.srtObs = false : undefined;
					}
					ret = toBind ? Lyte.arrayUtils(data,type,pos,len) : data.splice(pos,len);
					break;
				}
				case "insertAt": {
					if(this.isModelDataArray(data)){
						data._recMap == undefined ? store.$.defProp(data, "_recMap", new Map()) : undefined;
						if(!data.modelless){
							data._recMap.set(typeof obj.$.pK == "object" ? obj.$.pK : obj.$.pK.toString(), obj);
						}
						else{
							data._recMap.set(obj[data.pK], obj);					
						}
					}
					if(!sort){
						ret = toBind ? Lyte.arrayUtils(data,type,pos,obj) : data.splice(pos,len,obj);
					}
					else{
						ret = toBind ? Lyte.arrayUtils(data, "sort", sort, [obj]) : data.splice(pos,len,obj);
					}
					if(srtObs && obj && obj.$){
						!obj.$.hasOwnProperty("srtObs") ? store.$.defProp(obj.$, "srtObs", true, false, true) : undefined;
					}
					break;
				}
				case "replaceAt": {
					if(!sort){
						ret = toBind ? Lyte.arrayUtils(data,type,pos,obj) : data.splice(pos,len,obj);
					}
					else{
						ret = toBind ? Lyte.arrayUtils(data, "sort", sort, [obj]) : data.splice(pos,len,obj);
					}
					if(srtObs && obj && obj.$){
						!obj.$.hasOwnProperty("srtObs") ? store.$.defProp(obj.$, "srtObs", true, false, true) : undefined;
					}
					break;
				}
				case "sort" : {
					ret = Lyte.arrayUtils(data, "sort", sort);	
					break;
				}
				default: {
					Lyte.error("LD07", type);
					break;
				}
			}
			return ret;
		},
		defpayObjUtls:function(obj){
			Object.defineProperties(obj,{
				set:{
					value: store.$.payloadSet
				},
				remove:{
					value:store.$.payloadRemove
				}
			})
		},
		defPayArrUtls:function(obj){
			Object.defineProperties(obj,{
				add : {
					value : store.$.payloadAdd
				},
				remove : {
					value : store.$.payloadRemove
				}
			})
		},
		defArrUtls:function(obj){
			Object.defineProperties(obj, {
				filterBy : {
					value : store.$.filterBy
				},
				sortBy : {
					value : store.$.sortBy
				},
				mapBy : {
					value : store.$.mapBy
				}
			});
		},
		defPolyUtls:function(obj){
			Object.defineProperties(obj,{
				add : {
					value : store.$.add
				},
				remove : {
					value : store.$.remove
				}
			})
		},
		defUtls:function(obj,model,record,key){
			if(model){
				store.$.defProp(obj, "model", model);
				// if(model._fldGrps && model._fldGrps.hasOwnProperty("srtObs")){
				// 	store.$.defProp(obj, "srtObs", true, false, true);
				// }
			}
			if(record){
				store.$.defProp(obj, "record", record, false, true);
			}
			if(key){
				store.$.defProp(obj, "key", key);
			}
		},
		defPar:function(arr){
			store.$.defProp(arr, "partial", new Map());
		},
		cmpSet:function(obj, key, value, opts, fromStore){
			if(typeof Lyte.Component != "undefined"){
				// obj = Lyte.isRecord(obj) && obj.$.delayPersistence ? obj.$._data : obj;
				Lyte.Component.set(obj, key, value, opts, fromStore);
			}
			else{
				obj[key] = value;
			}
		},
		defProp:function(scp, key, val, enume, write){
			enume = !enume ? false : true;
			write = !write ? false : true;
			Object.defineProperty(scp, key, {
				value : val,
				enumerable : enume,
				writable : write
			});
		},
		removeChildRecords:function(scope,record,recMap,partOnlyRem){
			if(!recMap.get(record) && scope){
				recMap.set(record,true);
				var pkval=record?record.$.pK:undefined,arrPK=[]
				var r = scope._fldGrps.inherit;
				for(var v in r){
					var fkey = r[v].relKey?r[v].relKey:undefined
					if(record && fkey){
						if(scope.fieldList[fkey].relType=="belongsTo" && record[scope.fieldList[fkey].relKey]){
							this.removeChildRecords(store.modelFor(scope.fieldList[fkey].relatedTo),record[scope.fieldList[fkey].relKey],recMap);
						}
						else if(scope.fieldList[fkey].relType=="hasMany" && record[scope.fieldList[fkey].relKey]){
							var len = record[scope.fieldList[fkey].relKey].length;
							for(var v1=len-1; v1>=0; v1--){
								this.removeChildRecords(store.modelFor(scope.fieldList[fkey].relatedTo),record[scope.fieldList[fkey].relKey][v1],recMap);
							}
						}
					}
				}
				arrPK.push(pkval);
				this.removeFromStore(scope,arrPK,true,true,undefined,undefined,partOnlyRem);
			}
		},
		rBinherit:function(scope,recmp){
			var record=scope.record,
			rel=scope.model._fldGrps.inherit;
			for(var v in rel){
				if(rel[v].opts && rel[v].opts.inherit && record[rel[v].relKey]){
					if(rel[v].relType === "belongsTo"){
						var _record = record[rel[v].relKey]
						if(_record && !recmp.get(_record)){
							recmp.set(_record,true);
							this.rollBackRecord(_record.$,{inherit:true});
							store.$.rBinherit(_record.$,recmp);
						}
					}
					else if (rel[v].relType === "hasMany"){
						var rel_len = record[rel[v].relKey].length;
						if(rel_len != 0 ){
							for(var j=rel_len-1; j>=0; j--){
								var _record = record[rel[v].relKey][j]
								if(_record && !recmp.get(_record)){
									recmp.set(_record,true);
									this.rollBackRecord(_record.$,{inherit:true});
									store.$.rBinherit(_record.$,recmp);
								}
							}
						}
					}
				}
			}
		},
		rollBackRecord:function(scope,inherit){
			var model = scope.model, pK = model._pK;
			if(scope.isModified){
				scope.rollBackAttributes(scope.getDirtyAttributes(),inherit);
				delete scope._savedState;
			}
			if(scope.isDeleted){
				store.$.rollBackDelete(model, scope.get(pK), undefined, inherit);
			}
			else if(scope.isNew){
				store.$.rollBackNew(model, scope.record, pK,inherit);
			}			
			else if(scope.isError){
				store.$.clrRecErr(scope);
			}
			store.$.removeOnSave(scope.model._name, scope.record.$.pK);
		},
		buildVariables:function(gqlvar,variables,key,type){
			gqlvar=gqlvar?gqlvar:{};
			for(var v in variables){
				if(variables[v].search(/!/g)!=-1){
					if(!gqlvar[v] && !key ){
						return {LdEr:"LD30",LyteError:"ERR30","key":v};
					}
				}
				if(variables[v].search(/!/g)!=-1){
					variables[v]=variables[v].replace(/!/g,"");
				}
				if(key && variables[v].search(/\./g)==-1){
					if(variables[v]=="ID" || variables[v]=="ID!"){
						gqlvar[v]=key;
					}
				}
				var ErrObj={LdEr:"LD31",LyteError:"ERR30","key":v};
				if(gqlvar && gqlvar[v]){
					switch(variables[v]){
						case "Int":
							if(typeof gqlvar[v] != "number"){
								return ErrObj;
							}
							break;
						case "String":
							if(typeof gqlvar[v] != "string"){
								return ErrObj;
							}
							break;
						case "Float":
							if(typeof gqlvar[v] != "number"){
								return ErrObj;
							}
							break;
						case "Boolean":
							if(typeof gqlvar[v]!="boolean"){
								return ErrObj;
							}
							break;
						case "Object":
							if(typeof gqlvar[v]!="object"){
								return ErrObj;
							}
							break;
					}
				}
			}
				for(var t in gqlvar){
					if(typeof gqlvar[t] == "string"||typeof gqlvar[t] == "object"){
						gqlvar[t]=store.$.LyteStringfy(gqlvar[t],"")
					}
				}
			return gqlvar;
		},
		buildQuery:function(modelName,type,fieldArr,variables,parent,qname,sendvar,key,LocalAttrs,Pmodel){
			var str="",ignore=false;
			for(var v in fieldArr){
				if (typeof(fieldArr[v]) == "object"){
                       str+=Object.keys(fieldArr)[0]+" ";
					if(sendvar){
                        str+="( ";
						//str+=(key?"id: "+key:'')+" ";
						for(var s in sendvar){
							if(s.search(/[.]/g)==-1 && parent ==''){
								str+=s+":"+sendvar[s]+" ";
							}
							else if(parent!='' && s.search(/[.]/g)!=-1){
								//var pcheck=s.replace(".","_");
								if(parent == s.match(/.*(?=\..*$)/g)[0]){
									var split= s.split('.');
									str+=split[split.length-1]+":"+sendvar[s]+" ";
								}
							}
						}
						str+=") ";
						str = str.replace(/\([ ]*\)/g,"");
					}
                    str+="{ ";
					for(var i =0; i<fieldArr[v].length;  i++){
						var v1 = fieldArr[v][i];
						ignore=false;
						if(LocalAttrs){
							ignore = (typeof(v1) == "string" && LocalAttrs.includes(v1) && parent == "")?true:(typeof v1 == "object" && LocalAttrs.includes(Object.keys(v1)[0]) && parent == "")?true:false
						}
						if(!ignore){
							if(typeof(v1) == "string"){
								str=str+v1+" ";
							}
							else{
								parent=(parent?parent+".":"")+Object.keys(v1)[0]
								str+=store.$.buildQuery(modelName,type,v1,variables,parent,qname,sendvar,key,LocalAttrs,Pmodel);
								parent=(v==qname)?"":v;
							}
						}
					}
					str+=" } ";
				}
			}
			return str;
		},
		QueryCallback: function(modelName,type,parent,fieldArr,variables,qstuct,qv,queryParams,urlObj){
			var mdl;
			if (typeof(fieldArr)== "object"){
				var key = Object.keys(fieldArr)[0];
				for(var i=0; i<fieldArr[key].length; i++){
					var v = fieldArr[key][i];
					if(typeof v ==  "object" && store.modelFor(modelName).fieldList[Object.keys(v)[0]] && store.modelFor(modelName).fieldList[Object.keys(v)[0]].relatedTo){
						mdl=store.modelFor(modelName).fieldList[Object.keys(v)[0]].relatedTo;
						store.$.QueryCallback(mdl,type,parent,v,variables,qstuct,qv,queryParams,urlObj);
					}
				}
				//console.log("selfquery",modelName,fieldArr,variables);
				var res =  store.$.initCB("serializer", modelName, "serializeSelfQuery", {args:[modelName,type,urlObj,fieldArr,variables,qstuct]});
				if(res){
					var qst= res.data[Object.keys(fieldArr)[0]];
					fieldArr[Object.keys(fieldArr)[0]]=qst;
				}
			}
			// modelName=parent;
		},
		buildFields:function(modelName ,parent , key,pModel,marr,properties){
            var mdl = store.modelFor(modelName),mdlfl = mdl.fieldList;
            var LocalAttrs=(mdl.gql && mdl.gql.localAttrs)?mdl.gql.localAttrs:[];
            if(!properties){
                 marr.set(modelName,true);
            }
            else{
                mdlfl = properties;
            }
			var obj = {},arr =[];
			for( var v in mdlfl){
				if(!LocalAttrs.includes(v)){
					if (mdlfl[v].type == "relation" ){
						if(store.modelFor(mdlfl[v].relatedTo) && mdlfl[v].relatedTo!=pModel && mdlfl[v].relatedTo!=modelName){
							var check = store.$.getBackwardRel(store.modelFor(modelName),mdlfl[v],store.modelFor(mdlfl[v].relatedTo));
							if(check && check.relatedTo == parent && check.dummy == undefined){
								continue;
							}
							else{
								var flag =0;
								// for(var item =0; item<marr.length;item++){
								// 	var check_=store.$.getBackwardRel(store.model[modelName],mdlfl[v],store.model[marr[item]]);
								// 	if(check_ && check_.relatedTo==modelName && check_.dummy == undefined){
								// 		flag=1;
								// 	}
								// }
								if(!marr.has(mdlfl[v].relatedTo)){
									arr.push(store.$.buildFields(mdlfl[v].relatedTo, mdlfl[v].relatedTo,v,pModel,marr));
								}
							}
						}
						continue;
					}
                    else if( mdlfl[v].type == "object" && mdlfl[v].properties){
                        arr.push(store.$.buildFields(modelName,parent,v,pModel,marr,mdlfl[v].properties))
                    }
					else{
						arr.push(v);
					}
				}
			}
			obj[key] = arr;
			marr.delete(modelName);
			return obj;
		},
		parseQuery:function(modelName,key,type,queryParams,gqlObj,mdlq,gqlvar,urlObj,LocalAttrs,payLoad,customData){
			var qstr,qv,qlvar={},ret={},sendvar,qkey={};
			if(typeof(mdlq) == "object"){
				var qstuct,sq,mparent,k;
				var k = Object.keys(mdlq.query);
				var queryName = k[0]!="variables"?k[0]:k[1];			
				qv=Object.assign({},mdlq.query.variables);
				qkey[k[0]!="variables"?k[0]:k[1]]=Object.assign(mdlq.query[k[0]!="variables"?k[0]:k[1]]);
				if(typeof(qkey) == "object"){
					qstuct = qkey;
				}
			}
			if(typeof(mdlq) == "string" && mdlq.search(/[ ]/g)!=-1){
				var cquery = mdlq,cvar={},qst='';
				cquery=cquery.replace(new RegExp('\n','g')," ");
				cquery=cquery.replace(/ *[ ]*\(/g,":{variables:[");
				cquery=cquery.replace(/ *\) *{/g,"],attrs:[");
				cquery=cquery.replace(/\w+/g,'"$&"');
				cquery=cquery.replace(/"!/g,'!"')
				cquery=cquery.replace(/" +"/g,'", "');
				cquery=cquery.replace(/\S+{"variables"/g,"{$&");
				cquery=cquery.replace(/} *"/g,'}, "')
				cquery=cquery.replace(/" *{/g,'" :{"attrs" :[')
				cquery=cquery.replace(/\} *\}/g,"]}}");
				cquery=cquery.replace(/" *}/g,'"]} }');
				cquery=cquery.replace(/]}}/g,"]}}]}}");
				cquery=cquery.replace(/]}}]}} *}/g,"]}}]}}]}}")
				cquery=cquery.replace(/} *{/g,"},{");
				cquery=cquery.replace(/\S+ *:{"attrs"/g,"{$&");
				cquery=JSON.parse(cquery);
				qstuct=store.$.buildQueryFields(cquery,cvar,qst,Object.keys(cquery)[0]);
				qv=cvar;
			}
			if(typeof(qstuct) == "object"){
				store.$.QueryCallback(modelName,type,modelName,qstuct,gqlvar,qstuct,qv,queryParams,urlObj)
				gqlObj.query=qstuct;
				if(gqlvar){
					gqlObj.variables=gqlvar;
				}
				var qvkey = Object.keys(qv)[0];
				gqlObj.type == "Mutation" && Object.keys(qv).length == 1 && (qv[qvkey]=="Object" || qv[qvkey] =="Object!")?gqlObj.variables[qvkey]=payLoad:gqlObj.variables;
				var res = store.$.initCB("serializer", modelName, "serializeGqlQuery", {args:[modelName,type,key,gqlObj,urlObj,payLoad,customData]});
				if(res){
					qstuct = res.data.query;
					if(res.data.variables){
						gqlvar = res.data.variables;
					}
				}
				sendvar = store.$.buildVariables(gqlvar,qv,key,urlObj.type);
				if(sendvar && sendvar.LdEr){
					return sendvar;
				}
				urlObj.gqlObj=gqlObj;
				qstr = store.$.buildQuery(modelName,type,qstuct,qv,'',Object.keys(qstuct)[0],Object.keys(sendvar).length!=0?sendvar:undefined,key,LocalAttrs,modelName);
				qstr='{ '+qstr+' }';
			}
			gqlObj.type == "Query"?ret.query=qstr:ret.query = 'mutation '+qstr;		
			return ret;
		},
		graphQlconfig:function(modelName,key,type,queryParams,oprName,gqlvar,urlObj,payLoad,customData){
			var gQobj={},model=store.modelFor(modelName),mdlq,mdq,gqlObj={},mp =new Map();
			var LocalAttrs=(model.gql && model.gql.localAttrs)?model.gql.localAttrs:[];
			if(type == "findAll" || type =="findRecord"){
				gqlObj.type="Query";
				mdq= (model.gql && model.gql.query && model.gql.query[oprName]) ?  model.gql.query[oprName] :oprName;
				if(mdq === undefined ){
					var stq = store.$.buildFields(modelName, null, modelName,modelName,mp); 
					mdlq={};
					mdlq.query=stq;
					gqlObj.queryType="default"
				}
				else{
					if(typeof(oprName) == "string" && oprName.search(/[ ]/g)!=-1){
						mdlq=oprName;
						gqlObj.queryType="query"
					}
					else if(typeof(oprName) == "object"){
						mdlq=oprName;
					}
					else if(typeof(mdq) == "object"){
						mdlq=mdq;
					}
					else {
						if (typeof(mdq) == "string" && mdq.search(/[ ]/g)!=-1){
							mdlq = mdq;
							gqlObj.queryType="namedQuery";
							gqlObj.queryName=oprName;	
						}
						else{
							return {LdEr:"LD32",LyteError:"ERR31",key:oprName};
						}
					}
				}
				gqlvar=gqlvar?Object.assign({},gqlvar):undefined;
			}
			else{
				gqlObj.type="Mutation";
				mdq = (model.gql && model.gql.mutation && model.gql.mutation[oprName]) ?  model.gql.mutation[oprName] :oprName;
				if(typeof(oprName) == "string" && oprName.search(/[ ]/g)!=-1){
					mdlq=oprName;
					gqlObj.mutationType="customMutation";
				}
				else{
					if(typeof(mdq) == "string" && mdq.search(/[ ]/g)!=-1){
						mdlq = mdq;
						gqlObj.mutationType = "namedMutation";
						gqlObj.MutationName=oprName;
					}
					else{
						return {LdEr:"LD32",LyteError:"ERR31",key:oprName};
					}
				}
			}
			var sendQuery = store.$.parseQuery(modelName,key,type,queryParams,gqlObj,mdlq,gqlvar,urlObj,LocalAttrs,payLoad,customData);
			if(!sendQuery.LdEr){
				gQobj.data = JSON.stringify(sendQuery);
				return gQobj.data;
			}
			return sendQuery;
		},
		setQuery:function value(scope,key,type,Query){
			var model = scope;
			if(model.gql){
				model.gql[type]=model.gql[type]?model.gql[type]:{};
				model.gql[type][key]=model.gql[type][key]?model.gql[type][key]:{}
			}
			else{
				model.gql={};
				model.gql[type]={};
				model.gql[type][key]={};
			}
			model.gql[type][key]=Query;
		},
		buildQueryFields:function(fields,variable,parent,objkey){
			var key = Object.keys(fields)[0],arr=[],query={};
			if(fields[key].variables){
				for(var i=0; i<fields[key].variables.length; i=i+2){
					variable[(parent?parent+".":"")+fields[key].variables[i]]=fields[key].variables[i+1];
				}
			}
			for(var q=0; q<fields[key].attrs.length; q++){
				if(typeof fields[key].attrs[q] == "object"){
					parent=(parent?parent+".":"")+Object.keys(fields[key].attrs[q])[0];
					arr.push(this.buildQueryFields(fields[key].attrs[q],variable,parent,objkey));
					parent=(key != objkey)?key:"";
				}
				else{
					arr.push(fields[key].attrs[q]);
				}
			}
			query[key]=arr;
			return query;
		},
		LyteStringfy:function(object,string,fs){
			if(typeof object == "string"){
				return '\"'+object+'"\ '
			}
			else if(Array.isArray(object)){
				string+='[';
				var i=0,len = object.length;
				object.forEach(function(val){
					i++;
					if(typeof val == "string"){
						string=string+'\"'+val+'"\ ';
					}
					else if(typeof val == "object"){
						string=store.$.LyteStringfy(val,string);
					}
					else if(typeof val == "number"){
						string=string+object.toString();
					}
					string=(i!=len)?string+',':string;
				})
				string+=']';
			}
			else if (object && !Array.isArray(object) && typeof object == "object"){
				string=string+'{';
				var j =0;
				for(var i in object){
					j++;
					if(typeof object[i] == "string"){
						string=string+i+' : \"'+object[i]+'"\ ';
					}
					else if(typeof object[i] == "object"){
						string=string+i+" : "
						string = store.$.LyteStringfy(object[i],string)
					}
					else{
						string=string+i+' : '+object[i].toString()
					}

					if(Object.keys(object).length!=j){
						string = string+', '
					}
				}
				string=string+'}'
			}
			else{
				 return object.toString();
			}
			return string;
		},
		cpdGql:function(modelName,type,qp,urlObj,changedData,customData){
			var createdVariables=[];
			if(urlObj.gql){
				if(typeof urlObj.gql == "object"){
					mutName=urlObj.gql.mutation;
				}else if(urlObj.gql == true){
					mutName=undefined;
				}
				urlObj.data=store.$.graphQlconfig(modelName,undefined,type,qp,mutName,createdVariables,urlObj,changedData,customData)
			}
		},
		payloadAdd:function(key,index){
			if(!Array.isArray(key)){
				key=[key];
			}
			var modelName= this._model,partObj=this._partialObj,payload=this._payloadObj;
			var field = {opts : { serialize : this._serialize}};
			var _pk = {} , partial={};
			for(var i =0 ; i<key.length; i++){
				if(partObj._removedRecords && partObj._removedRecords.hasOwnProperty(key[i])){
					_pk = partObj._removedRecords[key[i]]._payload;
					partial = partObj._removedRecords[key[i]]._partial;
					delete partObj._removedRecords[key[i]];
				}
				else{
					var record=store.$.peekRecord(modelName,key[i]);
					var data = store.$.PayloadSerialize(field,_pk,record,undefined,store.modelFor(modelName),partial)
					_pk = data.payload;
					partial= data.partial;
				}
				if(!this.partRecMap.get(key[i])){
					if( index != undefined && typeof index == "number"){
						Lyte.arrayUtils(partObj,"insertAt",index,partial);
						Lyte.arrayUtils(payload,"insertAt",index,_pK);
						index=index++;
					}
					else{
						Lyte.arrayUtils(partObj,"push",partial);
						Lyte.arrayUtils(payload,"push",_pk);
					}
					this.partRecMap.set(key[i],true);
				}
			}
		},
		payloadRemove:function(key){
			var modelName= this._model,partObj=this._partialObj,payload=this._payloadObj;
			if(!Array.isArray(key)){
				key=[key];
			}
			for(var j =0; j<key.length; j++){
				if(Array.isArray(payload)){
					var len=payload.length;
					if(this._serialize && this._serialize == "id"){
						if(payload.includes(key[j])){
							var _index = payload.indexOf(key[j]);
							payload.splice(_index,1);
						}
					}
					else{
						for(var i =0; i<len; i++){
							if(partObj[i] && partObj[i].$.pkVal == key[j]){
								if(!partObj.hasOwnProperty("_removedRecords")){
									var val =  {};
									val[partObj[i].$.pkVal]={ _partial:partObj[i] , _payload : payload[i]};
									Object.defineProperties(partObj,{
										_removedRecords : {
											value : val
										}
									})
								}else{
									partObj._removedRecords[partObj[i].$.pkVal] = {
										_partial : partObj[i] , 
										_payload : payload[i]
									}
								}
								//!partObj.hasOwnProperty("_removedRecords") ? Object.defineProperties(partObj,{ _removedRecords :{ value : { [partObj[i].$.pkVal] :{ _partial:partObj[i] , _payload : payload[i]} } } } ):partObj._removedRecords[partObj[i].$.pkVal] = { _partial:partObj[i] , _payload : payload[i]};
								Lyte.arrayUtils(partObj,"removeAt",i,1);
								Lyte.arrayUtils(payload,"removeAt",i,1);
								this.partRecMap.delete(key[j]);
							}
						}
					}
				}
				else{
					if(payload[key[j]]){
						partObj.hasOwnProperty("_removedAttr") && !partObj._removedAttr.hasOwnProperty(key[j])? partObj._removedAttr[key[j]]={ _partial:partObj[key[j]] , _payload : payload[key[j]]} : !partObj.hasOwnProperty("_removedAttr") ? Object.defineProperties(partObj,{ _removedAttr : { value : { _partial:partObj[key[j]] , _payload : payload[key[j]]} } }):undefined;
						if(partObj[key[j]]){
							partObj._removedAttr[key[j]]._partial = partObj[key[j]];
							Lyte.objectUtils(partObj,"delete",key[j]);
						}
						Lyte.objectUtils(payload,"delete",key[j]);
					}
				}
			}
		},
		payloadSet:function(fkey){
			if(!Array.isArray(fkey)){
				fkey=[fkey];
			}
			var modelName=this._model,pk=this._pkVal,model=store.modelFor(modelName),payload=this._payloadObj;
			var record = store.$.peekRecord(modelName,pk),partial=this._partialObj;
			for(var i_key=0; i_key<fkey.length; i_key++){
				var key = fkey[i_key];
				if(!this._payloadObj[key]){
					if(partial.hasOwnProperty("_removedAttr")){
						if(partial._removedAttr.hasOwnProperty(key) && partial._removedAttr[key] != true){
							payload[key]=partial._removedAttr[key]._payload;
							if(partial._removedAttr[key]._partial){
								partial[key] = partial._removedAttr[key]._partial;
							}
							Lyte.objectUtils(partial._removedAttr,"delete",key);
							return;
						}
					}
					var field = model.fieldList[key];
					if(record[key] && field.type == "relation"){
						if(field.relType == "hasMany"){
							partial[key]=[];
							payload[key]=[];
							if(field.opts && field.opts.serialize=="id"){
								store.$.payLoadIdSerialize(payload,key,record,model,field,partial)
							}
							store.$.defProp(payload[key], "$", {});
							store.$.defPayArrUtls(payload[key].$);
							Object.defineProperties(payload[key].$,{
								_key:{
									value:field.relKey
								},
								_partialObj:{
									value:partial[key]
								},
								_model:{
									value:field.relatedTo
								},
								_payloadObj:{
									value:payload[key]
								},
								replace:{
									value:store.$.replaceCheck,
									writable:true
								},
								partRecMap : {
									value: new Map()
								}
							})
							if(field.opts && field.opts.serialize && !payload[key].$.serialize){
								Object.defineProperty(payload[key].$,"_serialize",{
									value : field.opts.serialize
								})
							}
							if(field.opts && field.opts.serialize!="id" || !field.opts){
								if(field.opts.serialize == "record"){
									for(i=0; i<record[key].length; i++){
										payload[key].$.add(record[key][i].$.pK);
									}
								}
								if(field.opts.serialize=="partial"){
									var dirtyRecords = record[key].partial;
									dirtyRecords.forEach(function(value,pk){
										payload[key].$.add(pk);
									})
								}
							}
						}
						else{
							partial[key]={};
							payload[key]={};
							var data = store.$.PayloadSerialize(field,payload[key],record[key],key,store.modelFor(field.relatedTo),partial[key]);
							payload[key]=data.payload
							partial[key]=data.partial
						}
					}
					else{
						payload[key]=record[key];
						partial[key]=record[key];
					}
				}

			}
		},
		payLoadIdSerialize : function(payload,key,record,model,field,partial){
			var rel={};
			payload[key] = Lyte.deepCopyObject(record[key]);
			store.$.getRelations(model,key,store.modelFor(field.relatedTo),rel);
			store.$.idSerialize(payload,rel,undefined,partial);
		},
		PayloadSerialize : function(field,payload,record,key,model,partial){
			var newKey = {};
			newKey[record.$.model._pK] = record.$.pK;
			var getPayloadData=typeof record.$.pK =="object" ? record.$.pK:newKey;
			var mdl = model;
			var data, part, isModifiedFlag = false;
			if(field.opts && field.opts.serialize){
				part = store.adapter.$.initPartialObj(model._name);
				if(field.opts.serialize == "record"){
					getPayloadData = store.$.toJSON(model._name,record,undefined,undefined,part);
				}
				if(field.opts.serialize == "partial"){
					var dirty = store.$.isDirty(record,mdl.relations);
					var rec = record;
					if(rec.$.isModified ||(dirty && dirty.length)){
						data = store.$.updateJSON(rec,mdl,dirty);
						getPayloadData = store.$.toJSON(model._name,data,undefined,undefined,part)
						isModifiedFlag = true;
					}
					else{
						part.obj.set( record.$.pK , partial)
					}
				}
				partial = part.obj.get( record.$.pK ) || partial;
				var partobj ={
					pkVal : {
						value : record.$.pK
					},
					type : {
						value : "related"
					},
					model : {
						value : mdl._name
					},
					record : {
						value : record[key] || record
					}
				}
				if(isModifiedFlag == true){
					partobj.type.value="modified"
				}
				if(getPayloadData){
					payload = store.adapter.$.serializeRecords(model._name,getPayloadData,record,undefined,"serializeRecord",undefined,part.obj)
				}
				if(field.opts && field.opts.serialize == "id"){
					getPayloadData=record.$.pK
				}
				if(typeof payload == "object"){
					if(partial && !partial.$){
						store.$.defProp(partial, "$", {});
					}
					var nPartial = 	partial.$;
					Object.defineProperties(nPartial,partobj);
					if(field.opts && field.opts.serialize && payload.$ && !payload.$._serialize && field.relType == "belongsTo"){
						Object.defineProperty(payload.$,"_serialize",{
							value : field.opts.serialize
						})
					}
				}
				var data = {
					"payload": payload,
					"partial": partial
				}
				return data;
			}
		},
		replaceCheck:function(bool){
			store.$.defProp(this._partialObj,"replace",bool)
		},
		savingDonorRecord : function(scope){
			var donor = scope.donor, dirtAttr = scope.getDirtyAttributes() , relDirty = store.$.isDirty(scope.record , scope.model.relations);
			if(relDirty.length || dirtAttr.length){
				var state = scope.toJSON("state");
				store.$.setData(donor.$,state,undefined,undefined,undefined,undefined,true);
				scope.persist();
			}
			return donor.$;
		},
		peekRecord: function(modelName, pKey, isDeleted, prx){
			var model = store.modelFor(modelName), modelless = store.$.getFromCB("adapter",modelName,"modelless"), _defless;
			model = modelless ? modelName : model;
			if( !model ){
				Lyte.warn("LD02","Model ",modelName);
				return;
			}
			else if(modelless == true && model){
				model = store.modelless[model];
				if(!model){
					// Lyte.error("LD02","Model");
					return;	
				}
				_defless = true;
			}   
			if(isDeleted === true){
				var deleted = model._deleted;
				var obj = deleted.get(pKey);
				if(obj && obj.data){
					if(obj.data && Lyte.getConfig("mutable")){
						return Lyte.mut(obj.data);
					}
					return obj.data;
				}
			}
			else{
				var isComp = model.isComp; 
				pKey = (pKey == undefined) ? "" : pKey;
				if(!isComp && model.data._recMap){
					var rec = model.data._recMap.get(pKey.toString());
					if(prx && Lyte.getConfig("mutable")){
						return Lyte.mut(rec);
					}
					return rec;
				}
				else{
					var data = model.data, record;
					if(_defless != true){
						record = data.filter(function(record){
							if(store.$.comparePk(record, pKey)){
								if(prx && Lyte.getConfig("mutable")){
									return Lyte.mut(record);
								}
								return record;
							}
						});
					}
					else{
						record = data.filter(function(ins){
							if(ins[model._pK] === pKey){
								return ins;
							}
						});
					}    
					if(record[0]){
						if(prx && Lyte.getConfig("mutable")){
							return Lyte.mut(record[0]);
						}
						return record[0];
					}
				}
			}
			return undefined;
		},
		getCreatedTime : function(cTmap){
			var time = new Date().getTime().toString();
			var count = 1;
			if(cTmap.get(time)){
				count = cTmap.get(time)
				count = count+1;
				cTmap.set(time,count)
			}
			else{
				cTmap.clear();
				cTmap.set(time , count)
			}
			var numLen = count.toString().length,res;
			switch(numLen){
				case 1 : {
					res="000"+count;
					break;
				}
				case 2 : {
					res="00"+count;
					break;
				}
				case 3 : {
					res="0"+count;
					break;
				}
				case 4 : {
					res=""+count;
					break;
				}
				default :{
					res = "9999";
				}
			}
			return time+res;
		}
	}
}


function Adapter(attrs,opts,name){
	var self =this;
	Object.defineProperty(self,'$lg', {
		value : Lyte.__gl
	});
	store.$.newCB("adapter", this, name, attrs, opts);
}
store.$.cbDef(Adapter, "adapter");
store.adapter = {
	$: {
		buildURL : function(type,method,modelName,key, snapshot, queryParams,actionName,customData,url,gqlEnables){
			var adapter = store.$.getAdapter({name:modelName}), host = store.$.getFromCB("adapter",modelName,"host"), url = url || "", makeBatch = store.$.makeBatch;
			// var modelless = store.$.getFromCB("adapter",modelName,"modelless"), name;	
			// if(typeof modelName == "string" && modelless){
			// 	name = modelName;
			// }
			url = url || "";
			var ret={method: method};
			if(!url){
				if(!makeBatch){
					if(host !== undefined){
						url += host;
						if(host[host.length-1] != "/"){
							url+="/";					
						}
					}
				}
				// enable = store.$.getFromCB("adapter",modelName,"enableGraphQl");
				// var check = store.$.enableGraphql(enable,type,enableGQl); 
				// var check = store.$.initCB("adapter", modelName, "GraphQl", {args:[modelName,type,queryParams,key,{query:oprName,variables:gqlVariables},customData]});
				if(!gqlEnables){
					var namespace = store.$.getFromCB("adapter",modelName,"namespace");
					if(namespace !== "" && namespace[namespace.length-1] != "/"){
						url+=namespace+"/";
					}
					else{
						url+=namespace;
					}
					if(type != "batch"){
						url+=modelName;
						if(key && typeof key != "object"){
							url+="/"+key;
						}	
					}
					if(type == "action"){
						url+="/"+store.$.getFromCB("adapter",modelName,"actionNamespace");
						var actions = store.modelFor(modelName).actions, action = actions[actionName].endPoint?actions[actionName].endPoint:actionName;
						url+="/"+action;
					} else if(type == "batch"){
						url+=store.$.getFromCB("adapter","application","batchNamespace");
					}
					ret.method = method ? method : "";
				}
				else{
					ret.method="POST";
					ret.gql=gqlEnables;
					method = ret.method;
					var gqlNamespace = store.$.getFromCB("adapter",modelName,"gqlNamespace");
					url+=gqlNamespace?gqlNamespace:"";
				}
			}
			if(!queryParams){
				queryParams = {};
			}
			var res = store.$.initCB("adapter", modelName, "headersForRequest", {args:[type, queryParams, customData, actionName, key]});
			if(res){
				ret.headers = res.data;
			}

			res = store.$.initCB("adapter", modelName, "buildURL", {args:[modelName, type, queryParams, snapshot, url,actionName,customData, key]});
			if(res){
				url = res.data;
			}

			res = store.$.initCB("adapter", modelName, "methodForRequest", {args:[method, type, queryParams, customData, actionName, key]});
			if(res){
				ret.method = res.data;
			}
			if(!makeBatch && queryParams &&Object.keys(queryParams).length){
				url+="?";
				var index = 0;
				for(var qKey in queryParams){
					if(index !== 0){
						url+="&";
					}
					var res = queryParams[qKey];
					if(res && typeof res == "object"){
						res = JSON.stringify(res);
					}
					url+=qKey+"="+encodeURIComponent(res);
					index++;
				}
			}
            if(adapter && adapter.withCredentials == true){
                ret.withCredentials = true;
            }
			ret.url = url;
			ret.qP = queryParams;
			return ret;
		},
		get : function(type, modelName, key, queryParams, cacheQuery, customData, cacheData,oprName,gqlVariables){
			var mdl = store.modelFor(modelName), 
			makeBatch = store.$.makeBatch, 
			gqlEnables, 
			gqlobj= ( gqlVariables || oprName ) ? {} : undefined, 
			modelless = store.$.getFromCB("adapter",modelName,"modelless");	
			if(modelless && typeof modelName == "string"){
				var defobj = store.modelless, _name = modelName; 
				def = defobj[_name] = defobj[_name] || {};
				def._name = _name;
			}		
			if(mdl || (modelName && modelless)){
				customData = customData == undefined ? store.$.getFromCB("adapter", modelName, "customData") : customData;
				oprName?gqlobj.query=oprName:undefined;
				gqlVariables?gqlobj.variables=gqlVariables:undefined;
				gqlEnables = store.$.initCB("adapter", modelName, "gql", {args:[modelName,type,queryParams,key,gqlobj,customData]});
				var urlObj = this.buildURL(type, "GET", modelName, key, undefined, queryParams,undefined,customData,undefined,gqlEnables?gqlEnables.data:undefined), self = this;
				queryParams = urlObj.qP,
				toCheckParams = (cacheQuery && typeof cacheQuery !== "boolean") ? cacheQuery : (queryParams && typeof queryParams == "object") ? queryParams : undefined;
				if(urlObj.gql){
					if (typeof (urlObj.gql) =="object"){
						oprName=urlObj.gql.query,
						gqlVariables=urlObj.gql.variables;
					}else if(urlObj.gql === true){
						oprName=gqlVariables=undefined;
					}
					urlObj.data=store.$.graphQlconfig(modelName,key,type,queryParams,oprName,gqlVariables,urlObj);
					if(urlObj.data.LdEr){
						Lyte.warn(urlObj.data.LdEr,urlObj.data.key,modelName);
						return Promise.reject({code :urlObj.data.LyteError , message : Lyte.errorCodes[urlObj.data.LyteError], data:urlObj.data.key})
					}
				}
				if(type == "findAll" && toCheckParams && store.model.cachedQueries && store.model.cachedQueries[modelName]){
					var cachedQueries = store.model.cachedQueries[modelName], sendData;
					for(var i=0; i<cachedQueries.length; i++){
						var qry = cachedQueries[i];
						if(!qry.hasDeletedRecords){
							var params = qry.cacheQuery;
							if(this.compareData(params, toCheckParams, true)){
								sendData = [qry.data, "cache", undefined, qry.status];
								break;
							}
						}
					}
					if(sendData){
						return new Promise(function(resolve){
							if(makeBatch){
								store.$.addToCachedBatch(Array.isArray(sendData) ? sendData[0][modelName] : sendData);
							}
							resolve(sendData);
						});
					}
				}
				else if(type == "findRecord" && toCheckParams && store.model.cachedRecordQueries && store.model.cachedRecordQueries[modelName] && store.model.cachedRecordQueries[modelName][key]){
					var cachedQueries = store.model.cachedRecordQueries[modelName][key], sendData;
					for(var i=0; i<cachedQueries.length; i++){
						var params = cachedQueries[i].cacheQuery;
						if(this.compareData(params, toCheckParams, true)){
							sendData = [cachedQueries[i].data, "cache", undefined, cachedQueries[i].status];
							break;
						}
					}
					if(sendData){
						return new Promise(function(resolve){
							if(makeBatch){
								store.$.addToCachedBatch(Array.isArray(sendData) ? sendData[0][modelName] : sendData);
							}
							resolve(sendData);
						});
					}
				}
				else{
					var scope = store.$.cbScp(modelName, (type == "findRecord" ? "reloadRecord" : "reloadAll"), "adapter");
					if(scope){
						var records, callReload = false;
						if(type == "findRecord"){
							records = store.$.peekRecord(modelName,key);
							callReload = Lyte.isRecord(records) ? true : false;							
						}
						else if(type == "findAll"){
							records = store.peekAll(modelName);
							callReload = records && records.length ? true : false;
						}
						if(callReload && !store.$.cB(scope, [records, queryParams, customData, modelName])){
							var toRet = {};
							toRet[modelName] = records;
							return new Promise(function(resolve){
								if(makeBatch){
									store.$.addToCachedBatch(toRet[modelName]);
								}
								resolve([toRet, "cache"], "success", undefined, true);
							});
						}
					}
				}
				if(urlObj.method == "POST"){
					var res = store.$.initCB("serializer", modelName, "serialize", {args:[type,urlObj?urlObj.data:undefined,undefined,customData,modelName,queryParams,undefined,urlObj?urlObj.gqlObj:undefined]});
					if(res){
						urlObj.data = res.data;
						if(urlObj.data && (typeof urlObj.data == "object" || Lyte.isRecord(urlObj.data) || Array.isArray(urlObj.data)) && !(urlObj.data instanceof FormData)){
							// urlObj.reqData = Lyte.deepCopyObject(urlObj.data);
							urlObj.data = JSON.stringify(urlObj.data);
						}
					}
				}
				return new Promise(function(resolve, reject){
					var model = store.modelFor(modelName);
					var idbObj = store.$.getIDBObj(model, queryParams, type, key, customData);
					var processRequest = store.$.getFromCB("adapter", modelName, "processRequest"),payLoad, sendXHR = true;
					var batchPro = false;
					var argsXHR = [modelName,type,key,urlObj,resolve,reject,"get",undefined,customData];
					var opts = { cacheQuery : cacheQuery, cacheData : cacheData, customD : customData};
					if(processRequest){
						sendXHR = false;
						var returnPromise = self.callGeneric(type,modelName,undefined,undefined,customData, queryParams,key,urlObj.url,undefined,urlObj.method,urlObj.headers);
						if(returnPromise instanceof Promise){
							batchPro = true;
							returnPromise.then(function(resp){
                                resp = (resp == "" ? JSON.parse("{}") : JSON.parse(resp));
								payLoad = self.getResponse(resp,modelName,type,key,urlObj,undefined,customData,opts);
								resolve([payLoad]);
							},function(message){
                                reject(message);
							});
						}
						else{
							sendXHR = true;
						}
					}
					if(makeBatch && !batchPro){
						store.adapter.$.constructBatch.apply(store.adapter.$, argsXHR).then(function(resObj){
							var payLoad = resObj.content;
							store.adapter.$.getSuccess(modelName,type,key,urlObj,undefined,resolve,reject,payLoad,resObj,undefined,opts);
							//resolve(payLoad);							
						},function(resObj){
							store.adapter.$.getFailure(modelName,type,key,urlObj,undefined,resolve,reject,opts,resObj.content,resObj.code, resObj);
						});
					}
					else if(idbObj){
						store.adapter.$.getFromIDB(idbObj, modelName, type, queryParams, key, urlObj, customData).then(function(payLoad){
							var res = store.$.initCB("serializer", modelName, "idbResponse", {args:[modelName, type, queryParams, key, payLoad]});
							if(res){
								payLoad = res.data;
							}
							if(payLoad == false){
								store.adapter.$.sendXHR.apply(store.adapter.$, argsXHR).then(function(xhrReq){
									store.adapter.$.getSuccess(modelName,type,key,urlObj,xhrReq,resolve,reject,undefined,undefined,undefined,opts);
								}, function(xhrReq){
									store.adapter.$.getFailure(modelName,type,key,urlObj,xhrReq,resolve,reject,opts);
								});							
							}
							else{
								store.adapter.$.getSuccess(modelName,type,key,urlObj,undefined,resolve,reject,payLoad,undefined,"idb",opts);
							}
						},function(message){
							store.adapter.$.sendXHR.apply(store.adapter.$, argsXHR).then(function(xhrReq){
								store.adapter.$.getSuccess(modelName,type,key,urlObj,xhrReq,resolve,reject,undefined,undefined,undefined,opts);
							}, function(xhrReq){
								store.adapter.$.getFailure(modelName,type,key,urlObj,xhrReq,resolve,reject,opts);
							});							
						});
					}
					else if(sendXHR){
						store.adapter.$.sendXHR.apply(store.adapter.$, argsXHR).then(function(xhrReq){
							store.adapter.$.getSuccess(modelName,type,key,urlObj,xhrReq,resolve,reject,undefined,undefined,undefined,opts);
						},function(xhrReq){
							store.adapter.$.getFailure(modelName,type,key,urlObj,xhrReq,resolve,reject,opts);
						});
					}
				});
			}
			else {
				Lyte.warn("LD02","Model",modelName);
				return Promise.reject({code : "ERR19", message : Lyte.errorCodes.ERR19, data:modelName});
			}
		},
		constructBatch:function(modelName,type,key,urlObj){
			return new Promise(function(resolve, reject){
				var batch = store.$.currentBatch;
				var q = store.$.batch[batch] = store.$.batch[batch] || [];
				var pro = store.$.batchPromise[batch] = store.$.batchPromise[batch] || []; 
				var batchObj = {};
				batchObj.method = urlObj.method;
				batchObj.uri = "/" + urlObj.url;
				batchObj.parameters = urlObj.qP;
				batchObj.content = typeof urlObj.data == "string" ? JSON.parse(urlObj.data) : undefined;
				q.push(batchObj);
				pro.push({resolve:resolve,reject:reject});	
			});
		},
		getFromIDB : function(idbObj ,modelName, type, queryParams,key, urlObj, customData){
			return new Promise(function(resolve, reject){
				var reqType = idbObj.queryCache ? "getCachedData" : type == "findAll" ? "getAll" : "get";
				var obj = {resolve : resolve, reject: reject, type:reqType, model:modelName, req:type, key:key};
				if(reqType == "getCachedData"){
					obj.queryParams = queryParams;
				}
				obj.queryCache = idbObj.queryCache;
				obj.customData = customData;
				LyteIDB.postMessage(obj);
			});
		},
		sendXHR:function(modelName,type,key,urlObj,resolve,reject,xhrType,data,customData){
			var xhr = new XMLHttpRequest();
			var prm = new Promise(function(res, rej){
				xhr.open(urlObj.method, urlObj.url, true);
				for(var header in urlObj.headers){
					xhr.setRequestHeader(header, urlObj.headers[header]);
				}
				xhr.withCredentials = (urlObj.withCredentials)?true:false;
				store.$.initCB("adapter", modelName, "parseRequest", {args:[type, modelName, xhr ,urlObj ? urlObj.qP : undefined, key, customData , urlObj.method , urlObj.headers , urlObj.url , urlObj.withCredentials?true:false , urlObj.data]});
				store.emit("beforeRequest", [xhr, modelName, type, key, urlObj.qP , urlObj.method , urlObj.headers , urlObj.url , urlObj.withCredentials?true:false , customData , urlObj.data]);
				xhr.send(urlObj.data);
				xhr.onreadystatechange = function(){
					if(xhr.readyState == 4){
						store.emit("afterRequest",[xhr, modelName, type, key, urlObj.qP , urlObj.method , urlObj.headers , urlObj.url , urlObj.withCredentials?true:false , customData , urlObj.data]);
						if(xhr.status.toString()[0] == "2" || xhr.status.toString()[0] == "3"){
							return res(xhr);
						}
						else{
							return rej(xhr);
						}
					}
				}
			});
			prm.xhr = xhr;
			return prm;
		},
		getSuccess:function(modelName,type,key,urlObj,xhr,resolve,reject,response,resObj,from,opts){
			var resp = response, req = xhr, batchIndex, batch, customD = opts.customD, status = xhr ? xhr.status : undefined;;
			if(from != "idb"){
				if(req){
					resp = req.responseText;
					if(resp && resp.length != 0){
						resp = JSON.parse(resp);
					}
					else{
						resp = JSON.parse("{}");
					}
				}
				if(resObj){
					batchIndex = resObj.index;
					batch = resObj.batch;
					req = resObj.resp;
				}
				if(req){
					var res = store.$.initCB("adapter", modelName, "parseResponse", {args:[type, modelName, req, resp, urlObj ? urlObj.qP : undefined, key, customD, opts]});
					if(res){
						resp = res.data;
					}
					if(resp instanceof Promise)
					{
						return this.handleParseResponsePromise(resp,modelName,type,key,urlObj,xhr,undefined,batchIndex,batch,resolve,reject,opts);
					}
				}
				return this.findParseRequestPromise(resp,modelName,type,key,urlObj,xhr,batchIndex,batch,resolve,opts);
				//resp = this.getResponse(resp,modelName,type,key,urlObj,xhr);
			}
			var resArr = xhr ? [resp, xhr.statusText, xhr] : (batchIndex != undefined) ? [resp,"batch",{index:batchIndex,batch:batch}] : from ? [resp, "idb"] : [resp];
			resolve(resArr);
		},
		getFailure:function(modelName,type,key,urlObj,xhr,resolve,reject,opts,content,code,bObj){
			var customD = opts.customD;
			if(xhr){
				var resp,response = xhr.responseText;
				if(response){
					try{
						response = (response == "" ? JSON.parse("{}") : JSON.parse(response));
					}
					catch(exp){
						Lyte.warn("LD24", exp);
					}
				}
				resp = response;
				var res = store.$.initCB("adapter", modelName, "parseResponse", {args:[type, modelName, xhr, response ,urlObj ? urlObj.qP : undefined, key, customD, opts]});
				if(res){
					resp = res.data;
				}
				if(resp instanceof Promise)
				{
					return this.handleParseResponsePromise(resp,modelName,type,key,urlObj,xhr,undefined,undefined,undefined,resolve,reject,opts);
				}
			}
			else if(content){
				var batch, batchIndex;
				if(bObj){
					batchIndex = bObj.index;
					batch = bObj.batch;
				}
				store.$.batchResponse[batch][batchIndex] = {code:code, status:"requestFailure", data:content};
				reject({code:code,status:"requestFailure", data:content});
			}
			reject(xhr);
		},
        getResponse:function(resp,modelName,type,key,urlObj,xhr,customData,opts){
			var doNormalize = opts.cacheData !== undefined && opts.cacheData !== null && typeof opts.cacheData == "object" && opts.cacheData.hasOwnProperty("normalize")  ? opts.cacheData.normalize : true;
			if(doNormalize === true){
				resp = store.serializer.$.normalizeResponse(modelName, type, resp, key, xhr ? xhr.status : xhr, urlObj,customData,opts)
				var scope, payLoad = resp, args, qP = urlObj ? urlObj.qP : undefined;
				if(typeof payLoad != "object"){
					payLoad = JSON.parse(payLoad);
				}
				var res = store.$.initCB("serializer", modelName, "extractMeta", {args:[payLoad,modelName,type,qP,customData,opts]}), metaRes;
				if(res){
					metaRes = res.data;
					if(!store.$.isEmpty(metaRes)){
						payLoad.meta = metaRes;
					}	
				}
				var keys = Object.keys(payLoad);
				var len = keys.length; 
				if(len){			
					res = store.$.initCB("serializer", modelName, "payloadKey", {args:[modelName,type,key,qP,customData,opts]});
					var plKey;
					if(res){
						plKey = res.data;
						if(plKey && plKey != modelName){
							var temp = payLoad[plKey];
							payLoad[modelName] = temp;
							delete payLoad[plKey];
						}
					}
					scope = store.$.cbScp(modelName, "deserializeKey", "serializer");
					if(scope){
						Lyte.warn("LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
						if(len > 2){
							Lyte.error("LD09");
						}
						var index = 0;
						if(len == 2 && keys[0] == "meta"){
							index = 1;
						}
						args = [modelName,type];
						var deserializeKey = store.$.cB(scope, args), rec = payLoad[keys[index]];
						delete payLoad[keys[index]];
						payLoad[deserializeKey] = rec;
					}
					store.serializer.$.normalize(modelName, type, payLoad, key, xhr ? xhr.status : xhr, urlObj.headers, customData, opts, urlObj);
				}
				return payLoad;
			}
			else{
				if(typeof resp != "object"){
					resp = JSON.parse(resp);
				}
				var res = store.$.initCB("serializer", modelName, "extractMeta", {args:[resp,modelName,type,qP,customData,opts]}), metaRes;
				if(res){
					metaRes = res.data;
					if(!store.$.isEmpty(metaRes)){
						resp.meta = metaRes;
					}	
				}
				return resp;
			}
		},
		initPartialObj : function(modelName, type, qP, key, url, customData){
			var partial = { obj : new Map() };			
			// partial.ref = new Map();
			// var rKey = "recId", refKey;
			// var res = store.$.initCB("serializer", modelName, "referenceKey", {args:[modelName,type,qP,key,url,customData]});
			// refKey = res ? res.data : undefined;
			// if(!store.$.isEmpty(refKey)){
			// 	rKey = refKey;
			// }
			// partial.ref.refKey = rKey;
			return partial;
		},
		create : function(modelName, data, isSingleRecord, customData, qP,mutationName){
			var type= isSingleRecord ? "createRecord": "create",gqlObj=mutationName?{"mutation":mutationName}:undefined;
			var gqlEnables=store.$.initCB("adapter",modelName,"gql",{args:[modelName,type,qP,undefined,gqlObj,customData]}),mutName,createdVariables={};
			customData = customData == undefined ? store.$.getFromCB("adapter", modelName, "customData") : customData;
			var urlObj = this.buildURL(type, "POST", modelName, undefined, data,qP,undefined,customData,undefined,gqlEnables?gqlEnables.data:undefined);
			qP = urlObj.qP;
			var partial = this.initPartialObj(modelName, type, qP, undefined, urlObj.url, customData);
			var changedData = store.$.toJSON(modelName, data, undefined, "create", partial);
			this.sendingData(modelName, changedData, urlObj, type, customData, data,partial.obj);
			if(urlObj.gql){
				store.$.cpdGql(modelName,type,qP,urlObj,changedData,customData);
			}
			return this.handleRequest(urlObj, modelName, data, type, changedData, customData, partial.obj, undefined, undefined, partial.ref);
		},
		put : function(modelName, data, record, isSingleRecord,customData, qP,mutationName){
			var model = store.model[modelName], bK = model.bK , isComp = model.isComp,gqlObj=mutationName?{"mutation":mutationName}:undefined;
			var type = (isSingleRecord) ? "updateRecord" : "update", partialObj = new Map(), key = isSingleRecord ? (isComp && bK ? record[bK] : record.$.pK) : undefined;
			var gqlEnables=store.$.initCB("adapter",modelName,"gql",{args:[modelName,type,qP,undefined,gqlObj,customData]}),mutName,createdVariables={};
			customData = customData == undefined ? store.$.getFromCB("adapter", modelName, "customData") : customData;
			var urlObj = this.buildURL(type, "PATCH", modelName, key, data, qP, undefined, customData,undefined,gqlEnables?gqlEnables.data:undefined);
			qP = urlObj.qP;
			var partial = this.initPartialObj(modelName, type, qP, key, urlObj.url, customData);
			var updatedData = store.$.toJSON(modelName, data, undefined, undefined, partial);
			this.sendingData(modelName, updatedData, urlObj, type, customData, record,partial.obj);
			if(urlObj.gql){
				store.$.cpdGql(modelName,type,qP,urlObj,updatedData,customData);
			}
			return this.handleRequest(urlObj, modelName, record, type, updatedData, customData, partial.obj,undefined, undefined, partial.ref);
		},
		del : function(modelName, data, isSingleRecord, destroy, customData, qP,mutationName){
			var model = store.model[modelName], bK = model.bK , isComp = model.isComp,gqlObj=mutationName?{"mutation":mutationName}:undefined;
			var type = destroy || "deleteRecord";
			var key = isSingleRecord ? (isComp && bK ? data[bK] : data.$.pK) : undefined;
			customData = customData == undefined ? store.$.getFromCB("adapter", modelName, "customData") : customData;
			var gqlEnables=store.$.initCB("adapter",modelName,"gql",{args:[modelName,type,qP,undefined,gqlObj,customData]}),mutName,createdVariables={};
			var urlObj = this.buildURL(type, "DELETE", modelName, key, data,qP,undefined,customData,undefined,gqlEnables?gqlEnables.data:undefined);
			qP = urlObj.qP;
			var partial = this.initPartialObj(modelName, type, qP, key, urlObj.url, customData);
			var ids = [];
			if(!isSingleRecord){
				ids = data.map(function(val){
					return val.$.pK;
				});				
			}
			var pkVal = (isSingleRecord) ?  (data ? data.$.pK : undefined) : ids;
			this.sendingData(modelName, pkVal, urlObj, type, customData, data);
			if(urlObj.gql){
				store.$.cpdGql(modelName,type,qP,urlObj,pkVal,customData);
			}
			return this.handleRequest(urlObj, modelName, data, type, pkVal, customData, undefined, key);
		},
		sendingData:function(modelName,data,urlObj,type,customData,snapshot,partial){
			var serializeKey = modelName, payload = {}, qP = urlObj ? urlObj.qP : undefined, tempObj={};
			for (var key in urlObj){
				tempObj[key] = urlObj[key];
			}
			tempObj.type = type;
			tempObj.model = modelName;
			var res = store.$.initCB("serializer", modelName, "serializeKey", {args:[modelName,type,customData,qP]});
			if(res){
				serializeKey = res.data;
			}
			data = this.serializeRecords(modelName,data,snapshot,tempObj,"serializeRecord",customData,partial);
			if(!serializeKey){
				payload = data;
			}
			else if(Array.isArray(data) || typeof data == "object" || Lyte.isRecord(data)){
				payload[serializeKey] = data;
			}
			var res = store.$.initCB("serializer", modelName, "serialize", {args:[type,payload,snapshot,customData,modelName,qP,urlObj?urlObj.gqlObj:undefined]});
			if(res){
				payload = res.data;
			}
			urlObj.data = payload;
		},
		serializeRecords:function(modelName,data,records,urlObj,type,customData,partial){
			var modelless = store.$.getFromCB("adapter",modelName,"modelless");
			var model = store.modelFor(modelName)
			if(!model){
				return data;
			}
			var rels = model.relations;
			if(!records && type != "normalizeRecord"){
				records = store.$.peekRecord(model._name,data.$.pK);
			}
			var result, partObj;
			if(Array.isArray(data)){
				result = [];
				for(var index1=0;index1<data.length;index1++){
					var record = data[index1];
					if(record && typeof record === "object")
					{
						result.push(this.serializeSingleRecord(model._name,record,records ? records[index1]:undefined,urlObj,rels,type,customData,partial));
					}
					else{
						result.push(record);
					}
				}
			}
			else if(data){
				result=data;
				if(typeof data === "object"){
					result = this.serializeSingleRecord(model._name,data,records,urlObj,rels,type,customData,partial)
				}
			}
			return result;
		},
		serializeSingleRecord:function(model_name,data,record,urlObj,rels,type,customData,partial){
			var partObj;
			type == "serializeRecord" && typeof data == "object" && data.$ == undefined ? store.$.defProp(data, "$", {}): data;
			if(type == "normalizeRecord" && Lyte.isRecord(data)){
				return data;
			}
			if(typeof partial == "object" && record && record.$ && record.$.pK){
				partObj = partial.get ? partial.get(record.$.pK):partial;
				if(data.$ && data.$._partialObj){
					var data$; 
					data$ = Object.assign({}, data.$);
					data = Object.assign({}, data);
					store.$.defProp(data, "$", data$);
				}
				var relDirty =  store.$.isDirty(record,record.$.model.relations);
				if(record.$.isModified || (Array.isArray(relDirty) && relDirty.length != 0)){
					var dirtAttr = record.$.getDirtyAttributes();
					Array.isArray(relDirty) && dirtAttr.concat(relDirty);
					var keys = Object.keys(data);
					!partObj.hasOwnProperty("_removedAttr")?Object.defineProperties(partObj,{_removedAttr : {value : {} }}):undefined; 
					dirtAttr.forEach(function(val){
						if(!keys.includes(val) && !record.$.model._arrPk.includes(val)){
							partObj._removedAttr[val] = true;
						}
					})
				}
				Object.defineProperties(data.$,{
					_partialObj:{
						value:partObj
					},
					_pkVal:{
						value:record.$.pK
					},
					_model:{
						value:model_name
					},
					_payloadObj:{
						value:data
					}
				})
			}
			type == "serializeRecord" ? store.$.defpayObjUtls(data.$) : undefined;
			var scope = store.$.cbScp(model_name,type,"serializer");
			if(scope){
				var args;
				if(type == "serializeRecord"){
					args = [urlObj,data,record,model_name,customData];
				}
				else{
					args = [urlObj,data,model_name,customData];
				}
				data = store.$.cB(scope,args);
			}
			for(var key in rels){
				var rel = rels[key], relLen = rel.length;
				for(var i=0; i<relLen; i++){
					var field = rel[i];
					var val = data[field.relKey], recs, res, relTo, srz, isPoly;
					if(field.type == "relation" && val && ( type == "normalizeRecord" || ( type == "serializeRecord" && field.opts && field.opts.serialize && field.opts.serialize != "id"))){
						recs = record ? record[field.relKey] : undefined, relTo = field.relatedTo, srz = field.opts ? field.opts.serialize : undefined;
						isPoly = field.opts ? field.opts.polymorphic : undefined
						if(field.relType === "hasMany"){
							if(!Array.isArray(val)){
								val = [val];
							}
							var valLen = val.length, res = [];
							if(type == "serializeRecord"){
								store.$.defProp(res, "$", {});
								store.$.defPayArrUtls(res.$);
								if(partObj && partObj[field.relKey]){
									Object.defineProperties(res.$,{
										_key:{
											value:field.relKey
										},
										_partialObj:{
											value:partObj[field.relKey]
										},
										_model:{
											value:relTo
										},
										_payloadObj:{
											value:res
										},
										replace:{
											value:store.$.replaceCheck,
											writable:true
										},
										partRecMap:{
											value : new Map()
										}
									});
									if(field.opts && field.opts.serialize){
										Object.defineProperty(res.$,"_serialize",{
											value:field.opts.serialize
										});
									}
								}
							}
							for(var index1=0;index1<valLen;index1++){
								var _relTo = relTo;
								if(isPoly){
									if(type == "normalizeRecord"){
										_relTo = val[index1] && val[index1]._type ? val[index1]._type : relTo; 
									}
									else if(type == "serializeRecord"){
										if(srz == "record"){
											_relTo = recs && Lyte.isRecord(recs[index1]) ? recs[index1].$.model._name : relTo;
										}
										else if(srz == "partial"){
											_relTo =  val[index1] && val[index1].$ ?  val[index1].$.polymorphicType : relTo;
										}
									}
								}
								if(type== "serializeRecord"){
									var relPk = store.modelFor(relTo)._pK
									res.$.partRecMap.set(val[index1][relPk],true);
								}
								res.push(this.serializeRecords(_relTo,val[index1],undefined,urlObj,type,customData,partObj?partObj[field.relKey][index1]:undefined));
							}
							data[field.relKey] = res;
						}
						else {
							var _relTo = relTo;
							if(isPoly){
								if(type == "normalizeRecord"){
									_relTo = data[field.relKey] && data[field.relKey]._type ? data[field.relKey]._type : relTo; 
								}
								else if(type == "serializeRecord"){
									_relTo = Lyte.isRecord(record[field.relKey]) ? record[field.relKey].$.model._name : relTo;									
								}
							}
							if(val && typeof val == "object" && !val.$ &&field.opts && field.opts.serialize){
								store.$.defProp(val, "$", {});
								Object.defineProperty(val.$,"_serialize",{
									value:field.opts.serialize
								});
							}
							data[field.relKey] = this.serializeRecords(_relTo,data[field.relKey],record ? record[field.relKey] : undefined,urlObj,type,customData,partObj?partObj[field.relKey]:undefined);
						}
					}
					else if	( type == "serializeRecord" && field.opts && field.opts.serialize && field.opts.serialize == "id" && field.type == "relation"){
						if(field.relType == "hsaMany"){
							store.$.defProp(data[field.relKey], "$", {});
							store.$.defPayArrUtls(data[field.relKey].$);
							if(partObj && partObj[field.relKey]){
								Object.defineProperties(data[field.relKey].$,{
									_key:{
										value:field.relKey
									},
									_partialObj:{
										value:partObj[field.relKey]
									},
									_model:{
										value:relTo
									},
									_payloadObj:{
										value:data[field.relKey]
									},
									replace:{
										value:store.$.replaceCheck,
										writable:true
									}
								});
								if(field.opts && field.opts.serialize){
									Object.defineProperty(res.$,"_serialize",{
										value:field.opts.serialize
									});
								}
							}
						}
					}
				}
			}
			return data;
		},
		handleAjax:function(obj){
			if(obj.url){
				if(!obj.model){
					Lyte.error("Please pass model param to ajax call");
					return Promise.reject("Please pass model param to ajax call");
				}
			}
			// var argsObj = { type: "ajax", schemaName : obj.schema, queryParams: obj.queryParams, customData: obj.customData}
			var urlObj = store.adapter.$.buildURL("ajax", obj.type, obj.model, obj.index, undefined, obj.queryParams, undefined, obj.customData, obj.url);
			urlObj.data = obj.data;
			var qP = urlObj.qP, res = store.$.initCB("serializer", obj.model, "serialize", { args:["ajax",urlObj.data,undefined,obj.customData,obj.model,qP,undefined]});
			// if(res){
			// 	argsObj.data = urlObj.data = res.data;
			// }
			return store.adapter.$.handleRequest(urlObj, obj.model, undefined, "ajax",undefined,obj.customData,undefined,undefined,undefined,undefined);
		},
		handleAction:function(actionName,model,record,customData,qP,method,data){
			var pkVal;
			if(record && Lyte.isRecord(record)){
				pkVal = record.$.get(model._pK);				
			}
			var modelName = model._name, type = "action";
			customData = customData == undefined ? store.$.getFromCB("adapter", model._name, "customData") : customData;
			var urlObj = this.buildURL(type, method ? method : "POST", model._name, pkVal, record, qP, actionName, customData);
			urlObj.data = data, qP = urlObj.qP;
			var res = store.$.initCB("serializer", model._name, "serialize", {args:["action",data,record,customData,modelName,qP,actionName]});
			if(res){
				urlObj.data = res.data;
			}
			return this.handleRequest(urlObj, model._name, undefined, type,undefined,customData,undefined,undefined,actionName);
		},
		handleRequest:function(urlObj,modelName,data,type,changedData,customData,partialObj,key,actionName, partialRef){
			if(urlObj.data && urlObj.data.LdEr){
				Lyte.warn(urlObj.data.LdEr,urlObj.data.key,modelName);
				return Promise.reject({code :urlObj.data.LyteError , message : Lyte.errorCodes[urlObj.data.LyteError], data:urlObj.data.key})
			}
			if(urlObj.data && (typeof urlObj.data == "object" || Lyte.isRecord(urlObj.data) || Array.isArray(urlObj.data)) && !(urlObj.data instanceof FormData)){
				// urlObj.reqData = Lyte.deepCopyObject(urlObj.data);
				urlObj.data = JSON.stringify(urlObj.data);
			}
			var self = this, xhr, key;
			return new Promise(function(resolve, reject){
				var processRequest = store.$.getFromCB("adapter", modelName, "processRequest"),sendXHR = true;
				var makeBatch = store.$.makeBatch;
				var batchPro = false;
				if(processRequest){
					sendXHR = false;
					var returnPromise = self.callGeneric(type,modelName,urlObj.data,data,customData,urlObj?urlObj.qP:undefined,key,urlObj.url,actionName,urlObj.method,urlObj.headers),response;
					if(returnPromise instanceof Promise){
						batchPro = true;						
						returnPromise.then(function(resp){
							if(type == "action" || type == "ajax"){
								try {
									resp = JSON.parse(resp);
								}
								catch(exp){
									resp = resp;
								}
							}
							else{
								resp = JSON.parse(resp);
							}
							response = self.genericResponse(resp,modelName,type,data,urlObj,undefined,partialObj,customData);
							resolve(response);
						},function(message){
							reject(message);
						});
					}
					else{
						sendXHR = true;
					}
				}
				if(makeBatch && !batchPro){
					store.adapter.$.constructBatch(modelName,type,key,urlObj).then(function(respObj){
						var resp = respObj.content; 
						store.adapter.$.handleSuccess(modelName, type, xhr, data, urlObj, resolve, resp, respObj,undefined,reject,key,customData,actionName,partialRef);
						// resolve(resp);
					},function(resObj){
						store.adapter.$.handleFailure(modelName, type, xhr, data, urlObj, resolve,resObj.content,undefined,reject,key,customData,resObj.code,actionName,resObj);
					});
				}
				else if(sendXHR){
					var argsXHR = [modelName,type,key,urlObj,resolve,reject,"other",data,customData];
					store.adapter.$.sendXHR.apply(store.adapter.$, argsXHR).then(function(xhrReq){
						store.adapter.$.handleSuccess(modelName, type, xhrReq, data, urlObj, resolve, undefined, undefined, partialObj,reject,key,customData,actionName,partialRef);					
					},function(xhrReq){
						store.adapter.$.handleFailure(modelName, type, xhrReq, data, urlObj, resolve, undefined,partialObj,reject,key,customData,undefined,actionName);
					});
				}
			});	
		},
		handleSuccess:function(modelName, type, xhr, data, urlObj, resolve, resp, respObj, partialObj, reject, key, customData, actionName, partialRef){
			var response = xhr ? xhr.responseText : undefined, response, req, batchIndex, batch, status = xhr ? xhr.status : undefined;
			if(resp){
				response = resp;
			}
			else{
				if(response && response.length != 0){
					if(type == "action"){
					    try {
					        resp = JSON.parse(response);
					    }
					    catch(exp){
					        resp = response;
					    }
					}
					else{
					    resp = JSON.parse(response);
					}
				}
				else{
					resp = JSON.parse("{}");
				}
			}
			if(xhr){
				req = xhr;
			}
			if(respObj){
				batchIndex = respObj.index;
				batch = respObj.batch;
				req = respObj.resp;
			}
			var opts = { customD : customData };
			if(req){
				var res = store.$.initCB("adapter", modelName, "parseResponse", {args:[type, modelName, req, resp, urlObj ? urlObj.qP : undefined, key,customData,undefined,actionName]});
				if(res){
					resp = res.data;
					if(resp instanceof Promise)
					{
						return this.handleParseResponsePromise(resp,modelName,type,data,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,opts);
					}
				}
			}
			return this.otherParseRequestPromise(resp,modelName,type,data,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,customData,partialRef,key);
		},
		handleFailure:function(modelName, type, xhr, data, urlObj, resolve, respObj, partialObj,reject,key,customData,code,actionName,bObj){
			if(xhr){
				var resp;
				var scope =  store.$.cbScp(modelName, "parseResponse", "adapter"), args,response = xhr.responseText;
				if(response){
					try{
						response = (response == "" ? JSON.parse("{}") : JSON.parse(response));
					}
					catch(exp){
						Lyte.warn("LD24", exp);
					}
				}
				var res = store.$.initCB("adapter", modelName, "parseResponse", {args:[type, modelName, xhr, response, urlObj ? urlObj.qP : undefined, key, customData, undefined, actionName]});
				if(res){
					resp = res.data;
					if(resp instanceof Promise)
					{
						return this.handleParseResponsePromise(resp,modelName,type,data,urlObj,xhr,partialObj,undefined,undefined,resolve,reject,customData);
					}
				}
			}
			else if(respObj){
				var batch, batchIndex;
				if(bObj){
					batchIndex = bObj.index;
					batch = bObj.batch;
				}
				store.$.batchResponse[batch][batchIndex] = {code:code, status:"requestFailure", data:respObj};
				reject({code:code, status:"requestFailure", data:respObj});
			}
			reject(xhr);
		},
		updateIDB:function(modelName, type, data, customData, urlObj, key){
			if(data && !Array.isArray(data)){
				data = [data];
			}
			var model = store.model[modelName];
			var idb = store.$.getIDBObj(model, urlObj && urlObj.qP ? urlObj.qP : undefined, type, key, customData);
			if(!model || !idb || (idb && !idb.hasOwnProperty("queryCache"))){
				data.forEach(function(item, index){
					if(item && Lyte.isRecord(item)){
						store.adapter.$.updateRelationsIDB(item, store.model[modelName].relations, customData, type);
					}
				});
				return;
			}
			var q =	store.$.idbQ2[modelName] = store.$.idbQ2[modelName] || [];
			var queryCache = idb.queryCache;
			if(data){
				switch(type){
					case "update":
					case "updateRecord":
					{
						data.forEach(function(item, index){
							if(item && Lyte.isRecord(item)){
								var model = store.model[modelName];
								var relations = model.relations;
								// var parent = item.$.parent;
								// if(parent){
								// 	var pModel = parent.$.model._name;
								// 	var piObj = store.$.getIDBObj(parent.$.model, urlObj && urlObj.qP ? urlObj.qP : undefined, type, key, customData, modelName)
								// 	var pModCacheQuery = piObj.queryCache;
								// 	var parentQ = store.$.idbQ2[pModel] = store.$.idbQ2[pModel] || [];
								// 	parentQ.push({type:"updateRecord",model:pModel,data:parent.$.toJSON(true),queryCache:pModCacheQuery, customData:customData});
								// }
								// else{
								// }
								if(item.$.inIDB && item.$.inIDB.self){
									q.push({type:"updateRecord",model:modelName,data:item.$.toJSON("idb"), queryCache:queryCache, customData:customData});
								}
								store.adapter.$.updateRelationsIDB(item, relations, customData);
								store.$.addToIDBonSave(modelName,item);
							}
						});
						break;
					}
					case "delete":
					case "deleteRecord":
					case "destroyRecord":
					{
						var parent, pModel, parentQ, 
						arrPk = store.modelFor(modelName)._arrPk;
						data.forEach(function(item, index){
							if(item && Lyte.isRecord(item)){
								var model = store.model[modelName];
								var relations = model.relations;
								parent = item.$.parent;
								var pkObj = {};
								for(var i=0;i<arrPk.length;i++){
									pkObj[arrPk[i]] = item[arrPk[i]];
								}
								// if(parent){
								// 	var pMod = parent.$.model;
								// 	pModel = pMod._name;
								// 	var piObj = store.$.getIDBObj(parent.$.model, urlObj && urlObj.qP ? urlObj.qP : undefined, type, key, customData, modelName)
								// 	var pModCacheQuery = piObj.queryCache;
								// 	parentQ = store.$.idbQ2[pModel] = store.$.idbQ2[pModel] || [];
								// 	parentQ.push({type:"updateRecord",model:parent.$.model._name,data:parent.$.toJSON(true), queryCache:pModCacheQuery, customData:customData});
								// }
								// else{
								// }
								if(item.$.inIDB && item.$.inIDB.self){
									q.push({type:"deleteRecord",model:modelName,key:pkObj, queryCache:queryCache, customData:customData});
								}
								store.adapter.$.updateRelationsIDB(item, relations, customData);
								store.$.removeOnSave(modelName,item.$.pK);
							}
						});
						break;
					}
					case "create":
					case "createRecord":{
						data.forEach(function(item, index){
							if(item && Lyte.isRecord(item)){
								var model = store.model[modelName];
								var relations = model.relations;
								q.push({type:"createRecord",model:modelName,data:item.$.toJSON("idb"), queryCache:queryCache, customData:customData});
								store.adapter.$.updateRelationsIDB(item, relations, customData, "create");
								store.$.addToIDBonSave(modelName,item);
							}
						});
						break;
					}
				}
			}
		},	
		updateRelationsIDB : function(item, relations, customData, type){
			switch(type){
				case "create":
				case "createRecord": {
					for(var key in relations){
						var rel = relations[key];
						rel.forEach(function(obj){
							var relKey = obj.relKey, 
							relModel = obj.relatedTo, 
							relQ = store.$.idbQ2[relModel] = store.$.idbQ2[relModel] || [],
							data,
							idbObj = item.$.inIDB;		
							if(obj.dummy){
								data = store.$.getRelatedRecord(item,obj.relatedTo,obj.dummy);
							}	
							else{
								data = item[relKey];
							}	
							if(data && !Array.isArray(data)){
								data = [data];
							}	
							if(data){
								data.forEach(function(_data){
									var pModel = _data.$.model, pRelQ = store.$.idbQ2[pModel._name] = store.$.idbQ2[pModel._name] || [];
									if(_data.$.inIDB.self){
										pRelQ.push({type:"updateRecord",model:pModel._name, data:_data.$.toJSON("idb"), customData:customData});
									}
									for(var iKey in _data.$.inIDB){
										var mp = _data.$.inIDB[iKey], 
										_relQ =  store.$.idbQ2[iKey] = store.$.idbQ2[iKey] || [];
										mp.forEach(function(value, pkVal){
											_relQ.push({type:"updateRecord", model:iKey, data:store.$.peekRecord(iKey, pkVal).$.toJSON("idb"), customData:customData});
										});
									}
								});
							}
						});
					}
				}
				break;
				default: {
					var idbObj = item.$.inIDB;
					if(idbObj){
						for(mKey in idbObj){
							var mp = idbObj[mKey];
							mp.forEach(function(value, key){
								var pRec = store.$.peekRecord(mKey, key);
								var relQ = store.$.idbQ2[mKey] = store.$.idbQ2[mKey] || [];
								relQ.push({type:"updateRecord",model:mKey,data:pRec.$.toJSON("idb"), customData:customData});
							});
						}
					}
				}
			}
		},
        callGeneric : function(type, modelName,data,record,customData,queryParams,key,url,actionName,method,headers){
			var res = store.$.initCB("adapter", modelName, "processRequest", {args:[type,modelName,data,record,customData,queryParams,key,url,actionName,method,headers]});
			return res ? res.data : undefined;
		},
		genericResponse:function(resp,modelName,type,data,urlObj,xhr,partialObj,customData,partialRef){
            var response = resp, status = xhr ? xhr.status : undefined;
            var scope, args, qP = urlObj ? urlObj.qP : undefined, extractMetaCall;
			scope = store.$.cbScp(modelName, "extractMeta", "serializer");
			if(scope){
				if(response){
					var metaRes = store.$.cB(scope, [response,modelName,type,qP,customData]);
					if(!store.$.isEmpty(metaRes)){
						response.meta = metaRes;
					}
					extractMetaCall = true;
				}
				else{
					extractMetaCall = false;
				}
			}
			if(response && type != "action" && type != "ajax"){
				response = store.serializer.$.buildJSON(modelName, type, response, Lyte.isRecord(data) ? data[store.modelFor(modelName)._pK] :undefined ,xhr ? xhr.status : undefined, urlObj, customData, qP);
				if( extractMetaCall == false && scope && response ){
					var metaRes = store.$.cB(scope, [response,modelName,type,qP,customData]);
					if(!store.$.isEmpty(metaRes)){
						response.meta = metaRes;
					}
				}
				var keys = Object.keys(response);
				var len = keys.length;
				scope = store.$.cbScp(modelName, "deserializeKey", "serializer");
				if(scope){
					Lyte.warn("LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
					if(len > 2){
						Lyte.error("LD09");
					}
						var index = 0;
						if(keys[0] == "meta"){
							index = 1;
						}
						var deserializeKey = store.$.cB(scope, [modelName,type]), rec = response[keys[index]];
						delete response[keys[index]];
						response[deserializeKey] = rec;	
				}	
				this.handleResponse(data, response, store.modelFor(modelName), type, partialObj, undefined, partialRef);
			}
			return response;
		},
		removePartialKeys:function(data,model,pK){
			var rels = model.relations;
			var pkVal = data.$.pK;
			for(var key in rels){
				var relArr = rels[key];
				relArr.forEach(function(rel){
					var relObj = {}, inv;
					//self.$scope.$.getRelations(model, rel.relKey, self.$scope.model[rel.relatedTo], relObj);
					inv,
					bMod = store.model[rel.relatedTo];
					// if(relObj){
					// 	inv = relObj;
					// }
					if(bMod){
						inv = store.$.getBackwardRel(model,rel,bMod);
						if(inv&&inv.relType=="hasMany"&&inv.opts&&inv.opts.serialize){
							var relKey = rel.relKey;
							var invRelKey = inv.relKey;
							var invObj = data[relKey];
							if(invObj){
								if(Array.isArray(invObj)){
									invObj.forEach(function(invRelRec){
										var invRelObj = invRelRec[invRelKey];
										if(invRelObj && invRelObj.partial && invRelObj.partial.get(pkVal)){
											invRelObj.partial.delete(pkVal);
										}		
									});
								}
								else if(invObj[invRelKey]){
									var invRelObj = invObj[invRelKey];
									if(invRelObj && invRelObj.partial && invRelObj.partial.get(pkVal)){
										invRelObj.partial.delete(pkVal);
									}
								}
							}
						}
					}
				});
			}
		},
		mergeError: function(model, data, response){
			if(response && response.$ && response.$.isError){
				if(response.$.error){
					var obj = response.$.error;
					for(var key in obj){
						if(model.fieldList.hasOwnProperty(key)){
							store.$.setRecErr(data.$, key, obj[key]);
						}
					}
				}
				delete response.$.error;
				delete response.$.isError;
				return true;
			}
		},
        mergeResponse:function(data , model , response , pK , partialObj, cPersist){
			this.removePartialKeys(data, model, pK);
			if(partialObj && Object.keys(partialObj).length){
				this.mergeNewDataKeys(partialObj, data, response, cPersist);
			}
			if(this.mergeError(model, data, response)){
				return;
			}
			var isRec = store.$.peekRecord(data.$.model._name, data.$.pK);
			var dirtyId, mergeDone = false;
			if(data.$.isDeleted){
				this.mergeDeletedRec(partialObj, data, cPersist);
			}
			if(data.$.isNew && isRec){
				mergeDone = this.mergeNewRecord(partialObj, data, response, true, cPersist);
			}
			if(data.$.isModified && isRec){
				this.mergeModifiedRec(partialObj, data, response, true, mergeDone, cPersist);
			}
            if(model.dirty.length){
                store.$.deleteFromArray(model.dirty, dirtyId);
            }
			if(partialObj && Object.keys(partialObj).length && response && !mergeDone){
				if(response){
					if(isRec){
						result = store.$.validateAndMerge(model, response, partialObj, true);
						if(result && result.data){
							result = result.data;
						}
						else if(result && result.type){
							Lyte[result.type].apply(Lyte, result.args || []);
						}
					}
					else{
						result = store.$.insertIntoStore(model._name, response, undefined, undefined, partialObj);
					}
				}						
			}
			store.adapter.$.removeDirtyStack(data,partialObj);
			// store.$.removeDeepNest(data);
		},
		removeDirtyStack : function(data,partial){
			if(partial && partial._removedAttr && Object.keys(partial._removedAttr).length !=0){
				for(var key in data.$._attributes){
					if(!partial._removedAttr.hasOwnProperty(key)){
						delete data.$._attributes[key];
					}
				}
			}
			else{
				data.$._attributes = {};
			}
			// data.$._attributes={};
			data.$.undoStack = store.$.genUnRedoStack();
			data.$.redoStack = store.$.genUnRedoStack();
			delete data.$._savedState;
			store.$.clrRecErr(data.$);  
		},
		// handleResults: function(results, partialRef){
		// 	if(Array.isArray(results)){
		// 		var self = this;
		// 		results.forEach(function(itm, idx){
		// 			var refKey = partialRef.refKey;
		// 			var refId = itm[refKey], refObj = partialRef.get(refId);
		// 			if(refObj){
		// 				self.mergePartialObj(refObj, undefined, itm, true);
		// 			} 
		// 		});
		// 	}
		// 	else{
		// 		Lyte.warn("results expected be a flat structure of type array, instead it was "+typeof(results));
		// 	}
		// },
		removeBackwardRelDirty: function(rec,pkVal){
			var model = rec.$.model, relations = model.relations;
			for(var rModl in relations){
				var rArr = relations[rModl];
				rArr.forEach(function(itm){
					if(rec.hasOwnProperty(itm.relKey)){
						var bRel;
						if(store.modelFor(itm.relatedTo)){
							bRel = store.$.getBackwardRel(model, itm, store.modelFor(itm.relatedTo));
						}
						if(bRel && bRel.opts && bRel.opts.serialize){
							if(bRel.relType == "hasMany"){
								store.adapter.$.removeRelPartial(rec[itm.relKey], bRel, pkVal);
							}
							else if(bRel.relType == "belongsTo"){
								store.adapter.$.removeRelPartial(rec[itm.relKey], bRel, pkVal);
							}
						}
					}
				});
			}
		},
		removeRelPartial: function(data, bRel, pK){
			if(Array.isArray(data)){
				data.forEach(function(rec){
					var relData = rec[bRel.relKey];
					if(relData){
						if(bRel.relType == "hasMany"){							
							if(relData.partial){
								relData.partial.delete(pK);
								if(!relData.partial.size){
									store.$.deleteDeepNest(rec, bRel.relKey, pK);
								}
							}
						}
						else{
							store.$.deleteDeepNest(rec, bRel.relKey, pK);
						}
					}
				});
			}
			else if(Lyte.isRecord(data)){
				var relData = data[bRel.relKey];
				if(relData){
					if(bRel.relType == "hasMany"){							
						if(relData.partial){
							relData.partial.delete(pK);
							if(!relData.partial.size){
								store.$.deleteDeepNest(data, bRel.relKey, pK);
							}
						}
					}
					else{
						store.$.deleteDeepNest(data, bRel.relKey, pK);
					}
				}
			}
		},
		mergeNewRecord : function(partialObj, data, response, doMerge, cPersist){
			var mName = partialObj.$ ? partialObj.$.model : data.$.model._name, mdl = store.model[mName], pKeys = mdl._arrPk, oldPk = data.$.pK;
			var rec = store.$.peekRecord(mName, oldPk), result;
			var partRec = partialObj.$ ? partialObj.$.record : undefined;
			if(Lyte.isRecord(partRec) && partRec !== rec){
				return;
			}
			if(rec){
				var oldRelPk = typeof oldPk == "object" ? oldPk : oldPk.toString(); 
				var crProcessed = false;
				if(cPersist !== true){
					pKeys.forEach(function(item){
						if(!response || !response.hasOwnProperty(item)){
							Lyte.error("LD16", mName, Lyte.isRecord(data) ? (typeof data.$.pK == "object" ? JSON.stringify(data.$.pK) : data.$.pK) : undefined);
							return;
						}	
						store.$.cmpSet(data, item, response[item], undefined, true);
						crProcessed = true;
					});
					var newPk = store.$.getpKVal(data);
					store.$.cmpSet(data.$, "pK", store.$.getpKVal(data));
					var newRelPk = typeof newPk == "object" ? newPk : newPk.toString();
					if(mdl.data._recMap){
						mdl.data._recMap.delete(oldRelPk);
						mdl.data._recMap.set(newRelPk, data);
					}
					store.$.changeRelPkMaps(data, oldRelPk, newRelPk);
					store.$.updateNestScp(data, oldPk);
				}
				if(crProcessed && partialObj && partialObj.$ ){
					partialObj.$.processed = true;
				}
				if(doMerge && cPersist !== true){
					result = store.$.validateAndMerge(mdl, response, partialObj, true);
					if(result && result.data){
						result = result.data;
					}
					else if(result && result.type){
						Lyte[result.type].apply(Lyte, result.args || []);
					}
				}
				store.$.cmpSet(data.$, "isNew", false);
				if(partialObj.hasOwnProperty("_removedAttr") && Object.keys(partialObj._removedAttr).length!=0){
					return result;
				}
				store.$.cmpSet(data.$, "isModified", false);
				store.$.changePersist(data, true);
				store.$.deleteFromArray(mdl.dirty, oldPk);
				store.adapter.$.removeBackwardRelDirty(data,oldPk);
				if(!data.$.dN || ( data.$.dN && Object.keys(data.$.dN).length == 0 )){
					store.$.removeParentNesting(data);
				}
			}
			return result;
		},
		mergeModifiedRec : function(partialObj, data, response, doMerge, mergeDone, cPersist){
			var dirtyId = !dirtyId ? data.$.pK : dirtyId, result;
			if(!data.$.isDeleted && response && !mergeDone && cPersist !== true){
				if(response && doMerge){
					result =  store.$.validateAndMerge(data.$.model, response, partialObj, true);
					if(result && result.data){
						result = result.data;
					}
					else if(result && result.type){
						Lyte[result.type].apply(Lyte, result.args || []);
					}
				}
				mergeDone = true;					
			}
			if(partialObj && partialObj.hasOwnProperty("_removedAttr") && Object.keys(partialObj._removedAttr).length){
				return result;
			}
			store.$.cmpSet(data.$, "isModified", false);
			store.$.changePersist(data, true);
			store.$.deleteFromArray(data.$.model.dirty,data.$.pK);
			store.adapter.$.removeBackwardRelDirty(data,data.$.pK);
			if(!data.$.dN || ( data.$.dN && Object.keys(data.$.dN).length == 0 )){
				store.$.removeParentNesting(data);
			}
			return result;
		},
		mergeDeletedRec : function(partialObj, data){
			var mName, pkVal, model, obj;
			if(partialObj){
				mName = partialObj.$.model;
				pkVal = partialObj.$.pkVal;
			}
			else if(data){
				mName = data.$.model._name;
				pkVal = data.$.pK;
			}
			model = store.model[mName]
			obj = model._deleted.get(pkVal);
			var rec = obj ? obj.data : undefined;
			var isRec = store.$.peekRecord(mName, pkVal);
			if(rec){
				store.$.cmpSet(rec.$, "isDeleted", false);
				store.$.cmpSet(rec.$, "isUnloaded", true);
				store.$.cmpSet(rec.$, "isPersisted", true);
				var scpObj = rec.$.__scpObj;
				for(var key in scpObj){
                    var sid = scpObj[key];
                    var sidArr = sid.split("_");
                    var nestObj = Lyte.nestScp[sidArr[0]];
                    nestObj ? Lyte.removeNestScp(nestObj._data, sidArr[0], sidArr[1], undefined, rec, undefined, undefined, {model:mName, pK: pkVal, attr: key}) : undefined;
				}				
				model._deleted.delete(pkVal);
				store.$.removeParentNesting(rec);
			}
			if(isRec){
				store.$.removeFromStore(model, pkVal, true, undefined, undefined, true);
				store.$.removeParentNesting(isRec);
			}
			else{
				var cqueries = store.model.cachedQueries;
				if(cqueries){
					var Nm = cqueries[mName],n=mName;
					if(Nm && Nm.length){
						for(var i=Nm.length-1; i>=0; i--){
							var obj = Nm[i];
							if(obj.hasDeletedRecords){
								if(obj.data){
									var ind = obj.data[mName].indexOf(rec);
									if(ind !== -1){
										Nm.splice(i,1);					
									}
								}
							}
						}					
					}
				}
			}
			if(partialObj && partialObj.$ && partialObj.$.parent){
				partialObj.$.parent.$.partial = {};
			}
			partialObj && partialObj.$ ? partialObj.$.processed = true : undefined;
		},
		mergePartialObj: function(partialObj, data, response, doMerge, cPersist){
			var prec = store.$.peekRecord(partialObj.$.model, partialObj.$.pkVal), data = data || prec, isRec = prec ? true : false, mergeDone;
			if(partialObj && partialObj.$ && partialObj.$.processed){
				return;
			}
			if(this.mergeError(store.model[partialObj.$.model], data, response)){
				return;
			}
			if(partialObj.$.type == "removed"){
				this.mergeDeletedRec(partialObj, data, cPersist);
				return;
			}
			else if((partialObj.$.type == "added" || (data && data.$ && data.$.isNew == true)) && isRec){
				mergeDone = this.mergeNewRecord(partialObj, data, response, doMerge, cPersist);
			}
			else if((partialObj.$.type == "modified" || partialObj.$.type == "related" || (data && data.$ && data.$.isModified == true)) && isRec){
				this.mergeModifiedRec(partialObj, data, response, doMerge, mergeDone, cPersist);
			}
			if(isRec){
				if(partialObj.$.type != "removed"){
					for(var key in partialObj){
						var part = partialObj[key];
						this.mergeNewDataKeys(part, data[key], response ? response[key] : undefined, cPersist);
					}
				}
				if(data.$.partial && Object.keys(data.$.partial)){
					data.$.partial = new Map();
				}
				store.adapter.$.removeDirtyStack(data,partialObj);
			}
		},
		mergeNewDataKeys:function(partialObj, data, response, cPersist){
			if(partialObj && ((data && data.partial && data.partial.size) || partialObj.partial == true)){ //true checked since partial key can come in this 
				var self = this;
				if(Array.isArray(partialObj)){		
					var rep = partialObj.replace?partialObj.replace:false;		
					partialObj.forEach(function(item, index){
						if(item.$){
							var pK = store.model[item.$.model]._pK;
							var ind = store.$.getIndex(data, pK, item.$.pkVal);
							if(item.$.onlyDetach === true){
								if(data.record && data.key){
									store.$.deleteDeepNest(data.record,data.key,item.$.pkVal);
								}
								store.$.handleArrOp(data, "removeAt", undefined, ind, 1);
							}
							else{
								if(rep && item.$.record && item.$.record.$.isNew){
									rep = true;
								}
								else{
									self.mergeNewDataKeys(item, ind != -1 ? data[ind] : undefined, response ? response[index] : undefined, cPersist);
								}
								data.partial ? data.partial.delete(item.$.pkVal) : undefined;
							}
							if(!item._removedAttr || (item._removedAttr && Object.keys(item._removedAttr).length)){
								data.partial ? data.partial.delete(item.$.pkVal) : undefined;
							}
						}
					});
					if(Array.isArray(data) && data.partial && data.partial.size && data.record && data.key && data.record.$.model){
						var relFld = data.record.$.model.fieldList[data.key], toRemPart = [];
						if(relFld.opts && /^(id|record)$/.test(relFld.opts.serialize)){
							data.partial.forEach(function(pObj, pKey){
								if(pObj.type == "removed"){
									toRemPart.push(pKey);
								}
							});
							toRemPart.forEach(function(rItm){
								var rec = store.$.peekRecord(data.model._name, rItm) || store.$.peekRecord(data.model._name, rItm, true);
								data.partial.delete(rItm);
								rec ? store.$.removeParentNesting(rec) : undefined;
							});	
						}
					}
				}

			}
			else if(partialObj && partialObj.$ && partialObj.$.type){
				if(partialObj.$.onlyDetach){ //only for belongsTo
					var parent = partialObj.$.parent;
					if(parent && parent.$.partial && parent.$.partial[partialObj.$.relKey] && parent.$.partial[partialObj.$.relKey].has(partialObj.$.pkVal) && parent.$.partial[partialObj.$.relKey].get(partialObj.$.pkVal).type == "removed"){						
						var rec = store.$.peekRecord(partialObj.$.model, partialObj.$.pkVal) || store.$.peekRecord(partialObj.$.model, partialObj.$.pkVal, true);
						parent.$.partial[partialObj.$.relKey].delete(partialObj.$.pkVal);
						if(!parent.$.partial[partialObj.$.relKey].size){
							delete parent.$.partial[partialObj.$.relKey];
							if(!Object.keys(parent.$.partial).length){
								delete parent.$.partial;
							}
						}
						rec ? store.$.removeParentNesting(rec) : undefined;
					}
				}
				else{
					this.mergePartialObj(partialObj, data, response, undefined, cPersist);
				}
			}
			else{
				if(Array.isArray(partialObj)){
					var self = this;
					partialObj.forEach(function(item, index){
						self.mergeNewDataKeys(item, data[index], response ? response[index] : undefined, cPersist);
					});
				}
				else if(typeof partialObj == "object"){
					for(var key in partialObj){
						var part = partialObj[key];
						this.mergeNewDataKeys(partialObj[key], data[key], response ? response[key] : undefined, cPersist);
					}
				}
			}
		},
		handleResponse:function(data, response, model, type, partialObj, status, partialRef){
			var pK = model._pK, partial, obj, pkVal;
			// if(response.results && model._name != "results"){
			// 	this.handleResults(response.results, partialRef);
			// }
			response = response[model._name];
			if(Array.isArray(data)){
				for(var i=0; i<data.length; i++){
					obj = data[i], pkVal = obj.$.pK;
					partial = partialObj && obj && pkVal ?  partialObj.get(pkVal) : undefined;
					this.mergeResponse(data[i], model, Array.isArray(response) ? response[i] : response, pK, partial);	
				}
			}
			else{
				pkVal = data.$.pK;
				partial = partialObj && data && pkVal ?  partialObj.get(pkVal) : undefined;
				this.mergeResponse(data, model, response, pK, partial);	
			}
		},
        /*Compares two objects
        params - obj1, obj2
        return true/false
        */
	    compareData : function(data1, data2, isQp){
			if(!store.$.isEmpty(data1) && !store.$.isEmpty(data2)){
				var data1Type = typeof data1, data2Type = typeof data2;
				if(data1Type !== data2Type){
					return false;
				}
				switch(data1Type){
					case "string":
				    case "number":
					case "boolean":
						if(data1 === data2){
							return true;
						}
						break;
					case "object":
						return this.compareObjects(data1, data2, isQp);
				}
			}
			return false;
		},
		compareObjects : function(obj1, obj2, qP){
            if(!(obj1 instanceof Object) || !(obj2 instanceof Object)){
                return false;
            }
			if(Object.keys(obj1).length != Object.keys(obj2).length){
				return false;
			}
			for(var key in obj1){
				var val1 = obj1[key], val2 = obj2[key];
				if(qP && Array.isArray(val1) && Array.isArray(val2)){
					if(val1.length != val2.length){
						return false;
					}
					var len = val1.length;
					for(var i=0; i<len; i++){
						var ret = store.adapter.$.compareData(val1[i], val2[i], qP);
						if(!ret){
							return false;
						}
					}
				}
				else if(val2 === undefined || !store.adapter.$.compareData(val1,val2,qP)){
					return false;
				}
			}
			return true;
		},
		handleBatchPromise:function(obj){
			var response = obj.response, 
			batch = obj.batch, 
			fail = obj.fail;
			if(!fail){
				var res = store.$.initCB("serializer", "application", "normalizeResponse", {args:[undefined,"batch",obj.response]});
				if(res){
					response = res.data;
				}
	
				var resp = response.batch_requests;
				resp.forEach(function(item, index){
					var pro = store.$.batchPromise[batch][index];
					var status = item.status.toString();
					var code = status[0];
					if(code == "2"){
						pro.resolve({content:item.content,index:index,batch:batch,resp:item});
					}
					else if(code == "4" || code == "5"){
						store.$.batchResponse[batch][index] = undefined;
						pro.reject({content:item.content,index:index,batch:batch,resp:item,code:status});
					}
				});
			}
			else{
				var prmArr = store.$.batchPromise[batch];
				prmArr.forEach(function(itm, idx){
					itm.reject({content:{}, index: idx, batch:batch, code:"400",resp:{}})
				});
			}
			// obj.resolve(response);
			delete store.$.batch[batch];
			delete store.$.batchPromise[batch];
		},
		handleParseResponsePromise:function(response,modelName,type,key,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,opts)
		{
			response.then(function(payload){
				if(type == "findRecord"	|| type == "findAll")
				{
					store.adapter.$.findParseRequestPromise(payload,modelName,type,key,urlObj,xhr,batchIndex,batch,resolve,opts);
				}
				else
				{
					store.adapter.$.otherParseRequestPromise(payload,modelName,type,key,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,opts ? opts.customD : undefined,undefined, key);
				}
			},function(payload){	
				reject(xhr);
			});
		},
		findParseRequestPromise:function(payload,modelName,type,key,urlObj,xhr,batchIndex,batch,resolve,opts){
			var options = Object.assign({},opts);
			delete options.customD;
			var resp = this.getResponse(payload,modelName,type,key,urlObj,xhr, opts ? opts.customD : undefined, options);
			var resArr = xhr ? [resp, xhr.statusText, xhr] : (batchIndex != undefined) ? [resp,"batch",{index:batchIndex,batch:batch}] : [resp];
			resolve(resArr);
		},
		otherParseRequestPromise:function(resp,modelName,type,data,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,customData,partialRef,key){
			var response = this.genericResponse(resp,modelName,type,data,urlObj,xhr,partialObj,customData,partialRef);
			if(batchIndex != undefined){
				store.$.batchResponse[batch][batchIndex] = response;
			}
			if(type != "action" && type != "ajax"){
				this.updateIDB(modelName,type,data,customData,urlObj,key);
			}
			resolve(response);
		}
	}
}

store.$.defProp(store.adapter, "extends", function value(adapterName,opts,parent){
	return store.$.scExtd("adapter",adapterName,opts,parent);
}, false);

Lyte.$.requiredMixins.serializer = Lyte.$.requiredMixins.adapter = function(mixin,parent,callback_name){
	if(Object.keys(mixin).length){
		parent.forEach(function(item,index){
			var scope = item.scope, name = item.name , callback = scope[callback_name][name];
			if(callback){
				for(var key in mixin){
					callback[key] = mixin[key];
				}
			}
		});
	}
};

if(Lyte.$.injectServices){
	Lyte.$.injectServices.adapter = Lyte.$.injectServices.serializer = function (key, name, type, ins, cmpIns, data) {
		var cls = store[type];
		var obj = {};
		obj.as = key;
		obj.service = name;
		for(var cName in cls){
			var def = cls[cName];
			store.$.extendService([obj], type, cName, def, store, true, data);
		}
	}
}

function Serializer(attrs,opts,name){
    var self=this;
    Object.defineProperty(self,'$lg', {
        value : Lyte.__gl
    });
    store.$.newCB("serializer", this, name, attrs, opts);
}
store.$.cbDef(Serializer, "serializer");
store.serializer = {
    $:{
        buildJSON:function(modelName, type, payLoad, id, status, urlObj, customData, qP){
            var headers = urlObj ?  urlObj.headers : undefined, realData = payLoad;
            var res = store.$.initCB("serializer", modelName, "normalizeResponse", {args:[modelName, type, realData, id, status, headers, urlObj ? urlObj.qP : undefined,customData,undefined,urlObj?urlObj.gqlObj:undefined]});
            if(res){
                realData = res.data;
            }
            var changed = false, recs, isGet = /^(findRecord|findAll)$/.test(type);
            if(!isGet && realData && typeof realData == "object"){
                res = store.$.initCB("serializer", modelName, "payloadKey", {args:[modelName,type,undefined,qP,customData]});
                if(res){
                    var plKey = res.data;
                    if(plKey && plKey != modelName){
                        var temp = realData[plKey];
                        realData[modelName] = temp;		
                        delete realData[plKey];
                    }	
                }
            }    
            if(isGet || (realData && realData[modelName])){
                recs = realData[modelName], changed = true;
                scope = store.$.cbScp(modelName, "normalize","serializer");
                if(scope){
                    if(Array.isArray(recs)){
                        for(var i=0; i<recs.length; i++){
                            recs[i] = store.$.cB(scope, [modelName, type, recs[i], customData]);
                        }
                    }					
                    else{
                        recs = store.$.cB(scope, [modelName, type, recs, customData]);
                    }
                }
                var flUrlObj = type != "pushPayload" ? {url:urlObj.url, method:urlObj.method, headers:urlObj.headers, type: type, qP : urlObj.qP, withCredentials: urlObj.withCredentials, model:modelName} : undefined;
                recs = store.adapter.$.serializeRecords(modelName, recs, undefined, flUrlObj, "normalizeRecord", customData);
                realData[modelName] = recs;
            }
            return realData;
        },
        normalizeResponse : function(modelName, type, payLoad, id, status, urlObj, customData, opts){
            var headers = urlObj ? urlObj.headers : undefined, realData = payLoad;
            var res = store.$.initCB("serializer", modelName, "normalizeResponse", {args:[modelName, type, realData, id, status, headers, urlObj ? urlObj.qP : undefined, customData, opts,urlObj?urlObj.gqlObj:undefined]});
            if(res){
                realData = res.data;
            }
            return realData;
        },
        normalize : function(modelName,type,payLoad,id, status, headers, customData, opts, urlObj){
            var realData = payLoad, changed = false;
            if(/^(findRecord|findAll)$/.test(type) || realData[modelName]){
                realData = realData[modelName];
                changed = true;
            }
            var scope = store.$.cbScp(modelName, "normalize", "serializer");
            if(scope && realData){
                if(Array.isArray(realData)){
                    for(var i=0; i<realData.length; i++){
                        realData[i] = store.$.cB(scope, [modelName, type, realData[i], customData, opts]);
                    }
                }					
                else{
                    realData = store.$.cB(scope, [modelName, type, realData, customData, opts]);
                }
            }
            if(changed && realData){
                //payLoad = {};
                realData = store.adapter.$.serializeRecords(modelName, realData, undefined, {url:urlObj.url, method:urlObj.method, headers:urlObj.headers, type: type, qP : urlObj.qP, withCredentials: urlObj.withCredentials, model:modelName}, "normalizeRecord", customData)
                payLoad[modelName] = realData;
            }
        } 
    }
}
store.$.defProp(store.serializer, "extends", function value(serializerName, opts, parent){
    return store.$.scExtd("serializer",serializerName,opts,parent);
});

Object.defineProperties(store,{
	modelless: {
		value: {}
	},
	registerModel: {
		get(){
			Lyte._preRegister();
			return store.$.registerModel;
		}
	},
	ajax: {
		value: function ajax(obj){
			if(!obj.model){
				return Promise.reject("Model name is mandatory for ajax method");
			}
			var defless = store.$.getFromCB("adapter",obj.model,"modelless");
			if(defless != true){
				return Promise.reject("Modelless behaviour is not enabled. Please enable it to make ajax call for models that are not defined");
			}
			if(!obj.type){
				return Promise.reject(obj.type+" is not a valid HTTP method");
			}
			var def = typeof obj.model === "string" ? this.model[obj.model] : undefined;
			if(def && def.fieldList){
				return Promise.reject(obj.model+" is a defined model. ajax is supported only for a model which is not defined");
			}
			return store.adapter.$.handleAjax(obj);
		}
	},
	triggerUpdate:{
		value: function value(modelName, pkVal, keys, qP, customData,mutationName){
			var model = store.modelFor(modelName),ArrayOfKeys,sendData=[],recordsArray=[];
			if(model == undefined){
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({code : "ERR19", message : Lyte.errorCodes.ERR19, data:modelName});
			}
			ArrayOfKeys = Array.isArray(pkVal)?pkVal:[pkVal]
			for(var update_Rec = 0; update_Rec<ArrayOfKeys.length ; update_Rec++){
				var record = store.$.peekRecord(modelName, ArrayOfKeys[update_Rec]);
				if(record){
					var obj = {};
					var model = record.$.model;
					var pK = model._arrPk;
					var fields = keys || Object.keys(model.fieldList);	
					fields.forEach(function(item){
						obj[item] = record[item];
					});
					pK.forEach(function(item){
						obj[item] = record[item];
					});
					sendData.push(obj)
					recordsArray.push(record);
				}
				else{
					return Promise.reject("No such record found");
				}
			}
			var isSingleRecord = false;
			if(!Array.isArray(pkVal)){
				sendData=sendData[0];
				recordsArray=recordsArray[0];
				isSingleRecord=true;
			}
			return store.adapter.$.put(modelName, sendData, recordsArray, isSingleRecord, customData, qP,mutationName);
		}
	},
	batch:{
		value:function value(arg){
			return new Promise(function(resolve, reject){
				store.$.makeBatch = true;
				store.$.batch = store.$.batch || {};
				store.$.batchPromise = store.$.batchPromise || {};
				var method,
				customData, 
				bLen = (store.$.currentBatch === undefined) ? Object.keys(store.$.batch).length : (store.$.currentBatch + 1), 
				batch = store.$.currentBatch = bLen;
				if(arg && typeof arg == "function"){
					method = arg;
				}
				else if(arg && typeof arg == "object"){
					method = arg.method;
					customData = arg.customData;
				}
				try{
					method();
				}
				catch(e){
					store.$.makeBatch = false;
					throw e;
				}
				store.$.makeBatch = false;
				var payLoad = {batch:store.$.batch[batch]};
				var urlObj = store.adapter.$.buildURL("batch", "POST", "application", undefined, payLoad, undefined, undefined, customData);
				var batchPl = payLoad.batch;
				if(store.$.isEmpty(batchPl)){
					if(store.$.cachedBatch && store.$.cachedBatch[batch] && store.$.cachedBatch[batch].length){
						var finalRes = store.$.handleCachedResponse(batch, []);
						return resolve(finalRes);
					}
					return resolve();					
				}
				var res = store.$.initCB("serializer", "application", "serialize", {args:["batch",payLoad,undefined,customData]});
				if(res){
					payLoad = res.data;
				}
				var xhr = new XMLHttpRequest();
				xhr.open("POST", urlObj.url, true);
				for(var header in urlObj.headers){
					xhr.setRequestHeader(header, urlObj.headers[header]);
				}
				xhr.withCredentials = (urlObj.withCredentials)?true:false;
				xhr.send(JSON.stringify(payLoad));
				xhr.onreadystatechange = function(){
					if(xhr.readyState == 4){
						if(xhr.status.toString()[0] == "2" || xhr.status.toString()[0] == "3"){
							var resp = JSON.parse(xhr.responseText);
							store.$.batchResponse = store.$.batchResponse || {};
							store.$.batchResponse[batch] = [];
							store.adapter.$.handleBatchPromise({response:resp,batch:batch,resolve:resolve});
							setTimeout(function(){
								var finalRes = store.$.handleCachedResponse(batch, store.$.batchResponse[batch]);
								resolve(finalRes);
								store.$.batchResponse[batch] = [];
							},0);
						}
						else{
							store.$.batchResponse[batch] = [];
							store.adapter.$.handleBatchPromise({batch:batch,resolve:resolve,fail:true});
							setTimeout(function(){
								var finalRes = store.$.handleCachedResponse(batch, store.$.batchResponse[batch]);
								reject(finalRes);
							},0);
						}
					}
				}					
			});
		}
	},
	pushPayload:{
		value:function value(modelName,data,deserialation,ind,Deserialize){
			var model = store.modelFor(modelName), 
			modelless = store.$.getFromCB("adapter",modelName,"modelless"), _defless;
			model = modelless ? modelName : model;
			if(!model){
				Lyte.warn("LD02", "Model", modelName);
				return;
			}
			var result = data, len;
			if(deserialation){
                data = store.serializer.$.buildJSON(modelName,"pushPayload",data);
                var scope = store.$.cbScp(modelName, "deserializeKey","serializer");
				len = data ? Object.keys(data).length : undefined;
                if(scope){
					Lyte.warn("LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
					if(len > 2){
						Lyte.error("LD09");
					}
					var keys = Object.keys(data), index = 0;
					if(keys.length == 2 && keys[0] == "meta"){
						index = 1;
					}
					var deserializeKey = store.$.cB(scope, [modelName,"pushPayload"]), rec = data[keys[index]];
					delete data[keys[index]];
					data[deserializeKey] = rec;
					
                }
                result = data[modelName];
			}
  			data = store.$.insertIntoStore(modelName, result, true, undefined, undefined, index, true, undefined, ind,Deserialize);
			var nData = data || [];
			if(!Array.isArray(nData)){
				nData = [nData];
			}
			var idb = model && model.hasOwnProperty("idb");
			if(window.LyteIDB){
				nData.forEach(function(itm){
					if(Lyte.isRecord(itm)){
						if(idb){
							store.$.idbQ2Push(modelName,itm,undefined,"pushPayload");
						}
						if(!itm.$.isError){
							if(itm.$.inIDB && Object.keys(itm.$.inIDB).length){
								store.adapter.$.updateRelationsIDB(itm, itm.$.model.relations);
							}
						}
					}
				});
			}
			model ? delete model.rel : undefined;
			return data && Lyte.getConfig("mutable") ? Lyte.mut(data) : data;
		}
	},
	unregisterModel:{
		value:function(data,inherit){
		  inherit=(inherit===false)?false:true;
		  if(Array.isArray(data)){
			  data.forEach(function(item){
				  store.$.unregisterModel(item,inherit);
			  });
		  }
		  else{
			  store.$.unregisterModel(data,inherit);
		  }
		}
	  },
  
	unregisterAdapter:{
		value:function value(data){
			if(Array.isArray(data)){
				data.forEach(function(item){
					store.$.unRegCb("adapter", item);
				});
			}	
			else{
				store.$.unRegCb("adapter", data);
			}		
		}
	},
	unregisterSerializer:{	
		value:function value(data){
			if(Array.isArray(data)){
				data.forEach(function(item){
					store.$.unRegCb("serializer",item);
				});
			}
			else{
				store.$.unRegCb("serializer",data);
			}
		}
	},
	addField:{
		value:function value(modelName, key, type, options, ignoreValidation, deserialize){
			var model = store.modelFor(modelName), fieldType;
			var obs = [];
			if(model.fieldList.hasOwnProperty(key)){
				if(model.fieldList[key].type == "relation"){
					var relfld = model.fieldList[key];
					var rel = model.relations[relfld.relatedTo]
					if(Array.isArray(rel)){
						var index = rel.indexOf(relfld);
						rel.splice(index,1)
					}
					if(relfld.relType == "hasMany"){
						delete model._fldGrps.hasMany[key];
					}
				}
			}
			if(type && typeof type == "object"){
				// if(type && type.type !== "relation" && model.fieldList.hasOwnProperty(key) && type.type === model.fieldList[key].type && store.adapter.$.compareData(type, model.fieldList[key])){
				// 	ignoreValidation = true;
				// }
				store.$.registerField(model,key,type,obs);
				if(type.type == "relation"){
					fieldType = "relation"
				}
				else{
					fieldType = "attr"; 
				}
				var deserialize = arguments[4],
				ignoreValidation = ignoreValidation === undefined ? arguments[3] : ignoreValidation;
			}
			else{
				var field = Lyte.attr(type,options);
				// if(field.type !== "relation" && model.fieldList.hasOwnProperty(key) && model.fieldList[key].type === field.type && store.adapter.$.compareData(field, model.fieldList[key])){
				// 	ignoreValidation = true;
				// }
				store.$.registerField(model,key,field,obs);

			}
			if(fieldType != "relation"){
				if(!ignoreValidation || deserialize){
					store.$.updateFieldValidation(model, key, deserialize, ignoreValidation);
				}
			}
		}
	},
	modelFor:{		
		value:function value(name){
			return store.model[name];
		}
	},
	createRecord:{
		value : function value(modelName, opts, withoutValidation){
			var rec = this.$.newRecord(modelName, opts, withoutValidation);
			if(rec && Lyte.getConfig("mutable")){
				return Lyte.mut(rec);
			}
			return rec;
		}
	},
	deleteRecord:{
		value : function value(modelName, key){
			this.$.removeFromStore(store.modelFor(modelName), key, undefined);
		}
	},
    /*
	 args - modelName, queryParams, cacheQuery, cacheData, customData
	 	cacheQuery - true/false (default false) -> whether to cache the request with queryparams or not
	 	cacheData - true/false (default true) -> whether to store the data in the store or not
	 	customData - some custom data that can be sent, which will be received as the last param in all adapter functions
	 */
	findAll:{
		value : function value(modelName, queryParams, cacheQuery,cacheData,customData,oprName,variables,index){
			return store.adapter.$.get("findAll", modelName, undefined, queryParams, cacheQuery, customData, cacheData,oprName,variables).then(function(){
				var args = arguments, 
				data = args[0][0], 
				xhr = args[0][2],
				status = xhr ? xhr.status :  args[0][3], 
				fromCache = args[0][1] == "cache" ? true : false, 
				batchObj = args[0][1] == "batch" ? args[0][2] : undefined, 
				fromIDB = args[0][1] == "idb" ? true : false, model, toCacheParams;
				var modelless = store.$.getFromCB("adapter",modelName,"modelless"), _defless;
				// if(!modelless){
					model = store.model[modelName];
				// }
				toCacheParams = (cacheQuery && cacheQuery !== true) ? cacheQuery : (cacheQuery === true && queryParams && typeof queryParams == "object" && Object.keys(queryParams).length ) ? queryParams : undefined;
				if(!model && cacheData == undefined){
					cacheData = false;
				}  
				else if(modelless && !model && cacheData == true){
					_defless = true;
				}  
				if(cacheData !== undefined && typeof cacheData == "object" && cacheData !== null){
					cacheData = cacheData.hasOwnProperty("cache") ? cacheData.cache : true;
				}
				if(cacheData === false){
                    if( !fromCache && toCacheParams){
						store.$.cacheQuery(modelName, toCacheParams, data, status);
					}
					if(batchObj != undefined){
						store.$.batchResponse[batchObj.batch][batchObj.index] = data;
					}
					return data;
				}
				if(data && !data.save){
					if(!fromCache){
						if(!data || !data.hasOwnProperty(modelName)){
							Lyte.error("LD13", "findAll",modelName,(queryParams && typeof queryParams == "object" ? ",queryParams-"+JSON.stringify(queryParams):"") /*, Lyte.isRecord(data) ? data: JSON.stringify(data)*/);
							return;
						}
						// if(!fromIDB){
						// 	store.$.idbQ2Push(modelName,data,queryParams,"findAll",undefined,undefined,customData);
						// }
						var payLoad = data[modelName];
						if(payLoad === undefined || payLoad === null || store.$.isEmptyArray(payLoad)){
							data[modelName] = [];
						}
						else{
							if(!Array.isArray(payLoad)){
								Lyte.warn("LD19");
							}
							var defnd = _defless ? "id" : undefined,
                            ind = _defless && index != undefined ? index : defnd;
							var records = store.$.toInsertData(modelName, data,true,ind), nRec = records;
							if(records && !Array.isArray(records)){
								nRec =[records];
							}
							if(window.LyteIDB && !fromIDB && ((nRec && !nRec.$) || (records && records.$ && !records.$.isError))){
								if(model && model.hasOwnProperty('idb')){
									store.$.idbQ2Push(modelName,nRec,queryParams,"findAll",undefined,undefined,customData);
								}
								nRec.forEach(function(itm){
									if(itm && itm.$ && itm.$.inIDB && Object.keys(itm.$.inIDB).length){
										store.adapter.$.updateRelationsIDB(itm, itm.$.model.relations);
									}
								});
							}
							if(window.LyteIDB && fromIDB && nRec && Array.isArray(nRec)){
								nRec.forEach(function(itm){
									LyteIDB.changeIDBState(itm);
								});
							}
							data[modelName] = records;
						}
						if(data.hasOwnProperty("meta")){
							data[modelName].$ || store.$.defProp(data[modelName], "$", {});
							data[modelName].$.meta = data.meta;
						}
						if(toCacheParams){
							store.$.cacheQuery(modelName, toCacheParams, data);								
						}						
					}
					if(batchObj != undefined){
						store.$.batchResponse[batchObj.batch][batchObj.index] = data[modelName];
					}
					return Lyte.getConfig("mutable") ? Lyte.mut(data[modelName]) : data[modelName];	
				}
				return arguments;
			}, function(e){
				return Promise.reject(e);
			});
		}		
	},
    /*
	 args - modelName , key, queryParams, cacheQuery, cacheData, customData
	 	cacheQuery - true/false (default - false) -> to cache the query with queryParams and key
	 	cacheData - true/false (default - true) -> to store the data in store / not
	 	customData - custom data that will be available as last param in all adapter callbacks 
	 */
	findRecord:{	
		value : function value(modelName, key, queryParams, cacheQuery,cacheData,customData,oprName,variables,index){
			if(key == undefined){
				return Promise.reject({code : "ERR20", message : Lyte.errorCodes.ERR20});
			}
			return store.adapter.$.get("findRecord", modelName, key, queryParams, cacheQuery,customData,cacheData,oprName,variables).then(function(){
				var data = arguments[0][0], fromCache = arguments[0][1] == "cache" ? true : false;
				var xhr = arguments[0][2];
				var status = xhr ? xhr.status : arguments[0][3];
				var batchObj = arguments[0][1] == "batch" ? arguments[0][2] : undefined; 
				var fromIDB = arguments[0][1] == "idb" ? true : false;
				var model = store.model[modelName];
				var toCacheParams = (cacheQuery && cacheQuery !== true) ? cacheQuery : (cacheQuery === true && queryParams && typeof queryParams == "object" && Object.keys(queryParams).length) ? queryParams : undefined;
				var modelless = store.$.getFromCB("adapter",modelName,"modelless"), _defless;
				if(!model && cacheData == undefined){
					cacheData = false;
				}
				else if(modelless && !model && cacheData == true){
					_defless = true;
				}  
				if(cacheData !== undefined && typeof cacheData == "object" && cacheData !== null){
					cacheData = cacheData.hasOwnProperty("cache") ? cacheData.cache : true;
				}
				if(cacheData === false){
                    if(!fromCache && toCacheParams){
						store.$.cacheRecordQuery(modelName, key, toCacheParams, data, status);
					}
					if(batchObj != undefined){
						store.$.batchResponse[batchObj.batch][batchObj.index] = data;
					}
					return data;
				}
				if(data){
					if(!fromCache){
						var isEmpty;
						if(!data || !data.hasOwnProperty(modelName)){
							Lyte.error("LD13", "findRecord",modelName, (",key-"+(typeof key == "object"? JSON.stringify(key):key)+(queryParams && typeof queryParams == "object" ? ", queryParams-"+JSON.stringify(queryParams)+"":"")) /*, Lyte.isRecord(data) ? data: JSON.stringify(data)*/);
							return;
						}						
						// if(!fromIDB){
						// 	store.$.idbQ2Push(modelName,data,queryParams,"findRecord",key,data && data.meta ? data.meta : undefined,customData);
						// }
						if(!Lyte.isRecord(data)){
							var payLoad = data[modelName];
							if(store.$.isEmpty(payLoad) || store.$.isEmptyObj(payLoad)){
								data[modelName] = {};
								isEmpty = true;
							}
							if(typeof payLoad != "object" || Array.isArray(payLoad)){
								Lyte.warn("LD11");
							}
							if(!isEmpty){
								var defnd = _defless ? "id" : undefined,
								ind = _defless && index != undefined ? index : defnd;
								var record = store.$.insertIntoStore(modelName, payLoad, true, true, undefined,undefined, undefined, undefined, ind), nRec;
								if(window.LyteIDB && !fromIDB && (Lyte.isRecord(record) && !record.$.isError) ){
									if(!Array.isArray(record)){
										nRec = [record];
									}
									if(model && model.hasOwnProperty('idb')){
										store.$.idbQ2Push(modelName,nRec,queryParams,"findRecord",key,data && data.meta ? data.meta : undefined,customData);
									}
									nRec.forEach(function(itm){
										if(itm && itm.$ && itm.$.inIDB && Object.keys(itm.$.inIDB).length){
											store.adapter.$.updateRelationsIDB(itm, itm.$.model.relations);
										}
									});
								}
								if(window.LyteIDB && fromIDB && nRec && Array.isArray(nRec)){
									nRec.forEach(function(itm){
										LyteIDB.changeIDBState(itm);
									});
								}
								data[modelName] = record;
							}
							if(data.hasOwnProperty("meta")){
								if(Lyte.isRecord(record)){
									record.$.meta = data.meta;
								}
								else{
									payLoad = data[modelName];
									payLoad.$ || store.$.defProp(payLoad, "$", {});
									payLoad.$.meta = data.meta;
								}
							}
						}
						if(!fromCache && toCacheParams){
							store.$.cacheRecordQuery(modelName, key, toCacheParams, data);
						}						
					}
					if(batchObj != undefined){
						store.$.batchResponse[batchObj.batch][batchObj.index] = data[modelName];
					}
					return Lyte.getConfig("mutable") ? Lyte.mut(data[modelName]) : data[modelName];	
				}
				return arguments;
			}, function(e){
				return Promise.reject(e);
			});
		}
	},
	peekRecord:{	
		value : function value(modelName, pKey, isDeleted){
			return store.$.peekRecord(modelName, pKey, isDeleted, true);
		}
	},
	peekAll:{
		value : function value(modelName){
			var model = this.modelFor(modelName), 
			modelless = store.$.getFromCB("adapter",modelName,"modelless"), _defless;
			model = modelless ? modelName : model;
			if( !model ){
				Lyte.warn("LD02","Model ",modelName);
				return;
			}
			else if(modelless == true && model){
				model = store.modelless[model];
				if(!model){
					// Lyte.error("LD02","model ",modelName);
					return;	
				}
			}  
			arr= model.data;
			if(modelless){
				return arr;
			}
			if(Lyte.getConfig("mutable")){
				return Lyte.mut(arr);
			}
			else{
				return arr;
			}
		}	
	},
	deleteMany:{
		value : function value(modelName, keys){
			this.$.removeFromStore(store.modelFor(modelName), keys, undefined);
		}
	},
	unloadRecord:{
		value : function value(modelName, key,inherit,idbPersist){
			var model = this.modelFor(modelName), 
			modelless = store.$.getFromCB("adapter",modelName,"modelless"), _defless;
			model = modelless ? modelName : model;
			if( !model ){
				Lyte.warn("LD02","Model ",modelName);
				return;
			}
			else if(modelless == true && model){
				model = store.modelless[model];
				if(!model){
					// Lyte.error("LD02","model ",modelName);
					return;	
				}
				_defless = true;
			}  
			if(key == undefined){
				Lyte.warn("LD18","key");
			}
			var data = store.$.peekRecord(modelName, key);
			var pkVal;
			if(_defless == true){
				var ind = store.$.getInd(model.data, model._pK, key);
				if(ind != -1){
					store.$.handleArrOp( model.data, "removeAt", undefined, ind, 1);
				}
			}
			else if(data){
				var inhFldLen = model._fldGrps.inherit && Object.keys(model._fldGrps.inherit).length 
				inherit=(inherit===false)?false:true;
				pkVal = data.$.pK;
				//this.$.removeFromStore(model, pkVal, true, true);
				if(inherit && inhFldLen){
					var recmp = new Map(); 
					store.$.removeChildRecords(model,data,recmp,true);
				}
				else{
					this.$.removeFromStore(model, pkVal, true, true, undefined, undefined, true,idbPersist);
				}
				model._deleted.delete(key);
				var crq = this.model.cachedRecordQueries;
				if(crq && crq[modelName] && crq[modelName][key]){
					crq[modelName][key] = [];
				}
				var cqueries = store.model.cachedQueries;	
				if(cqueries){
					var Nm = cqueries[modelName],n=modelName;
					if(Nm && Nm.length){
						for(var i=Nm.length-1; i>=0; i--){
							var obj = Nm[i];
							if(obj && obj.data){
								var ind = obj.data[modelName].indexOf(data);
								if(ind != -1){
									Nm.splice(i, 1);
								}							
							}
						}					
					}
				}			
			}
		}
	},
	unloadAll:{	
		value : function value(modelName, arr,inherit,idbPersist){
			var model = this.modelFor(modelName), 
			modelless = store.$.getFromCB("adapter",modelName,"modelless"), _defless;
			model = modelless ? modelName : model;
			if( !model ){
				Lyte.warn("LD02","Model ",modelName);
				return;
			}
			else if(modelless == true && model){
				model = store.modelless[model];
				if(!model){
					// Lyte.error("LD02","model ",modelName);
					return;	
				}
				_defless = true;
			} 
			var keys = [];
			var data = arr || store.peekAll(modelName);
			if(_defless == true){
				store.$.handleArrOp(model.data, "removeAt", undefined, 0, model.data.length);
			}
			else{
				if(data){
					for(var i=0; i<data.length; i++){
						keys.push(data[i].$.pK);
					}				
				}
				var inhFldLen = model._fldGrps.inherit && Object.keys(model._fldGrps.inherit).length 
				inherit=(inherit===false)?false:true;
				if(inherit && inhFldLen){
					for(var i = keys.length-1 ;i>=0 ; i--){
						var pk = data[i]
						var recmp = new Map(); 
						store.$.removeChildRecords(model,pk,recmp,true);
					}
				}
				else{
					this.$.removeFromStore(model, keys, true, true, undefined, undefined, true,idbPersist);
				}
				this.model[modelName].dirty = [];
				this.model[modelName]._deleted = new Map();
				var cq = store.model.cachedQueries;
				if(cq && cq[modelName]){
					cq[modelName] = [];
				}
				var crq = this.model.cachedRecordQueries; 
				if(crq && crq[modelName]){
					crq[modelName] = [];
				}
			}
		}
	},
	triggerAction:{
		value:function value(modelName,actionName,customData,qP,method,data){
			var model = store.modelFor(modelName);
			if(model == undefined){
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({code : "ERR19", message : Lyte.errorCodes.ERR19, data:modelName});
			}
			var actions = model.actions, action = (actions)?model.actions[actionName]:undefined;
			if(action){
				return store.adapter.$.handleAction(actionName,model,store.peekAll(modelName),customData,qP,method,data).then(function(data){
					return data;
				},function(err){
					return Promise.reject(err);
				});
			}
			else{
				return Promise.reject({code : "ERR18", message : Lyte.errorCodes.ERR18});
			}
		}
	},
	rollBack :{
		value:function value(modelName){
			var model = this.modelFor(modelName),rel=model.relations;
			if(model == undefined){
				Lyte.warn("LD02", "Model", modelName);
				return;
			}
			var pK = model._pK,self = this, dirty = Array.from(model.dirty);
			var len = dirty.length;
			for(var i=0; i<len; i++){
				var rec = self.peekRecord(modelName, dirty[i]);
				if(rec && rec.$.isDeleted){
					continue;
				}
				else if(rec && rec.$.isNew){
					self.$.rollBackNew(model, rec, pK);
				}                                
				else if(rec && rec.$.isModified){
					rec.$.rollBackAttributes(rec.$.getDirtyAttributes());
				}
			}
			this.$.rollBackDelete(model, undefined, true);
		}
	},
	create : {
		value : function value(modelName, data, customData, qP, toFilterRecords,mutationName){
			var model = store.modelFor(modelName);
			if(model == undefined){
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({code : "ERR19", message : Lyte.errorCodes.ERR19, data:modelName});
			}
			if(Array.isArray(data)){
				var self = this;
				data.forEach(function(item){
					var resp = self.$.newRecord(modelName, item);
					if(resp.$.isError){
						return Promise.reject(resp);
					}
				});
			}
			else if(data && typeof data == "object"){
				var resp = this.$.newRecord(modelName, data);
				if(resp.$.isError){
					return Promise.reject(resp);
				}				
			}
			var dirty = model.dirty, len = dirty.length, created = [], err;
			for(var i=0; i<len; i++){
				var rec = store.peekRecord(modelName, dirty[i]);
				if(rec && rec.$.isNew){
					if(toFilterRecords && toFilterRecords.indexOf(rec) == -1){
						continue;
					}	
					err = new error1();
					store.$.validateRecord(rec, model.fieldList);
					if(rec.$.isError && Object.keys(rec.$.error).length > 0){
						return Promise.reject(err);
					}
					created.push(rec.$.record);
				}
			}
			if(created.length){
				return store.adapter.$.create(modelName, created, false, customData, qP,mutationName);
			}
			return Promise.resolve();
		}
	},
	update : {
		value : function value(modelName, customData, qP, toFilterRecords, mutationName){
			var model = this.modelFor(modelName);
			if(model == undefined){
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({code : "ERR19", message : Lyte.errorCodes.ERR19, data : modelName});
			}
			var changed = [], recordsChanged = [];
			var records = toFilterRecords || store.peekAll(modelName);
			var model = store.model[modelName];
			var rels = model.relations;
			records.forEach(function(item){
				if(Lyte.isRecord(item) && item.$.model._name == modelName ){
					var rec = item;
					var dirty = store.$.isDirty(rec, rels);
					if((rec && !rec.$.isNew && !rec.$.isDeleted && ( rec.$.isModified || ( dirty && dirty.length ) ) ) ) {
						var obj = store.$.updateJSON(rec, model, dirty);
						changed.push(obj);
						recordsChanged.push(rec.$.record);
					}
				}
			});
			if(changed.length){
				return store.adapter.$.put(modelName, changed, recordsChanged,false, customData, qP,mutationName);
			}
			return Promise.resolve();
		}
	},
	delete : {
		value : function value(modelName, key, customData, qP, toFilterRecords , mutationName){
			var model = store.modelFor(modelName);
			if(model == undefined){
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({code : "ERR19", message : Lyte.errorCodes.ERR19,data:modelName});
			}
			if(key){
				this.deleteRecord(modelName, key);				
			}
			var deleted = [];
			model._deleted.forEach(function(itm, idx){
				deleted.push(itm.data);
			});
			if(toFilterRecords){
				var newDel = [];
				toFilterRecords.forEach(function(itm){
					var ind = deleted.indexOf(itm.$.record);
					if(ind != -1){
						newDel.push(itm.$.record);
					}
				});
				deleted = newDel;
			}
			// for(var i=0; i<model._deleted.length; i++){
			// 	if(!model._deleted[i].$.isNew){
			// 		deleted.push(model._deleted[i]);					
			// 	}
			// 	else{
			// 		// store.adapter.$.handleResponse(model._deleted[i], model._deleted[i], undefined, undefined, model);
			// 	}
			// }
			if(deleted.length){
				var prm = store.adapter.$.del(modelName, deleted,undefined,"delete",customData,qP,mutationName);
				return prm.then(function(resp){
					return resp;
				}, function(e){
					return Promise.reject(e);
				});
				// return prm;
			}
			return Promise.resolve();
		}
	},
	registerAdapter : {
		value : store.adapter.extends
	},
	registerSerializer : {
		value : store.serializer.extends
	},
	// removeCachedQuery: {
	// 	value: function(obj){
	// 		var modelName = obj.modelName,
	// 		key = obj.key,
	// 		params = obj.params,
	// 		cq;
	// 		if(params === undefined){
	// 			if(key !== undefined){
	// 				if(modelName !== undefined){
	// 					var cq = this.model.cachedQueries;
	// 					var crq = this.model.cachedRecordQueries;
	// 					cq && cq.hasOwnProperty(modelName) ? delete cq[modelName] : undefined;
	// 					crq && crq.hasOwnProperty(modelName) ? ( key ? delete crq[modelName][key] : delete crq[modelName] )  : undefined;	
	// 				}
	// 				else{
	// 					this.model.cachedRecordQueries = {};
	// 					this.model.cachedQueries = {};
	// 				}
	// 			}
	// 			else {
	
	// 			}
	// 		}
	// 	}
	// },
	clearCachedQuery : {
		value : function(modelName, key, cacheQuery){
			var isObj = modelName && typeof modelName == "object" ? true : false, qP, obj;
			if(isObj){
				obj = modelName;
				modelName = obj.modelName;
				key = obj.key;
				qP = cacheQuery = obj.cacheQuery;
			}
			else{
				if( key && typeof key == "object"){
					qP = key;
					key = undefined;
				}
				else if(cacheQuery && typeof cacheQuery == "object"){
					qP = cacheQuery;
				}				
			}
			var cachedQueries = [];
			if(!qP){
				if(modelName){
					var cq = this.model.cachedQueries;
					var crq = this.model.cachedRecordQueries;
					cq && cq.hasOwnProperty(modelName) ? delete cq[modelName] : undefined;
					crq && crq.hasOwnProperty(modelName) ? ( key ? delete crq[modelName][key] : delete crq[modelName] )  : undefined;
				}
				else{
					this.model.cachedQueries = [];
					this.model.cachedRecordQueries = {};
				}
				return;
			}
			if(qP){
				if(key == undefined){
					var cq = this.model.cachedQueries;
					if(cq && cq[modelName]){
						cachedQueries = cq[modelName];
					}
				}
				else{
					var crq = this.model.cachedRecordQueries;
					if(crq && crq[modelName] && crq[modelName][key]){
						cachedQueries = crq[modelName][key];
					}
				}
				for(var i=0; i<cachedQueries.length; i++){
					if(this.adapter.$.compareData(cachedQueries[i].cacheQuery, qP, true)){
						cachedQueries.splice(i, 1);
						break;
					}
				}
			}
		}
	},
	getErrorMessage : {
		value : function (code){
			return Lyte.errorCodes[code];
		}
	},
	setErrorMessages : {
		value : function(obj){
			Object.assign(Lyte.errorCodes, obj);
		}
	},
    addEventListener : {
        value:function(type,func){
            return store.$.eventListeners.add(store,type,func);
        }
    },
    removeEventListener : {
        value:function(id){
            store.$.eventListeners.remove(store,id);
        }
    },
    emit : {
        value:function(type,args){
            store.$.eventListeners.emit(store,type,args);
        }
	},
	getPrimaryKey : {
		value:function(modelName){
			var model = store.model[modelName];
			if(!model){
				Lyte.warn("LD02","Model ",modelName);
				return;
			}
			return model._pK;
		}
	},
	getDirtyRecords : {
		value : function(modelName,filters,deepNest){
			var model = store.modelFor(modelName);
			if(!model){
				Lyte.warn("LD02","Model ",modelName);
				return;
			}
			var DirtyKeys = model.dirty,dirtyRecords=[],dirty={isNew :[],isModified :[],isDeleted :[]};
			for(var i_dirty = 0 ; i_dirty<DirtyKeys.length; i_dirty++){
				var record = store.$.peekRecord(modelName,DirtyKeys[i_dirty]);
				if(record){
					record.$.isNew?dirty.isNew.push(record):dirty.isModified.push(record);
				}
			}
			if(model._deleted.size){
				var deletedRecord = model._deleted
				deletedRecord.forEach(function(value){
					dirty.isDeleted.push(value.data);
				})
			}
			if(model.dirty || model._deleted.size){
				if(filters == undefined || filters == true){
					dirtyRecords=dirtyRecords.concat(dirty.isNew,dirty.isModified,dirty.isDeleted);
				}
				if(Array.isArray(filters)){
					filters.forEach(function(value){
						dirtyRecords=dirtyRecords.concat(dirty[value]);
					})
				}
				if(typeof filters == "string"){
					dirtyRecords = dirty[filters];
				}
			}
			if(deepNest){
				var records = store.peekAll(modelName);
				records.forEach(function(rec){
					if(rec && !rec.$.isNew && !rec.$.isDeleted && rec.$.isDirty() && !dirtyRecords.includes(rec)){
						dirtyRecords.push(rec);
					}
				});
			}
			return dirtyRecords;
		}
	}
});

var error1 = function error1(attr, obj, message){
	Object.defineProperties(this, {
		$ : {
			value : {isError : true , error: message ? message : {}}
		}
	});
    if(attr){
		store.$.setError(this,attr,obj);
	}
}; 
 Lyte.developmentVariables =  { production :undefined}