window.isLyteWidget=true;String.prototype._replace = String.prototype.replace;var originalBind = Function.prototype.bind;
Function.prototype.bind = function() {
  let args = Array.from(arguments);
  var func = originalBind.apply(this, args);
  func.__notNative = true;
  return func;
}
if(typeof window !== 'undefined') {
  document.listenerIndex = 0;
  var oldEventListener = HTMLElement.prototype.addEventListener;
  var oldShadowEventListener = ShadowRoot.prototype.addEventListener;
  document.addEventListener = HTMLElement.prototype.addEventListener = function(type, func) {
    // if(arguments[0] == "mousemove") {
      if(this._m) {
        // var self = this;
        var rootNode = this.getRootNode();
        var argX = rootNode._id;
        rootNode._eL = rootNode._eL || [];
        var argW = rootNode._eL.push(func);
        func.__refCode = argW;
          let obj = {
            "c" : "4",
            "y" : type,
            "z" : this._m,
            "w" : argW
          }
          if(rootNode._isBodyShadow) {
            obj.x1 = argX;
          } else {
            obj.x = argX;
          }
          window.top.postMessage(obj, "*");
      } else {
      func.__liIn = document.listenerIndex++;
      window.top.postMessage({
        "c" : "4a", 
        "y" : type,
        "z" : func.__liIn
      }, "*");
      for(var key in window.childWidgetMappings) {
        oldShadowEventListener.apply(window.childWidgetMappings[key].shadow, Array.from(arguments));
      }
    }
    
    oldEventListener.apply(this, Array.from(arguments));
  }

  var oldGetElementById = document.getElementById;
  document.getElementById = function(id) {
    if(Object.keys(window.childWidgetMappings).length) {
      for(let key in window.childWidgetMappings) {
        var ret = window.childWidgetMappings[key].shadow.querySelector("[id='"+id+"'");
        if(ret) {
          return ret;
        }
      }
      if(window.childBodyWidgetMappings) {
        for(let key in window.childBodyWidgetMappings) {
          var ret = window.childBodyWidgetMappings[key].shadow.querySelector("[id='"+id+"'");
          if(ret) {
            return ret;
          }
        }
      }
    } else {
      return oldGetElementById.apply(document, Array.from(arguments));
    }
  }

  var funcsToBeOverrided = [{"v" : "getElementsByTagName", "a" : true, "r" : "querySelectorAll"}, {"v" : "querySelector"}, {"v" : "contains"}, {"v" : "querySelectorAll", "a" : true}];
  var oldFunctions = {};
  funcsToBeOverrided.forEach(function(key2){
    let key1 = key2.v;
    let key3 = key2.r || key2.v;
    oldFunctions[key1] = document[key1];
    
    document[key1] = function(id) {
      let retVal = key2.a ? [] : null;
      if(Object.keys(window.childWidgetMappings).length) {
        for(let key in window.childWidgetMappings) {
          var ret = window.childWidgetMappings[key].shadow[key3](id);
          if(ret) {
            if(key2.a) {
              for(let i=0;i<ret.length;i++) {
                retVal.push(ret[i]);
              }
            } else {
              return ret;              
            }

          }
        }
        if(window.childBodyWidgetMappings) {
          for(let key in window.childBodyWidgetMappings) {
            var ret = window.childBodyWidgetMappings[key].shadow[key3](id);
            if(ret) {
              if(key2.a) {
                for(let i=0;i<ret.length;i++) {
                  retVal.push(ret[i]);
                }
              } else {
                return ret;
              }
            }
          }
        }
        return retVal;
      } else {
        return oldFunctions[key1].apply(document, Array.from(arguments));
      }
  }
});



  var oldRemoveEventListener = HTMLElement.prototype.removeEventListener;
  var oldShadowRemoveEventListener = ShadowRoot.prototype.removeEventListener;
  document.removeEventListener = HTMLElement.prototype.removeEventListener = function(type, func) {
    if(!func) {
      return;
    }
      if(this._m && func.__refCode) {
        // var self = this;
        var rootNode = this.getRootNode();
        let argX = rootNode._id;
        let rootArray = rootNode._eL || [];
        let argW = func.__refCode;
        delete rootArray[argW - 1];
        let obj = {
          "c" : "5", 
          "y" : type, 
          "z" : this._m,
          "w" : argW
        }
        if(rootNode._isBodyShadow) {
          obj.x1 = argX;
        } else {
          obj.x = argX;
        }
        
        setTimeout(function() {
          window.top.postMessage(obj, "*");
        },2)
      } else {
        let __liIn = func.__liIn;
        window.top.postMessage({
          "c" : "5a",
          "y" : type,
          "z" : __liIn
        }, "*");
        for(var key in window.childWidgetMappings) {
          oldShadowRemoveEventListener.apply(window.childWidgetMappings[key].shadow, Array.from(arguments));
        }
      }
    oldRemoveEventListener.apply(this, Array.from(arguments));
  }
  var oldCustomElementsDefine = customElements.define;
  customElements.define = function(name, classObj) {
    
    var oldConnected = classObj.prototype.connectedCallback;
    var oldAttributeChangedCB = classObj.prototype.attributeChangedCallback;
    classObj.prototype.connectedCallback = function() {
      var obj = {};
      this.__ccCBPromise = new Promise(function(resolve, reject) {
        obj.resolve = resolve;
        obj.reject = reject;
      });
      this.__ccCBPromise.__node = this;
      window.liveCcCBArray.push(this.__ccCBPromise);
      var self = this;
      var args = Array.from(arguments);
      self._pendingAttrs = self._pendingAttrs || [];
      this.__cp = this.__cp || [];
      Promise.all(this.__cp).then(async function() {
        if(oldConnected) {
          for(var i=0;i<self._pendingAttrs.length;i++) {
              $Lt._aW(await oldAttributeChangedCB.apply(self, self._pendingAttrs[i]));
            }
          var connectedPromise = oldConnected.apply(self, args);
          connectedPromise.finally(function() {
            self.__ccCB = true;
            obj.resolve();
          });
          // self.__ccCBPromise = connectedPromise;
        } else {
          obj.resolve();
          self.__ccCB = true;
        }
      });
    }

    classObj.prototype.attributeChangedCallback = function() {
      this._pendingAttrs = this._pendingAttrs || [];
      var args = Array.from(arguments);
      if(this.__ccCB) {
        oldAttributeChangedCB.apply(this, args);
      } else {
        this._pendingAttrs.push(args);
      }
    }

    oldCustomElementsDefine.apply(this, Array.from(arguments));
  };

var oldDispatchEvent = Element.prototype.dispatchEvent;
Element.prototype.dispatchEvent = async function(eventObj) {
  if(!eventObj.__lyteCreated) {
    return oldDispatchEvent.apply(this, Array.from(arguments));
  }
  var obj = {};
  var prom = new Promise(function(resolve, reject) {
    obj.resolve = resolve;
  });
  arguments[0]._handledResolve = obj.resolve;
  oldDispatchEvent.apply(this, Array.from(arguments));
  //Check again. Can use unhanledRejection event instead of setTimeout
  setTimeout(function() {
    obj.resolve();
  },2);
  await $Lt._aW(prom);
  // return Lyte._aW(arguments[0]._handled);
}

var oldAppendChild = Element.prototype.appendChild;
window.liveCcCBArray = [];
DocumentFragment.prototype.appendChild = Element.prototype.appendChild = async function(node) {
  var oldArray = window.liveCcCBArray;
  var newArray = window.liveCcCBArray = [];
  var res = oldAppendChild.apply(this, Array.from(arguments));
  if(newArray.length) {
    await $Lt._aW(Promise.all(newArray));
  }
  window.liveCcCBArray = oldArray;
  if(node.__ccCBPromise) {
    await $Lt._aW(node.__ccCBPromise);
    node.__ccCBPromise = null;
  }
  return res;
}

var oldInsertBefore = Element.prototype.insertBefore;
var oldInsertBeforeDoc = DocumentFragment.prototype.insertBefore;
DocumentFragment.prototype.insertBefore = Element.prototype.insertBefore = async function() {
  var oldArray = window.liveCcCBArray;
  var newArray = window.liveCcCBArray = [];
  var arr = Array.from(arguments);
  var node = arguments[0];
  if(node instanceof DocumentFragment) {
    node = node.children[0];
  }
  var method;
  if(this instanceof DocumentFragment) {
    method = oldInsertBeforeDoc;
  } else {
    method = oldInsertBefore;
  }
  var res = method.apply(this, arr);
  if(newArray.length) {
    await $Lt._aW(Promise.all(newArray));
  } 
  window.liveCcCBArray = oldArray;
  if(node && node.__ccCBPromise) {
    await $Lt._aW(node.__ccCBPromise);
    node.__ccCBPromise = null;
  }
  return res;
}

}

async function sample() {

}

Object.defineProperty(sample.constructor.prototype, "prototype", {
    "get" : function() {
        return (this._lyteProto || (this._lyteProto = {}));
    }
});

  
// Promise Handling - from polyfill library
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (factory());
}(this, (function () { 
  /**
   * @this {Promise}
   */

    var oldFetch = fetch;
    self.fetch = async function() {
        var args = Array.from(arguments);
        var promise = new Promise(function(resolve, reject) {
            oldFetch.apply(self, args).then(resolve, reject);
        });
        return promise;
    }
    var overridePrototype = function(original) {
      return (function() {  
        var thisObj = this;
        var promise = new Promise(function(resolve, reject) {
          original.apply(thisObj, Array.from(arguments)).then(resolve, reject);
        });
        return promise;
      })
    }    
    self.Response.prototype.text =  overridePrototype(Response.prototype.text);
    self.Response.prototype.json = overridePrototype(Response.prototype.json);  
  function finallyConstructor(callback) {
    var constructor = this.constructor;
    return this.then(
      function(value) {
        // @ts-ignore
        return constructor.resolve(callback()).then(function() {
          return value;
        });
      },
      function(reason) {
        // @ts-ignore
        return constructor.resolve(callback()).then(function() {
          // @ts-ignore
          return constructor.reject(reason);
        });
      }
    );
  }

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function isArray(x) {
    return Boolean(x && typeof x.length !== 'undefined');
  }

  function noop() {}

  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function() {
      fn.apply(thisArg, arguments);
    };
  }



  /**
   * @constructor
   * @param {Function} fn
   */
  function Promise(fn) {
    if (!(this instanceof Promise)){
        throw new TypeError('Promises must be constructed via new');
    }
    if (typeof fn !== 'function'){
        throw new TypeError('not a function');
    } 
    /** @type {!number} */
    this._state = 0;
    /** @type {!boolean} */
    this._handled = false;
    /** @type {Promise|undefined} */
    this._value = undefined;
    /** @type {!Array<!Function>} */
    this._deferreds = [];
    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function() {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self){
          throw new TypeError('A promise cannot be resolved with itself.');
      }
      if (
        newValue &&
        (typeof newValue === 'object' || typeof newValue === 'function')
      ) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  /**
   * @constructor
   */
  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(
        function(value) {
          if (done) {
              return;
          }
          done = true;
          resolve(self, value);
        },
        function(reason) {
          if (done){
              return;
          } 
          done = true;
          reject(self, reason);
        }
      );
    } catch (ex) {
      if (done) { 
          return;
      }
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function(onRejected) {
    return this.then(null, onRejected);
  };

  var thenFunction = function(onFulfilled, onRejected) {
    // @ts-ignore
    var prom = new this.constructor(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  function isFuncNative(f) {
      if(f && f.__notNative == true) {
        return false;
      }
      return !!f && (typeof f).toLowerCase() == 'function' 
      && (f === Function.prototype 
      || /^\s*function\s*(\b[a-z$_][a-z0-9$_]*\b)*\s*\((|([a-z$_][a-z0-9$_]*)(\s*,[a-z$_][a-z0-9$_]*)*)\)\s*{\s*\[native code\]\s*}\s*$/i.test(String(f)));
  }
  Promise.prototype.then = function(onFulfilled, onRejected) {
  //   if(this._lyteFrom) {
      
  //   }
      if(isFuncNative(onFulfilled) && !this.__actAwait) {
          var prevThen = this.then;
          this.then = undefined;
          onFulfilled(this);
          this.then = prevThen;
      } else {
          delete this.__actAwait;
          return thenFunction.call(this, onFulfilled, onRejected);
      }
      
  }

  Promise.prototype['finally'] = finallyConstructor;
  Promise.any = function(arr) {
    return new Promise(function(resolve,reject) {
      if(!isArray(arr)) {
        return reject(new TypeError("Promise.any accepts an array"));
      }
      var args = Array.prototype.slice.call(arr);
      if(args.length === 0) { 
          return reject(AggregateError([],"All promises were rejected"));
      }
      var rejectedPromises = [];
      var count = args.length;
      for(var i=0;i<args.length;i++) {
        if(args[i].then && typeof args[i].then == "function") {
          let currentI = i;
          args[i].then(function(val) {
            resolve(val)
          },function(val) {
            rejectedPromises[currentI] = val;
            count--;
            if(count == 0) {
              reject(new AggregateError(rejectedPromises))
            }
          });
        } else {
          resolve(args[i]);
        }
      }
    })
  }

  Promise.allSettled = function(arr) {
    return new Promise(function(resolve,reject) {
      if(!isArray(arr)) {
        return reject(new TypeError("Promise.any accepts an array"));
      }
      var args = Array.prototype.slice.call(arr);
      if(args.length === 0) { 
          return resolve([]);
      }
      var handledPromises = [];
      var count = args.length;
      for(var i=0;i<args.length;i++) {
        if(args[i].then && typeof args[i].then == "function") {
          let currentI = i;
          args[i].then(function(val) {
            handledPromises[currentI] = {"status" : "fulfilled", "value" : val};
            count--;
            if(count == 0) {
              resolve(handledPromises);
            }
          }, function(val) {
            handledPromises[currentI] = {"status" : "rejected" , "reason" : val};
            count--;
            if(count == 0) {
              resolve(handledPromises);
            }
          });
        } else {
          handledPromises[i] = {"status" : "fulfilled", "value" : args[i]}
          count--;
          if(count == 0) {
            resolve(handledPromises);
          }
        }
      }
    })
  }



  Promise.all = function(arr) {
    return new Promise(function(resolve, reject) {
      if (!isArray(arr)) {
        return reject(new TypeError('Promise.all accepts an array'));
      }

      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) {
          return resolve([]);
      }    
      var remaining = args.length;
      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(
                val,
                function(val) {
                  res(i, val);
                },
                reject
              );
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }
      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function(value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function(resolve) {
      resolve(value);
    });
  };

  Promise.reject = function(value) {
    return new Promise(function(resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function(arr) {
    return new Promise(function(resolve, reject) {
      if (!isArray(arr)) {
        return reject(new TypeError('Promise.race accepts an array'));
      }

      for (var i = 0, len = arr.length; i < len; i++) {
        Promise.resolve(arr[i]).then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn =
    // @ts-ignore
    (typeof setImmediate === 'function' &&
      function(fn) {
        // @ts-ignore
        setImmediate(fn);
      }) ||
    function(fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /** @suppress {undefinedVars} */
  var globalNS = (function() {
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== 'undefined') {
      return self;
    }
    if (typeof window !== 'undefined') {
      return window;
    }
    if (typeof global !== 'undefined') {
      return global;
    }
    throw new Error('unable to locate global object');
  })();
  globalNS.$Lt = globalNS.$Lt|| {};
  var defaultProps = globalNS.$Lt.__defaultProps = globalNS.$Lt.__defaultProps || {};
  defaultProps["Object"] = {
    "defineProperty" : Object.defineProperty
  };
  globalNS.$Lt._oldPromise = globalNS.Promise;
  globalNS.Promise = Promise;

  var __splArrayProtos = ["Array","TypeArray", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Float32Array", "Float64Array", "BigInt64Array", "BigUint64Array"];
var __splArrayProtosLen = __splArrayProtos.length;
var __arrProtos = ["every","filter","find","findIndex","flatMap","map","reduce","reduceRight","some","sort"];
var __typeArrProtos = Array.from(__arrProtos);
__typeArrProtos.splice(4,1);
var __protoMapsObj = {
    "Array" : __arrProtos,
    "TypeArray" : __typeArrProtos
};
for(var i=2;i<__splArrayProtosLen;i++){
    var proto = __splArrayProtosLen[i];
    __protoMapsObj[proto] = __typeArrProtos;
}
async function __test__(){}
var asyncConstructor = __test__.constructor;
let arraySlice = Array.prototype.slice;
var __protoOverrideObj = {
    filter : async function(callbackfn, scope){
        var len = this.length, res = [];
        if(typeof callbackfn != "function"){
            throw new TypeError(callbackfn+" is not a function");
        }
        for(var i=0;i<len;i++){
            if(i in this){
                var ret = await __protoOverrideObj.__callbackfn(callbackfn, scope ? scope : this, [this[i], i, this]);
                if(ret){
                    res.push(this[i]);
                }
            }
        }
        return res;
    },
    every : async function(callbackfn, scope){
        var len = this.length;
        if(typeof callbackfn != "function"){
            throw new TypeError(callbackfn+" is not a function");
        }
        for(var i=0;i<len;i++){
            if(i in this){
                var ret = await __protoOverrideObj.__callbackfn(callbackfn, scope ? scope : this, [this[i], i, this]);
                if(!ret){
                    return false;
                }
            }
        }
        return true;
    },
    find : async function(callbackfn, scope){
        var len = this.length;
        if(typeof callbackfn != "function"){
            throw new TypeError(callbackfn+" is not a function");
        }
        for(var i=0;i<len;i++){
            var ret = await __protoOverrideObj.__callbackfn(callbackfn, scope ? scope : this, [this[i], i, this]);
            if(ret){
                return this[i];
            }
        }
        return undefined;
    },
    findIndex : async function(callbackfn, scope){
        var len = this.length;
        if(typeof callbackfn != "function"){
            throw new TypeError(callbackfn+" is not a function");
        }
        for(var i=0;i<len;i++){
            var ret = await __protoOverrideObj.__callbackfn(callbackfn, scope ? scope : this, [this[i], i, this]);
            if(ret){
                return i;
            }
        }
        return -1;
    },
    some : async function(callbackfn, scope){
        var len = this.length;
        if(typeof callbackfn != "function"){
            throw new TypeError(callbackfn+" is not a function");
        }
        for(var i=0;i<len;i++){
            if(i in this){
                var ret = await __protoOverrideObj.__callbackfn(callbackfn, scope ? scope : this, [this[i], i, this]);
                if(ret){
                    return true;
                }
            }
        }
        return false;
    },
    flatMap : async function(callbackfn, scope){
        var len = this.length, arr = [];
        if(typeof callbackfn != "function"){
            throw new TypeError(callbackfn+" is not a function");
        }
        for(var i=0;i<len;i++){
            if(i in this){
                var ret = await __protoOverrideObj.__callbackfn(callbackfn, scope ? scope : this, [this[i], i, this]);
                if(Array.isArray(ret)){
                    arr = arr.concat(ret);
                }else{
                    arr.push(ret);
                }
            }
        }
        return arr;
    },
    map : async function(callbackfn, scope){
        var len = this.length, arr = this.constructor.name == "String" ? new Array(len) : new this.constructor(len);
        if(typeof callbackfn != "function"){
            throw new TypeError(callbackfn+" is not a function");
        }
        for(var i=0;i<len;i++){
            if(i in this){
                var ret = await __protoOverrideObj.__callbackfn(callbackfn, scope ? scope : this, [this[i], i, this]);
                arr[i]= ret;
            }
        }
        return arr;
    },
    reduce : async function(callbackfn, initial){
        if(typeof callbackfn != "function"){
            throw new TypeError(callbackfn+" is not a function");
        }
        var accumulator, len = this.length;
        var ind = 0;
        if (initial != undefined) {
            accumulator = initial;
        } 
        else {
            while (ind < len && !(ind in this)) {
              ind++; 
            }    
            if (ind >= len) {
              throw new TypeError( 'Reduce of empty array ' +
                'with no initial value' );
            }
            accumulator = this[ind++];
        }
        for(var i=ind;i<len;i++) {
            if(i in this) {
                accumulator = await __protoOverrideObj.__callbackfn(callbackfn, this, [accumulator, this[i], i, this]);
            }
        }
        return accumulator;
    },
    reduceRight : async function(callbackfn, initial){
        if(typeof callbackfn != "function"){
            throw new TypeError(callbackfn+" is not a function");
        }
        var accumulator, len = this.length;
        var ind = len - 1;
        if (initial != undefined) {
            accumulator = initial;
        } 
        else {
            while (ind >= 0 && !(ind in this)) {
              ind--; 
            }    
            if (ind < 0) {
              throw new TypeError( 'Reduce of empty array ' +
                'with no initial value' );
            }
            accumulator = this[ind--];
        }
        for(var i=ind;i>=0;i--){
            if(i in this){
                accumulator = await __protoOverrideObj.__callbackfn(callbackfn, this, [accumulator, this[i], i, this]);
            }
        }
        return accumulator;
    },
    sort: async function(compareFn) {
        return await __protoOverrideObj.__srt(this,compareFn);
    },
    __srt : async function(arr, compareFn, thisArg){
        var sortedArray = await __protoOverrideObj.__sort(arr, compareFn, thisArg);
        sortedArray.forEach(function(itm, idx){
            arr[idx] = itm;
        });
        return sortedArray;
    },
    __sort: async function(arr, compareFn, thisArg) {
        var thisArg = thisArg ? thisArg : arr;
        if (arr.length === 1) {
            return arr
        }
        var middle = Math.floor(arr.length / 2);
        var left = arraySlice.call(arr, 0 , middle);
        var right = arraySlice.call(arr, middle);
        return await __protoOverrideObj.__merge( await __protoOverrideObj.__sort(left, compareFn, thisArg), await __protoOverrideObj.__sort(right, compareFn, thisArg), thisArg, compareFn);
    },
    __merge : async function(left, right, thisArg, compareFn) {
        var res = [], indL = 0, indR = 0
        while (indL < left.length && indR < right.length) {
            var leftEle = left[indL]
            var rightEle = right[indR]
            if (compareFn ? ((await __protoOverrideObj.__callbackfn(compareFn, thisArg, [leftEle, rightEle])) <= 0 ) : (leftEle.toString() <= rightEle.toString())) {
                res.push(left[indL]);
                indL++
            } else {
                res.push(right[indR]);
                indR++;
            }
        }
        return res.concat(arraySlice.call(left, indL)).concat(arraySlice.call(right, indR));
    },
    __callbackfn : async function(callbackfn, context, args){
        var ret;
        if(callbackfn instanceof asyncConstructor){
            ret = await callbackfn.apply(context, args);
        }
        else{
            ret = callbackfn.apply(context, args);
        }
        return ret;
    }
}
for(var key in __protoMapsObj){
    var arr = __protoMapsObj[key];
    var struct = globalNS[key];
    if(struct){
        arr.forEach(function(itm){
            var proto = struct.prototype[itm];
            if(proto && __protoOverrideObj[itm]){
                Object.defineProperty(globalNS[key].prototype, itm, {
                    value: __protoOverrideObj[itm],
                    enumerable : false
                });
            }
        });
    }
}
var replaceOriginal = String.prototype.replace;
String.prototype.replace = async function(arg1, arg2) {
    var self = this;
    if(typeof arg2 == "function" && arg2 instanceof asyncConstructor) {
        var promises = [];
        replaceOriginal.call(this, arg1, async function() {
            promises.push(arg2.apply(self, Array.from(arguments)));
        });
        if(!promises.length) {
          return this.toString();
        }
        return await $Lt._aW(Promise.all(promises).then(function(values) {
            return replaceOriginal.call(self, arg1, function() {
                return values.shift();
            });
        }));
    } else {
        return replaceOriginal.apply(this, Array.from(arguments));
    }
};
var stringifyOriginal = JSON.stringify;
if(typeof window !== 'undefined') {
JSON.stringify = async function() {
	var args = arguments;
  let zerothArgs = args[0];
	var replacerFn = args[1];
  var self = this;  
  if(replacerFn && typeof replacerFn == "function" && replacerFn instanceof asyncConstructor) {
    replacerFn.apply(self,['',zerothArgs]);
    let recursiveCallingObj = async function(obj) {
      let result,returnVal;
      if(Array.isArray(obj)) {
        result = [];
        for(let index =0,len  = obj.length;index<len;index++)  {
          let value = obj[index];
          if(typeof value == "object" && value.toJSON) {
            value = await value.toJSON(index.toString());
          }
          returnVal = await commonBlock(await replacerFn.apply(self,[index,value]));
          returnVal && result.push(returnVal);
        }
      } else {
        result = {};
        for(var key in obj) {
          if(key != "toJSON")  {
            let val = obj[key];
            if(typeof val == "object" && val.toJSON) {
              val = await val.toJSON(key);
            }
            returnVal = await commonBlock(await replacerFn.apply(self,[key,val]));
            returnVal && (result[key] = returnVal);
          }
        }
      }
      return result;
    }
    let commonBlock = async function(returnVal) {
      let type = typeof returnVal;
      if(type == "number" || type == "string" || type == "boolean" || type == "null"){
        return returnVal
      } else if(type == "function" || type == "symbol"  ||  type == "undefined") {
        return undefined;
      } else if(type == "object"){
        return await recursiveCallingObj.apply(this,[returnVal]);
      } 
    }
   
    let resultObj = await recursiveCallingObj.apply(self,[zerothArgs]);
    return await stringifyOriginal.apply(self,Array.from([resultObj,null,args[2]]))
  } else {
    return await stringifyOriginal.apply(self,arguments)
  }
};
}
})));

;(function() {
    var globalNS = (function() {
      // the only reliable means to get the global object is
      // `Function('return this')()`
      // However, this causes CSP violations in Chrome apps.
      if (typeof self !== 'undefined') {
        return self;
      }
      if (typeof window !== 'undefined') {
        return window;
      }
      if (typeof global !== 'undefined') {
        return global;
      }
      throw new Error('unable to locate global object');
    })();
    function isFuncNative(f) {
      if(f && f.__notNative == true) {
        return false;
      }
      return !!f && (typeof f).toLowerCase() == 'function' 
      && (f === Function.prototype 
      || /^\s*function\s*(\b[a-z$_][a-z0-9$_]*\b)*\s*\((|([a-z$_][a-z0-9$_]*)(\s*,[a-z$_][a-z0-9$_]*)*)\)\s*{\s*\[native code\]\s*}\s*$/i.test(String(f)));
    }
    var $Lt = globalNS.$Lt;
    let Lyte_globalContext = {};
    let varDeclarationVariable = [];
    let Lyte_constVariable = [];
    let _underExecution = false,_pendingStack = [];
    // globalNS.$Lt = $Lt;
    var importScriptsLocalVar = globalNS.importScripts;
    var setTimeoutFunc = globalNS.setTimeout;
    if(!$Lt.oldProxy){
      $Lt.oldProxy = Proxy;
    }
    self.Proxy = function(target,handler) {
      var originalGet = handler.get;
      if(originalGet) {
        handler.get = function(target,prop){
          if(prop == 'then'){
            return originalGet.apply(this,[target,prop]);
          } else {
            return $Lt._get(arguments,originalGet.bind(this))
          } 
        }
      }
      return new $Lt.oldProxy(target,handler);
    }
    let defineProperty = $Lt.__defaultProps.Object.defineProperty;
    self.Object.defineProperty = function() {
        var args = arguments;
        var originalGet = args[2].get;
        if(!args[3] && originalGet) {
          args[2].get = function(){
            return $Lt._get(arguments,originalGet.bind(args[0]));
          }
        }
        return defineProperty.apply(this,[args[0],args[1],args[2]]);
    }
    $Lt.error = function(err) {
      var message = err.message
      if(message) {
        var ltVarArray = {
          "$Lt._gc." : "\\$Lt\\._gc\\.",
          "$Lt._gcFn." : "\\$Lt\\._gcFn\\."
        };
        for(var key in ltVarArray){
          if(message.includes(key)) {
            message =  replaceOriginal.apply(message,[new RegExp(ltVarArray[key],'g'),""])
          }
        }
        err.message = message;
      }
      return err;
    }
  
    $Lt.getCp = function(self) {
      if(!self.__cp) {
        self.__cp = [];
        // Object.defineProperty(self, "__cp", {
        //   "enumerable" : false, 
        //   "value" : []
        // });
      }
      return self.__cp;
    }

    $Lt._sT = function(){
        return setTimeoutFunc.apply(globalNS, Array.from(arguments));
    };
  
    $Lt._dG = function(func) {
        return func();
    };
  
    $Lt._gc = new $Lt.oldProxy(globalNS,{
      get : function(target, prop) {
        if(Lyte_globalContext.hasOwnProperty(prop)) {
            return Lyte_globalContext[prop];
        } else {
            return globalNS[prop];
        }
      },
      set : function(target,prop,value) {
        if(Lyte_globalContext.hasOwnProperty(prop)) {
          Lyte_globalContext[prop] = value;
        } else {
          globalNS[prop] = value;
        }
        return true;
      }
    });

    $Lt._gcFn = new $Lt.oldProxy({}, {
      get : function(target,prop)  {
        if(Lyte_globalContext.hasOwnProperty(prop)) {
          return Lyte_globalContext[prop];
        } else {
          if(typeof globalNS[prop] == 'function'){
            let value = globalNS[prop];
            return function() {
              return value.apply(globalNS, Array.from(arguments));
            };
          } else {
              return globalNS[prop];
          }
        }
      }
      
    });

	  $Lt.isVarDeclarationVariable = function(variable){
		  return varDeclarationVariable.indexOf(variable) == -1 ? false : true;
	  }

    $Lt.isConstDeclarationVariable = function(variable) {
      return Lyte_constVariable.indexOf(variable) == -1 ? false : true;
    }
    
    $Lt._cV= function(variable,value,type) {
      var writable = true;
      let val = value;
      if(type == "var") {
          if(Lyte_globalContext[variable]){
            throw new Error("Identifier '"+variable+"' has already been declared");
          } else {
            globalNS[variable] = value;
            varDeclarationVariable.push(variable);
          }
      } else {
        if(varDeclarationVariable.includes(variable) || variable ==  "window" || Lyte_globalContext.hasOwnProperty(variable)) {
          throw "Identifier '"+variable+"' has already been declared";
        } else {
          type ==  "const" && Lyte_constVariable.push(variable);
          defineProperty(Lyte_globalContext,variable,{
            get : function() {
              return val;
            },

            set : function(newValue) {
              if(!writable) {
                throw "Assignment to constant variable";
              } else {
                val = newValue;
                if(Lyte_constVariable.includes(variable)) {
                  writable = false;
                }
              }
            }
          });
        }
      }
    };

    $Lt._executeStack = function() {
      let c = function() {
        _pendingStack.shift();
        _underExecution = false;
        $Lt._executeStack();
      }
      if(_pendingStack.length && !_underExecution) {
        var first = _pendingStack[0];
        _underExecution = true;
        try {
          var ret = first();
          ret.then(function() {
            c();
          }).catch(function(e){
            c();
          })
        } catch(e) {
          c();
        }				
      }
    }

    $Lt._get = function(val,actValue) {
      var fn = async function () {
            var args = await $Lt._gc.Array.from(arguments);
            args = await args.splice(0, await args.length);
            var result = await actValue.apply(this,val);
            var a = await $Lt._aW(await result);
            return  a ? await a.apply(this,args) : undefined;
      };
      fn.then = async function (res) {
        if(!actValue) {
          await res(actValue);  
        } else {
          await res(await actValue.apply(this,val))
        }
        return $Lt._aR(undefined);
      };
      return fn;
    }

    $Lt._execScript = async function(func) {
      _pendingStack.push(func);
      $Lt._executeStack();
    }
    $Lt._knownClasses = [Map, Array, Date, Set, Promise];
    if(typeof document !== "undefined") {
      var documentCreateElement = document.createElement;
      document.createElementLyte = async function(elementName) {

        var createdElement = documentCreateElement.call(document, elementName);
        var _cp = createdElement.__cp || []
        var somePromise = new Promise(function(resolve,reject) {
          Promise.all(_cp).then(function() {
            resolve();
          }
          );
        });
        await $Lt._aW(somePromise);
        return createdElement;
      }
    }
    
    $Lt._cO = async function() {
      var arr = Array.from(arguments);
      var b = arr.shift();
      if(b.constructor.name != "AsyncFunction") {
          if($Lt._knownClasses.indexOf(b) != -1) {
            return Reflect.construct(b,arr);
          }
          var someValue = Reflect.construct(b, arr);
          var _cp = someValue.__cp || []
          var somePromise = new Promise(function(resolve,reject) {
              Promise.all(_cp).then(function() {
                resolve();
              }
            );
          });
          await $Lt._aW(somePromise);
         return someValue;
      }
      var functionVal = b._lyteNF;
      if(!functionVal) {
          // functionVal = new Function('fn', 
          //     "return function " + b.name + "(){ return fn.apply(this,arguments)}"
          // )(function() {
          //     this._lyteCP = b.apply(this, Array.from(arguments));
          //     return this;
          // });
          //Providing Object as function name displays the desired constructor name when we print it in the console.
          functionVal = function Object() {
            this._lyteCP = b.apply(this, Array.from(arguments));
            return this;
          }
          // Object.defineProperty(functionVal, "name", {
          //   "get" : function() {
          //     return b.name;
          //   }
          // });
          b._lyteProto = b._lyteProto || {};
          functionVal.prototype = b._lyteProto;
          if(isFuncNative(b._lyteProto.constructor)) {
            b._lyteProto.constructor = b;
            Object.defineProperty(b._lyteProto,"constructor",{
                "enumerable" : false,
                value : b
            })
          }
          Object.defineProperty(b, "_lyteNF", {
              "enumerable" : false, 
              "value" : functionVal
          });
      }

      var actObj = Reflect.construct(functionVal , arr);
      var retVal = await actObj._lyteCP;
      delete actObj._lyteCP;
      return (retVal || actObj);
     };

    $Lt._iO = function (instance, constr) {
        if(constr.constructor.name == "AsyncFunction") {
            if(constr._lyteNF) {
                return instance instanceof constr._lyteNF;
            } else {
                return false;
            } 
        } else {
            return instance instanceof constr;
        }
    };

    $Lt._forInR = function(val)  {
      return {
        _forInR :  val
      }
    };
    

    $Lt._aW = function(val) {
      if(val) {
        if(Object.isExtensible(val)) {
          Object.defineProperty(val,"__actAwait",{
            value : true,
            enumerable : false
          })
        }
      }
      return val;
    };

    $Lt._cI = async function (obj, func, thisVar) {
      
      if(obj instanceof Array) {
          for(var i=0;i<obj.length;i++) {
              let a = await func.apply(thisVar, [obj[i]]);
              if(a._forInR) {
                return a;
              }
          }
      } else {
          var iterator = await obj[Symbol.iterator]();
          while(true) {
              let result = await iterator.next();
              if(result.done) {
                break;
              }
              let a = await func.apply(thisVar,[result.value]);
              if(a._forInR) {
                return a;
              }
          }
      }
    };

    $Lt._fE = async function(array,callback,thisArg) { 
        var thisObj = thisArg ?  thisArg : globalNS;
        for (let index = 0; index < array.length; index++) { 
            await callback.call(thisObj,array[index], index, array); 
        } 
    };

    $Lt._aR = function(val) {
      if(!(val instanceof Promise)) {
        // var prom = new Promise(function(resolve, reject) {
        //   resolve(val);
        // });
        // return prom;
        return Promise.resolve(val);
      }
      return val;
    };

    $Lt._importScripts = function() {
        var args = Array.from(arguments);
        return new Promise(function(resolve,reject) {
            importScriptsLocalVar.apply(self,args);  
            if(_pendingStack.length == 0) {
              resolve();
            } else {
              $Lt._execScript(resolve);
            }
        });
    };

    Object.freeze(globalNS.$Lt);
    if(globalNS.$Lt !== $Lt){
      Object.defineProperty(globalNS,"$Lt",{
        value : $Lt,
        writable : false,
        configurable : false,
        enumerable : false
      });  
    }
})();
  
;$Lt._execScript(async function () {
	await async function (__globalScope) {
		$Lt._cV("_Lyte", {
			version: "3.7.0-BETA1",
			$: { consoleTime: [] },
			registeredMixins: {},
			registeredServices: {},
			requiredServices: {},
			toBeInjectedServices: {},
			_registeredComponents: {},
			_keywords: {
				"component": [
						"init",
						"didConnect",
						"didDestroy",
						"constructor",
						"onError",
						"actions",
						"methods",
						"data"
					],
				"adapter": [
					"namespace",
					"actionNamespace",
					"host",
					"withCredentials",
					"buildURL",
					"methodForRequest",
					"headersForRequest",
					"reloadRecord",
					"reloadRecord",
					"reloadAll",
					"processRequest",
					"parseResponse",
					"parseRequest",
					"super"
				],
				"serializer": [
					"normalize",
					"normalizeResponse",
					"serialize",
					"serializeKey",
					"deserializeKey",
					"extractMeta",
					"payloadKey",
					"serializeRecord",
					"normalizeRecord",
					"super"
				],
				"route": [
					"getDependencies",
					"getResources",
					"beforeModel",
					"model",
					"afterModel",
					"redirect",
					"renderTemplate",
					"afterRender",
					"beforeExit",
					"didDestroy",
					"queryParams",
					"title",
					"routeName",
					"component",
					"parent",
					"currentModel",
					"forceFetch",
					"setTitle",
					"setQueryParams",
					"getQueryParams",
					"setDynamicParam",
					"getDynamicParam",
					"removeFromCache",
					"refresh",
					"transitionTo",
					"replaceWith",
					"actions"
				],
				"is": async function (key, scope) {
					var arr = [
							"component",
							"adapter",
							"serializer",
							"route"
						];
					if (scope) {
						arr = [scope];
					}
					var len = await arr.length;
					for (var i = 0; i < len; (i = i + 1) - 1) {
						var keyArr = await this[await arr[i]];
						if (keyArr) {
							var res = await keyArr.indexOf(key);
							if (res != -1) {
								return true;
							}
						}
					}
					return false;
				}
			},
			Mixin: {},
			Service: {},
			debug: false,
			performance: false,
			toBeRegistered: [],
			browser: {},
			registeredCustomComponent: {},
			Globals: {}
		}, "let");
		if (await $Lt._gc.window.isLyteWidgetParent) {
			$Lt._gc._widgetLyte = $Lt._gc._Lyte;
			$Lt._gc._Lyte.isWidgetBuild = true;
			(await $Lt._gc.window.__lyteConfig).isWidgetBuild = true;
		} else {
			Lyte = $Lt._gc._Lyte;
		}
		$Lt._cV("IdleTaskScheduler", class {
			constructor(obj) {
				$Lt.getCp(this).push(async function () {
					this.idleCallback = await (await this.idleCallback).bind(this);
					this.timeout = 50;
					this.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
					this.tasks = await $Lt._cO($Lt._gc.Map);
					this.idleCallbackRequested = false;
					this.delayInit = false;
					this.useRequestIdleCallback = true;
					this.priorityQueue = [];
					this.processTime = {};
					this.perf = false;
					if (obj != $Lt._gc.undefined) {
						if (await obj.useRequestIdleCallback !== $Lt._gc.undefined) {
							this.useRequestIdleCallback = await obj.useRequestIdleCallback;
						}
						if (await obj.delayInit !== $Lt._gc.undefined) {
							this.delayInit = await obj.delayInit;
						}
						if (await obj.timeout !== $Lt._gc.undefined) {
							this.timeout = await obj.timeout;
						}
						if (await obj.priorityQueue !== $Lt._gc.undefined) {
							this.priorityQueue = await obj.priorityQueue;
						}
						if (await obj.perf !== $Lt._gc.undefined) {
							this.perf = await obj.perf;
						}
					}
				}.call(this));
			}
			async isGenerator(obj) {
				return obj !== null && typeof obj === "object" && typeof await obj.next === "function" && typeof await obj[await Symbol.iterator] === "function";
			}
			async init(obj) {
				if (await this.delayInit == true) {
					if (obj !== $Lt._gc.undefined) {
						if (await obj.useRequestIdleCallback !== $Lt._gc.undefined) {
							this.useRequestIdleCallback = await obj.useRequestIdleCallback;
						}
						if (await obj.timeout !== $Lt._gc.undefined) {
							this.timeout = await obj.timeout;
						}
						if (await obj.perf !== $Lt._gc.undefined) {
							this.perf = await obj.perf;
						}
					}
					this.delayInit = false;
					await this.tasksScheduler();
				}
			}
			async getUniqueKey(len) {
				var result;
				while (result == $Lt._gc.undefined || await (await this.tasks).has(result)) {
					result = $Lt._gc.undefined;
					result = await this.generateUniqueKey(len);
				}
				return result;
			}
			async generateUniqueKey(length) {
				let result = "", clen = await (await this.chars).length;
				for (let i = 0; i < length; (i = i + 1) - 1) {
					result += await (await this.chars).charAt(await $Lt._gc.Math.floor(await $Lt._gc.Math.random() * clen));
				}
				return result;
			}
			async enqueueTask(handler, data, id) {
				if (!id) {
					id = await this.getUniqueKey(6);
				}
				if (await (await this.tasks).has(id)) {
					await $Lt._gc.console.error("Task with id-" + id + " is alreaded queued for execution.");
					return;
				}
				await (await this.tasks).set(id, {
					handler: handler,
					data: data
				});
				await this.tasksScheduler();
				return id;
			}
			async deleteTask(id) {
				if (id) {
					var val = await (await this.tasks).get(id);
					await (await this.tasks).delete(id);
					if (await (await this.priorityQueue).length) {
						var ind = await (await this.priorityQueue).indexOf(id);
						if (ind != -1) {
							await (await this.priorityQueue).splice(ind, 1);
						}
					}
					return val;
				}
			}
			async getPriorityQObj() {
				var id, i = 0, pObj;
				if (await (await this.priorityQueue).length) {
					var len = await (await this.priorityQueue).length;
					while (i < len) {
						id = await (await this.priorityQueue)[i];
						if (await (await this.tasks).has(id)) {
							pObj = await (await this.tasks).get(id);
							break;
						}
						(i = i + 1) - 1;
					}
					if (pObj) {
						return {
							id: id,
							obj: pObj,
							ind: i
						};
					}
				}
				return false;
			}
			async dequeueTask(id) {
				if (id) {
					var val = await (await this.tasks).get(id);
					await (await this.tasks).delete(id);
					return val;
				} else if (await (await this.tasks).size || await (await this.priorityQueue).length) {
					var pqObj = await this.getPriorityQObj(), gnxt, gval, obj, isPriority = false, ind;
					if (pqObj !== false) {
						id = await pqObj.id;
						obj = await pqObj.obj;
						ind = await pqObj.ind;
						isPriority = true;
					} else {
						if (!await (await this.tasks).size) {
							return;
						}
						var val = await (await (await (await this.tasks).entries()).next()).value;
						id = await val[0];
						obj = await val[1];
					}
					this.currentTask = {
						id: id,
						handler: await obj.handler
					};
					await Lyte.extendEventListeners(await this.currentTask);
					if (await this.isGenerator(await obj.handler)) {
						gnxt = await (await obj.handler).next();
						if (await gnxt.done == false) {
							gval = await gnxt.value;
							if (typeof gval == "function") {
								return gval;
							}
						} else {
							await (await this.currentTask).triggerEvent("done", id);
							if (isPriority) {
								await (await this.priorityQueue).splice(ind, 1);
							}
							await (await this.tasks).delete(id);
							return await this.dequeueTask();
						}
					} else {
						await (await this.currentTask).triggerEvent("done", id);
						if (isPriority) {
							await (await this.priorityQueue).splice(ind, 1);
						}
						await (await this.tasks).delete(id);
					}
					return obj;
				}
			}
			async tasksScheduler() {
				if (await this.delayInit == false) {
					if (await (await this.tasks).size) {
						if (await this.idleCallbackRequested == false) {
							if (("requestIdleCallback" in $Lt._gc.window) && await this.useRequestIdleCallback) {
								this.idleCallbackRequested = true;
								await $Lt._gcFn.requestIdleCallback(await this.idleCallback);
							} else {
								await this.requestIdleCallback(await this.idleCallback);
							}
						}
					} else {
						if (("cancelIdleCallback" in $Lt._gc.window) && await this.useRequestIdleCallback) {
							await $Lt._gcFn.cancelIdleCallback(await this.idleCallback);
						}
					}
				}
			}
			async idleCallback(deadline) {
				var task, i = 0, remTime = await deadline.timeRemaining();
				while (remTime > 0 && await (await this.tasks).size) {
					task = await this.dequeueTask();
					if (await this.perf) {
						var p1 = await $Lt._gc.performance.now();
					}
					if (typeof task == "function") {
						await task();
					}
					if (typeof task == "object") {
						var data = await task.data || [];
						if (typeof await task.handler == "function") {
							await task.handler(...data);
						}
					}
					if (await this.perf) {
						var p2 = await $Lt._gc.performance.now();
						var id = await (await this.currentTask).id;
						(await this.processTime)[id] = (await (await this.processTime).hasOwnProperty(id) ? await (await this.processTime)[id] : 0) + (p2 - p1);
					}
					remTime = await deadline.timeRemaining();
				}
				this.idleCallbackRequested = false;
				await this.tasksScheduler();
			}
			async requestIdleCallback(callback) {
				var self = this;
				await $Lt._gcFn.setTimeout(async function () {
					await $Lt._gcFn.setTimeout(async function () {
						var startTime = await $Lt._gc.Date.now();
						await callback({ timeRemaining: async function () {
								var diffTime = await $Lt._gc.Date.now() - startTime;
								if (diffTime > await self.timeout) {
									return 0;
								}
								return await self.timeout - diffTime;
							} });
					}, 1);
				}, 50);
			}
		}, "class");
		await async function (Lyte) {
			async function getFileExtn(file) {
				return await file.match((/\.[a-zA-Z]+(?=\?|$)/));
			}
			async function getFileExtn(file) {
				return await file.match((/\.[a-zA-Z]+(?=\?|$)/));
			}
			async function domContentLoaded1() {
				await (await Lyte.assetsDivContainer).appendChild(await (await Lyte.$).assetsDiv);
			}
			async function addStateToMap(event, target, XHR, stateName) {
				var mp = Lyte.__nodeXHRMap = await Lyte.__nodeXHRMap || await $Lt._cO($Lt._gc.Map);
				var nodeMap = await mp.get(target);
				if (!nodeMap) {
					await mp.set(target, await $Lt._cO($Lt._gc.Map));
				}
				nodeMap = await mp.get(target);
				var sr = target.lyteState = await target.lyteState || [], type = stateName || XHR;
				if (await sr.indexOf(type) == -1) {
					await sr.push(type);
				}
				await target.setAttribute("lyte-state", "");
				var evMap = await nodeMap.get(event);
				if (!evMap) {
					await nodeMap.set(event, []);
					evMap = await nodeMap.get(event);
				}
				if (stateName) {
					await evMap.push({ state: stateName });
					return {
						target: target,
						event: event
					};
				} else {
					await evMap.push({
						isXHR: true,
						xhr: XHR
					});
					var callback = async function (arg) {
							if (await XHR.readyState == 4) {
								await removeStateFromMap(XHR, event, target);
								await XHR.removeEventListener("readystatechange", callback);
							}
						};
					await XHR.addEventListener("readystatechange", callback);
				}
			}
			async function removeStateFromMap(type, event, target) {
				var mp = await Lyte.__nodeXHRMap;
				var nodeMap = await mp.get(target);
				if (!nodeMap) {
					return;
				}
				var evMap = await nodeMap.get(event);
				if (!evMap) {
					return;
				}
				if (evMap) {
					var arr = evMap;
					var ind = -1;
					await arr.every(async function (itm, idx) {
						if (itm && await itm.isXHR && await itm.xhr == type || typeof type == "string" && await itm.state == type) {
							ind = idx;
							return false;
						}
						return true;
					});
					if (ind != -1) {
						await arr.splice(ind, 1);
						var sind = await (await target.lyteState).indexOf(type);
						await (await target.lyteState).splice(sind, 1);
						if (!await arr.length) {
							await nodeMap.delete(event);
							var tyInd = target && await $Lt._gc.Array.isArray(await target.lyteState) ? await (await target.lyteState).indexOf(type) : -1;
							tyInd != -1 ? await (await target.lyteState).splice(tyInd, 1) : $Lt._gc.undefined;
							if (target && await target.lyteState && await (await target.lyteState).length == 0) {
								target.lyteState = null;
								await target.removeAttribute("lyte-state");
							}
						}
						if (!await nodeMap.size) {
							await mp.delete(target);
						}
					}
				}
			}
			var userAgent = (await Lyte.$).userAgent = $Lt._gc.window.userAgent = await $Lt._gc.navigator.userAgent;
			var singletonServices = await $Lt._cO($Lt._gc.Map);
			if (await userAgent.match((/rv:11/))) {
				(await Lyte.browser).ie = true;
				$Lt._gc.window.action = async function () {
					return;
				};
			}
			if (await userAgent.match("Edge")) {
				var s = await $Lt._gcFn.createElement("div");
				s.innerHTML = "<template><div>c</div></template>";
				if (await (await (await s.querySelector("template")).childNodes).length) {
					(await Lyte.browser).ie = true;
				} else {
					(await Lyte.browser).edge = true;
				}
				await s.remove();
			}
			(await Lyte.Globals).set = async function (scope, value) {
				await (await Lyte.Component).set(await Lyte.__gl, scope, value);
			};
			(await Lyte.Globals).get = async function (scope) {
				return await (await Lyte.Component)._get(await Lyte.__gl, scope);
			};
			await $Lt._gc.Object.defineProperty(await Lyte.Service, "__Lyte__", { value: Lyte });
			await $Lt._gc.Object.defineProperty(await Lyte.Mixin, "__Lyte__", { value: Lyte });
			await $Lt._gc.Object.defineProperty(await Lyte.$, "__Lyte__", { value: Lyte });
			(await (await Lyte.Mixin).__Lyte__).requiredMixins = {};
			Lyte.oldProxy = typeof $Lt._gc.$Lt != "undefined" && await $Lt._gc.$Lt.oldProxy ? await $Lt._gc.$Lt.oldProxy : $Lt._gc.undefined;
			(await Lyte.$).assetsDiv = await $Lt._gc.document.createElement("div");
			await (await (await Lyte.$).assetsDiv).setAttribute("id", "lyteAssetsDiv");
			Lyte.assetsDivContainer = await $Lt._gc.document.head;
			(await Lyte.$).widgetWrapper = await $Lt._gc.document.createElement("shadow-wrapper");
			await (await (await Lyte.$).widgetWrapper).attachShadow({ "mode": "open" });
			await (await (await Lyte.$).widgetWrapper).setAttribute("id", "widgetWrapperDiv");
			Lyte.domContentLoaded = async function (callback) {
				if (await $Lt._gc.document.readyState === "complete" || await $Lt._gc.document.readyState === "interactive") {
					await callback();
				} else {
					await $Lt._gc.window.addEventListener("DOMContentLoaded", async function () {
						await callback();
					});
				}
			};
			Lyte.createApplication = async function (name, obj) {
				if (await obj.init) {
					await (await obj.init).apply(Lyte);
				}
			};
			Lyte.registerErrorCodes = async function (obj) {
				await $Lt._gc.Object.assign(await Lyte.errorCodes, obj);
			};
			Lyte.establishObserverBindings = async function (observers, fromStore, properties, model) {
				var scope = this;
				var watchProps = model && fromStore ? await (await model._fldGrps).JsonPathWatch : await (await scope.constructor)._deepWatchProperties;
				if (fromStore) {
					scope = fromStore;
				}
				for (var i = 0; i < await observers.length; (i = i + 1) - 1) {
					var props = await (await observers[i]).properties;
					var obsAttr = {}, obsDuplicate = false;
					var Jpath = {};
					for (var j = 0; j < await props.length; (j = j + 1) - 1) {
						var actProp;
						var isArrayObserver = false;
						if (typeof await props[j] == "string") {
							if (await (await props[j]).search((/^\$\./g)) != -1) {
								var JsonPath = await props[j];
								var CmpPropertyPath = await (await JsonPath.match((/[^\$.][^\.]*/g)))[0];
								if (await CmpPropertyPath.search((/\[[0-9*]\]/g)) != -1) {
									CmpPropertyPath = await (await CmpPropertyPath.split((/\[[0-9*]\]/g)))[0];
								}
								if (await watchProps[CmpPropertyPath] == $Lt._gc.undefined) {
									watchProps[CmpPropertyPath] = [];
								}
								if (await Jpath[CmpPropertyPath] == $Lt._gc.undefined) {
									Jpath[CmpPropertyPath] = [];
								}
								var JSONPATH;
								var reg = "^\\$\\." + CmpPropertyPath + "\\.?";
								reg = await $Lt._cO($Lt._gc.RegExp, reg);
								JSONPATH = await (await props[j]).replace(reg, "$.");
								if (!await (await watchProps[CmpPropertyPath]).includes(JSONPATH)) {
									await (await watchProps[CmpPropertyPath]).push(JSONPATH);
								}
								if (!await (await Jpath[CmpPropertyPath]).includes(JSONPATH)) {
									await (await Jpath[CmpPropertyPath]).push(JSONPATH);
								}
								CmpPropertyPath = CmpPropertyPath + ".*";
								if (!await obsAttr.hasOwnProperty(CmpPropertyPath)) {
									actProp = await (await Lyte.getProperty).call(this, CmpPropertyPath, fromStore, properties);
									obsAttr[CmpPropertyPath] = true;
									obsDuplicate = false;
								} else {
									obsDuplicate = true;
								}
							} else if (await (await props[j]).indexOf(".[]") !== -1) {
								isArrayObserver = true;
								actProp = await (await Lyte.getProperty).call(this, await (await props[j]).substring(0, await (await props[j]).indexOf(".[]")), fromStore, properties);
							} else {
								if (await (await props[j]).indexOf(".*") !== -1) {
									var prop = await (await (await props[j]).split("."))[0];
									var isDeepObs = !fromStore && await (await (await this.component).__data)[prop] && await (await (await (await this.component).__data)[prop]).watch || fromStore && model && await model.fieldList && await (await model.fieldList)[prop] && await (await (await model.fieldList)[prop]).watch ? true : false;
									if (!isDeepObs) {
										continue;
									}
								}
								actProp = await (await Lyte.getProperty).call(this, await props[j], fromStore, properties);
							}
							if (!obsDuplicate) {
								if (!await actProp._observers) {
									await $Lt._gc.Object.defineProperty(actProp, "_observers", {
										value: await $Lt._cO($Lt._gc.Set),
										enumerable: false,
										writable: true,
										configurable: true
									});
								}
								await (await actProp._observers).add({
									callee: scope,
									observer: await observers[i],
									isArrayObserver: isArrayObserver
								});
							}
						} else {
							await Lyte.warn("ERR27", await $Lt._gc.JSON.stringify(await props[j]), await (await observers[i]).fnName, await this.tagName);
						}
					}
					(await observers[i]).Jpath = Jpath;
					obsAttr = {};
				}
			};
			Lyte.getProperty = async function (key, fromStore, properties) {
				let arr = await key.match((/([^[\].]+|\[\])/g));
				let property = this;
				if (fromStore) {
					property = properties;
					if (!await properties[await arr[0]]) {
						properties[await arr[0]] = {};
					}
					property = await properties[await arr[0]];
				} else {
					if (!await (await property._properties)[await arr[0]]) {
						(await property._properties)[await arr[0]] = {};
					}
					property = await (await property._properties)[await arr[0]];
				}
				await $Lt._gc.Object.defineProperty(property, "_path", {
					enumerable: false,
					value: await arr[0]
				});
				for (let i = 1; i < await arr.length; (i = i + 1) - 1) {
					if (await (await arr[i]).startsWith("'") || await (await arr[i]).startsWith("\"")) {
						arr[i] = await (await arr[i]).substring(1, await (await arr[i]).length - 1);
					}
					if (!await property[await arr[i]]) {
						property[await arr[i]] = {};
						await $Lt._gc.Object.defineProperty(await property[await arr[i]], "_path", {
							enumerable: false,
							value: await property._path + "." + await arr[i]
						});
					}
					property = await property[await arr[i]];
				}
				return property;
			};
			Lyte.getErrorMessage = async function (code) {
				var args = await (await $Lt._gc.Array.from(arguments)).slice(1);
				if (await (await Lyte.errorCodes)[code]) {
					return await (await (await Lyte.errorCodes)[code]).replace((/{(\d+)}/g), async function (t, i) {
						return await args[i];
					});
				} else {
					return code;
				}
			};
			Lyte.error = async function () {
				var errorObj = await arguments[0], parse = await errorObj.stack;
				errorObj = parse ? errorObj : await $Lt._gcFn.Error(await (await Lyte.getErrorMessage).apply(Lyte, arguments));
				if (await Lyte.onerror) {
					await (await Lyte.onerror).call(this, errorObj, await arguments[1]);
				}
				await Lyte.triggerEvent("error", errorObj, await arguments[1]);
				var safari = await errorObj.stack && await (await errorObj.stack).indexOf(await errorObj.message) == -1;
				if (parse && !safari) {
					errorObj = await $Lt._gc.JSON.parse(await $Lt._gc.JSON.stringify(errorObj, await $Lt._gc.Object.getOwnPropertyNames(errorObj)));
				}
				if (await arguments[1]) {
					await $Lt._gc.console.error(await errorObj.stack ? safari ? errorObj : await errorObj.stack : await errorObj.message, await arguments[1]);
				} else {
					await $Lt._gc.console.error(await errorObj.stack ? safari ? errorObj : await errorObj.stack : await errorObj.message);
				}
			};
			Lyte.warn = async function () {
				var errorObj = await arguments[0];
				errorObj = await errorObj.stack ? await $Lt._gc.JSON.parse(await $Lt._gc.JSON.stringify(errorObj, await $Lt._gc.Object.getOwnPropertyNames(errorObj))) : await $Lt._gcFn.Error(await (await Lyte.getErrorMessage).apply(Lyte, arguments));
				await $Lt._gc.console.warn(await errorObj.stack ? await (await errorObj.stack).indexOf(await errorObj.message) != -1 ? await (await errorObj.stack).replace("Error: ", "") : errorObj : await errorObj.message);
			};
			var requiredMixins = {};
			var fnProto = await $Lt._gc.Function.prototype;
			if (!await fnProto.on) {
				fnProto.on = async function () {
					await Lyte.warn("'.on()' method with the argument '" + await arguments[0] + "' cannot be executed outside component scope.");
					return {
						"type": "callBack",
						"value": await this.type === "observer" ? await this.value : this,
						"properties": arguments,
						"observes": await this.type === "observer" ? this : $Lt._gc.undefined
					};
				};
			}
			if (!await fnProto.observes) {
				fnProto.observes = async function () {
					await Lyte.warn("'.observes()' method with the arguments '" + await arguments[0] + "' cannot be executed outside component scope.");
					return {
						"type": "observer",
						"value": this,
						"properties": arguments,
						"on": await Lyte._onObj,
						"lyteOn": await Lyte._onObj
					};
				};
			}
			if (!await fnProto.computed) {
				fnProto.computed = async function () {
					await Lyte.warn("'.computed()' method with the arguments '" + await arguments[0] + "' cannot be executed outside component scope.");
					return {
						"type": "computed",
						"value": this,
						"properties": arguments
					};
				};
			}
			Lyte._onObj = async function () {
				return {
					"type": "callBack",
					"value": await this.type === "observer" ? await this.value : this,
					"properties": arguments,
					"observes": await this.type === "observer" ? this : $Lt._gc.undefined
				};
			};
			Lyte._observesObj = async function () {
				return {
					"type": "observer",
					"value": this,
					"properties": arguments,
					"on": await Lyte._onObj,
					"lyteOn": await Lyte._onObj
				};
			};
			Lyte._computedObj = async function () {
				return {
					"type": "computed",
					"value": this,
					"properties": arguments
				};
			};
			Lyte._preRegister = async function () {
				Lyte._actualFnProtoOn = await (await $Lt._gc.Function.prototype).on;
				Lyte._actualFnProtoObserves = await (await $Lt._gc.Function.prototype).observes;
				Lyte._actualFnProtoComputed = await (await $Lt._gc.Function.prototype).computed;
				let fnProto = await $Lt._gc.Function.prototype;
				fnProto.on = fnProto.lyteOn = await Lyte._onObj;
				fnProto.observes = fnProto.lyteObserves = await Lyte._observesObj;
				fnProto.computed = fnProto.lyteComputed = await Lyte._computedObj;
			};
			Lyte._postRegister = async function () {
				let fnProto = await $Lt._gc.Function.prototype;
				fnProto.on = await Lyte._actualFnProtoOn;
				fnProto.observes = await Lyte._actualFnProtoObserves;
				fnProto.computed = await Lyte._actualFnProtoComputed;
			};
			await $Lt._gc.Object.defineProperty(await Lyte.Mixin, "register", {
				get: async function () {
						await Lyte._preRegister();
						return await Lyte.registerMixinWrapper;
					},
				"enumerable": true
			});
			Lyte.registerMixinWrapper = async function () {
				try {
					await (await Lyte.registerMixin).apply(Lyte, arguments);
					await Lyte._postRegister();
				} catch (e) {
					await Lyte._postRegister();
				}
			};
			Lyte.registerMixin = async function (name, mixin) {
				(await Lyte.registeredMixins)[name] = mixin;
				var req;
				if (req = await requiredMixins[name]) {
					for (var key in req) {
						await (await (await Lyte.$).requiredMixins)[key](mixin, await req[key], key);
					}
				}
			};
			(await Lyte.Mixin).get = async function (name) {
				return await (await Lyte.registeredMixins)[name];
			};
			(await Lyte.$).instantiateService = async function (name, data) {
				var service = await (await Lyte.registeredServices)[name];
				if (await service.singleton == true) {
					if (await singletonServices.has(name)) {
						return await singletonServices.get(name);
					} else {
						var ins = await $Lt._cO(service, data);
						await singletonServices.set(name, ins);
						return ins;
					}
				} else {
					return await $Lt._cO(service, data);
				}
			};
			(await Lyte.Service).register = async function (name, service, isSingleton) {
				if (await (await Lyte.registeredServices).hasOwnProperty(name)) {
					await Lyte.warn("Service -" + name + " is already registered");
					return;
				}
				if (!await (await Lyte._keywords).is(name)) {
					var data = service, req;
					if (isSingleton) {
						data.singleton = isSingleton;
					}
					(await Lyte.registeredServices)[name] = data;
					var serv = await (await Lyte.requiredServices)[name];
					if (serv && await serv.size) {
						await $Lt._fE(serv, async function (obj) {
							var toSend = data;
							if (await obj.isGlobal) {
								toSend = (await Lyte.__gS)[await obj.key] = await (await Lyte.__gS)[await obj.key] || await (await Lyte.$).instantiateService(name, await obj.data);
							}
							await obj.cB(toSend, await obj.key, await obj.name, name);
						});
					}
					return data;
				} else {
					await Lyte.warn("Service name-" + name + " should not be a keyword used in Lyte");
				}
			};
			(await Lyte.Service).getInjected = async function (key) {
				if (await (await Lyte.__gS).hasOwnProperty(key)) {
					return await (await Lyte.__gS)[key];
				}
			};
			(await Lyte.$).requiredServices = async function (key, serviceName, cB, type, name, isGlobal, data) {
				var reqServ = await (await Lyte.requiredServices)[serviceName];
				var req = reqServ ? reqServ : (await Lyte.requiredServices)[serviceName] = await $Lt._cO($Lt._gc.Map);
				var id = await (await Lyte.$).genMapId(req);
				await req.set(id, {
					key: key,
					cB: cB,
					type: type,
					name: name,
					serviceName: serviceName,
					isGlobal: isGlobal,
					data: data
				});
				return serviceName + "-" + id;
			};
			(await Lyte.$).lazyRegisterService = async function (service, obj) {
				var scope = await obj.scope, name = await obj.name, callback = await (await scope[await obj.type])[name];
				if (callback) {
					callback[await obj.key] = service;
				}
			};
			(await Lyte.$).injectServices = {};
			await $Lt._gc.Object.defineProperty(Lyte, "__gS", { value: {} });
			Lyte.injectServices = async function (data) {
				var serv = {};
				if (!await $Lt._gc.Array.isArray(data)) {
					data = [data];
				}
				await $Lt._fE(data, async function (itm) {
					if (itm && typeof itm == "object") {
						var key = await itm.as, service = await itm.service, args = await itm.data;
						if (!await (await Lyte._keywords).is(key)) {
							if (!await (await Lyte.toBeInjectedServices).hasOwnProperty(key)) {
								(await Lyte.toBeInjectedServices)[key] = service;
								serv[key] = {
									service: service,
									data: args
								};
								if (await (await Lyte.registeredServices)[service]) {
									(await Lyte.__gS)[key] = await (await Lyte.$).instantiateService(service, args);
								}
							} else {
								await Lyte.warn("A service has already been injected in the key named, ", key);
							}
						} else {
							await Lyte.warn("Service cannot be used in any keywords of Lyte.");
						}
					} else if (typeof itm == "string") {
						if (!await (await Lyte.toBeInjectedServices).hasOwnProperty(itm)) {
							(await Lyte.toBeInjectedServices)[itm] = itm;
							serv[itm] = { service: itm };
							if (await (await Lyte.registeredServices)[itm]) {
								(await Lyte.__gS)[itm] = await (await Lyte.$).instantiateService(itm);
							}
						} else {
							await Lyte.warn("A service has already been injected in the key named, ", itm);
						}
					} else {
						await Lyte.warn("Invalid data passed to injectServices", itm);
					}
				});
				var mdlObj = await (await Lyte.$).injectServices;
				for (var mKey in mdlObj) {
					for (var key in serv) {
						await mdlObj[mKey](key, await (await serv[key]).service, mKey, await (await Lyte.__gS)[key], $Lt._gc.undefined, await (await serv[key]).data);
					}
				}
			};
			(await Lyte.$).genMapId = async function (map) {
				var id = await $Lt._gc.Math.floor(await $Lt._gc.Math.random() * 10000000000 + 1);
				while (await map.get(id)) {
					id = await $Lt._gc.Math.floor(await $Lt._gc.Math.random() * 10000000000 + 1);
				}
				return await id.toString();
			};
			(await Lyte.$).toRemoveFromRequiredServices = async function (str) {
				var arr = await str.split("-"), id = await arr[await arr.length - 1], idLen = await id.length, servName = await str.substr(0, await str.length - (idLen + 1));
				var reqArr = await (await Lyte.requiredServices)[servName];
				if (reqArr) {
					await reqArr.delete(id);
				}
			};
			Lyte.toBeUsedServices = async function (obj) {
				var serviceToBeUsed = {};
				var arr = await obj.services;
				if (arr) {
					await $Lt._fE(arr, async function (service) {
						if (typeof service == "string") {
							serviceToBeUsed[service] = service;
						} else if (service && typeof service == "object") {
							var key = await service.as, serv = await service.service;
							if (!await (await Lyte._keywords).is(key, await obj.type)) {
								serviceToBeUsed[key] = serv;
							} else {
								await Lyte.warn("Service cannot be used in any keywords of Lyte.");
							}
						}
					});
				}
				return serviceToBeUsed;
			};
			Lyte.extendService = async function (arg) {
				var servObj = await Lyte.toBeUsedServices(arg), name;
				for (var serv in servObj) {
					name = await servObj[serv];
					if (await arg.isGlobal && await (await Lyte.__gS).hasOwnProperty(serv) || !await arg.isGlobal && await (await Lyte.registeredServices).hasOwnProperty(name)) {
						var ins = await arg.ins, service = await arg.isGlobal ? await (await Lyte.__gS)[serv] : await (await Lyte.$).instantiateService(name);
						if (!await $Lt._gc.Array.isArray(ins)) {
							ins = [await arg.ins];
						}
						await $Lt._fE(ins, async function (insObj) {
							insObj[serv] = await arg.isGlobal ? await (await Lyte.__gS)[serv] : await (await Lyte.$).instantiateService(name);
						});
					} else {
						await (await Lyte.$).requiredServices(serv, name, await arg.callback, await arg.type, await arg.name, await arg.isGlobal, await arg.data);
					}
				}
			};
			(await Lyte.$).requiredMixins = async function (mixin, dir, type) {
				var req = await requiredMixins[mixin] ? await requiredMixins[mixin] : requiredMixins[mixin] = {};
				if (!await req[type]) {
					req[type] = [dir];
				} else {
					await (await req[type]).push(dir);
				}
			};
			(await Lyte.Mixin).exists = async function (name) {
				if (!await (await Lyte.registeredMixins)[name]) {
					return false;
				}
				return true;
			};
			Lyte.log = async function (text, src, color) {
				if (await Lyte.debug) {
					if (color) {
						await $Lt._gc.console.log("%c" + text, "color:" + color);
					} else {
						await $Lt._gc.console.log(text);
					}
				}
			};
			Lyte.time = async function (fn) {
				if (await Lyte.performance) {
					var index;
					if ((index = await (await (await Lyte.$).consoleTime).indexOf(fn)) != -1) {
						await (await (await Lyte.$).consoleTime).splice(index, 1);
						await $Lt._gc.console.timeEnd(fn);
					} else {
						await (await (await Lyte.$).consoleTime).push(fn);
						await $Lt._gc.console.time(fn);
					}
				}
			};
			Lyte.isRecord = function (object) {
				if (object && object.$ && object.$.hasOwnProperty("isModified")) {
					return true;
				}
				return false;
			};
			Lyte.isComponent = async function (object) {
				if (object && await object.$node && await object.__data) {
					return true;
				}
				return false;
			};
			(await Lyte.$).reqFiles = {};
			Lyte.injectResources = async function (files, every, completed, options) {
				async function injectJS(files, resolve, execFiles) {
					async function loaded() {
						(len = len + 1) - 1;
						if (len == 0) {
							await resolve(successFiles, errorFiles);
						}
					}
					var len;
					execFiles = execFiles || [];
					if (!files) {
						await resolve(successFiles, errorFiles);
					} else {
						if (!await $Lt._gc.Array.isArray(files)) {
							files = [files];
						}
						if (!await files.length) {
							await resolve(successFiles, errorFiles);
						}
						len = -await files.length;
						await $Lt._fE(files, async function (file) {
							if (typeof file == "string") {
								var type = await getFileExtn(file);
								if (type && (type == ".js" || type == ".css") && await execFiles.indexOf(file) == -1) {
									await execFiles.push(file);
									await createScript(file, async function () {
										await loaded();
									});
								} else {
									await loaded();
								}
							} else if (await $Lt._gc.Array.isArray(file)) {
								await injectJS(file, async function () {
									await loaded();
								});
							} else {
								(len = len - 1) + 1;
								await injectJS(await file.parent, async function () {
									await injectJS(await file.child, async function () {
										await loaded();
									});
									await loaded();
								});
							}
						});
					}
				}
				async function createScript(file, resolve) {
					var ev = await (await (await Lyte.injectResources).respObj)[file];
					if (ev && (!await (await (await Lyte.injectResources).availableTags)[file] || await (await (await (await (await Lyte.injectResources).availableTags)[file]).tag).getAttribute("rel") == "preload")) {
						var type = await getFileExtn(file), tag;
						if (type == ".js") {
							tag = await $Lt._gc.document.createElement("script");
							await tag.setAttribute("type", "text/javascript");
							await tag.setAttribute("src", file);
						} else if (type == ".css") {
							tag = await $Lt._gc.document.createElement("link");
							await tag.setAttribute("type", "text/css");
							await tag.setAttribute("rel", "stylesheet");
							await tag.setAttribute("href", file);
						}
						await $Lt._fE(await ev.getAttributeNames(), async function (attr) {
							if (await [
									"href",
									"as",
									"rel"
								].indexOf(attr) == -1) {
								await tag.setAttribute(attr, await ev.getAttribute(attr));
							}
						});
						tag.onerror = tag.onload = async function (event) {
							if (await event.type == "error") {
								await errorFiles.push(event);
							} else {
								await successFiles.push(event);
							}
							delete (await (await Lyte.injectResources).respObj)[file];
							await (await (await (await (await Lyte.injectResources).availableTags)[file]).tag).remove();
							(await (await Lyte.injectResources).availableTags)[file] = {
								tag: tag,
								event: event,
								type: await event.type == "error" ? "error" : "load"
							};
							await resolve();
							tag.onerror = tag.onload = $Lt._gc.undefined;
						};
						await (await (await Lyte.$).assetsDiv).appendChild(tag);
					} else {
						var t = await (await (await Lyte.injectResources).availableTags)[file];
						if (await t.type == "error") {
							await errorFiles.push(await t.event);
						} else {
							await successFiles.push(await t.event);
						}
						await resolve();
					}
				}
				async function processRequirements(files, resolve) {
					async function loaded() {
						(len = len + 1) - 1;
						if (len == 0) {
							await resolve();
						}
					}
					async function requestFile(file, cached, resolve) {
						if (await (await (await Lyte.$).reqFiles)[file]) {
							await (await (await (await Lyte.$).reqFiles)[file]).push(resolve);
						} else {
							(await (await Lyte.$).reqFiles)[file] = [resolve];
							if (cached && await (await cached.event).type != "error") {
								if (await (await (await Lyte.removeFromCache).arr).indexOf(file) != -1) {
									await (await (await Lyte.removeFromCache).arr).splice(await (await (await Lyte.removeFromCache).arr).indexOf(file), 1);
								}
								await fileLoaded.call(await cached.tag, file, await cached.event, true);
								await resolve();
							} else {
								await makeRequest(file, async function (event) {
									(await (await Lyte.injectResources).respObj)[file] = this;
									await $Lt._fE(await (await (await Lyte.$).reqFiles)[file], async function (resolve) {
										await resolve();
									});
									await fileLoaded.call(this, file, event);
									await every.call(this, event);
								});
							}
						}
					}
					async function fileLoaded(file, event, cached) {
						delete (await (await Lyte.$).reqFiles)[file];
						if (!cached) {
							if (await (await (await Lyte.injectResources).availableTags)[file]) {
								await (await (await (await (await Lyte.injectResources).availableTags)[file]).tag).remove();
								delete (await (await Lyte.injectResources).respObj)[file];
							}
							(await (await Lyte.injectResources).availableTags)[file] = {
								tag: this,
								event: event,
								type: await event.type
							};
						}
					}
					var len;
					if (!files) {
						await resolve();
					} else {
						if (!await $Lt._gc.Array.isArray(files)) {
							files = [files];
						}
						if (!await files.length) {
							await resolve();
						}
						len = -await files.length;
						await $Lt._fE(files, async function (file) {
							if (typeof file == "string") {
								await requestFile(file, await (await (await Lyte.injectResources).availableTags)[file], async function () {
									await loaded();
								});
							} else if (await $Lt._gc.Array.isArray(file)) {
								await (await $Lt._cO($Lt._gc.Promise, async function (r) {
									await processRequirements(file, r);
								})).then(async function () {
									await loaded();
								});
							} else {
								(len = len - 1) + 1;
								await (await $Lt._cO($Lt._gc.Promise, async function (r) {
									await processRequirements(await file.parent, r);
								})).then(async function () {
									await loaded();
								});
								await (await $Lt._cO($Lt._gc.Promise, async function (r) {
									await processRequirements(await file.child, r);
								})).then(async function () {
									await loaded();
								});
							}
						});
					}
				}
				async function makeRequest(file, callBack) {
					var tag, ev = await every.internal || {}, type = await getFileExtn(file);
					ev.file = file;
					if (type == null) {
						await Lyte.error("Type of file is not specified in injectResources.");
						return;
					}
					tag = await $Lt._gc.document.createElement("link");
					await tag.setAttribute("href", file);
					ev.tag = tag;
					if (type == ".css") {
						await tag.setAttribute("as", "style");
					} else {
						await tag.setAttribute("as", "script");
					}
					await tag.setAttribute("rel", "preload");
					tag.onerror = tag.onload = async function (event) {
						await callBack.call(this, event);
						this.onerror = this.onload = $Lt._gc.undefined;
					};
					await Lyte.triggerEvent("onBeforeInject", ev);
					await (await (await Lyte.$).assetsDiv).appendChild(tag);
				}
				var successFiles = [], errorFiles = [];
				every = every || async function () {
				};
				completed = completed || async function () {
				};
				return await $Lt._cO($Lt._gc.Promise, async function (resolve, reject) {
					await processRequirements(files, async function () {
						if (options && await options.defer) {
							await options.defer({
								injectJS: injectJS,
								files: files,
								errorFiles: errorFiles
							});
							await resolve();
						} else {
							await injectJS(files, async function () {
								await completed(successFiles, errorFiles);
								if (await errorFiles.length) {
									await reject(successFiles, errorFiles);
								} else {
									await resolve(successFiles, errorFiles);
								}
							});
						}
					}.bind(this));
				});
				;
			};
			(await Lyte.injectResources).availableTags = [];
			(await Lyte.injectResources).respObj = [];
			(await Lyte.$).replaceOldInjectResource = async function () {
				Lyte.injectResources = async function (files, every, completed) {
					async function processRequirements(files, resolve) {
						async function loaded() {
							(len = len + 1) - 1;
							if (len == 0) {
								await resolve();
							}
						}
						async function requestFile(file, cached, resolve) {
							if (await (await (await Lyte.$).reqFiles)[file]) {
								await (await (await (await Lyte.$).reqFiles)[file]).push(resolve);
							} else {
								(await (await Lyte.$).reqFiles)[file] = [resolve];
								if (cached && await (await cached.event).type != "error") {
									if (await (await (await Lyte.removeFromCache).arr).indexOf(file) != -1) {
										await (await (await Lyte.removeFromCache).arr).splice(await (await (await Lyte.removeFromCache).arr).indexOf(file), 1);
									}
									await fileLoaded.call(await cached.tag, await cached.event, true);
									await resolve();
								} else {
									await makeRequest(file, async function (event) {
										await $Lt._fE(await (await (await Lyte.$).reqFiles)[file], async function (resolve) {
											await resolve();
										});
										await fileLoaded.call(this, event);
										await every.call(this, event);
									});
								}
							}
						}
						async function fileLoaded(event, cached) {
							var file = await this.getAttribute("src") || await this.getAttribute("href");
							delete (await (await Lyte.$).reqFiles)[file];
							if (!cached) {
								if (await (await (await Lyte.injectResources).availableTags)[file]) {
									await (await (await (await (await Lyte.injectResources).availableTags)[file]).tag).remove();
								}
								this.onerror = this.onload = $Lt._gc.undefined;
								(await (await Lyte.injectResources).availableTags)[file] = {
									tag: this,
									event: { type: await event.type }
								};
							}
						}
						var len;
						if (!files) {
							await resolve();
						} else {
							if (!await $Lt._gc.Array.isArray(files)) {
								files = [files];
							}
							if (!await files.length) {
								await resolve();
							}
							len = -await files.length;
							await $Lt._fE(files, async function (file) {
								if (typeof file == "string") {
									await requestFile(file, await (await (await Lyte.injectResources).availableTags)[file], async function () {
										await loaded();
									});
								} else if (await $Lt._gc.Array.isArray(file)) {
									await (await $Lt._cO($Lt._gc.Promise, async function (r) {
										await processRequirements(file, r);
									})).then(async function () {
										await loaded();
									});
								} else {
									await (await $Lt._cO($Lt._gc.Promise, async function (r) {
										await processRequirements(await file.parent, r);
									})).then(async function () {
										await (await $Lt._cO($Lt._gc.Promise, async function (r1) {
											await processRequirements(await file.child, r1);
										})).then(async function () {
											await loaded();
										});
									});
								}
							});
						}
					}
					async function makeRequest(file, callBack) {
						var tags = {
								".js": "script",
								".css": "link"
							}, type = await getFileExtn(file);
						$Lt._gc.tag = await $Lt._gc.document.createElement(await tags[type]);
						if (!type) {
							await Lyte.error("Type of file is not specified in injectResources.");
							return;
						} else if (type == ".css") {
							await $Lt._gc.tag.setAttribute("href", file);
							await $Lt._gc.tag.setAttribute("type", "text/css");
							await $Lt._gc.tag.setAttribute("rel", "stylesheet");
						} else {
							await $Lt._gc.tag.setAttribute("src", file);
						}
						$Lt._gc.tag.onerror = $Lt._gc.tag.onload = async function (event) {
							if (await event.type == "error") {
								await errorFiles.push(event);
							} else {
								await successFiles.push(event);
							}
							if (callBack) {
								await callBack.call(this, event);
							}
						};
						var ev = await every.internal || {};
						ev.file = file;
						ev.tag = $Lt._gc.tag;
						await Lyte.triggerEvent("onBeforeInject", ev);
						await (await (await Lyte.$).assetsDiv).appendChild($Lt._gc.tag);
					}
					var successFiles = [], errorFiles = [];
					every = every || async function () {
					};
					completed = completed || async function () {
					};
					return await (await $Lt._cO($Lt._gc.Promise, async function (resolve) {
						await processRequirements(files, resolve);
					})).then(async function () {
						await completed(successFiles, errorFiles);
					});
					;
				};
				(await Lyte.injectResources).availableTags = [];
				(await Lyte.injectResources).respObj = [];
			};
			Lyte.removeFromCache = async function (arr) {
				await (await Lyte.removeFromCache).assign(arr);
				if (await (await (await Lyte.removeFromCache).arr).length) {
					await $Lt._fE(await (await Lyte.removeFromCache).arr, async function (file) {
						if (await (await (await Lyte.injectResources).availableTags)[file]) {
							await (await (await (await (await Lyte.injectResources).availableTags)[file]).tag).remove();
							delete (await (await Lyte.injectResources).availableTags)[file];
							delete (await (await Lyte.injectResources).respObj)[file];
						}
					});
					(await Lyte.removeFromCache).arr = [];
				}
			};
			(await Lyte.removeFromCache).arr = [];
			(await Lyte.removeFromCache).assign = async function (arr) {
				arr = arr == "*" ? await $Lt._gc.Object.keys(await (await Lyte.injectResources).availableTags) : await $Lt._gc.Array.isArray(arr) ? arr : [arr];
				(await Lyte.removeFromCache).arr = await (await (await Lyte.removeFromCache).arr).concat(arr);
				return;
			};
			(await Lyte.$).prefetchSupport = false;
			try {
				if (!await (await Lyte.browser).ie) {
					var link = await $Lt._gc.document.createElement("link");
					(await Lyte.$).prefetchSupport = await (await link.relList).supports("prefetch") && await (await link.relList).supports("preload");
				}
			} catch (e) {
			}
			if (!await (await Lyte.$).prefetchSupport) {
				await $Lt._gc.console.log("Prefetch is not supported. Falling back to old implementation");
				await (await Lyte.$).replaceOldInjectResource();
			}
			Lyte.checkProperty = async function (property, dataVal, key, fieldVal, field, record, type, name, init) {
				var exts = "extends";
				switch (property) {
				case "type":
					if (await (await Lyte.Transform).hasOwnProperty(fieldVal) && dataVal !== $Lt._gc.undefined && dataVal !== null) {
						var _fld = await (await Lyte.Transform)[fieldVal], _ret = true;
						if (await $Lt._gc.Array.isArray(dataVal)) {
							if (await (await (await Lyte.Transform)[fieldVal])[exts] != "array") {
								return {
									code: "ERR03",
									message: await (await Lyte.errorCodes).ERR03,
									expected: fieldVal
								};
							}
							if (await _fld.hasOwnProperty("items")) {
								_ret = await Lyte.checkProperty("items", dataVal, key, await _fld.items);
							}
						} else if (typeof dataVal === "object" && await (await (await Lyte.Transform)[fieldVal])[exts] == "object" && await _fld.hasOwnProperty("properties")) {
							_ret = await Lyte.checkProperty("properties", dataVal, key, await _fld.properties);
						} else if (await (await (await Lyte.Transform)[fieldVal])[exts] != typeof dataVal) {
							return {
								code: "ERR03",
								message: await (await Lyte.errorCodes).ERR03,
								expected: fieldVal
							};
						}
						if (_ret !== true) {
							return _ret;
						}
					} else if (dataVal !== $Lt._gc.undefined && dataVal !== null) {
						if (await $Lt._gc.Array.isArray(dataVal)) {
							if (fieldVal != "array") {
								return {
									code: "ERR03",
									message: await (await Lyte.errorCodes).ERR03,
									expected: fieldVal
								};
							}
						} else if (fieldVal != typeof dataVal) {
							return {
								code: "ERR03",
								message: await (await Lyte.errorCodes).ERR03,
								expected: fieldVal
							};
						}
					}
					break;
				case "mandatory":
					let validateFlag = fieldVal;
					if (typeof fieldVal == "object") {
						if (init && await fieldVal.skipValidationOnInit == true) {
							validateFlag = false;
						}
					}
					if (validateFlag && (dataVal == $Lt._gc.undefined || dataVal == null || dataVal === "")) {
						return {
							code: "ERR02",
							message: await (await Lyte.errorCodes).ERR02
						};
					}
					break;
				case "maximum":
					if (typeof dataVal == "number" && dataVal > fieldVal) {
						return {
							code: "ERR04",
							message: await (await Lyte.errorCodes).ERR04,
							expected: fieldVal
						};
					}
					break;
				case "minimum":
					if (typeof dataVal == "number" && dataVal < fieldVal) {
						return {
							code: "ERR05",
							message: await (await Lyte.errorCodes).ERR05,
							expected: fieldVal
						};
					}
					break;
				case "maxLength":
				case "maxItems":
					if (dataVal && await dataVal.length > fieldVal) {
						return {
							code: "ERR06",
							message: await (await Lyte.errorCodes).ERR06,
							expected: fieldVal
						};
					}
					break;
				case "minLength":
				case "minItems":
					if (dataVal && await dataVal.length < fieldVal) {
						return {
							code: "ERR07",
							message: await (await Lyte.errorCodes).ERR07,
							expected: fieldVal
						};
					}
					break;
				case "pattern":
					if (typeof dataVal == "string" && !await (await $Lt._cO($Lt._gc.RegExp, fieldVal)).test(dataVal)) {
						return {
							code: "ERR08",
							message: await (await Lyte.errorCodes).ERR08,
							expected: fieldVal
						};
					}
					break;
				case "uniqueItems": {
						if (await $Lt._gc.Array.isArray(dataVal) && fieldVal) {
							var newArr = [];
							for (var i = 0; i < await dataVal.length; (i = i + 1) - 1) {
								var val = await dataVal[i];
								if (await newArr.indexOf(val) != -1) {
									return {
										code: "ERR09",
										message: await (await Lyte.errorCodes).ERR09
									};
								}
								await newArr.push(val);
							}
						}
						break;
					}
				case "constant":
					if (await $Lt._gc.Array.isArray(dataVal)) {
						var resp = await dataVal.length == await fieldVal.length && await dataVal.every(async function (v, i) {
								return v === await fieldVal[i];
							});
						if (!resp) {
							return {
								code: "ERR10",
								message: await (await Lyte.errorCodes).ERR10,
								expected: fieldVal
							};
						}
					} else if (typeof dataVal == "object") {
						var resp = await (await (await $Lt._gc.store.adapter).$).compareObjects(dataVal, fieldVal);
						if (!resp) {
							return {
								code: "ERR10",
								message: await (await Lyte.errorCodes).ERR10,
								expected: fieldVal
							};
						}
					} else if (dataVal && dataVal != fieldVal) {
						return {
							code: "ERR10",
							message: await (await Lyte.errorCodes).ERR10,
							expected: fieldVal
						};
					}
					break;
				case "items": {
						if (await $Lt._gc.Array.isArray(dataVal)) {
							for (var i = 0; i < await dataVal.length; (i = i + 1) - 1) {
								if (!(await fieldVal.any && await $Lt._gc.Array.isArray(fieldVal))) {
									fieldVal = [fieldVal];
								}
								var fldLen = await fieldVal.length, _ret = true;
								for (var j = 0; j < fldLen; (j = j + 1) - 1) {
									var _fld = await fieldVal[j];
									for (var property in _fld) {
										var resp = await Lyte.checkProperty(property, await dataVal[i], i, await _fld[property], _fld);
										if (resp !== true) {
											if (_ret === true) {
												resp.path = await resp.path ? i + "." + await resp.path : await resp.path;
												_ret = resp;
											}
											break;
										}
									}
								}
								if (_ret !== true) {
									return _ret;
								}
							}
						}
						break;
					}
				case "properties":
					if (typeof dataVal == "object" && !await $Lt._gc.Array.isArray(dataVal)) {
						for (var key in dataVal) {
							if (await fieldVal.hasOwnProperty(key)) {
								var fld = await fieldVal[key];
								if (!(await fld.any && await $Lt._gc.Array.isArray(fld))) {
									fld = [fld];
								}
								var fldLen = await fld.length, _ret = true;
								for (var i = 0; i < fldLen; (i = i + 1) - 1) {
									var _fld = await fld[i];
									for (var property in _fld) {
										var resp = await Lyte.checkProperty(property, await dataVal[key], key, await _fld[property], _fld);
										if (resp != true) {
											if (_ret === true) {
												resp.path = await resp.path ? key + "." + await resp.path : await key.toString();
												_ret = resp;
											}
											break;
										}
									}
								}
								if (_ret !== true) {
									return _ret;
								}
							}
						}
					}
					break;
				case "validation": {
						var resp = await (await (await Lyte.customValidator)[fieldVal]).apply(record, [
								key,
								dataVal,
								name
							]);
						if (resp != true) {
							return resp;
						}
						break;
					}
				case "instanceof": {
						if (typeof dataVal === "object" && !await $Lt._gc.Array.isArray(dataVal) && !await $Lt._iO(dataVal, fieldVal)) {
							return {
								code: "ERR30",
								message: await (await Lyte.errorCodes).ERR30,
								property: key,
								instanceof: fieldVal
							};
						}
					}
				}
				return true;
			};
			Lyte.checkNestedProp = async function (id, path, dtype, wobj, object, property, value, check, fromStore) {
				if (await (await Lyte.Transform)[await dtype.type]) {
					dtype = await (await Lyte.Transform)[await dtype.type];
					dtype.type = await dtype.extends;
				}
				if (await path.length != 0) {
					if (await dtype.type == "array") {
						if (await dtype.items && !await $Lt._gcFn.isNaN(await path[0]) && typeof await dtype.items == "object") {
							path = await path.slice(1);
							await Lyte.checkNestedProp(id, path, await dtype.items, wobj, object, property, value, check, fromStore);
						}
					} else if (await dtype.type == "object") {
						if (await dtype.properties && await (await dtype.properties).hasOwnProperty(await path[0])) {
							var k = await path[0];
							path = await path.slice(1);
							await Lyte.checkNestedProp(id, path, await (await dtype.properties)[k], wobj, object, property, value, check, fromStore);
						}
					}
				} else {
					var err;
					if (dtype && (await dtype.properties || await dtype.items) && !await check.hasOwnProperty("warn")) {
						var component = {};
						component.__data = {};
						if (await dtype.properties) {
							(await component.__data)[property] = await (await dtype.properties)[property];
						} else if (await dtype.items && await wobj.index) {
							(await component.__data)[await wobj.index] = dtype;
						} else {
							(await component.__data)[property] = await dtype.items;
						}
						var cp = await Lyte.validate(object, property, value, component);
						var errKey = await wobj.attr ? await wobj.attr : await wobj.key, _path = await (await wobj.path).split(".");
						var PathWay = await wobj.index == $Lt._gc.undefined && property ? await wobj.path + (await wobj.path != "" ? "." : "") + property : await wobj.index != $Lt._gc.undefined ? await wobj.path + (await wobj.path != "" ? "." : "") + await wobj.index : await wobj.path;
						if (cp && (typeof cp === "undefined" ? "undefined" : typeof cp) == "object" && await cp.code) {
							cp.value = value;
							cp.path = await wobj.path != "" ? await wobj.path : property;
							if (await wobj.isRec && fromStore && await wobj.key == $Lt._gc.undefined && await wobj.path != "") {
								errKey = await (await (await wobj.path).split("."))[0];
								await _path.shift();
								_path = await _path.length == 1 && await _path[0] == property ? [] : _path;
							}
							await wobj.Error && await (await wobj.Error)[errKey] ? await (await (await wobj.Error)[errKey]).code && await (await (await wobj.Error)[errKey]).nested ? await (await (await wobj.Error)[errKey]).nested : (await (await wobj.Error)[errKey]).nested = {} : (await wobj.Error)[errKey] = { nested: {} };
							(await (await wobj.Error)[errKey]).code = "ERR34";
							(await (await wobj.Error)[errKey]).message = await (await Lyte.errorCodes).ERR34;
							err = await (await (await wobj.Error)[errKey]).nested;
							await (await wobj._cmpErr)[errKey] ? true : (await wobj._cmpErr)[errKey] = {};
							(await (await wobj._cmpErr)[errKey]).code = "ERR34";
							(await (await wobj._cmpErr)[errKey]).message = await (await Lyte.errorCodes).ERR34;
							var cmpErrPath = await (await (await wobj._cmpErr)[errKey]).path ? await (await (await wobj._cmpErr)[errKey]).path : [];
							if (await wobj.path != "") {
								await $Lt._fE(_path, async function (k) {
									if (err && !await err[k]) {
										err = err[k] = {};
									} else {
										err = await err[k];
									}
								});
							}
							await wobj.index != $Lt._gc.undefined ? err[await wobj.index] = cp : err[property] = cp;
							if (!await cmpErrPath.includes(PathWay)) {
								await cmpErrPath.push(PathWay);
							}
							(await (await wobj._cmpErr)[errKey]).path = cmpErrPath;
						} else {
							if (await wobj.isRec && fromStore && await wobj.key == $Lt._gc.undefined) {
								errKey = await (await (await wobj.path).split("."))[0];
								await _path.shift();
								_path = await _path.length == 1 && await _path[0] == property ? [property] : _path;
							}
							err = await (await wobj.Error)[errKey] && await (await (await wobj.Error)[errKey]).nested ? await (await (await wobj.Error)[errKey]).nested : $Lt._gc.undefined;
							var cmpErr = await (await wobj._cmpErr)[errKey] || $Lt._gc.undefined;
							if (cmpErr && await cmpErr.path && await (await cmpErr.path).includes(PathWay)) {
								var ind = await (await cmpErr.path).indexOf(PathWay);
								await (await cmpErr.path).splice(ind, 1);
							}
							if (err) {
								var key = await wobj.index || property;
								var flag = true, p = await PathWay.split(".");
								await $Lt._fE(p, async function (r) {
									if (await err[r] && await (await err[r]).code) {
										delete err[r];
										if (err && await (await $Lt._gc.Object.keys(err)).length == 0) {
											flag = true;
										} else {
											flag = false;
										}
									} else {
										err = await err[r];
									}
								});
								if (flag == true && await (await wobj.Error)[errKey] && await (await wobj._cmpErr)[errKey]) {
									delete (await wobj.Error)[errKey];
									delete (await wobj._cmpErr)[errKey];
								}
							}
						}
						if (await check.value && await (await check.value).hasOwnProperty("code") && await cp.code || !await check.value) {
							check.value = cp;
						}
					}
				}
				await wobj.index && delete wobj.index;
			};
			Lyte.types = [
				"string",
				"object",
				"number",
				"boolean",
				"array"
			];
			Lyte.attr = async function (type, opts) {
				var obj = {};
				obj.type = type;
				if (opts == $Lt._gc.undefined) {
					opts = {};
				}
				if (await (await Lyte.types).indexOf(type) == -1 && !await (await Lyte.Transform).hasOwnProperty(type)) {
					throw await $Lt._cO($Lt._gc.Error, "Not a valid field type - " + type);
				}
				await $Lt._gc.Object.assign(obj, opts);
				return obj;
			};
			$Lt._gc.window.prop = await Lyte.attr;
			Lyte.defineRelation = async function (name, type, opts) {
				var relation = {
						type: "relation",
						relType: type,
						relatedTo: name
					};
				if (opts) {
					relation.opts = opts;
				}
				return relation;
			};
			Lyte.belongsTo = async function (name, opts) {
				return await this.defineRelation(name, "belongsTo", opts);
			};
			Lyte.hasMany = async function (name, opts) {
				return await this.defineRelation(name, "hasMany", opts);
			};
			Lyte.Transform = {};
			Lyte.customValidator = {};
			Lyte.registerDataType = async function (fieldTypeName, properties) {
				var exts = "extends";
				if (await (await this.Transform).hasOwnProperty(fieldTypeName)) {
					await Lyte.warn("Custom Field Type - " + fieldTypeName + " -  already exists.");
					return;
				}
				if (await properties[exts] == $Lt._gc.undefined || await (await Lyte.types).indexOf(await properties[exts]) == -1) {
					await Lyte.error("Not a valid field type - " + await properties[exts]);
					return;
				}
				(await this.Transform)[fieldTypeName] = properties;
			};
			Lyte.registerValidator = async function (customValidatorName, func) {
				if (await (await this.customValidator).hasOwnProperty(customValidatorName)) {
					await Lyte.warn("Custom Validator with name - " + customValidatorName + " - already exists");
					return;
				}
				(await this.customValidator)[customValidatorName] = func;
			};
			Lyte.patterns = {
				email: (/^([A-Za-z0-9._%\-'+/]+@[A-Za-z0-9.-]+\.[a-zA-Z]{2,22})$/),
				url: (/(^(ht|f)tp(s?):\/\/[0-9a-zA-Z][-.\w]*(:[0-9])*(\/?)([a-zA-Z0-9\-.?,:'/\\+=&amp;%$#_[\]@!()*;~]*)?$)/),
				ampm: (/^(AM|PM|am|pm)$/),
				hour: (/^(0?[0-9]|1[0-9]|2[0-4])$/),
				minute: (/^(0?[0-9]|[1-5][0-9]|60)$/),
				boolean: (/^(true|false|TRUE|FALSE)$/),
				alphaNumeric: (/([a-zA-Z0-9])+/),
				alphabetsOnly: (/([a-zA-Z])+/),
				numeric: (/([0-9])+/),
				phoneNo: (/^[0-9a-zA-Z+.()\-;\s]+$/)
			};
			Lyte.validate = async function (object, key, value, component, init) {
				var definition = await (await component.__data)[key];
				var isError = false;
				var type = definition ? await definition.type : $Lt._gc.undefined;
				var _def = definition;
				if (_def) {
					if (!(await _def.any && await $Lt._gc.Array.isArray(_def))) {
						_def = [_def];
					}
					var defLen = await _def.length, _ret = true;
					for (var i = 0; i < defLen; (i = i + 1) - 1) {
						var _d = await _def[i];
						for (var defKey in _d) {
							isError = await Lyte.checkProperty(defKey, value, key, await _d[defKey], _d, object, type, $Lt._gc.undefined, init);
							if (isError !== true) {
								if (_ret === true) {
									_ret = isError;
								}
							}
						}
					}
					if (_ret !== true) {
						return _ret;
					}
				}
				return false;
			};
			Lyte.registerPattern = async function (patternName, pattern) {
				(await this.patterns)[patternName] = pattern;
			};
			Lyte.errorCodes = {
				ERR01: "Primary key cannot be modified",
				ERR02: "Mandatory field cannot be empty",
				ERR03: "Type of value does not match the specified data type",
				ERR04: "Value is greater than the maximum value allowed",
				ERR05: "Value is less than the minimum value allowed",
				ERR06: "Length of string/array is greater than the maximum limit allowed",
				ERR07: "Length of string/array is less than the minimum limit allowed",
				ERR08: "String does not match the specified pattern",
				ERR09: "Values in array are not unique",
				ERR10: "Value is not equal to the specified constant",
				ERR11: "Model of related field is not defined",
				ERR12: "Model of backward relation is not defined",
				ERR13: "Record not found",
				ERR14: "Model does not match the related field model",
				ERR15: "Error in creating a record as a relation",
				ERR16: "Record with primary key already exists",
				ERR17: "Value cannot be changed because record has been deleted",
				ERR18: "Action not defined",
				ERR19: "Model not defined",
				ERR20: "Key not specified",
				ERR21: "'belongsTo' relationship expects a single object/id",
				ERR22: "Type not specified for polymorphic relation",
				ERR23: "Primary Key value not present",
				ERR24: "Error while relating record",
				ERR25: "Backward relation not present",
				ERR26: "Primary key value cannot be undefined or null",
				ERR27: "Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'",
				ERR28: "Unloaded record cannot be saved",
				ERR29: "Property not defined in the object",
				ERR30: "Error in variables declaration for Query",
				ERR31: "Query not registered for the Model",
				ERR32: "Property not defined in the object",
				ERR33: "Property's value is not an instanceof the mentioned class",
				ERR34: "Type definition for nested properties / items does not match with the value",
				ERR35: "A datatype mismatch has occurred for custom DataType '{0}'"
			};
			Lyte.registeredGlobalEvents = Lyte.__lyteRegisteredEvents = {};
			Lyte.__lyteRegisteredEventsGlobal = {};
			Lyte.triggerEvent = async function (obj) {
				var args;
				var actArgs;
				var eventObjectPath;
				if (typeof obj == "object" && await obj.global) {
					actArgs = await obj.args;
					args = await (await (await $Lt._gc.Array.prototype).slice).call(actArgs, 1);
					$Lt._gc.eventName = await actArgs[0];
					eventObjectPath = "__lyteRegisteredEventsGlobal";
				} else {
					args = await (await (await $Lt._gc.Array.prototype).slice).call(arguments, 1);
					$Lt._gc.eventName = await arguments[0];
					eventObjectPath = "__lyteRegisteredEvents";
				}
				var stopEvent = false;
				var s = await (await this[eventObjectPath])[$Lt._gc.eventName];
				if (!s) {
					s = (await this[eventObjectPath])[$Lt._gc.eventName] = { "listeners": [] };
				} else {
					for (var i = 0; i < await (await s.listeners).length; (i = i + 1) - 1) {
						var func = await (await s.listeners)[i];
						if (func) {
							var ret = await func.apply(this, args);
							if (ret === false) {
								stopEvent = true;
								break;
							}
						}
					}
				}
				var customEvent = await $Lt._cO($Lt._gc.CustomEvent, $Lt._gc.eventName, { "detail": args });
				if (!stopEvent) {
					await $Lt._gc.document.dispatchEvent(customEvent);
				}
			};
			Lyte.triggerGlobalEvent = async function () {
				return await Lyte.triggerEvent({
					"global": true,
					"args": await $Lt._gc.Array.from(arguments)
				});
			};
			Lyte.addEventListener = async function (eventName, func, options) {
				if (typeof func !== "function") {
					await Lyte.error("Second parameter to Lyte.Component.addGlobalEventListener() must be a function");
					return;
				}
				var eventObjectPath = options && await options.global ? "__lyteRegisteredEventsGlobal" : "__lyteRegisteredEvents";
				var s = await (await this[eventObjectPath])[eventName];
				if (!s) {
					s = (await this[eventObjectPath])[eventName] = { "listeners": [] };
				}
				var d = await (await s.listeners).push(func);
				return eventName + "-" + (d - 1);
			};
			Lyte.removeEventListener = async function (id, options) {
				let lastIndex;
				if (!id || (lastIndex = await id.lastIndexOf("-")) == -1) {
					await Lyte.error("listener unique id not specified / invalid");
					return;
				}
				var globalId = await id.split("-");
				if (options) {
					var globalId = await id.split("-");
					var eventObjectPath = options && await options.global ? "__lyteRegisteredEventsGlobal" : "__lyteRegisteredEvents";
					var s = await (await this[eventObjectPath])[await globalId[0]];
					if (!s || !await (await s.listeners)[await globalId[1]]) {
						await Lyte.error("No such listener registered");
						return;
					}
					(await s.listeners)[await globalId[1]] = null;
				} else {
					var eventName = await id.substring(0, lastIndex);
					var eventId = await id.substring(lastIndex + 1);
					var s = await (await this.__lyteRegisteredEvents)[eventName];
					if (!s || !await (await s.listeners)[eventId]) {
						await Lyte.error("No such listener registered");
						return;
					}
					(await s.listeners)[eventId] = null;
				}
			};
			Lyte.extendEventListeners = async function (scp) {
				if (scp && typeof scp == "object" && !await scp.hasOwnProperty("__lyteRegisteredEvents")) {
					await $Lt._gc.Object.defineProperties(scp, {
						__lyteRegisteredEvents: { value: {} },
						addEventListener: { value: await Lyte.addEventListener },
						removeEventListener: { value: await Lyte.removeEventListener },
						triggerEvent: { value: await Lyte.triggerEvent }
					});
				}
			};
			Lyte.deepCopyObject = async function (obj) {
				var targetVal = await $Lt._gc.Array.isArray(obj) ? [] : await $Lt._gc.Object.create(await $Lt._gc.Object.getPrototypeOf(obj));
				var current, copies = [{
							source: obj,
							target: targetVal
						}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];
				var cloneObject = await (await copies[0]).target, targetReferences = [cloneObject];
				while (current = await copies.shift()) {
					keys = await $Lt._gc.Object.keys(await current.source);
					for (propertyIndex = 0; propertyIndex < await keys.length; (propertyIndex = propertyIndex + 1) - 1) {
						descriptor = await $Lt._gc.Object.getOwnPropertyDescriptor(await current.source, await keys[propertyIndex]);
						if (!descriptor) {
							continue;
						}
						if (!await descriptor.value || typeof await descriptor.value != "object") {
							await $Lt._gc.Object.defineProperty(await current.target, await keys[propertyIndex], descriptor);
							continue;
						}
						nextSource = await descriptor.value;
						descriptor.value = await $Lt._gc.Array.isArray(nextSource) ? [] : await $Lt._iO(nextSource, $Lt._gc.Set) ? await $Lt._cO($Lt._gc.Set) : await $Lt._gc.Object.create(await $Lt._gc.Object.getPrototypeOf(nextSource));
						indexOf = await sourceReferences.indexOf(nextSource);
						if (indexOf != -1) {
							descriptor.value = await targetReferences[indexOf];
							await $Lt._gc.Object.defineProperty(await current.target, await keys[propertyIndex], descriptor);
							continue;
						}
						await sourceReferences.push(nextSource);
						await targetReferences.push(await descriptor.value);
						await $Lt._gc.Object.defineProperty(await current.target, await keys[propertyIndex], descriptor);
						await copies.push({
							source: nextSource,
							target: await descriptor.value
						});
					}
					if (await Lyte.isRecord(await current.source)) {
						await $Lt._gc.Object.defineProperty(await current.target, "$", { value: {} });
						(await (await current.target).$).isNew = await (await (await current.source).$).isNew;
						(await (await current.target).$).isModified = await (await (await current.source).$).isModified;
						(await (await current.target).$).isDeleted = await (await (await current.source).$).isDeleted;
						(await (await current.target).$).pK = await (await (await current.source).$).pK;
						(await (await current.target).$)._attributes = await (await (await current.source).$)._attributes;
						(await (await current.target).$).isCloned = true;
						(await (await current.target).$).model = { _name: await (await (await (await current.source).$).model)._name };
						if (await (await (await current.source).$).hasOwnProperty("deepNest")) {
							(await (await current.target).$).deepNest = await (await (await current.source).$).deepNest;
						}
						if (await (await (await current.source).$).hasOwnProperty("partialType")) {
							(await (await current.target).$).partialType = await (await (await current.source).$).partialType;
						}
					}
					if (await $Lt._gc.Array.isArray(await current.source)) {
						if (await (await current.source).partial) {
							await $Lt._gc.Object.defineProperty(await current.target, "partial", { value: await (await current.source).partial });
						}
					}
				}
				return cloneObject;
			};
			Lyte.nestScpId = 1;
			Lyte.nestScp = {};
			Lyte.__nestRef__ = {};
			Lyte.__nestScp__ = await $Lt._cO($Lt._gc.Map);
			Lyte.establishObjectBinding = async function (data, attr, fromStore, update, storeRecord, watch) {
				var model, fld, nestObj;
				var checkAttrs = await data.__component__ && await (await (await data.__component__).component).__data ? await (await (await (await data.__component__).component).__data)[attr] : $Lt._gc.undefined;
				if (fromStore) {
					if (data && !await data.$ && await data._scp) {
						var keys = await $Lt._gc.Array.from(await (await data._scp).keys());
						await $Lt._fE(keys, async function (id) {
							var recObj = await (await Lyte.nestScp)[id];
							model = await $Lt._gc.store.modelFor(await recObj.model);
						});
					} else {
						model = await (await data.$).model;
					}
					fld = model && await model.fieldList && await (await model.fieldList).hasOwnProperty(attr) ? await (await model.fieldList)[attr] : {};
					var _checkDtype = false;
					if (fld) {
						var _dtype = await (await Lyte.Transform)[await fld.type];
						if (_dtype && (await _dtype.hasOwnProperty("properties") || await _dtype.hasOwnProperty("items"))) {
							_checkDtype = true;
						}
					}
					if (fld && (await fld.type !== "relation" && await fld.watch) || _checkDtype) {
						checkAttrs = fld;
					} else {
						if (await data._scp) {
							var keys = await $Lt._gc.Array.from(await (await data._scp).keys());
							await $Lt._fE(keys, async function (id) {
								var _mpObj = await (await data._scp).get(id), mpObj = await _mpObj.paths;
								var _dtype = await (await Lyte.nestScp)[id] || $Lt._gc.undefined;
								watch = _dtype && await _dtype["watch"] ? await _dtype["watch"] : watch;
								for (var key in mpObj) {
									var path = key ? await key.split(".") : [];
									await path.push(attr);
									await Lyte.bindObj(data, attr, id, path, await $Lt._cO($Lt._gc.Map), $Lt._gc.undefined, checkAttrs, watch, true);
								}
							});
						}
						return;
					}
				}
				if (update && await data._scp && await (await data._scp).size) {
					var keys = await $Lt._gc.Array.from(await (await data._scp).keys());
					await $Lt._fE(keys, async function (id) {
						var _mpObj = await (await data._scp).get(id), mpObj = await _mpObj.paths;
						var _dtype = await (await Lyte.nestScp)[id] || $Lt._gc.undefined;
						watch = _dtype && await _dtype["watch"] ? await _dtype["watch"] : watch;
						for (var key in mpObj) {
							var path = key ? await key.split(".") : [];
							await path.push(attr);
							await Lyte.bindObj(data, attr, id, path, await $Lt._cO($Lt._gc.Map), $Lt._gc.undefined, checkAttrs, watch, true);
						}
					});
				}
				var customDtype = false;
				if (checkAttrs && await (await Lyte.Transform)[await checkAttrs.type]) {
					var dtype = await (await Lyte.Transform)[await checkAttrs.type];
					if (await dtype.hasOwnProperty("properties") || await dtype.hasOwnProperty("items")) {
						checkAttrs = await (await Lyte.Transform)[await checkAttrs.type];
						customDtype = true;
					}
				}
				if ((!fromStore || await fld.watch || await fld.properties || await fld.items || watch || customDtype) && await data[attr]) {
					var _scpObj, kmpKey;
					if (data && await data.__component__) {
						await (await data.__component__).__scpObj || await $Lt._gc.Object.defineProperty(await data.__component__, "__scpObj", { value: {} });
						kmpKey = await data.__component__;
						_scpObj = await (await data.__component__).__scpObj;
					} else if (await Lyte.isRecord(data)) {
						await (await data.$).__scpObj || await $Lt._gc.Object.defineProperty(await data.$, "__scpObj", { value: {} });
						kmpKey = data;
						_scpObj = await (await data.$).__scpObj;
					}
					var obj = _scpObj, id;
					if (_scpObj) {
						var __nestScp1Set__ = false, __nestScp2Set__ = false;
						if (fromStore) {
							if (await data[attr] && !await (await Lyte.__nestScp__).has(await data[attr])) {
								nestObj = {
									model: await model._name,
									attr: attr,
									pK: await (await data.$).pK,
									Error: {}
								};
								__nestScp1Set__ = true;
							} else {
								var __nId = await (await Lyte.__nestScp__).get(await data[attr]);
								var refMp = (await Lyte.__nestRef__)[__nId] = await (await Lyte.__nestRef__)[__nId] || await $Lt._cO($Lt._gc.Map);
								var refMpId = await (await Lyte.$).genMapId(refMp);
								await refMp.set(refMpId, true);
								await Lyte.setRecBindMap(await (await Lyte.nestScp)[__nId], {
									model: await model._name,
									attr: attr,
									pK: await (await data.$).pK,
									Error: {}
								});
								obj[attr] = __nId + "_" + refMpId;
							}
						} else {
							if (await data[attr] && !await (await Lyte.__nestScp__).has(await data[attr])) {
								var ErrMap = [], cmpDataKeys = {};
								cmpDataKeys.key = attr;
								cmpDataKeys.dtype = await (await (await (await data.__component__).component).__data)[attr];
								cmpDataKeys._cmpErr = await data.errors;
								cmpDataKeys.Error = {};
								await ErrMap.push(cmpDataKeys);
								nestObj = {
									data: await data[attr],
									PropsInfo: ErrMap
								};
								if (await (await cmpDataKeys.dtype).watch) {
									nestObj.watch = true;
								}
								__nestScp2Set__ = true;
							} else {
								var __nId = await (await Lyte.__nestScp__).get(await data[attr]);
								var scope = await (await Lyte.nestScp)[__nId];
								if (scope) {
									if (!await scope.PropsInfo) {
										scope.PropsInfo = [];
									}
									var errMp = await scope.PropsInfo;
									var cmpDataKeys = {};
									cmpDataKeys.key = attr;
									cmpDataKeys.Error = {};
									cmpDataKeys._cmpErr = await data.errors;
									cmpDataKeys.dtype = await (await (await (await data.__component__).component).__data)[attr];
									if (await (await cmpDataKeys.dtype).watch) {
										scope.watch = true;
									}
									await errMp.push(cmpDataKeys);
								}
								var refMp = (await Lyte.__nestRef__)[__nId] = await (await Lyte.__nestRef__)[__nId] || await $Lt._cO($Lt._gc.Map);
								var refMpId = await (await Lyte.$).genMapId(refMp);
								await refMp.set(refMpId, true);
								obj[attr] = __nId + "_" + refMpId;
							}
						}
						if (nestObj) {
							var nestScpId = (Lyte.nestScpId = await Lyte.nestScpId + 1) - 1;
							var refMp = (await Lyte.__nestRef__)[nestScpId] = await (await Lyte.__nestRef__)[nestScpId] || await $Lt._cO($Lt._gc.Map);
							var refMpId = await (await Lyte.$).genMapId(refMp);
							await refMp.set(refMpId, true);
							await (await Lyte.__nestScp__).set(await data[attr], nestScpId);
							if (__nestScp1Set__) {
								(await Lyte.nestScp)[nestScpId] = {};
								await Lyte.setRecBindMap(await (await Lyte.nestScp)[nestScpId], nestObj);
								(await (await Lyte.nestScp)[nestScpId]).Error = await nestObj.Error;
							}
							if (__nestScp2Set__) {
								(await Lyte.nestScp)[nestScpId] = nestObj;
							}
							(await (await Lyte.nestScp)[nestScpId])._data = await data[attr];
							obj[attr] = await obj[attr] || nestScpId + "_" + refMpId;
							var path = [];
							await Lyte.bindObj(data, attr, nestScpId, path, await $Lt._cO($Lt._gc.Map), $Lt._gc.undefined, checkAttrs, watch);
						}
					}
				}
			};
			Lyte.removeNestScp2Bind = async function (mp, mdlObj) {
				var mp = await mp.model;
				if (await mp.has(await mdlObj.model)) {
					var mp1 = await mp.get(await mdlObj.model);
					if (await mp1.has(await mdlObj.pK)) {
						var mp2 = await mp1.get(await mdlObj.pK);
						if (await mp2.has(await mdlObj.attr)) {
							await mp2.delete(await mdlObj.attr);
						}
						!await mp2.size ? await mp1.delete(await mdlObj.pK) : $Lt._gc.undefined;
					}
					!await mp1.size ? await mp.delete(await mdlObj.model) : $Lt._gc.undefined;
				}
			};
			Lyte.setRecBindMap = async function (obj, nestObj) {
				var mp = obj.model = await obj.model || await $Lt._cO($Lt._gc.Map), modelName = await nestObj.model, pK = await nestObj.pK, attr = await nestObj.attr;
				if (modelName && !await mp.has(modelName)) {
					await mp.set(modelName, await $Lt._cO($Lt._gc.Map));
				}
				mp = await mp.get(modelName);
				if (pK && !await mp.has(pK)) {
					await mp.set(pK, await $Lt._cO($Lt._gc.Map));
				}
				mp = await mp.get(pK);
				if (attr && !await mp.has(attr)) {
					await mp.set(attr, true);
				}
			};
			Lyte.bindObj = async function (data, key, id, path, mp, check, checkAttrs, watch, ignoreCyclicDelete) {
				mp = mp || await $Lt._cO($Lt._gc.Map);
				var value = key != $Lt._gc.undefined ? await data[key] : data;
				var cyclic = false;
				if (!ignoreCyclicDelete && !await path.length && await (await Lyte.__nestScp__).get(data) === id) {
					delete (await (await Lyte.nestScp)[id]).cyclic;
				}
				if (await path.length > 1 && value && await (await Lyte.nestScp)[id] && await (await (await Lyte.nestScp)[id]).hasOwnProperty("data") && await (await (await Lyte.nestScp)[id]).data === value) {
					if (await mp.get(value)) {
						cyclic = true;
					} else {
						try {
							await $Lt._gc.JSON.stringify(value);
						} catch (exp) {
							cyclic = true;
						}
					}
					if (await Lyte.checkAndAddBind(value, id, path, cyclic)) {
						await Lyte.estObjScp(value, id, path, cyclic);
					}
					return;
				}
				var attrs, nestedSCP;
				if (checkAttrs) {
					if (await checkAttrs.hasOwnProperty("items") || await checkAttrs.hasOwnProperty("properties")) {
						attrs = await checkAttrs.items || await checkAttrs.properties;
						nestedSCP = true;
					} else if (watch == $Lt._gc.undefined && await checkAttrs.watch == true) {
						watch = await checkAttrs.watch;
					}
				}
				attrs = watch ? $Lt._gc.undefined : attrs;
				if (await $Lt._gc.Array.isArray(value)) {
					if (!await mp.get(value)) {
						await mp.set(value, true);
						await $Lt._fE(value, async function (val, idx) {
							await path.push(idx);
							if (watch || checkAttrs && await checkAttrs.hasOwnProperty("items") && typeof await checkAttrs.items == "object") {
								await Lyte.bindObj(value, idx, id, path, mp, $Lt._gc.undefined, attrs, watch);
							}
							await path.pop();
						});
					} else {
						cyclic = true;
					}
					if (await Lyte.checkAndAddBind(value, id, path, cyclic)) {
						var _establish;
						if (await $Lt._gc.Array.isArray(watch)) {
							_establish = await Lyte.checkEstablishingSCP(value, path, watch);
						}
						if (_establish || typeof watch == "boolean" && watch || nestedSCP) {
							await Lyte.estObjScp(value, id, path, cyclic);
						}
					}
				} else if (value && typeof value == "object") {
					var cyclic = false;
					if (!await mp.get(value)) {
						await mp.set(value, true);
						for (var str in value) {
							await path.push(str);
							if (watch || attrs && await attrs.hasOwnProperty(str)) {
								await Lyte.bindObj(value, str, id, path, mp, $Lt._gc.undefined, attrs ? await attrs[str] : $Lt._gc.undefined, watch);
							}
							await path.pop();
						}
					} else {
						cyclic = true;
					}
					if (await Lyte.checkAndAddBind(value, id, path, cyclic)) {
						var _establish;
						if (await $Lt._gc.Array.isArray(watch)) {
							_establish = await Lyte.checkEstablishingSCP(value, path, watch);
						}
						if (_establish || typeof watch == "boolean" && watch || nestedSCP) {
							await Lyte.estObjScp(value, id, path, cyclic);
						}
					}
				}
			};
			Lyte.checkAndAddBind = async function (value, id, path, cyclic) {
				if (!await value._scp || !await (await value._scp).size) {
					return true;
				}
				if (await (await value._scp).size) {
					if (await (await value._scp).has(id)) {
						var _obj = await (await value._scp).get(id);
						var obj = await _obj.paths;
						if (await obj.hasOwnProperty(await path.join("."))) {
							if (cyclic) {
								(await (await Lyte.nestScp)[id]).cyclic = true;
							}
							return false;
						}
					}
				}
				return true;
			};
			Lyte.estObjScp = async function (value, id, path, cyclic) {
				if (!await value._scp) {
					await $Lt._gc.Object.defineProperty(value, "_scp", {
						value: await $Lt._cO($Lt._gc.Map),
						enumerable: false,
						configurable: true
					});
				}
				var mp = await value._scp;
				if (!await mp.has(id)) {
					await mp.set(id, {});
				}
				var obj = await mp.get(id), path = path ? await path.join(".") : path;
				var pathObj = obj.paths = await obj.paths || {};
				pathObj[path] = true;
				var nestObj = await (await Lyte.nestScp)[id];
				if (!await nestObj.cyclic && cyclic == true) {
					nestObj.cyclic = true;
				}
			};
			Lyte.cmpObjs = async function (obj1, obj2) {
				if (await (await $Lt._gc.Object.keys(obj1)).length !== await (await $Lt._gc.Object.keys(obj2)).length) {
					return false;
				}
				for (var key in obj1) {
					if (!await obj2.hasOwnProperty(key)) {
						return false;
					}
					var ret = await Lyte.cmpData(await obj1[key], await obj2[key]);
					if (ret == false) {
						return false;
					}
				}
				return true;
			};
			Lyte.cmpData = async function (data1, data2) {
				if (await $Lt._gc.Array.isArray(data1)) {
					if (!await $Lt._gc.Array.isArray(data2) || await data1.length !== await data2.length) {
						return false;
					}
					if (data1 === data2) {
						return true;
					}
					var len = await data1.length, ret;
					for (var i = 0; i < len; (i = i + 1) - 1) {
						ret = await Lyte.cmpData(await data1[i], await data2[i]);
						if (ret == false) {
							return false;
						}
					}
				} else if (data1 && data2 && typeof data1 == "object" && typeof data2 == "object") {
					if (data1 === data2) {
						return true;
					}
					return await Lyte.cmpObjs(data1, data2);
				} else if (data1 !== data2) {
					return false;
				}
				return true;
			};
			Lyte.nestScpRmPath = async function (obj, path) {
				if (obj && await obj.paths) {
					obj = await obj.paths;
					for (var key in obj) {
						if (await key.startsWith(path + ".")) {
							delete obj[key];
						}
					}
				}
			};
			Lyte.nestScpRemove = async function (data, id, path) {
				var mp = await data._scp;
				if (mp && await mp.size) {
					if (path) {
						await Lyte.nestScpRmPath(await mp.get(id), path);
						var _obj = await mp.get(id);
						var obj = _obj ? await _obj.paths : $Lt._gc.undefined;
						if (obj && !await (await $Lt._gc.Object.keys(obj)).length) {
							await mp.delete(id);
						}
					} else {
						await mp.delete(id);
					}
					if (!await mp.size) {
						delete data._scp;
					}
				}
			};
			Lyte.rmNestScp = async function (value, id, mp, data, path) {
				if (await $Lt._gc.Array.isArray(value)) {
					if (!await mp.get(value)) {
						await mp.set(value, true);
						await $Lt._fE(value, async function (val, idx) {
							await Lyte.rmNestScp(val, id, mp, $Lt._gc.undefined, path);
						});
					}
					await Lyte.nestScpRemove(value, id, path);
				} else if (value && typeof value == "object") {
					if (!await mp.get(value)) {
						await mp.set(value, true);
						for (var str in value) {
							await Lyte.rmNestScp(await value[str], id, mp, $Lt._gc.undefined, path);
						}
					}
					await Lyte.nestScpRemove(value, id, path);
				}
			};
			Lyte.removeNestScp = async function (value, id, mpId, path, context, mp, data, recObj) {
				mp = mp || await $Lt._cO($Lt._gc.Map);
				id = await $Lt._gc.Number.parseInt(id);
				var obj = await (await Lyte.nestScp)[id], kmp = await (await Lyte.__nestRef__)[id];
				if (recObj && await obj.model) {
					await Lyte.removeNestScp2Bind(obj, recObj);
				}
				if (context) {
					if (kmp && await kmp.has(mpId)) {
						await kmp.delete(mpId);
					}
					if (!kmp || kmp && !await kmp.size) {
						delete (await Lyte.__nestRef__)[id];
						if (await (await Lyte.__nestScp__).has(value)) {
							await (await Lyte.__nestScp__).delete(value);
						}
						await Lyte.rmNestScp(value, id, mp, true, path);
						if (!data) {
							delete (await Lyte.nestScp)[id];
						}
					}
				} else {
					await Lyte.rmNestScp(value, id, mp, true, path);
				}
			};
			Lyte.resolvePromises = async function (promises) {
				async function promiseHash(promiseObj) {
					var actPromKeys = [], promises = [], promiseKeys = await $Lt._gc.Object.keys(promiseObj);
					await $Lt._fE(promiseKeys, async function (key) {
						var value = await promiseObj[key];
						if (await $Lt._iO(value, $Lt._gc.Promise) || value && !await $Lt._gc.Array.isArray(value) && typeof value == "object" && typeof await value.then == "function") {
							await actPromKeys.push(key);
							await promises.push(value);
						}
					});
					if (!await promises.length) {
						return await $Lt._gc.Promise.resolve(promiseObj);
					} else {
						var obj = {}, promise = await $Lt._cO($Lt._gc.Promise, async function (resolve, reject) {
								await (await $Lt._gc.Promise.all(promises)).then(async function (data) {
									await $Lt._fE(promiseKeys, async function (promiseKey) {
										if (await actPromKeys.indexOf(promiseKey) != -1) {
											obj[promiseKey] = await data[await actPromKeys.indexOf(promiseKey)];
										} else {
											obj[promiseKey] = await promiseObj[promiseKey];
										}
									});
									await resolve(obj);
								}, async function (err) {
									await reject(err);
									await Lyte.error("Error on resolve promises", err);
								});
							});
						return promise;
					}
				}
				async function promiseArray(promiseArray) {
					var array = [], hasPromise = false;
					await promiseArray.every(async function (item, i) {
						if (await $Lt._iO(item, $Lt._gc.Promise) || item && !await $Lt._gc.Array.isArray(item) && typeof item == "object" && typeof await item.then == "function") {
							hasPromise = true;
							return false;
						}
						return true;
					});
					if (!hasPromise) {
						return await $Lt._gc.Promise.resolve(promiseArray);
					}
					var promise = await $Lt._cO($Lt._gc.Promise, async function (resolve, reject) {
							await (await $Lt._gc.Promise.all(promiseArray)).then(async function (data) {
								await $Lt._fE(promiseArray, async function (key, index) {
									array[index] = await data[index];
								});
								await resolve(array);
							}, async function (err) {
								await reject(err);
								await Lyte.error("Error on resolve promises", err);
							});
						});
					return promise;
				}
				if (typeof promises == "string" || await $Lt._iO(promises, $Lt._gc.Promise)) {
					return promises;
				} else {
					if (await $Lt._gc.Array.isArray(promises)) {
						return await promiseArray(promises);
					} else if (typeof promises == "object") {
						return await promiseHash(promises);
					}
				}
			};
			if (await $Lt._gc.document.readyState === "complete" || await $Lt._gc.document.readyState === "interactive") {
				await domContentLoaded1();
			} else {
				await $Lt._gc.document.addEventListener("DOMContentLoaded", async function (e) {
					await domContentLoaded1();
				}, true);
			}
			;
			var XHRSend = await (await $Lt._gc.XMLHttpRequest.prototype).send;
			(await $Lt._gc.XMLHttpRequest.prototype).send = async function () {
				var event = await $Lt._gc.window.event;
				var type, target = event ? await event.target : $Lt._gc.undefined;
				if (await Lyte.getConfig("stateHandling")) {
					if (event) {
						type = await event.type;
						await (/^(click|dblclick)$/).test(type) && target && await target.getAttribute && await target.getAttribute("lyte-state-handling") != "false" ? await addStateToMap(type, target, this) : $Lt._gc.undefined;
					} else {
						var router = Lyte && await Lyte.Router ? await (await Lyte.Router).getRouteInstance() : $Lt._gc.undefined;
						if (router) {
							var currentAction = await router.transition ? await (await router.transition).ev : $Lt._gc.undefined;
							if (currentAction && await currentAction.target && await (await currentAction.target).getAttribute && await (await currentAction.target).getAttribute("lyte-state-handling") != "false") {
								var mp = Lyte.__transXHRMap = await Lyte.__transXHRMap || await $Lt._cO($Lt._gc.Map);
								await mp.set(await router.transition, {
									currentAction: currentAction,
									XHR: this
								});
								await addStateToMap(await currentAction.type, await currentAction.target, this);
							}
						}
					}
				}
				await XHRSend.apply(this, arguments);
			};
			await Lyte.addEventListener("transitionStart", async function (obj) {
				var trans = await obj.nextTrans;
				if (trans && await obj.prevTrans) {
					if (await $Lt._gc.window.event && await (/^(click|dblclick)$/).test(await (await $Lt._gc.window.event).type)) {
						trans.ev = await $Lt._gc.window.event;
						if (await (await obj.prevTrans).ev) {
							delete (await obj.prevTrans).ev;
						}
					} else if ((await (await obj.prevTrans).state == 409 || await (await obj.prevTrans).state == 308) && await (await obj.prevTrans).ev) {
						trans.ev = await (await obj.prevTrans).ev;
						delete (await obj.prevTrans).ev;
					}
				}
			});
			await Lyte.addEventListener("afterRouteTransition", async function (obj) {
				if (obj && await obj.trans) {
					var mp = await Lyte.__transXHRMap, removeEv = false;
					if (await (await obj.trans).state == 409 || await (await obj.trans).state == 308) {
						var ev1 = await $Lt._gc.window.event, ev2 = await (await obj.trans).ev;
						if (!ev1 || ev1 && ev2 && ev1 != ev2 && await ev1.target == await ev2.target && await ev1.type == await ev2.type) {
							(await obj.trans).nested = true;
						} else {
							removeEv = true;
						}
						if (mp) {
							var mpObj = await mp.get(await obj.trans);
							if (mpObj) {
								await removeStateFromMap(await mpObj.XHR, await (await mpObj.currentAction).type, await (await mpObj.currentAction).target);
								await mp.delete(await obj.trans);
							}
						}
					} else if (await (await obj.trans).state == 200) {
						mp ? await mp.delete(await obj.trans) : $Lt._gc.undefined;
						removeEv = true;
					}
					if (removeEv) {
						await (await obj.trans).ev ? delete (await obj.trans).ev : $Lt._gc.undefined;
					}
				}
			});
			await Lyte.addEventListener("beforeRouteTransition", async function (obj) {
				if (obj && await obj.prevTrans && await (await obj.prevTrans).nested) {
					(await obj.trans).ev = await (await obj.prevTrans).ev;
					delete (await obj.prevTrans).ev;
					(await obj.trans).fromPrevTrans = true;
				}
			});
			Lyte.setState = async function (str) {
				if (!str) {
					await $Lt._gc.console.error("Please provide a state name");
				}
				var evnt = await $Lt._gc.window.event;
				if (await (/^(click|dblclick)$/).test(await evnt.type)) {
					var target = await evnt.target;
					if (await Lyte.getConfig("stateHandling") == true && target && await target.getAttribute && await target.getAttribute("lyte-state-handling") != "false") {
						var state = await target.getAttribute("lyte-state");
						if (!state) {
							var mp = Lyte.__stateMap = await Lyte.__stateMap || await $Lt._cO($Lt._gc.Map);
							var mpobj = await mp.get(str);
							if (!mpobj) {
								var obj = await addStateToMap(await evnt.type, target, $Lt._gc.undefined, str);
								await mp.set(str, obj);
							} else {
								await $Lt._gc.console.error("There is already a open state by the name", str);
							}
						}
					}
				}
			};
			Lyte.removeState = async function (str) {
				if (!str) {
					await $Lt._gc.console.error("Please provide a state name");
				}
				var mp = await Lyte.__stateMap;
				if (mp) {
					var obj = await mp.get(str);
					if (obj) {
						await mp.delete(str);
						await removeStateFromMap(str, await obj.event, await obj.target);
					}
				}
			};
			Lyte.setConfig = async function (key, value, cons) {
				if (key == "mutable") {
					if (value == true) {
						Lyte.__gl = await Lyte.mut(await Lyte.__gl__);
					} else if (value == false) {
						Lyte.__gl = await Lyte.__gl__;
					}
				}
				var configObj = Lyte.__config = await Lyte.__config || {};
				if (cons) {
					await $Lt._gc.Object.defineProperty(configObj, key, { value: value });
				} else {
					configObj[key] = value;
				}
			};
			Lyte.getConfig = function (key) {
				var configObj = Lyte.__config;
				if (configObj) {
					return configObj[key];
				}
			};
			Lyte.establishWatchScope = async function (watchProps, model) {
				var scope = this, object;
				for (var v in watchProps) {
					var property = v;
					var watch = await watchProps[v];
					if (await scope.component && await (await scope.component).__data && await (await (await scope.component).__data)[property]) {
						object = await scope.getData(property);
						watch = await (await (await (await scope.component).__data)[property]).watch ? true : watch;
						if (typeof object == "object") {
							await Lyte.establishObjectBinding(await (await scope.component).data, v, false, $Lt._gc.undefined, $Lt._gc.undefined, watch);
						}
						var dataDef = await (await scope.component).__data;
						if (await (await Lyte.nestScp)[await (await Lyte.__nestScp__).get(object)]) {
							(await dataDef[v]).watch = watch;
						}
					} else {
						if (model) {
							var fieldList = await model.fieldList;
							if (await fieldList[v] && await (await fieldList[v]).watch == $Lt._gc.undefined) {
								(await fieldList[v]).watch = watch;
								(await (await model._fldGrps).watch)[v] = await fieldList[v];
							}
						}
					}
				}
			};
			Lyte.checkEstablishingSCP = async function (value, path, watch) {
				if (await $Lt._gc.Array.isArray(watch)) {
					var _path = "";
					_path = await path.join(".");
					if (await Lyte.checkWatchPath(_path, watch, true) && typeof value != "object") {
						return true;
					}
					var _key = await $Lt._gc.Object.keys(value);
					for (var i_scp = 0; i_scp < await _key.length; (i_scp = i_scp + 1) - 1) {
						var spiePath = await _key[i_scp];
						var finalaUth = _path == "" ? spiePath : _path + "." + spiePath;
						if (await Lyte.checkWatchPath(finalaUth, watch, true)) {
							return true;
						}
					}
				}
			};
			Lyte.checkWatchPath = async function (actualPath, watchArr, establishBind) {
				if (typeof watchArr == "boolean" && watchArr === true) {
					return true;
				} else if (await $Lt._gc.Array.isArray(watchArr)) {
					for (var i_watch = 0; i_watch < await watchArr.length; (i_watch = i_watch + 1) - 1) {
						var path = await watchArr[i_watch];
						path = await path.replace((/ /g), "");
						path = await path.replace((/\$\.\./g), "..");
						path = await path.replace((/\$\./g), "");
						var weirdPath = await path.search((/\.\./g)) != -1 || await path.search((/\[|\\]|\{|\}/g)) != -1 ? true : false || await path.includes("*");
						if (actualPath == path) {
							return true;
						} else if (weirdPath) {
							if (establishBind) {
								if (await path.search((/\.\./)) != -1) {
									path = await path.replace((/\.\.\S+/g), "..*");
									if (path == "..*") {
										return true;
									}
								}
							}
							path = await path.search((/\[/)) == 0 ? await path.replace("[", "") : path;
							path = await path.search((/\.\.\[/)) == 0 ? await path.replace("..[", "..") : path;
							path = await path.replace((/\.*\[/g), ".");
							path = await path.replace((/\]/g), "");
							var _watchPath = await Lyte.checkWeirdPath(path, actualPath);
							if (_watchPath) {
								return true;
							}
						}
					}
				}
			};
			Lyte.checkWeirdPath = async function (watchPath, actualPath) {
				if (actualPath == watchPath) {
					return true;
				} else if (await watchPath.includes("..") || await watchPath.includes("*")) {
					var cmpPath = watchPath;
					cmpPath = await cmpPath.replace((/\*/g), "$$");
					cmpPath = await cmpPath.replace((/\.\./g), "::");
					cmpPath = await cmpPath.replace((/\./g), "\\.");
					cmpPath = await cmpPath.replace((/\:\:/g), "\\.?.*\\.?");
					cmpPath = await cmpPath.replace((/\$/g), ".*");
					var _wildCard = await watchPath.split(".");
					var _wClenght = await _wildCard.length;
					if (await _wildCard[_wClenght - 2] == "" && await _wildCard[_wClenght - 1] != "*") {
						cmpPath = cmpPath + "$";
					}
					var regularExp = await $Lt._cO($Lt._gc.RegExp, cmpPath);
					if (await regularExp.test(actualPath)) {
						return true;
					}
					return false;
				}
			};
			var ignoreMut = false;
			Lyte.ignoreMut = async function (method) {
				ignoreMut = true;
				await method();
				ignoreMut = false;
			};
			var wkMap = new WeakMap();
			Lyte.mut = function mut(data) {
				if (data && data.__ltPrx__) {
					return data;
				}
				if (data && wkMap.has(data)) {
					return wkMap.get(data);
				}
				if (!data || data && (data.constructor.name !== "Object" && data.constructor.name !== "Record") && !Array.isArray(data) && !data.__ltPrx__) {
					return data;
				}
				let prxVal = new Proxy(data, {
						set: function (target, prop, value) {
								if (!Array.isArray(target)) {
									Lyte.Component.set(target, prop, value);
								} else {
									target[prop] = value;
								}
								return true;
							},
						get: function (target, prop) {
							if (prop === "__ltPrx__") {
								return true;
							}
							if (prop === "__target__") {
								return target;
							}
							var value = target[prop];
							if (value && value.__ltPrx__) {
								return value;
							}
							if (value && wkMap.has(value)) {
								return wkMap.get(value);
							}
							var descriptor = Object.getOwnPropertyDescriptor(target, prop);
							if (value && (value.constructor.name === "Object" || Array.isArray(value) || value && value.$ && value.$.hasOwnProperty("isModified")) && !value.__ltPrx__ && descriptor && descriptor.configurable) {
								let prxVal = Lyte.mut(value);
								wkMap.set(value, prxVal);
								return prxVal;
							}
							return value;
						}
					});
				wkMap.set(data, prxVal);
				return prxVal;
			};
			Lyte.immut = function immut(data, mp) {
				var mp = mp || new WeakMap(), nData;
				if (data && Array.isArray(data)) {
					nData = Array.from(data);
				} else if (data && typeof data == "object") {
					nData = Object.assign({}, data);
				}
				mp.get(data, nData);
				return new Proxy(data, {
					get: function (data, prop) {
							var _obj = mp.get(data), val;
							val = _obj[prop];
							if (val && typeof val == "object" && !mp.has(val)) {
								return Lyte.immut(val, mp);
							}
							return val;
						},
					set: function (data, prop, value) {
						var _obj = mp.get(obj);
						Lyte.Component.set(_obj, prop, value);
						return true;
					}
				});
			};
			await $Lt._gc.Object.defineProperty(Lyte, "__gl__", { value: {} });
			Lyte.__gl = await Lyte.__gl__;
		}($Lt._gc._Lyte);
		await async function (window) {
			function makeSet(obj, key) {
				if (!obj[key]) {
					defProp(obj, key, {
						value: new Set(),
						enumerable: false,
						writable: true,
						configurable: true
					});
				}
			}
			async function makeVal(obj, key, val) {
				if (!await obj[key]) {
					await $Lt._gcFn.defProp(obj, key, {
						value: val,
						enumerable: false,
						writable: true,
						configurable: true
					});
				}
			}
			async function addBindings(obj, property) {
				if (property) {
					let bindings = await obj._bindings;
					if (!bindings) {
						await makeSet(obj, "_bindings");
						bindings = await obj._bindings;
					}
					await bindings.add(property);
				}
			}
			function makeArray(obj, key) {
				if (!obj[key]) {
					defProp(obj, key, {
						value: [],
						enumerable: false,
						writable: true,
						configurable: true
					});
				}
			}
			async function createDocFragment() {
				return await $Lt._gc.document.createDocumentFragment();
			}
			async function createElement(elm) {
				return await $Lt._gc.document.createElement(elm);
			}
			async function insertBefore(parent, newNode, refNode) {
				await parent.insertBefore(newNode, refNode);
			}
			async function deleteBindingCheckSize(obj, key, valToDelete) {
				await (await obj[key])[delStr](valToDelete);
				if (!await (await obj[key]).size) {
					delete obj[key];
				}
			}
			async function noop() {
			}
			async function onDomContentForLyte() {
				if (await (await Lyte.$).assetsDiv) {
					await (await (await Lyte.$).assetsDiv).addEventListener("click", async function () {
						if (!await window.event) {
							_LC._windowEvNeeded = true;
						}
					});
					await (await (await Lyte.$).assetsDiv).dispatchEvent(await $Lt._cO($Lt._gc.Event, "click"));
				}
				if (!await _Lyte._ie) {
					await (await $Lt._gc.document.body).appendChild(await _LC.lyteComponentsDiv);
				}
				await (await $Lt._gc.document.body).appendChild(await _LC.hDiv);
				let bodyEvents = globalDOMEvents;
				for (let i = 0; i < await bodyEvents.length; (i = i + 1) - 1) {
					var evnt = await bodyEvents[i];
					await (await $Lt._gc.document.body).addEventListener(evnt, globalEventHandler, true);
				}
				let comp = await _LC.toBeRegistered;
				if (await comp.length) {
					for (let j = 0; j < await comp.length; (j = j + 1) - 1) {
						await $Lt._gc.customElements.define(await (await comp[j]).name, await (await comp[j]).def, $Lt._gc.undefined, await (await comp[j])._lyteOptions);
					}
					_LC.toBeRegistered = [];
				}
				if (await (/iPad|iPhone|iPod/).test(userAgent) && !await window.MSStream) {
					var style = await createElement("style");
					style.innerHTML = "* { cursor : pointer}";
					await (await $Lt._gc.document.head).appendChild(style);
				}
				if (await Lyte.isWidgetBuild) {
					let wrapper = await (await Lyte.$).widgetWrapper;
					await (await $Lt._gc.document.body).appendChild(wrapper);
					if (await window.docEventListenerHandler) {
						await (await window.docEventListenerHandler).attachShadow(await wrapper.shadowRoot);
					}
					await (await (await LyteComponent.shadow).shadowList).push(await wrapper.shadowRoot);
					(await wrapper.shadowRoot)._shadowChild = [];
					(await wrapper.shadowRoot)._lyteShadow = true;
					(await wrapper.shadowRoot)._compList = [];
					(await wrapper.shadowRoot)._duplicateStyle = [];
					(await wrapper.shadowRoot)._linkRef = [];
					wrapper.instantiated = true;
					await (await LyteComponent.shadow).attachEvents(await wrapper.shadowRoot);
				}
			}
			async function createSvgDepth(actualTemplate, type) {
				var svg = await $Lt._gc.document.createElementNS("http://www.w3.org/2000/svg", "svg");
				for (var s = 0; s < await (await actualTemplate.childNodes).length; (s = s + 1) - 1) {
					await svg.appendChild(await (await (await actualTemplate.childNodes)[s]).cloneNode(true));
				}
				var depthTemp = await $Lt._gc.document.createElement("template");
				await depthTemp.setAttribute("is", type);
				for (var s = 0; s < await (await svg.childNodes).length; (s = s + 1) - 1) {
					await (await depthTemp.content).appendChild(await (await svg.childNodes)[s]);
					(s = s - 1) + 1;
				}
				return depthTemp;
			}
			async function createDepth(actualTemplate, type) {
				var depthTemp = await $Lt._gc.document.createElement("template");
				await depthTemp.setAttribute("is", type);
				depthTemp.innerHTML = await actualTemplate.innerHTML;
				return depthTemp;
			}
			async function appendDepth(depthTemp, constr) {
				await constr.splitTextNodes(depthTemp);
				await (await (await (await constr.component)._depthTemp).content).appendChild(depthTemp);
			}
			async function setHT(dynN, info, dynNewCompile, constr) {
				var flag = true;
				if (await dynN.tagName == "TEMPLATE") {
					info._ht = await dynN.innerHTML;
					flag = false;
				}
				if (await info._ht) {
					if (flag) {
						dynN.innerHTML = await info._ht;
						await constr.splitTextNodes(dynN);
					}
					if (dynNewCompile && await dynNewCompile.innerHTML !== await info._ht) {
						dynNewCompile.innerHTML = await info._ht;
						await constr.splitTextNodes(dynNewCompile);
					}
				}
			}
			async function doCompileHandling(dynamicN, dynamicNodes, componentName, constr, newCompile, j) {
				let lastUsedAttrPosition;
				let info = await dynamicNodes[j], type = await info.type, pos = await info.position, helperInfo;
				let dynN = await getDynamicNode(dynamicN, pos);
				let dynNewCompile;
				if (newCompile) {
					dynNewCompile = await getDynamicNode(newCompile, pos);
				}
				switch (type) {
				case "text": {
						let mustache = await (await Lyte.Compile).getMustache(await dynN.nodeValue), dynamicValue, helperFunc;
						if (mustache) {
							helperFunc = await (await Lyte.Compile).getHelper(mustache);
						}
						let dynamic = mustache;
						if (helperFunc) {
							info.helperInfo = helperFunc;
							if (dynNewCompile) {
								info.newHelperInfo = await (await Lyte.Compile).getHelper(mustache, true);
								await _LC.replaceWithPf(dynNewCompile, await $Lt._gc.document.createTextNode("__**--Lyte" + j + "__**"));
							}
						} else if (dynamic) {
							info.dynamicValue = dynamic;
							info.newDynamicValue = await _LC.getDV(dynamic);
							if (dynNewCompile) {
								await _LC.replaceWithPf(dynNewCompile, await $Lt._gc.document.createTextNode("__**--Lyte" + j + "__**"));
							}
						}
					}
					break;
				case "insertYield": {
						if (dynNewCompile) {
							await dynNewCompile.appendChild(await $Lt._gc.document.createTextNode("__**--Lyte" + j + "__**"));
							let yieldAttr = await (await dynNewCompile.attributes)["yield-name"];
							info.yieldName = yieldAttr ? await yieldAttr.nodeValue : $Lt._gc.undefined;
						}
					}
					break;
				case "componentDynamic": {
						if (await _Lyte.isWidgetBuild) {
							await dynN.setAttribute("lyte-widget", "");
						}
						if (dynNewCompile) {
							if (await _Lyte.isWidgetBuild) {
								await dynNewCompile.setAttribute("lyte-widget", "");
							}
							await dynNewCompile.appendChild(await $Lt._gc.document.createTextNode("__**--Lyte" + j + "__**"));
							info.componentName = await dynNewCompile.localName;
							var attrs = await $Lt._gc.Array.from(await dynNewCompile.attributes);
							info.staticAttrs = {};
							for (var i = 0; i < await attrs.length; (i = i + 1) - 1) {
								(await info.staticAttrs)[await (await _LC.String).toCamelCase(await (await attrs[i]).nodeName)] = await (await attrs[i]).nodeValue;
							}
							delete (await info.staticAttrs)._lyteprop;
						}
					}
					break;
				case "attr": {
						let add = false, toBeRemoved = [], toBeAdded = [];
						let node = dynN;
						let attr = info.attr = await info.attr || {};
						for (let i = 0; i < await (await node.attributes).length; (i = i + 1) - 1) {
							if (await (await (await (await node.attributes)[i]).nodeValue).indexOf("{{") !== -1) {
								let val = await (await (await node.attributes)[i]).nodeValue;
								let actValue = await (await Lyte.Compile).getMustache(val), actObj;
								if (actValue) {
									actObj = await (await Lyte.Compile).getHelper(actValue);
								} else if (await (/{{.*}}/).test(val) && !await (/\\{{.*}}/).test(val)) {
									actObj = await (await Lyte.Compile).splitMixedText(val);
								}
								if (actObj && (await actObj.name === "action" || await actObj.name === "method") && await (/^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|__focus|__focusin|__focusout|__resize|__scroll|__click|__dblclick|__mousedown|__mouseup|__mousemove|__mouseover|__mouseout|__change|__select|__submit|__keydown|__keypress|__keyup|__contextmenu)$/).test(await (await (await node.attributes)[i]).name)) {
									attr[await (await (await (await node.attributes)[i]).name).substr(2)] = {
										name: await (await (await (await node.attributes)[i]).name).substr(2),
										camelCase: await (await _LC.String).toCamelCase(await (await (await (await node.attributes)[i]).name).substr(2)),
										helperInfo: actObj,
										newHelperInfo: await (await Lyte.Compile).getHelper(actValue, true),
										globalEvent: true
									};
									let actArgs = await _Lyte.deepCopyObject(await actObj.args);
									let actName = await (await actArgs.splice(0, 1))[0];
									actName = await actName.startsWith("'") ? await actName.replace((/'/g), "") : actName;
									let actString = await getArgString(actName, actArgs);
									await node.setAttribute(await (await (await (await node.attributes)[i]).name).substr(2), componentName + " => " + actString);
									if (dynNewCompile) {
										await dynNewCompile.setAttribute(await (await (await (await node.attributes)[i]).name).substr(2), componentName + " => " + actString);
									}
									await toBeRemoved.push(await (await (await node.attributes)[i]).name);
								} else {
									if (actObj || actValue) {
										let attrToPush = {};
										if (await (await (await (await node.attributes)[i]).name).startsWith("lbind:")) {
											await toBeRemoved.push(await (await (await node.attributes)[i]).name);
											await toBeAdded.push({
												"name": await (await (await (await node.attributes)[i]).name).substring(6),
												"value": await (await (await node.attributes)[i]).nodeValue
											});
											attrToPush.isLbind = true;
											attrToPush.name = await (await (await (await node.attributes)[i]).name).substring(6);
											attrToPush.camelCase = await (await _LC.String).toCamelCase(await attrToPush.name);
										} else {
											attrToPush.name = await (await (await node.attributes)[i]).name;
											attrToPush.camelCase = await (await _LC.String).toCamelCase(await attrToPush.name);
										}
										if (actObj) {
											if (await actObj.name === "lbind") {
												attrToPush.dynamicValue = await (await actObj.args)[0];
												attrToPush.newDynamicValue = await _LC.getDV(await (await actObj.args)[0]);
												attrToPush.isLbind = true;
											} else {
												attrToPush.helperInfo = actObj;
												attrToPush.newHelperInfo = await (await Lyte.Compile).getHelper(actValue, true);
											}
										} else {
											attrToPush.dynamicValue = actValue;
											attrToPush.newDynamicValue = await _LC.getDV(actValue);
										}
										add = true;
										attr[await attrToPush.name] = attrToPush;
									}
								}
							}
							if (await (await (await (await node.attributes)[i]).name).startsWith("@")) {
								let rt = await (await _LC.directive).compileNode(node, attr, toBeRemoved, toBeAdded, i, componentName);
								add = await rt.add;
								$Lt._gc.attrToPush = await rt.attrToPush;
							}
						}
						if (await toBeRemoved.length) {
							for (let i = 0; i < await toBeRemoved.length; (i = i + 1) - 1) {
								await node.removeAttribute(await toBeRemoved[i]);
								if (dynNewCompile) {
									await dynNewCompile.removeAttribute(await toBeRemoved[i]);
								}
							}
						}
						if (dynNewCompile) {
							for (let key in attr) {
								await dynNewCompile.removeAttribute(key);
							}
							await dynNewCompile.setAttribute("_lyteAttr", "__**--Lyte" + j + "__**", "");
						}
						if (await toBeAdded.length) {
							for (let i = 0; i < await toBeAdded.length; (i = i + 1) - 1) {
								await node.setAttribute(await (await toBeAdded[i]).name, await (await toBeAdded[i]).value);
							}
						}
					}
					break;
				case "for":
				case "forIn":
				case "registerYield":
					await setHT(dynN, info, dynNewCompile, constr);
				case "component": {
						var actualTemplate = await _Lyte._ie ? dynN : await dynN.content;
						if (!dynNewCompile && (type == "registerYield" || await dynN.hasAttribute("unbound"))) {
							if (await _Lyte._ms) {
								dynNewCompile = await $Lt._gc.document.createElement("div");
								dynNewCompile.innerHTML = await info.actualTemplate ? await info.actualTemplate : await dynN.outerHTML;
								dynNewCompile = await (await dynNewCompile.childNodes)[0];
								await constr.splitTextNodes(dynNewCompile);
							} else {
								dynNewCompile = await dynN.cloneNode(true);
							}
						}
						let depthTemp;
						let dnNode;
						var actualTemplateNewCompile = dynNewCompile ? await _Lyte._ie ? dynNewCompile : await dynNewCompile.content : $Lt._gc.undefined;
						let args = {};
						if (await info.actualTemplate) {
							actualTemplate = await _LC.getContentForIE(await info.actualTemplate, constr, $Lt._gc.undefined, await _Lyte._ms ? info : $Lt._gc.undefined);
							if (dynNewCompile) {
								actualTemplateNewCompile = await _LC.getContentForIE(await info.actualTemplate, constr);
							}
						}
						if ((await window.isLyteWidget || await window.__lyteEnablePromise) && await dynN.hasAttribute("has-child")) {
							var dynNContent = await dynN.content || dynN;
							for (let key in await info.cases) {
								let contentNewCompile;
								var content = await _LC.getContentForIE(await actualTemplate.querySelector("[case='" + await _LC.cssEscape(key) + "']"), $Lt._gc.undefined, true);
								await setHT(content, await (await info.cases)[key], contentNewCompile, constr);
								var gen = await doCompile(await content.tagName === "TEMPLATE" ? await content.content : content, await (await (await info.cases)[key]).dynamicNodes, componentName, constr, contentNewCompile);
								var gnxt = await gen.next(), gval;
								while (await gnxt.done == false) {
									gval = await gnxt.value;
									if (typeof gval == "function") {
										await gval();
									}
									gnxt = await gen.next();
								}
								if (await (await (await info.cases)[key])._ht) {
									(await (await info.cases)[key])._ht = await content.cloneNode(true);
									await (await (await constr._helperTemplate).content).append(await (await (await info.cases)[key])._ht);
									content.innerHTML = "";
								}
							}
						} else {
							var gen = await doCompile(actualTemplate, await info.dynamicNodes, componentName, constr, actualTemplateNewCompile, info);
							var gnxt = await gen.next(), gval;
							while (await gnxt.done == false) {
								gval = await gnxt.value;
								if (typeof gval == "function") {
									await gval();
								}
								gnxt = await gen.next();
							}
						}
						if (actualTemplateNewCompile) {
							let staticTemp = await info.actualTemplate ? actualTemplateNewCompile : dynNewCompile;
							info._sta = await _LC.processStatic(staticTemp);
						}
						if (await _Lyte._ms) {
							if (await info.actualTemplate) {
								info.templateContent = await actualTemplate.outerHTML;
								if (await info._content) {
									info.actualTemplate = await (await info._content).innerHTML;
									delete info._content;
								}
							} else {
								info.templateContent = await dynN.outerHTML;
							}
							dynN.innerHTML = "";
						}
						if (await info.actualTemplate) {
							depthTemp = type;
							if (!await _Lyte._ie) {
								if (await info.svg) {
									depthTemp = await createSvgDepth(actualTemplate, type);
								} else {
									depthTemp = await createDepth(actualTemplate, type);
								}
								await appendDepth(depthTemp, constr);
							}
							if (await dynamicNodes[j - 1] && await (await (await dynamicNodes[j - 1]).position).toString() === await (await (await dynamicNodes[j]).position).toString()) {
								dnNode = await dynamicNodes[j - 1];
							} else {
								dnNode = await dynamicNodes[j];
							}
							dnNode._depthTemp = depthTemp;
						}
						if (dynNewCompile) {
							info._args = {};
							if (type === "registerYield") {
								await _LC.replaceWithPf(dynNewCompile, await $Lt._gc.document.createTextNode("__**--Lyte" + j + "__**"));
							} else if (type === "component") {
								await _LC.replaceWithPf(dynNewCompile, await $Lt._gc.document.createTextNode((await dynNewCompile.hasAttribute("_lyteattr") ? await dynNewCompile.getAttribute("_lyteattr") : "") + "__**--Lyte" + j + "__**"));
							} else {
								await _LC.replaceWithPf(dynNewCompile, await $Lt._gc.document.createTextNode("__**--Lyte" + j + "__**"));
							}
							Array.from(dynNewCompile.attributes).forEach(function (item) {
								info._args[item.nodeName] = item.nodeValue;
							});
						}
						if (await info._ht) {
							info._ht = await dynN.cloneNode(true);
							await (await (await constr._helperTemplate).content).append(await info._ht);
							dynN.innerHTML = "";
						}
					}
					break;
				case "if":
				case "switch": {
						await setHT(dynN, info, dynNewCompile, constr);
						var oldDyn = dynN;
						let depthTemp;
						var actualTemplateNewCompile = dynNewCompile ? await _Lyte._ie ? dynNewCompile : await dynNewCompile.content : $Lt._gc.undefined;
						if (await info.actualTemplate) {
							dynN = await _LC.getContentForIE(await info.actualTemplate, constr, $Lt._gc.undefined);
							if (dynNewCompile) {
								let dummy = await _LC.getContentForIE(await info.actualTemplate, constr);
								actualTemplateNewCompile = await _Lyte._ie ? dummy : await dummy.content;
							}
						}
						var def = "default";
						if (await _Lyte._ms) {
							var cases = {};
							var defCase;
							var dynNchildNodes = await _Lyte._ed ? await (await dynN.content).childNodes : await dynN.childNodes;
							for (var i = 0; i < await dynNchildNodes.length; (i = i + 1) - 1) {
								if (await (await dynNchildNodes[i]).tagName === "TEMPLATE") {
									if (await (await dynNchildNodes[i]).getAttribute("case")) {
										cases[await (await dynNchildNodes[i]).getAttribute("case")] = await dynNchildNodes[i];
									} else if (await (await dynNchildNodes[i]).hasAttribute("default")) {
										defCase = await dynNchildNodes[i];
									}
								}
							}
							for (let key in await info.cases) {
								let contentNewCompile;
								content = await _LC.getContentForIE(await cases[key], $Lt._gc.undefined, true);
								if (actualTemplateNewCompile) {
									contentNewCompile = await _LC.getContentForIE(await actualTemplateNewCompile.querySelector("[case='" + await LyteComponent.cssEscape(key) + "']"));
								}
								await setHT(content, await (await info.cases)[key], contentNewCompile, constr);
								var gen = await doCompile(content, await (await (await info.cases)[key]).dynamicNodes, componentName, constr, contentNewCompile ? await _LC.getContentForIE(contentNewCompile) : $Lt._gc.undefined);
								var gnxt = await gen.next(), gval;
								while (await gnxt.done == false) {
									gval = await gnxt.value;
									if (typeof gval == "function") {
										await gval();
									}
									gnxt = await gen.next();
								}
								await (await cases[key]).remove();
								if (actualTemplateNewCompile) {
									(await (await info.cases)[key])._sta = await _LC.processStatic(contentNewCompile);
								}
								(await (await info.cases)[key]).templateContent = await (await cases[key]).outerHTML;
							}
							if (await (await info[def]).dynamicNodes) {
								let contentNewCompile;
								content = await _LC.getContentForIE(defCase, $Lt._gc.undefined, true);
								if (actualTemplateNewCompile) {
									contentNewCompile = await actualTemplateNewCompile.querySelector("[default]");
								}
								await setHT(content, await info[def], contentNewCompile, constr);
								var gen = await doCompile(content, await (await info[def]).dynamicNodes, componentName, constr, contentNewCompile ? await _LC.getContentForIE(contentNewCompile) : $Lt._gc.undefined);
								var gnxt = await gen.next(), gval;
								while (await gnxt.done == false) {
									gval = await gnxt.value;
									if (typeof gval == "function") {
										await gval();
									}
									gnxt = await gen.next();
								}
								await defCase.remove();
								(await info[def]).templateContent = await defCase.outerHTML;
								if (actualTemplateNewCompile) {
									(await info[def])._sta = await _LC.processStatic(contentNewCompile);
								}
							}
						} else {
							var dynNContent = await dynN.content || dynN;
							for (let key in await info.cases) {
								let contentNewCompile;
								if (actualTemplateNewCompile) {
									contentNewCompile = await _LC.getContentForIE(await actualTemplateNewCompile.querySelector("[case='" + await LyteComponent.cssEscape(key) + "']"));
								}
								var content = await _LC.getContentForIE(await dynNContent.querySelector("[case='" + await _LC.cssEscape(key) + "']"), $Lt._gc.undefined, true);
								await setHT(content, await (await info.cases)[key], contentNewCompile, constr);
								var gen = await doCompile(await content.tagName === "TEMPLATE" ? await content.content : content, await (await (await info.cases)[key]).dynamicNodes, componentName, constr, contentNewCompile);
								var gnxt = await gen.next(), gval;
								while (await gnxt.done == false) {
									gval = await gnxt.value;
									if (typeof gval == "function") {
										await gval();
									}
									gnxt = await gen.next();
								}
								if (actualTemplateNewCompile) {
									(await (await info.cases)[key])._sta = await _LC.processStatic(contentNewCompile);
								}
								if (await (await (await info.cases)[key])._ht) {
									(await (await info.cases)[key])._ht = await content.cloneNode(true);
									await (await (await constr._helperTemplate).content).append(await (await (await info.cases)[key])._ht);
									content.innerHTML = "";
								}
							}
							if (await (await info[def]).dynamicNodes) {
								let contentNewCompile;
								if (actualTemplateNewCompile) {
									contentNewCompile = await _LC.getContentForIE(await actualTemplateNewCompile.querySelector("[default]"));
								}
								var content = await _LC.getContentForIE(await dynNContent.querySelector("[default]"), $Lt._gc.undefined, true);
								await setHT(content, await info[def], contentNewCompile, constr);
								var gen = await doCompile(await content.tagName === "TEMPLATE" ? await content.content : content, await (await info[def]).dynamicNodes, componentName, constr, contentNewCompile);
								var gnxt = await gen.next(), gval;
								while (await gnxt.done == false) {
									gval = await gnxt.value;
									if (typeof gval == "function") {
										await gval();
									}
									gnxt = await gen.next();
								}
								if (actualTemplateNewCompile) {
									(await info[def])._sta = await _LC.processStatic(contentNewCompile);
								}
								if (await (await info[def])._ht) {
									(await info[def])._ht = await content.cloneNode(true);
									await (await (await constr._helperTemplate).content).append(await (await info[def])._ht);
									content.innerHTML = "";
								}
							}
						}
						if (await info.actualTemplate) {
							depthTemp = type;
							if (!await _Lyte._ie) {
								if (await info.svg) {
									depthTemp = await createSvgDepth(await dynN.content, type);
								} else {
									depthTemp = await createDepth(dynN, type);
								}
								await appendDepth(depthTemp, constr);
							}
							if (await dynamicNodes[j - 1] && await (await (await dynamicNodes[j - 1]).position).toString() === await (await (await dynamicNodes[j]).position).toString()) {
								(await dynamicNodes[j - 1])._depthTemp = depthTemp;
							} else {
								(await dynamicNodes[j])._depthTemp = depthTemp;
							}
						}
						if (dynNewCompile) {
							await _LC.replaceWithPf(dynNewCompile, await $Lt._gc.document.createTextNode("__**--Lyte" + j + "__**"));
						}
						if (await info._ht) {
							info._ht = await dynN.cloneNode(true);
							await (await (await constr._helperTemplate).content).append(await info._ht);
							dynN.innerHTML = "";
						}
					}
					break;
				}
			}
			function* doCompile(dynamicN, dynamicNodes, componentName, constr, newCompile) {
				let lastUsedAttrPosition;
				if (dynamicNodes && dynamicNodes.length) {
					for (let j = 0; j < dynamicNodes.length; (j = j + 1) - 1) {
						yield () => {
							doCompileHandling(dynamicN, dynamicNodes, componentName, constr, newCompile, j);
						};
					}
				} else {
					yield "";
				}
			}
			async function getDynamicNode(content, positions) {
				let dynamicN = content;
				for (var i = 0; i < await positions.length; (i = i + 1) - 1) {
					dynamicN = await dynamicN.tagName != "TEMPLATE" || await _Lyte._ie ? await (await dynamicN.childNodes)[await positions[i]] : await (await (await dynamicN.content).childNodes)[await positions[i]];
				}
				return dynamicN;
			}
			async function getArgString(name, array) {
				let retString;
				for (let i = 0; i < await array.length; (i = i + 1) - 1) {
					if (await array[i] && typeof await array[i] === "object") {
						array[i] = await getArgString(await (await (await array[i]).value).name, await (await (await array[i]).value).args);
					}
				}
				if (name) {
					retString = name + "(" + await array.toString() + ")";
				} else {
					retString = await array.toString();
				}
				return retString;
			}
			var idleScheduler = await $Lt._cO($Lt._gc.IdleTaskScheduler, {
					delayInit: true,
					timeout: 40
				});
			window._wrapperComponents = [];
			var _Lyte = await window.isLyteWidgetParent ? await window._widgetLyte : await window.Lyte;
			var Lyte = _Lyte;
			if (!await window.__lyteConfig) {
				window.__lyteConfig = {
					_definedBeforeBridging: [],
					_alreadyDefinedBeforeBridging: [],
					v3: true,
					_pendingV3Components: {},
					_firstRegisteredComp: {}
				};
			}
			let ltCf = await window.__lyteConfig;
			if (!await ltCf.customElementsDefine) {
				ltCf.customElementsDefine = await (await (await $Lt._gc.customElements.constructor).prototype).define;
				await $Lt._gc.Object.defineProperty(await (await $Lt._gc.customElements.constructor).prototype, "define", {
					value: async function (name, compClass, options, _lyteOptions) {
							if (await $Lt._gc.customElements.get(name)) {
								await (await ltCf._alreadyDefinedBeforeBridging).push({
									name: name,
									compClass: compClass,
									options: options,
									_lyteOptions: _lyteOptions,
									scope: this
								});
							} else {
								await (await ltCf._definedBeforeBridging).push({
									name: name,
									compClass: compClass,
									options: options,
									_lyteOptions: _lyteOptions,
									scope: this
								});
								await (await ltCf.customElementsDefine).apply(this, arguments);
							}
						},
					enumerable: false
				});
			}
			if (!await ltCf.instanciateBridge) {
				ltCf.instanciateBridge = async function () {
					if (await ltCf.isWidgetBuild || await ltCf._LyteCustomElement && await ltCf._customElementPrototype && await ltCf._LyteYield) {
						ltCf.instanctiatedBridge = true;
						var versionBridge = { component: {} };
						ltCf.versionBridge = versionBridge;
						class V3Registry {
							static async define(name, compClass, options, _lyteOptions) {
								var customCrmComponent, otherComponent;
								if (!await ltCf.isWidgetBuild) {
									if (_lyteOptions) {
										if (name == "lyte-yield") {
											if (_lyteOptions && await _lyteOptions.widget) {
											} else {
												customCrmComponent = await ltCf._LyteYield;
											}
										} else if (_lyteOptions && await _lyteOptions.v4raw) {
											let customElementClass = ltCf._LyteCustomElement;
											customCrmComponent = class extends customElementClass {
												constructor() {
													super();
												}
											};
										} else if (_lyteOptions && _lyteOptions.v3raw) {
											let customElementClass = ltCf._LyteCustomElement;
											customCrmComponent = class extends customElementClass {
												constructor() {
													super();
												}
											};
										} else if (_lyteOptions && (_lyteOptions.v3 || _lyteOptions.v4)) {
											let customElementPrototypeClass = ltCf._customElementPrototype;
											customCrmComponent = class extends customElementPrototypeClass {
												constructor() {
													super();
												}
											};
										} else if (_lyteOptions && (_lyteOptions.widget || _lyteOptions.widgetRaw)) {
										}
									} else {
										otherComponent = true;
									}
								}
								var arr = arguments;
								if (!otherComponent && _lyteOptions) {
									if (await _lyteOptions.v3) {
										await (await (await _LC.V3).pendingComp).firstRegister(name, "v3");
										(await (await V3Registry.allList).v3)[name] = compClass;
										if (!await ltCf.isWidgetBuild) {
											customCrmComponent._observedAttributes = await compClass._observedAttributes;
											arr = [
												name,
												customCrmComponent
											];
										}
									} else if (await _lyteOptions.widget) {
										await (await (await _LC.V3).pendingComp).firstRegister(name, "widget");
										(await (await V3Registry.allList).widget)[name] = compClass;
									} else if (await _lyteOptions.widgetRaw) {
										(await (await V3Registry.allList).widgetRaw)[name] = compClass;
										await (await (await _LC.V3).pendingComp).firstRegister(name, "widgetRaw");
									} else if (await _lyteOptions.v3raw) {
										(await (await V3Registry.allList).v3raw)[name] = compClass;
										await (await (await _LC.V3).pendingComp).firstRegister(name, "v3raw");
									} else if (await _lyteOptions.v4raw) {
										(await (await V3Registry.allList).v4raw)[name] = compClass;
										await (await (await _LC.V3).pendingComp).firstRegister(name, "v4raw");
									} else if (await _lyteOptions.v4) {
										(await (await V3Registry.allList).v4)[name] = compClass;
										await (await (await _LC.V3).pendingComp).firstRegister(name, "v4");
									}
									let definedClass = await $Lt._gc.customElements.get(name);
									if (!definedClass && !await (await V3Registry.definedHere)[name]) {
										await (await (await window.__lyteConfig).customElementsDefine).apply(this, arr);
										(await V3Registry.definedHere)[name] = compClass;
									}
								} else {
									await (await (await window.__lyteConfig).customElementsDefine).apply(this, arr);
								}
							}
							static async register() {
								var compArr = [
										await ltCf._alreadyDefinedBeforeBridging,
										await ltCf._definedBeforeBridging
									];
								await $Lt._fE(compArr, async function (itemArr) {
									if (itemArr && await itemArr.length) {
										await $Lt._fE(itemArr, async function (obj) {
											if (await obj._lyteOptions) {
												if (await (await obj._lyteOptions).v3raw) {
													(await (await V3Registry.allList).v3raw)[await obj.name] = await obj.compClass;
													await (await (await _LC.V3).pendingComp).firstRegister(await obj.name, "v3raw");
												} else if (await obj._lyteOptions && await (await obj._lyteOptions).v4raw) {
													(await (await V3Registry.allList).v4raw)[await obj.name] = await obj.compClass;
													await (await (await _LC.V3).pendingComp).firstRegister(await obj.name, "v4raw");
												} else if (await obj._lyteOptions && await (await obj._lyteOptions).v3) {
													(await (await V3Registry.allList).v3)[await obj.name] = await obj.compClass;
													await (await (await _LC.V3).pendingComp).firstRegister(await obj.name, "v3");
												} else if (await obj._lyteOptions && await (await obj._lyteOptions).v4) {
													(await (await V3Registry.allList).v4)[await obj.name] = await obj.compClass;
													await (await (await _LC.V3).pendingComp).firstRegister(await obj.name, "v4");
												} else if (await obj._lyteOptions && await (await obj._lyteOptions).widget) {
													(await (await V3Registry.allList).widget)[await obj.name] = await obj.compClass;
													await (await (await _LC.V3).pendingComp).firstRegister(await obj.name, "widget");
												} else if (await obj._lyteOptions && await (await obj._lyteOptions).widgetRaw) {
													(await (await V3Registry.allList).widgetRaw)[await obj.name] = await obj.compClass;
													await (await (await _LC.V3).pendingComp).firstRegister(await obj.name, "widgetRaw");
												}
											}
										});
									}
								});
								if (!await ltCf.versionBridge && !await ltCf.customElementsDefine) {
									ltCf.customElementsDefine = await (await (await $Lt._gc.customElements.constructor).prototype).define;
								}
								await $Lt._gc.Object.defineProperty(await (await $Lt._gc.customElements.constructor).prototype, "define", {
									value: async function (name, compClass, options, _lyteOptions) {
											await (await V3Registry.define).apply(this, [
												name,
												compClass,
												options,
												_lyteOptions
											]);
										},
									enumerable: false
								});
							}
						}
						(await (await ltCf.versionBridge).component).V3Registry = V3Registry;
						V3Registry.allList = {
							v3: {},
							v4: {},
							other: {},
							v3raw: {},
							v4raw: {},
							widget: {},
							widgetRaw: {}
						};
						V3Registry.definedHere = {};
						await V3Registry.register();
					}
				};
			}
			_Lyte.Security = {
				"_ourSanitizerInstance_": {},
				"_userSanitizerInstance_": {},
				"_eM": {
					"&": "&amp;",
					"<": "&lt;",
					">": "&gt;",
					"\"": "&quot;",
					"'": "&#x27;",
					"`": "&#x60;",
					"=": "&#x3D;"
				},
				"_eR": (/[&<>"'`=]/g),
				"_eF": async function (str) {
					return await (await this._eM)[str];
				},
				"escape": async function (string) {
					if (typeof string !== "string") {
						string = "" + string;
					}
					return await string.replace(await this._eR, await (await this._eF).bind(this));
				}
			};
			if (!await window.isLyteWidget) {
				var sec = {
						"GLOBAL_TAGS": [],
						"GLOBAL_ATTRIBUTES": [],
						"FORBID_TAGS": [],
						"FORBID_ATTR": [],
						REUSE_CONFIG: true
					};
				(await _Lyte.Security)._ourSanitizerInstance_ = await (await $Lt._gc.ZWAF["7_0_0"]).HTMLPurifier(sec);
				(await (await _Lyte.Security)._ourSanitizerInstance_)._GLOBAL_TAGS = await sec.GLOBAL_TAGS;
				(await (await _Lyte.Security)._ourSanitizerInstance_)._GLOBAL_ATTRIBUTES = await sec.GLOBAL_ATTRIBUTES;
				await (await sec.GLOBAL_ATTRIBUTES).push("is", "yield-name", "lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target", "lt-prop-td", "lt-prop-custom", "lt-prop-target", "lt-prop-id", "lt-prop-class", "lt-prop-style", "lt-prop-rel", "lt-prop-title");
				await (await sec.GLOBAL_TAGS).push("link-to");
				(await (await _Lyte.Security)._ourSanitizerInstance_)._FORBID_TAGS = await sec.FORBID_TAGS;
				(await (await _Lyte.Security)._ourSanitizerInstance_)._FORBID_ATTR = await sec.FORBID_ATTR;
				(await _Lyte.Security).createSanitizer = async function (obb) {
					if (obb && await obb.__target__) {
						obb = await obb.__target__;
					}
					if (!await obb.GLOBAL_ATTRIBUTES) {
						obb.GLOBAL_ATTRIBUTES = [];
					}
					if (!await obb.FORBID_TAGS) {
						obb.FORBID_TAGS = [];
					}
					if (!await obb.FORBID_ATTR) {
						obb.FORBID_ATTR = [];
					}
					if (!await obb.GLOBAL_TAGS) {
						obb.GLOBAL_TAGS = [];
					}
					obb.REUSE_CONFIG = true;
					await (await obb.GLOBAL_ATTRIBUTES).push("is", "yield-name", "lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target", "lt-prop-td", "lt-prop-custom", "lt-prop-target", "lt-prop-id", "lt-prop-class", "lt-prop-style", "lt-prop-rel", "lt-prop-title");
					await (await obb.GLOBAL_TAGS).push("link-to");
					var globalTagArr = await $Lt._gc.Array.from(await obb.GLOBAL_TAGS);
					var attr = [];
					for (var a = 0; a < await globalTagArr.length; (a = a + 1) - 1) {
						if (await (await _LC._registeredComponents)[await globalTagArr[a]]) {
							attr = await (await (await _LC._registeredComponents)[await globalTagArr[a]]).observedAttributes;
						} else if (await (await Lyte.registeredCustomComponent)[await globalTagArr[a]]) {
							attr = await (await (await Lyte.registeredCustomComponent)[await globalTagArr[a]]).observedAttributes;
						}
						if (attr) {
							for (var i = 0; i < await attr.length; (i = i + 1) - 1) {
								if (await (await obb.GLOBAL_ATTRIBUTES).indexOf(await attr[i]) == -1) {
									await (await obb.GLOBAL_ATTRIBUTES).push(await attr[i]);
								}
							}
						}
					}
					(await _Lyte.Security)._userSanitizerInstance_ = await (await $Lt._gc.ZWAF["7_0_0"]).HTMLPurifier(obb);
					(await (await _Lyte.Security)._userSanitizerInstance_)._GLOBAL_TAGS = await obb.GLOBAL_TAGS;
					(await (await _Lyte.Security)._userSanitizerInstance_)._GLOBAL_ATTRIBUTES = await obb.GLOBAL_ATTRIBUTES;
					(await (await _Lyte.Security)._userSanitizerInstance_)._FORBID_TAGS = await obb.FORBID_TAGS;
					(await (await _Lyte.Security)._userSanitizerInstance_)._FORBID_ATTR = await obb.FORBID_ATTR;
					return await (await _Lyte.Security)._userSanitizerInstance_;
				};
			}
			var globalDOMEvents = [
					"focus",
					"focusin",
					"focusout",
					"resize",
					"scroll",
					"click",
					"dblclick",
					"mousedown",
					"mouseup",
					"mousemove",
					"mouseover",
					"mouseout",
					"change",
					"select",
					"submit",
					"keydown",
					"keypress",
					"keyup",
					"contextmenu"
				];
			var registerHelperStr = "registerHelper";
			var delStr = "delete";
			window.defProp = function defProp() {
				Object.defineProperty.apply(Object, arguments);
			};
			await _Lyte.registerErrorCodes({
				"LC001": "Error while parsing custom prop handler attribute {0}. Check if the value provided is a valid JSON",
				"LC002": "{0} Component is not compiled. Please compile using Lyte CLI",
				"LC003": "Helper named {0} is not defined",
				"LC004": "Action named {0} doesn't exists",
				"LC005": "Lyte.objectUtils doesn't support {0} function",
				"LC006": "Lyte.arrayUtils doesn't support {0} function",
				"LC007": "Component name not specified in Lyte.Component.render",
				"LC008": "Specified outlet {0} doesn't exists - Lyte.Component.render",
				"LC009": "Method named {0} doesn't exists in {1} component",
				"LC010": "Parent Node / reference Node not provided for insertBefore method",
				"LC011": "Error in promise provided in initialize function of data '{0}' of {1} component"
			});
			let userAgent = await $Lt._gc.navigator.userAgent;
			if (await userAgent.match((/rv:11/))) {
				_Lyte._ie = true;
				window.action = async function () {
					return;
				};
			}
			if (await userAgent.match("Edge")) {
				var s = await createElement("div");
				s.innerHTML = "<template><div>c</div></template>";
				if (await (await (await s.querySelector("template")).childNodes).length) {
					_Lyte._ie = true;
				} else {
					_Lyte._ed = true;
				}
				await s.remove();
			}
			class Test extends $Lt._gc.HTMLElement {
				constructor() {
					super();
					$Lt.getCp(this).push(async function () {
						if (!await (await this.attributes).t) {
							_LC.frSpecial = true;
						}
					}.call(this));
				}
			}
			if (await _Lyte._ie || await _Lyte._ed) {
				var doc = await createDocFragment();
				await doc.appendChild(await $Lt._gc.document.createTextNode("  dummy "));
				await (await (await doc.childNodes)[0]).replaceWith(await $Lt._gc.document.createTextNode("changed"));
				if (await (await (await doc.childNodes)[0]).textContent !== "changed") {
					_Lyte._rwpf = true;
				}
				_Lyte._ms = true;
			}
			_Lyte.Component = {};
			Lyte.Compile = {};
			var _LyteComponent = await _Lyte.Component;
			(await _Lyte.Component).lazyRegisterScheduler = idleScheduler;
			(await _Lyte.Component).priorityRegistrationQ = await idleScheduler.priorityQueue;
			_Lyte.arrayUtils = async function () {
				return await (await _LC.aF).apply(_LC, arguments);
			};
			_Lyte.objectUtils = async function () {
				return await (await _LC.oF).apply(_LC, arguments);
			};
			await $Lt._gc.Object.defineProperty(_LyteComponent, "register", {
				get: async function () {
						await Lyte._preRegister();
						return await _LC.registerComponentWrapper;
					},
				"enumerable": true
			});
			_LyteComponent.nonFalsyAttrs = {
				add: async function (value) {
						if (await $Lt._gc.Array.isArray(value)) {
							await $Lt._fE(value, async function (item) {
								await (await _LC.booleanAttrList).push(item);
							});
						} else {
							await (await _LC.booleanAttrList).push(value);
						}
					},
				_remove: async function (item) {
					let ind = await (await _LC.booleanAttrList).indexOf(item);
					if (ind !== -1) {
						await (await _LC.booleanAttrList).splice(ind, 1);
					}
				},
				remove: async function (value) {
					if (await $Lt._gc.Array.isArray(value)) {
						await $Lt._fE(value, async function (item) {
							await (await _LyteComponent.nonFalsyAttrs)._remove(item);
						});
					} else {
						await (await _LyteComponent.nonFalsyAttrs)._remove($Lt._gc.item);
					}
				}
			};
			_LyteComponent.getComponentClass = async function (compName) {
				return await (await _LC._registeredComponents)[compName];
			};
			_LyteComponent.registerHelper = async function () {
				await (await _LC.registerHelper).apply(_LC, arguments);
			};
			_LyteComponent.set = async function () {
				await (await _LC.set).apply(_LC, arguments);
			};
			_LyteComponent.registeredHelpers = {};
			_LyteComponent.registeredComponents = {};
			_LyteComponent.customPropHandlersList = {};
			_LyteComponent.registerCustomPropHandler = async function (propName) {
				let dasherized = await (await _LC.String).dasherize(propName);
				propName = await (await _LC.String).toCamelCase(propName);
				if (await (await _LC.customPropHandlers).indexOf(propName) === -1) {
					await (await _LC.customPropHandlers).push(propName);
					let customPropHanlderFn = (await customElementPrototype.prototype)[propName] = async function () {
							let argsLength = await arguments.length;
							let arg0 = await arguments[0];
							let options = await arguments[2];
							let compData = await LyteComponent.getCmpData(await (await this.component).data);
							if (!arg0) {
								let obj = {};
								for (let key in compData) {
									if (await key.startsWith(propName)) {
										let objKey = await key.substring(await propName.length);
										objKey = await (await _LC.String).lowerCaseFirstLetter(objKey);
										obj[objKey] = await compData[key];
									}
								}
								return obj;
							} else if (typeof arg0 === "string") {
								if (argsLength > 1) {
									await this.set(propName + await (await _LC.String).upperCaseFirstLetter(arg0), await arguments[1], options);
								} else {
									let actKey = propName + await (await _LC.String).upperCaseFirstLetter(arg0);
									return await compData[actKey];
								}
							} else if (typeof arg0 === "object") {
								for (let key in arg0) {
									let objKey = propName + await (await _LC.String).upperCaseFirstLetter(key);
									await this.set(objKey, await arg0[key], await arguments[1]);
								}
							}
						};
					(await _LyteComponent.customPropHandlersList)[propName] = customPropHanlderFn;
					_LC.customPropRegex = await $Lt._cO($Lt._gc.RegExp, "^(" + await (await _LC.customPropHandlers).join("|") + ")");
				}
			};
			_LyteComponent.unregisterComponent = async function (componentName, configObj) {
				configObj = configObj || {};
				if (await (await _LyteComponent.registeredComponents)[componentName]) {
					var comp = await (await _LC._registeredComponents)[componentName];
					if (await comp.activeInstances > 0) {
						await _Lyte.warn("There are active instances of the component " + componentName + " and hence cannot be unregistered");
					} else if (await (await comp.component).activeInstances > 0) {
						await _Lyte.warn("There are active instances of the component " + componentName + " and hence cannot be unregistered");
					} else {
						comp._properties = (await comp.component)._properties = {};
						comp._mixins = comp._actions = comp._template = comp._dynamicNodes = null;
						comp._callBacks = (await comp.component)._callBacks = {};
						comp._observers = (await comp.component)._observers = [];
						comp._data = comp.component_data = $Lt._gc.undefined;
						comp._methods = (await comp.component)._methods = {};
						(await comp.prototype).get = noop;
						(await comp.prototype).set = noop;
						await $Lt._gc.Object.defineProperty(await comp.prototype, "setData", {
							configurable: true,
							writable: true,
							value: async function (arg0, arg1) {
								this._initProperties = await this._initProperties || {};
								if (typeof arg0 === "string") {
									(await this._initProperties)[arg0] = arg1;
								} else if (typeof arg0 === "object") {
									for (let key in arg0) {
										(await this._initProperties)[key] = await arg0[key];
									}
								}
							}
						});
						await $Lt._gc.Object.defineProperty(await comp.prototype, "setMethods", {
							configurable: true,
							writable: true,
							value: async function (arg0, arg1) {
								this._initMethods = await this._initMethods || {};
								if (typeof arg0 === "string") {
									(await this._initMethods)[arg0] = arg1;
								} else if (typeof arg0 === "object") {
									for (let key in arg0) {
										(await this._initMethods)[key] = await arg0[key];
									}
								}
							}
						});
						delete (await _LyteComponent.registeredComponents)[componentName];
						var template = await $Lt._gc.document.querySelector("template[tag-name=" + componentName + "]");
						if (template) {
							await template.remove();
						}
						var helperTemplate = await comp._helperTemplate;
						if (helperTemplate) {
							await helperTemplate.remove();
						}
						if (await (await comp.component)._depthTemp) {
							await (await (await comp.component)._depthTemp).remove();
						}
					}
				} else {
					await _Lyte.warn("Component " + componentName + " not yet registered");
				}
			};
			_Lyte.createCustomElement = async function (customElementName, definition) {
				var constructor = await definition.constructor;
				delete definition.constructor;
				var connectedCallback = await definition.connectedCallback;
				delete definition.connectedCallback;
				var attributeChangedCallback = await definition.attributeChangedCallback;
				delete definition.attributeChangedCallback;
				var disconnectedCallback = await definition.disconnectedCallback;
				delete definition.disconnectedCallback;
				this.defProperty = async function (obj, key, val) {
					var obj1 = {};
					if (await val.get) {
						obj1.get = val.get;
					}
					if (await val.set) {
						obj1.set = val.set;
					}
					await $Lt._gc.Object.defineProperty(obj, key, obj1, true);
				};
				class classDef extends $Lt._gc.HTMLElement {
					constructor() {
						super();
						$Lt.getCp(this).push(async function () {
							if (await window.ignoreParent) {
								this.__lyteIgnore = true;
								return;
							}
							await this.decideConstructor();
						}.call(this));
					}
					async decideConstructor() {
						if (ltCf && (await ltCf.v4 || await ltCf.isWidgetBuild)) {
							let V3Registry = await (await (await ltCf.versionBridge).component).V3Registry;
							let foundInV4List = await (await (await V3Registry.allList).v4raw)[await this.localName];
							let foundInV3List = await (await (await V3Registry.allList).v3raw)[await this.localName];
							let foundInWidgetList = await (await (await V3Registry.allList).widgetRaw)[await this.localName];
							if (foundInV4List) {
								if (!foundInV3List || (await this._callee && await (await this._callee).__v4 || await this.hasAttribute("lyte-v4") || await this.hasAttribute("lyte-registry") || await ltCf.lyteV4 || await ltCf.fromV4Render)) {
									let v4compClass = foundInV4List;
									let self = this;
									await $Lt._fE(await classDef._V4InsApi, async function (apiName) {
										self[apiName] = await (await v4compClass.prototype)[apiName];
									});
								}
							} else if (foundInWidgetList) {
								if (await this._callee && await (await this._callee).__widget || await this.hasAttribute("lyte-widget") || await (await window.__lyteConfig).isWidgetComponent || await ltCf.lyteWidget || await ltCf.fromWidgetRender) {
									let widgetCompClass = foundInWidgetList;
									let self = this;
									if (await (await ltCf._firstRegisteredComp)[await this.localName] != "widgetRaw") {
										await $Lt._fE(await classDef._V3InsApi, async function (apiName) {
											self[apiName] = await (await widgetCompClass.prototype)[apiName];
										});
									}
								} else if (foundInV3List) {
									let v3CompClass = foundInV3List;
									if (await (await ltCf._firstRegisteredComp)[await this.localName] != "v3raw") {
										await $Lt._fE(await classDef._V3InsApi, async function (apiName) {
											$Lt._gc.self[apiName] = await (await v3CompClass.prototype)[apiName];
										});
									}
								} else {
									await (await (await _LC.V3).pendingComp).add(this);
									this.__v3lyteIgnore = true;
									return;
								}
							}
						}
						await this.actualConstructor();
					}
					async actualConstructor() {
						if (await this.isNewComp(customElementName)) {
							await this.executeCallbacks(constructor, arguments);
						} else {
							this.__lyteIgnore = true;
						}
					}
					async connectedCallback() {
						await this._connectedCallback();
					}
					async _connectedCallback() {
						if (await this.__lyteIgnore || await this.hasAttribute("lyte-rendered-ce")) {
							return;
						}
						await this.executeCallbacks(connectedCallback, arguments);
						await this.setAttribute("lyte-rendered-ce", "");
						this._connectedCalled = true;
					}
					async attributeChangedCallback(attr, oldValue, newValue) {
						await this._attributeChangedCallback(attr, oldValue, newValue);
					}
					async _attributeChangedCallback() {
						if (!await this.__lyteIgnore || await this.__v3lyteIgnore) {
							await this.executeCallbacks(attributeChangedCallback, arguments);
						}
					}
					async disconnectedCallback() {
						await this._disconnectedCallback();
					}
					async _disconnectedCallback() {
						if (await this.__v3lyteIgnore) {
							await (await (await _LC.V3).pendingComp).remove(this);
							return;
						}
						if (!await _LyteComponent.shouldIgnoreDisconnect() && !await this.__lyteIgnore) {
							await this.executeCallbacks(disconnectedCallback, arguments);
							this._parentHelper = null;
						}
					}
					async executeCallbacks(callBack, argArr) {
						if (callBack) {
							await callBack.apply(this, await $Lt._gc.Array.from(argArr));
						}
					}
					async isNewComp(customElementName) {
						if (await this.hasAttribute("lyte-rendered-ce")) {
							return false;
						}
						return true;
					}
				}
				classDef._V4InsApi = [
					"_connectedCallback",
					"_attributeChangedCallback",
					"_disconnectedCallback",
					"actualConstructor",
					"executeLyteCallbacks",
					"isClonedNode",
					"_isClonedAttribute",
					"isClonedAttribute"
				];
				classDef._V3InsApi = [
					"_connectedCallback",
					"_attributeChangedCallback",
					"_disconnectedCallback",
					"actualConstructor",
					"executeCallbacks",
					"isNewComp"
				];
				var staticDef = await definition.static;
				definition._static = staticDef;
				if (staticDef) {
					for (var key in staticDef) {
						if (typeof await staticDef[key] === "object") {
							await this.defProperty(classDef, key, await staticDef[key]);
						} else {
							await $Lt._gc.Object.defineProperty(classDef, key, { value: await staticDef[key] });
						}
					}
					delete definition.static;
				}
				classDef._definition = definition;
				for (var key in definition) {
					if (typeof await definition[key] === "object") {
						await this.defProperty(await classDef.prototype, key, await definition[key]);
					} else {
						await $Lt._gc.Object.defineProperty(await classDef.prototype, key, {
							writable: true,
							value: await definition[key]
						});
					}
				}
				definition.static = staticDef;
				definition.constructor = constructor;
				definition.connectedCallback = connectedCallback;
				definition.attributeChangedCallback = attributeChangedCallback;
				definition.disconnectedCallback = disconnectedCallback;
				if (await $Lt._gc.document.readyState === "complete" || await $Lt._gc.document.readyState === "interactive") {
					await $Lt._gc.customElements.define(customElementName, classDef, $Lt._gc.undefined, await _Lyte.isWidgetBuild ? { "widgetRaw": true } : { v3raw: true });
				} else {
					await (await LyteComponent.toBeRegistered).push({
						name: customElementName,
						def: classDef,
						_lyteOptions: await _Lyte.isWidgetBuild ? { "widgetRaw": true } : { v3raw: true }
					});
				}
				(await Lyte.registeredCustomComponent)[customElementName] = classDef;
			};
			var elementPrototype = typeof $Lt._gc.HTMLElement !== "undefined" ? $Lt._gc.HTMLElement : $Lt._gc.Element;
			_Lyte.appendTemplateDiv = async function () {
				await (await $Lt._gc.document.body).appendChild(await _LC.tDiv);
				await (await $Lt._gc.document.body).appendChild(await _LC.h1Div);
				await _LCHD.appendTemp();
			};
			$Lt._gc.document._addShadowForGlobalRegistry = async function (shadow) {
				for (let i = 0; i < await globalDOMEvents.length; (i = i + 1) - 1) {
					var evnt = await globalDOMEvents[i];
					await shadow.addEventListener(evnt, globalEventHandler, true);
				}
				for (var j = 0; j < await $Lt._gc.windowEventListeners.length; (j = j + 1) - 1) {
					await (await shadow.addEventListener).apply(shadow, await $Lt._gc.windowEventListeners[j]);
				}
				await shadow.addEventListener("change", changeEventHandler);
			};
			var changeEventHandler = async function (event1) {
					var target = await event1.target || await event1.srcElement;
					if (!await target._attributeDetails) {
						return;
					}
					var attributeName = "value";
					if (await target.type === "checkbox" || await target.type === "radio") {
						attributeName = "checked";
					}
					let contextSwitchArray = [];
					var attrNode;
					var attrDetail = await (await target._attributeDetails)[attributeName];
					let saveAttr = await _LCSV.getAttr(await target._specialAttributeDetails);
					if (!attrDetail || !await attrDetail.isLbind && !saveAttr) {
						return;
					}
					var callee = target;
					if (!await target._callee) {
						while (callee && !await _LC.isCustomElement(callee) && await callee.tagName !== "LYTE-YIELD") {
							if (await callee.tagName === "BODY") {
								callee = null;
								break;
							}
							callee = await callee.parentNode;
						}
						if (callee && await callee.tagName === "LYTE-YIELD") {
							target._callee = await (await callee._registerYield)._callee;
						} else {
							target._callee = callee;
						}
					}
					let self = await target._callee;
					if (saveAttr) {
						await _LCSV.triggerAllListeners(self, await saveAttr.hookName, target, true);
					}
					if (target) {
						await _LC.adCx(target, contextSwitchArray);
					}
					if (attrDetail) {
						let obj = await _LC.getNew(await (await self.component).data, await attrDetail.dynamicValue);
						if (!await obj.context) {
							return;
						}
						let lastKeyIndex = +await obj.lastKey;
						if (await $Lt._gc.Array.isArray(await obj.context) && typeof lastKeyIndex == "number") {
							let callReplaceAt = lastKeyIndex < await (await obj.context).length;
							if (await (await obj.context)[lastKeyIndex] !== await target[attributeName] || !callReplaceAt) {
								await _LC.aF(await obj.context, callReplaceAt ? "replaceAt" : "insertAt", lastKeyIndex, await target[attributeName]);
							}
						} else {
							await _LC.set(await obj.context, await obj.lastKey, await target[attributeName]);
						}
					}
					if (target) {
						await _LC.rmCx(target, contextSwitchArray);
					}
				};
			await $Lt._gc.document.addEventListener("change", changeEventHandler);
			var docCaptureGlobalEventHandler = async function (ev) {
					var evnt = await ev.type;
					if (await window.docEventListenerHandler && await (await window.docEventListenerHandler).docEventlisteners && await (await (await (await ev.composedPath())[0]).getRootNode()).host) {
						let listenerArr = await (await (await (await window.docEventListenerHandler).docEventlisteners).capture)[evnt];
						if (listenerArr) {
							let listenerArrCpy = await $Lt._gc.Array.from(listenerArr);
							await $Lt._fE(listenerArrCpy, async function (listener) {
								if (await listenerArr.indexOf(listener) != -1) {
									await listener(ev);
								}
							});
						}
					}
				};
			var docBubbleGlobalEventHandler = async function (ev) {
					var evnt = await ev.type;
					if (await window.docEventListenerHandler && await (await window.docEventListenerHandler).docEventlisteners && await (await (await (await ev.composedPath())[0]).getRootNode()).host) {
						let listenerArr = await (await (await (await window.docEventListenerHandler).docEventlisteners).bubble)[evnt];
						if (listenerArr) {
							let listenerArrCpy = await $Lt._gc.Array.from(listenerArr);
							await $Lt._fE(listenerArrCpy, async function (listener) {
								if (await listenerArr.indexOf(listener) != -1) {
									await listener(ev);
								}
							});
						}
					}
				};
			var globalEventHandler = async function (ev) {
					var target = await ev.target;
					var evnt = await ev.type;
					var toRemove;
					if (await (/^(click|dblclick)$/).test(evnt) && await target.getAttribute && (await target.getAttribute("lyte-state") != null && !await _Lyte.isWidgetBuild)) {
						await ev.preventDefault();
						return;
					}
					if (await ev.currentTarget && await ev.currentTarget !== await $Lt._gc.document.body && !await $Lt._iO(await ev.currentTarget, $Lt._gc.DocumentFragment)) {
						target = await ev.currentTarget;
					}
					if (await _LC._windowEvNeeded) {
						toRemove = true;
						window.event = ev;
					}
					let eventStopped = false;
					while (target && await target.getAttribute && (!await target.getAttribute(evnt) || !await [
							"mouseenter",
							"mousemove",
							"mouseover",
							"mouseout",
							"mouseleave"
						].includes(await ev.type) && await target.hasAttribute("disabled") && evnt != "blur") && await target.tagName != "BODY") {
						if (await target._hiddenBoundEvents && await (await target._hiddenBoundEvents)[evnt]) {
							break;
						}
						if (await _LC.hasLyteEvents(target, evnt)) {
							eventStopped = await _LC.handleLyteEvents(target, ev);
							if (eventStopped) {
								break;
							}
						}
						target = await target.parentNode;
					}
					if (eventStopped || !target) {
						if (await ev._handledResolve) {
							await ev._handledResolve();
						}
						return;
					}
					var callee = target;
					if (await target._callee && await (await target._callee).component && await (await (await (await target._callee).component).constructor)._v4 || await target.component && await (await target.component).constructor && await (await (await target.component).constructor)._v4) {
						return;
					}
					if (!await target._callee) {
						while (callee && !await _LC.isCustomElementV3(callee) && await callee.tagName !== "LYTE-YIELD") {
							if (await callee.tagName === "BODY") {
								callee = null;
								break;
							}
							callee = await callee.parentNode;
						}
						if (callee && await callee.tagName === "LYTE-YIELD") {
							target._callee = await (await callee._registerYield)._callee;
						} else {
							target._callee = callee === target ? $Lt._gc.undefined : callee;
						}
					}
					if (await target._evBoundEvents && await (await target._evBoundEvents)[evnt]) {
						let actObj = await (await target._evBoundEvents)[evnt];
						let cloneActObj = await _Lyte.deepCopyObject(actObj);
						await _LC.skipArgProcessing(cloneActObj, ev, target);
						await (await _LC.throwAction).call(target, target, evnt, cloneActObj, $Lt._gc.undefined, $Lt._gc.undefined, target, ev, $Lt._gc.undefined, true);
					} else if (await target.getAttribute && await target.getAttribute(evnt) && await target._boundEvents && await (await target._boundEvents)[evnt]) {
						let func = await (await (await target.getAttribute(evnt)).split(" => "))[1];
						let actObj = await (await target._boundEvents)[evnt];
						let cloneActObj = await _Lyte.deepCopyObject(actObj);
						await _LC.skipArgProcessing(cloneActObj, ev, target);
						await (await _LC.throwAction).call(await target._callee, await target._callee, evnt, cloneActObj, $Lt._gc.undefined, $Lt._gc.undefined, target, ev);
					}
					await _LCHD.triggerGlobalEvent(target, evnt, ev);
					if (await target.tagName === "LABEL") {
						var input = await target.querySelector("input");
						if (input && await input.getAttribute(evnt)) {
							let func = await (await (await input.getAttribute(evnt)).split(" => "))[1];
							let actObj = await (await target._boundEvents)[evnt];
							let cloneActObj = await _Lyte.deepCopyObject(actObj);
							await _LC.skipArgProcessing(cloneActObj, ev, target);
							await (await _LC.throwAction).call(await target._callee, await target._callee, evnt, cloneActObj, $Lt._gc.undefined, $Lt._gc.undefined, input, ev);
						}
					}
					if (toRemove) {
						window.event = $Lt._gc.undefined;
					}
					if (await ev._handledResolve) {
						await ev._handledResolve();
					}
				};
			class LyteYield extends $Lt._gc.HTMLElement {
				constructor() {
					super();
					$Lt.getCp(this).push(async function () {
						await this.decideConstructor();
					}.call(this));
				}
				async decideConstructor() {
					if (ltCf && (await ltCf.v4 || await (await window.__lyteConfig).isWidgetBuild)) {
						let V3Registry = await (await (await ltCf.versionBridge).component).V3Registry;
						let foundInV4List = await (await (await V3Registry.allList).v4)[await this.localName];
						let foundInV3List = await (await (await V3Registry.allList).v3)[await this.localName];
						let foundInWidgetList = await (await (await V3Registry.allList).widget)[await this.localName];
						if (foundInV4List) {
							if (!foundInV3List || (await this._callee && await (await this._callee).__v4 || await this.hasAttribute("lyte-v4") || await this.hasAttribute("lyte-registry") || await ltCf.lyteV4 || await ltCf.fromV4Render)) {
								let v4CompClass = foundInV4List;
								let self = this;
								await $Lt._fE(await LyteYield._V4InsApi, async function (apiName) {
									self[apiName] = await (await v4CompClass.prototype)[apiName];
								});
							}
						} else if (foundInWidgetList) {
							if (await this._callee && await (await this._callee).__widget || await this.hasAttribute("lyte-widget") || await (await window.__lyteConfig).isWidgetComponent || await ltCf.lyteWidget || await ltCf.fromWidgetRender) {
								let widgetCompClass = foundInWidgetList;
								let self = this;
								if (await (await ltCf._firstRegisteredComp)[await this.localName] != "widget") {
									await $Lt._fE(await LyteYield._V3InsApi, async function (apiName) {
										self[apiName] = await (await widgetCompClass.prototype)[apiName];
									});
								}
							} else if (foundInV3List) {
								let v3CompClass = foundInV3List;
								if (await (await ltCf._firstRegisteredComp)[await this.localName] != "v3") {
									await $Lt._fE(await LyteYield._V3InsApi, async function (apiName) {
										$Lt._gc.self[apiName] = await (await v3CompClass.prototype)[apiName];
									});
								}
							} else {
								await (await (await _LC.V3).pendingComp).add(this);
								this.__v3lyteIgnore = true;
								return;
							}
						}
					}
				}
				async connectedCallback() {
					await this._connectedCallback();
				}
				async _connectedCallback() {
					this._callee = await this._callee || await _LC.getCallee(await this.parentNode, this);
					await (await _LCHD.yield).connect(this);
					if (!await this._registerYield && await this._callee) {
						var yieldName;
						if (await (await this._callee)._fR && await (await (await this._callee)._fR)._yieldCallee) {
							this._registerYield = { "_callee": await (await (await (await (await this._callee)._fR)._yieldCallee).component).$node };
						} else if (await (await this._callee)._yields && (yieldName = await (await this.attributes)["yield-name"]) && (yieldName = await yieldName.nodeValue) && await (await (await this._callee)._yields)[yieldName]) {
							this._registerYield = { "_callee": await (await (await (await this._callee)._yields)[yieldName])._callee };
						}
					}
				}
				async disconnectedCallback() {
					await this._disconnectedCallback();
				}
				async _disconnectedCallback() {
					if (await this.__v3lyteIgnore) {
						await (await (await _LC.V3).pendingComp).remove(this);
						return;
					}
					if (await _LyteComponent.shouldIgnoreDisconnect() || await this._deleted || await this._ignoreDisconnect) {
						return;
					}
					await (await _LCHD.yield).disConnect(this);
					this._deleted = true;
					if (!await this._properties) {
						return;
					}
					var nodeContextSwitchArray = [];
					let cmpData = await LyteComponent.getCmpData(await (await this.component).data);
					await _LC.adCx(this, nodeContextSwitchArray);
					await _LC.removeSelectedBindingDeep(await this._properties, cmpData, true);
					let node = await this._registerYield;
					if (!node) {
						await _LC.rmCx(this, nodeContextSwitchArray);
						return;
					}
					var toAppendContextSwitchArray = [];
					this._parentHelper = null;
					var del = "delete";
					await _LC.adCx(node, toAppendContextSwitchArray);
					for (let key in await this._dynamicProperty) {
						if (await (await (await this._dynamicProperty)[key]).isActualNode) {
							await (await (await (await (await this._dynamicProperty)[key]).isActualNode)._helperNodes)[del](this);
						} else {
							let helperNodes = await (await (await node._callee).getProperty(key))._helperNodes;
							if (helperNodes) {
								await helperNodes[del](this);
							}
						}
					}
					this._dynamicProperty = {};
					for (let i = 0; i < await (await this._helpers).length; (i = i + 1) - 1) {
						await (await node._callee).removeHelpers(await (await this._helpers)[i]);
					}
					this._helpers = [];
					await _LC.rmCx(node, toAppendContextSwitchArray);
					await _LC.rmCx(this, nodeContextSwitchArray);
				}
				async getProperty(key) {
					var arr = await key.match((/([^[\].]+|\[\])/g));
					let property = this;
					if (!await (await property._properties)[await arr[0]]) {
						(await property._properties)[await arr[0]] = {};
					}
					property = await (await property._properties)[await arr[0]];
					await $Lt._gcFn.defProp(property, "_path", {
						enumerable: false,
						value: await arr[0]
					});
					for (let i = 1; i < await arr.length; (i = i + 1) - 1) {
						if (await (await arr[i]).startsWith("'") || await (await arr[i]).startsWith("\"")) {
							arr[i] = await (await arr[i]).substring(1, await (await arr[i]).length - 1);
						}
						if (!await property[await arr[i]]) {
							property[await arr[i]] = {};
							await $Lt._gcFn.defProp(await property[await arr[i]], "_path", {
								enumerable: false,
								value: await property._path + "." + await arr[i]
							});
						}
						property = await property[await arr[i]];
					}
					return property;
				}
			}
			LyteYield._V4InsApi = [
				"_connectedCallback",
				"getProperty",
				"_disconnectedCallback"
			];
			LyteYield._V3InsApi = [
				"_connectedCallback",
				"getProperty",
				"_disconnectedCallback"
			];
			await $Lt._gc.customElements.define("lyte-yield", LyteYield, $Lt._gc.undefined, await _Lyte.isWidgetBuild ? { "widget": true } : { v3: true });
			class customElementPrototype extends elementPrototype {
				constructor() {
					super();
					$Lt.getCp(this).push(async function () {
						if (await window.isLyteWidget && await window.parentWrapperComps && await (await window.parentWrapperComps).indexOf(await this.tagName) != -1 && !await (await this.children).length) {
							this.__lyteIgnore = true;
						}
						if (await window.ignoreParent) {
							this.__lyteIgnore = true;
							return;
						}
						await this.decideConstructor();
					}.call(this));
				}
				async decideConstructor() {
					if (await window.__lyteConfig && (await (await window.__lyteConfig).v4 || await (await window.__lyteConfig).isWidgetBuild)) {
						let self = this;
						let V3Registry = await (await (await ltCf.versionBridge).component).V3Registry;
						let foundInV4List = await (await (await V3Registry.allList).v4)[await this.localName];
						let foundInV3List = await (await (await V3Registry.allList).v3)[await this.localName];
						let foundInWidgetList = await (await (await V3Registry.allList).widget)[await this.localName];
						if (foundInV4List) {
							if (!foundInV3List || (await this._callee && await (await this._callee).__v4 || await this.hasAttribute("lyte-v4") || await this.hasAttribute("lyte-registry") || await ltCf.lyteV4 || await ltCf.fromV4Render)) {
								let v4compClass = foundInV4List;
								await $Lt._fE(await customElementPrototype._V4InsApi, async function (apiName) {
									self[apiName] = await (await v4compClass.prototype)[apiName];
								});
								this.setData = await (await (await v4compClass.componentClass).prototype).setData;
								this.setMethods = await (await (await v4compClass.componentClass).prototype).setMethods;
							} else if (foundInV3List) {
								let v3CompClass = foundInV3List;
								self.component = (await self.constructor).component = await v3CompClass.component;
							}
						} else if (foundInWidgetList) {
							if (await this._callee && await (await this._callee).__widget || await ltCf.__widget || await this.hasAttribute("lyte-widget") || await (await window.__lyteConfig).isWidgetComponent || await ltCf.lyteWidget || await ltCf.fromWidgetRender) {
								let widgetCompClass = foundInWidgetList;
								if (await (await ltCf._firstRegisteredComp)[await this.localName] != "widget") {
									await $Lt._fE(await customElementPrototype._V3InsApi, async function (apiName) {
										self[apiName] = await (await widgetCompClass.prototype)[apiName];
									});
								}
								self.component = await widgetCompClass.component;
								self.__widget = true;
							} else if (foundInV3List) {
								let v3CompClass = foundInV3List;
								if (await (await ltCf._firstRegisteredComp)[await this.localName] != "v3") {
									await $Lt._fE(await customElementPrototype._V3InsApi, async function (apiName) {
										self[apiName] = await (await v3CompClass.prototype)[apiName];
									});
								}
								self.component = await v3CompClass.component;
							} else {
								await (await (await _LC.V3).pendingComp).add(this);
								this.__v3lyteIgnore = true;
								return;
							}
						} else if (await this.hasAttribute("lyte-widget") || await (await window.__lyteConfig).isWidgetComponent || await ltCf.lyteWidget || await ltCf.fromWidgetRender) {
							await (await (await _LC.V3).pendingComp).add(this);
							this.__v3lyteIgnore = true;
							return;
						}
					}
					await this.actualConstructor();
				}
				async doRegistration(componentName, customCrmComponent) {
					if (!await (await (await this.component).constructor).__isRegistered) {
						if (await (await idleScheduler.tasks).get(componentName) || await idleScheduler.currentTask && await (await idleScheduler.currentTask).id === componentName) {
							if (await idleScheduler.currentTask && await (await idleScheduler.currentTask).id !== componentName) {
								if (await Lyte.performance) {
									var _p1 = await $Lt._gc.performance.now();
								}
								var sval = await (await idleScheduler.tasks).get(await (await idleScheduler.currentTask).id);
								if (sval && await idleScheduler.isGenerator(await sval.handler)) {
									var gnxt = await (await sval.handler).next(), gval;
									while (await gnxt.done == false) {
										gval = await gnxt.value;
										if (typeof gval == "function") {
											await gval();
										}
										gnxt = await (await sval.handler).next();
									}
									await idleScheduler.dequeueTask(await (await idleScheduler.currentTask).id);
								}
								if (await Lyte.performance) {
									var _p2 = await $Lt._gc.performance.now();
									var oldPerf = await (await (await Lyte.Component).registerPerf)[await (await idleScheduler.currentTask).id];
									(await (await Lyte.Component).registerPerf)[await (await idleScheduler.currentTask).id] = (oldPerf ? oldPerf : 0) + (_p2 - _p1);
								}
							}
							if (await Lyte.performance) {
								var p1 = await $Lt._gc.performance.now();
							}
							var obj = await idleScheduler.dequeueTask(componentName);
							var gen = await obj.handler;
							if (await idleScheduler.isGenerator(gen)) {
								var gnxt = await gen.next(), gval;
								while (await gnxt.done == false) {
									gval = await gnxt.value;
									if (typeof gval == "function") {
										await gval();
									}
									gnxt = await gen.next();
								}
							}
							if (await Lyte.performance) {
								var p2 = await $Lt._gc.performance.now();
								var oldPerf = await (await (await Lyte.Component).registerPerf)[componentName];
								(await (await Lyte.Component).registerPerf)[componentName] = (oldPerf ? oldPerf : 0) + (p2 - p1);
							}
						} else {
							if (await Lyte.performance) {
								var p1 = await $Lt._gc.performance.now();
							}
							await customCrmComponent._registerComponent(componentName, customCrmComponent, await (await customCrmComponent.component)._widget);
							await _LC.postRegistration(componentName, customCrmComponent);
							await idleScheduler.dequeueTask(componentName);
							if (await Lyte.performance) {
								var p2 = await $Lt._gc.performance.now();
								var oldPerf = await (await (await Lyte.Component).registerPerf)[componentName];
								(await (await Lyte.Component).registerPerf)[componentName] = (oldPerf ? oldPerf : 0) + (p2 - p1);
							}
						}
					}
				}
				async actualConstructor() {
					if (await this.hasAttribute("lyte-rendered") || await this._ccCalled) {
						this.__lyteIgnore = true;
						return;
					} else if (!await (await _LyteComponent.registeredComponents)[await this.localName]) {
						this.__lyteIgnore = true;
						var origClass = await (await _LC._registeredComponents)[await this.localName];
						origClass._pendingComponents = await origClass._pendingComponents || [];
						await (await origClass._pendingComponents).push(this);
						return;
					}
					this.__v3 = true;
					var wdt = await _LyteComponent.currentWidget ? await _LyteComponent.currentWidget : await this._callee ? await (await this._callee).__lyteWidget : $Lt._gc.undefined;
					this.constr = await this.constructor;
					var widget = this.constructor.__widgetName;
					var map;
					if (widget) {
						map = widgetMap;
						window.ss = widgetMap;
						widget = map.get(widget);
					}
					((await this.constr).activeInstances = await (await this.constr).activeInstances + 1) - 1;
					((await (await this.constructor).component).activeInstances = await (await (await this.constructor).component).activeInstances + 1) - 1;
					let fastRenderIndex;
					let lytePropAttr = await (await this.attributes)._lyteprop;
					lytePropAttr = lytePropAttr ? await lytePropAttr.nodeValue : $Lt._gc.undefined;
					let fastRenderedProp = (fastRenderIndex = lytePropAttr) ? await (await _LC.fRP)[fastRenderIndex] : $Lt._gc.undefined;
					let compInstance = this.component = fastRenderedProp ? await fastRenderedProp.component : await this.component ? await $Lt._cO(await this.component) : await $Lt._cO(await (await this.constructor).component);
					compInstance.__isComponent__ = true;
					if (await Lyte.getConfig("lazyComponentRegister")) {
						await this.doRegistration(await this.localName, await this.constructor);
					}
					this._properties = {};
					this.registeredProp = await (await (await _LC.directive).registeredProp)[await this.localName];
					compInstance._config = await (await this.constructor)._config;
					let compData;
					var act = await compInstance.actions;
					if (!fastRenderedProp) {
						var _cmpData = {};
						compData = compInstance.data = {};
						let data = await (await (await this.component).constructor)._data ? await (await (await (await this.component).constructor)._data).apply(compInstance) : {};
						var def = "default";
						await $Lt._gcFn.defProp(_cmpData, "__component__", {
							value: this,
							configurable: true,
							writable: true,
							enumerable: false
						});
						_cmpData.errors = {};
						compData = compInstance.data = _cmpData;
						if (await (await _LC.__data).length) {
							await $Lt._fE(await _LC.__data, async function (item) {
								data = await $Lt._gc.Object.assign(data, item);
							});
						}
						compInstance.__data = data;
						this._hideAttr = {};
						var self = this;
						for (let key in data) {
							var obj = await data[key];
							compData[key] = await obj[def];
							if (await obj.initialize) {
								if (typeof await obj.initialize == "function") {
									var promise = await (await obj.initialize).apply(await self.component);
									if (promise) {
										compData[key] = promise;
									} else {
										await _Lyte.error("LC011", key, await self.tagName);
									}
								}
							}
							var customDtype;
							if (await (await Lyte.Transform)[await obj.type]) {
								var customDataType = await (await Lyte.Transform)[await obj.type];
								if (await (/^(object|array)$/).test(await customDataType.extends) && (await customDataType.hasOwnProperty("properties") || await customDataType.hasOwnProperty("items"))) {
									customDtype = true;
								}
							}
							if (await (/^(object|array)$/).test(await obj.type) && await obj.watch || customDtype) {
								await Lyte.establishObjectBinding(compData, key, false, $Lt._gc.undefined, $Lt._gc.undefined, await obj.watch ? true : $Lt._gc.undefined);
							}
							if (await obj.hasOwnProperty("hideAttr")) {
								(await this._hideAttr)[key] = await obj.hideAttr;
							}
						}
						if (await this._initMethods) {
							let arr = await $Lt._gc.Object.keys(await this._initMethods);
							compData.$methodAttributes = await arr.reduce(async (obj, key) => {
								obj[key] = true;
								return obj;
							}, {});
						}
						if (await this.$data) {
							let initProperties = await this.$data;
							for (let key in initProperties) {
								compData[key] = await initProperties[key];
							}
						}
						this.$data = compData;
						if (await this._initProperties) {
							let arr = await (await $Lt._gc.Object.keys(await this._initProperties)).filter(async ele => {
									if (!await compData.$methodAttributes) {
										return true;
									}
									;
									return !await (await compData.$methodAttributes)[ele];
								});
							compData.$dataAttributes = await arr.reduce(async (obj, key) => {
								obj[key] = true;
								return obj;
							}, {});
						}
						let observed_attributes = await (await (await this.component).constructor)._observedAttributes;
						if (observed_attributes && await this.attributes) {
							await $Lt._fE(await $Lt._gc.Object.values(await this.attributes), async value => {
								if (await observed_attributes.includes(await (await _LC.String).toCamelCase(await value.name))) {
									compData.$dataAttributes = await compData.$dataAttributes ? await compData.$dataAttributes : [];
									(await compData.$dataAttributes)[await (await _LC.String).toCamelCase(await value.name)] = true;
								}
							});
						}
						observed_attributes = [];
						compInstance.$dataAttributes = await compData.$dataAttributes;
						compInstance.$methodAttributes = await compData.$methodAttributes;
						if (await compInstance.$dataAttributes) {
							await $Lt._gc.Object.freeze(await compInstance.$dataAttributes);
							await $Lt._gc.Object.freeze(await compData.$dataAttributes);
						}
						if (await compInstance.$methodAttributes) {
							await $Lt._gc.Object.freeze(await compInstance.$methodAttributes);
							await $Lt._gc.Object.freeze(await compData.$methodAttributes);
						}
						compInstance.$data = compData;
						if (await window.isLyteWidget) {
							await _LCSV.connect(this);
						}
						if (await (await this.constructor)._serviceToBeUsed) {
							for (var serKey in await (await this.constructor)._serviceToBeUsed) {
								var serName = await (await (await this.constructor)._serviceToBeUsed)[serKey];
								if (await (await Lyte.registeredServices).hasOwnProperty(serName)) {
									(await this.component)[serKey] = await $Lt._cO(await (await Lyte.registeredServices)[serName]);
								} else {
									this.__toRemoveLazy = await this.__toRemoveLazy || {};
									var self = this;
									var id = await (await Lyte.$).requiredServices(serKey, serName, async function (serviceData, serviceKey, _sname, servName) {
											(await self.component)[serviceKey] = await (await Lyte.$).instantiateService(servName);
											var _toRemove = await (await self.__toRemoveLazy)[servName];
											await $Lt._fE(_toRemove, async function (id) {
												await (await Lyte.$).toRemoveFromRequiredServices(id);
											});
											delete (await self.__toRemoveLazy)[servName];
										});
									(await this.__toRemoveLazy)[serName] = await (await this.__toRemoveLazy)[serName] || [];
									await (await (await this.__toRemoveLazy)[serName]).push(id);
								}
							}
						}
						await this.initializeMethod(this, await (await (await this.component).constructor)._methods);
					}
					if (await compInstance.$node) {
						for (var key in await compInstance.$node) {
							if (key != "localName") {
								this[key] = await (await compInstance.$node)[key];
							}
						}
					}
					compInstance.$node = this;
					for (let propName in await _LyteComponent.customPropHandlersList) {
						this[propName] = await (await _LyteComponent.customPropHandlersList)[propName];
					}
					if (await this.component && await (await (await this.component).constructor)._template && await (await (await (await this.component).constructor)._template).widget) {
						this.__lyteWidget = await (await (await (await this.component).constructor)._template).widget;
						var widget = await $Lt._gc.widgetMap.get(await this.__lyteWidget);
						widget ? await (await widget.components).set(this, true) : $Lt._gc.undefined;
					}
					let _config_flag;
					if (await compInstance._config) {
						_config_flag = await (await compInstance._config).clientLifeCycleHooks == true || (typeof await (await compInstance._config).clientLifeCycleHooks == "object" ? await (await (await compInstance._config).clientLifeCycleHooks).includes("constructor") : false);
					}
					let _overrides;
					if (!fastRenderedProp) {
						this._actions = await this._actions ? await this._actions : {};
						this._callee = await this._callee || await this.getCallee(await this.parentNode);
						if (await this._callee && await (await this.constructor).__widgetName) {
							if (await (await (await this._callee).constructor).__widgetName != await (await this.constructor).__widgetName) {
								await (await widget.additionalComps).add(await this.parentElement);
							}
						}
						if (_config_flag || !await this.hasAttribute("server-rendered")) {
							if (_overrides && await _overrides.constructor && await this.serverCall) {
								await (await _overrides.constructor).apply(this);
							} else {
							}
						}
						for (var key in compData) {
							if ((await window.isLyteWidget || await window.__lyteEnablePromise) && await $Lt._iO(await compData[key], $Lt._gc.Promise)) {
								continue;
							}
							var error = await _LC.handleValidation(compData, key, await compData[key], compInstance, true);
							if (error) {
								compData[key] = $Lt._gc.undefined;
							}
						}
					} else {
						this._fR = fastRenderedProp;
						delete (await _LC.fRP)[fastRenderIndex];
					}
				}
				async getMethods(arg0) {
					return await (await this.component).getMethods(arg0);
				}
				async hasAction(arg0) {
					return await (await this.component).hasAction(arg0);
				}
				async setActions(arg0, arg1) {
					return await (await this.component).setActions(arg0, arg1);
				}
				async setMethods(arg0, arg1) {
					return await (await this.component).setMethods(arg0, arg1);
				}
				async getCallee(callee) {
					return await _LC.getCallee(callee, this);
				}
				async afterConnected(fastRenderProp, ssrBind) {
					let constr = await this.constructor;
					let compConstr = await (await this.component).constructor;
					if (await (await this.constructor)._mutable === true || await Lyte.getConfig("mutable")) {
						(await this.component).data = await Lyte.mut(await (await this.component).data);
					}
					if (await this.getAttribute("_lyteprop")) {
						return "";
					}
					let obsattr = await compConstr._observedAttributes;
					for (let i = 0; i < await obsattr.length; (i = i + 1) - 1) {
						let key = await obsattr[i];
						let prop = await this.getProperty(key);
						await $Lt._gcFn.defProp(prop, "__fromComponent", {
							value: true,
							enumerable: false
						});
					}
					await this.getProperty("errors");
					var $lg = await Lyte.__gl, compInstance = await this.component, compData = await compInstance.data;
					compData.$lg = $lg;
					if (await this._initProperties) {
						let initProperties = await this._initProperties;
						for (let key in initProperties) {
							let actVal;
							let field = await (await compInstance.__data)[key];
							if (field && await field.type !== await _LC.getDataType(await initProperties[key]) && (await initProperties[key] !== $Lt._gc.undefined || await field.type === "boolean")) {
								actVal = await _LC.typeCast(await initProperties[key], await (await (await compInstance.__data)[key]).type);
							} else {
								actVal = await initProperties[key];
							}
							let error = await _LC.handleValidation(compData, key, actVal, compInstance, true);
							if (!error) {
								compData[key] = actVal;
								var customDtype;
								if (field && await (await Lyte.Transform)[await field.type]) {
									var customDataType = await (await Lyte.Transform)[await field.type];
									if (await (/^(object|array)$/).test(await customDataType.extends) && (await customDataType.hasOwnProperty("properties") || await customDataType.hasOwnProperty("items"))) {
										customDtype = true;
									}
								}
								if (field && await (/^(object|array)$/).test(await field.type) && await field.watch || customDtype) {
									await Lyte.establishObjectBinding(compData, key, $Lt._gc.undefined, $Lt._gc.undefined, $Lt._gc.undefined, await field.watch ? true : $Lt._gc.undefined);
								}
							}
						}
						this._initProperties = $Lt._gc.undefined;
					}
					if (await this._initMethods) {
						let initMethods = await this._initMethods;
						for (let key in initMethods) {
							(await (await compInstance.$node)._methods)[key] = await initMethods[key];
						}
						this._initMethods = $Lt._gc.undefined;
					}
					await _LCSV.afterConnect(this);
					let _config_flag;
					if (await compInstance._config) {
						if (await (await compInstance._config).clientLifeCycleHooks != $Lt._gc.undefined) {
							_config_flag = await (await compInstance._config).clientLifeCycleHooks == true || (typeof await (await compInstance._config).clientLifeCycleHooks == "object" ? await (await (await compInstance._config).clientLifeCycleHooks).includes("init") : false);
						}
					}
					let _overrides;
					ssrBind && await this.cmpBind(fastRenderProp);
					if (await window.isLyteWidget) {
						let errorDetails = await (await (await this.component).data).errors;
						if (await (await $Lt._gc.Object.keys(errorDetails)).length) {
							compData._error = true;
						}
					}
					if (_config_flag || !await this.hasAttribute("server-rendered")) {
						if (_overrides && await _overrides.init && await this.serverCall) {
							await (await _overrides.init).apply(this);
						} else {
							await this.callback("init");
						}
						await this.onCallBack("init");
					}
					await this.registerYields();
					if (await compData.lyteUnbound) {
						_LC.unbound = true;
					}
					let content = "";
					let unboundBeta = await compData.lyteFastRender;
					if (!unboundBeta) {
						content = await this.renderNodes(await compConstr._template, await compConstr._dynamicNodes, $Lt._gc.undefined, $Lt._gc.undefined, $Lt._gc.undefined, $Lt._gc.undefined, await compConstr._tC, $Lt._gc.undefined, true);
					} else {
						content = await this.renderFast(await compConstr._dynamicNodes, await compConstr._sta, compInstance);
						await $Lt._gcFn.requestAnimationFrame(async function () {
							await $Lt._gcFn.requestAnimationFrame(async function () {
								await _LC.callCC();
							});
						});
					}
					return content;
				}
				async initializeMethod(node, actMethods) {
					let compInstance;
					if (await node.component) {
						compInstance = await node.component;
					} else {
						compInstance = node;
						node = await compInstance.$node;
					}
					compInstance.methods = {};
					node._methods = await compInstance.methods;
					for (let key in actMethods) {
						(await compInstance.methods)[key] = await actMethods[key];
					}
				}
				async renderComponent(dynNode, preDefObj) {
					var componentName = await dynNode.componentName;
					var staticAttrs = await dynNode.staticAttrs;
					var constr = await (await LyteComponent._registeredComponents)[componentName];
					if (!constr) {
						return "";
					}
					var compConstr = await (await (await LyteComponent._registeredComponents)[componentName]).component;
					var component = await $Lt._cO(await constr.component);
					preDefObj.component = component;
					if (await Lyte.getConfig("lazyComponentRegister")) {
						await this.doRegistration(componentName, constr);
					}
					if (await (await this.constructor)._mutable === true || await Lyte.getConfig("mutable")) {
						component.data = await Lyte.mut({});
					} else {
						component.data = {};
					}
					let cmpData = await LyteComponent.getCmpData(await component.data);
					let data = await compConstr._data ? await (await compConstr._data).apply(component) : {};
					var def = "default";
					for (let key in data) {
						cmpData[key] = await (await data[key])[def];
					}
					cmpData.errors = {};
					component.__data = data;
					var obsAttrs = await (await (await (await LyteComponent._registeredComponents)[componentName]).component)._observedAttributes;
					preDefObj.data = await preDefObj.data || {};
					for (var key in staticAttrs) {
						if (await obsAttrs.indexOf(key) !== -1) {
							(await preDefObj.data)[key] = await staticAttrs[key];
						}
					}
					let initProperties = await preDefObj.data;
					if (initProperties) {
						for (let key in initProperties) {
							let actVal;
							if (await (await component.__data)[key] && await (await (await component.__data)[key]).type !== await _LC.getDataType(await initProperties[key]) && (await initProperties[key] !== $Lt._gc.undefined || await (await (await component.__data)[key]).type === "boolean")) {
								actVal = await _LC.typeCast(await initProperties[key], await (await (await component.__data)[key]).type);
							} else {
								actVal = await initProperties[key];
							}
							let error = await _LC.handleValidation(cmpData, key, actVal, component);
							if (!error) {
								cmpData[key] = actVal;
							}
						}
					}
					if (true) {
						component.$node = {
							"querySelector": noop,
							"localName": componentName
						};
						await this.initializeMethod(component, await compConstr._methods);
						if (await component.init) {
							await (await component.init).apply(component);
						}
						let initCallbacks;
						if (await compConstr._callBacks && (initCallbacks = await (await compConstr._callBacks).init)) {
							for (let i = 0; i < await initCallbacks.length; (i = i + 1) - 1) {
								await (await (await initCallbacks[i]).value).apply(component);
							}
						}
						preDefObj.unbound = true;
						delete (await component.$node).querySelector;
						if (await Lyte.getConfig("lazyComponentRegister") && !await (await (await (await LyteComponent._registeredComponents)[componentName]).component).__isRegistered) {
							var sval = await (await (await Lyte.Component).lazyRegisterScheduler).dequeueTask(componentName);
							if (await Lyte.performance) {
								var p1 = await $Lt._gc.performance.now();
							}
							if (sval && await idleScheduler.isGenerator(await sval.handler)) {
								var gnxt = await (await sval.handler).next(), gval;
								while (await gnxt.done == false) {
									gval = await gnxt.value;
									if (typeof gval == "function") {
										await gval();
									}
									gnxt = await (await sval.handler).next();
								}
							}
							if (await Lyte.performance) {
								var p2 = await $Lt._gc.performance.now();
								var oldPerf = await (await (await Lyte.Component).registerPerf)[componentName];
								(await (await Lyte.Component).registerPerf)[componentName] = (oldPerf ? oldPerf : 0) + (p2 - p1);
							}
						}
						return await this.renderFast(await (await (await (await LyteComponent._registeredComponents)[componentName]).component)._dynamicNodes, await (await (await (await LyteComponent._registeredComponents)[componentName]).component)._sta, component, preDefObj);
					}
				}
				async renderFast(dynamicNodes, arr, comp, compPreDef) {
					var fastRenderIndex;
					var prevComp;
					if (comp) {
						prevComp = await this.component;
						this.component = comp;
					}
					var compData = await LyteComponent.getCmpData(await (await this.component).data);
					var str = "";
					var dynamicCompile = arr;
					var dynamicCompileNodes = await arr.cc;
					let removeFirstChar = false;
					for (var i = 0; i < await dynamicCompileNodes.length; (i = i + 1) - 1) {
						if (await dynamicCompileNodes[i] != $Lt._gc.undefined) {
							var inte = await dynamicCompileNodes[i];
							var dynNode = await dynamicNodes[inte];
							if (await dynNode.dynamicValue) {
								let locVal = await _LC.getDD(compData, await dynNode.newDynamicValue);
								locVal = locVal == $Lt._gc.undefined || locVal == null ? "" : locVal;
								str = str + await (await Lyte.Security).escape(locVal);
							} else if (await dynNode.helperInfo) {
								_LC.ffr = true;
								let helperVal = await this.processHelper({
										name: await (await dynNode.helperInfo).name,
										args: await this.processArgs(this, dynNode, [], $Lt._gc.undefined, $Lt._gc.undefined, true)
									}, $Lt._gc.undefined);
								_LC.ffr = false;
								helperVal = helperVal == $Lt._gc.undefined || helperVal == null ? "" : helperVal;
								str = str + (await (await dynNode.helperInfo).name === "unescape" ? helperVal : await (await Lyte.Security).escape(helperVal));
							} else if (await dynNode.type) {
								switch (await dynNode.type) {
								case "for": {
										let prevDynamic = await (await (await dynamicNodes[inte - 1]).attr).items;
										var items;
										if (await prevDynamic.dynamicValue) {
											items = await _LC.getDD(compData, await prevDynamic.newDynamicValue);
										} else if (await prevDynamic.helperInfo) {
											items = await this.processHelper({
												name: await (await prevDynamic.helperInfo).name,
												args: await this.processArgs(this, prevDynamic, [], $Lt._gc.undefined, $Lt._gc.undefined, true)
											}, $Lt._gc.undefined);
										}
										var itemKey = await (await dynNode._args).item || "item";
										var indexKey = await (await dynNode._args).index || "index";
										let renderedStr = "";
										if (items && await items.length) {
											var initialItemValue = await compData[itemKey];
											var initialIndexValue = await compData[indexKey];
											for (var indexInd = 0; indexInd < await items.length; (indexInd = indexInd + 1) - 1) {
												let item = await items[indexInd];
												compData[itemKey] = item;
												compData[indexKey] = indexInd;
												renderedStr += await this.renderFast(await dynNode.dynamicNodes, await dynNode._sta, $Lt._gc.undefined, compPreDef);
											}
											compData[itemKey] = initialItemValue;
											compData[indexKey] = initialIndexValue;
										}
										str += renderedStr;
									}
									break;
								case "forIn": {
										let prevDynamic = await (await (await dynamicNodes[inte - 1]).attr).object;
										var object;
										if (await prevDynamic.dynamicValue) {
											object = await _LC.getDD(compData, await prevDynamic.newDynamicValue);
										} else if (await prevDynamic.helperInfo) {
											object = await this.processHelper({
												name: await (await prevDynamic.helperInfo).name,
												args: await this.processArgs(this, prevDynamic, [], $Lt._gc.undefined, $Lt._gc.undefined, true)
											}, $Lt._gc.undefined);
										}
										var valueKey = await (await dynNode._args).value || "value";
										var keyKey = await (await dynNode._args).key || "key";
										let renderedStr = "";
										let objKeys;
										if (object && (objKeys = await $Lt._gc.Object.keys(object))) {
											var initialValueValue = await compData[valueKey];
											var initialKeyValue = await compData[keyKey];
											for (var keyIndex = 0; keyIndex < await objKeys.length; (keyIndex = keyIndex + 1) - 1) {
												let key = await objKeys[keyIndex];
												compData[valueKey] = await object[key];
												compData[keyKey] = key;
												renderedStr += await this.renderFast(await dynNode.dynamicNodes, await dynNode._sta, $Lt._gc.undefined, compPreDef);
											}
											compData[itemKey] = initialValueValue;
											compData[indexKey] = initialKeyValue;
										}
										str += renderedStr;
									}
									break;
								case "if":
								case "switch": {
										let prevDynamic = await (await (await dynamicNodes[inte - 1]).attr).value;
										var value;
										if (await prevDynamic.dynamicValue) {
											value = await _LC.getDD(compData, await prevDynamic.newDynamicValue);
										} else if (await prevDynamic.helperInfo) {
											value = await this.processHelper({
												name: await (await prevDynamic.helperInfo).name,
												args: await this.processArgs(this, prevDynamic, [], $Lt._gc.undefined, $Lt._gc.undefined, true)
											}, $Lt._gc.undefined);
										}
										var currentCaseName;
										if (value) {
											currentCaseName = await dynNode.type === "if" ? "true" : await value.toString();
										} else {
											if (await dynNode.type === "if") {
												currentCaseName = "false";
											} else {
												switch (value) {
												case $Lt._gc.undefined:
													currentCaseName = "undefined";
													break;
												case null:
													currentCaseName = "null";
													break;
												case false:
													currentCaseName = "false";
													break;
												case "":
													currentCaseName = "\"\"";
													break;
												}
											}
										}
										let scope = await (await dynNode.cases)[currentCaseName];
										if (!scope) {
											if ((scope = await dynNode.default) && await scope._sta) {
												str += await this.renderFast(await scope.dynamicNodes, await scope._sta, $Lt._gc.undefined, compPreDef);
											}
										} else {
											while (scope) {
												str += await this.renderFast(await scope.dynamicNodes, await scope._sta, $Lt._gc.undefined, compPreDef);
												if (await scope.additional) {
													if (await (await scope.additional).next) {
														scope = await (await dynNode.cases)[await (await scope.additional).next];
													} else {
														scope = await dynNode.default;
													}
												} else {
													break;
												}
											}
										}
									}
									break;
								case "attr": {
										let nextDynamic;
										let fastRenderProp;
										let dynLength = await dynamicNodes.length;
										for (let k = inte + 1; k < dynLength; (k = k + 1) - 1) {
											let locDyn = await dynamicNodes[k];
											if (await locDyn.type !== "registerYield" && await locDyn.type !== "componentDynamic" && await locDyn.type !== "insertYield" && await locDyn.type !== "component") {
												break;
											} else {
												if (await (await dynamicNodes[k]).type === "componentDynamic" || await (await dynamicNodes[k]).type === "insertYield" || await (await dynamicNodes[k]).type === "component") {
													if (await (await (await dynamicNodes[k]).position).toString() == await (await (await dynamicNodes[inte]).position).toString()) {
														if (await (await dynamicNodes[k]).type == "componentDynamic") {
															if (await (await _LyteComponent.registeredComponents)[await (await dynamicNodes[k]).componentName]) {
																nextDynamic = await dynamicNodes[k];
																break;
															}
														} else {
															nextDynamic = await dynamicNodes[k];
															break;
														}
													}
												}
											}
										}
										let setAttr;
										if (nextDynamic) {
											setAttr = await nextDynamic.type !== "component";
											fastRenderIndex = (_LC.fRC = await _LC.fRC + 1) - 1;
											fastRenderProp = (await _LC.fRP)[fastRenderIndex] = { "data": {} };
										}
										if (!nextDynamic || await nextDynamic.type !== "component") {
											str = await str.substring(0, await str.length - 11);
										}
										let attr = await dynNode.attr;
										let actionObj = {};
										for (let key in attr) {
											if (await (await attr[key]).dynamicValue) {
												let nodeValue = await (await attr[key]).newDynamicValue ? await _LC.getDD(compData, await (await attr[key]).newDynamicValue) : await this.get(await (await attr[key]).dynamicValue);
												if (fastRenderProp) {
													(await fastRenderProp.data)[await (await attr[key]).camelCase] = nodeValue;
													if (typeof nodeValue == "string" && setAttr) {
														nodeValue = await this.formatValue(key, nodeValue);
														str = str + nodeValue + " ";
													}
												} else {
													nodeValue = await this.formatValue(key, nodeValue);
													str = str + nodeValue + " ";
												}
											} else if (await (await attr[key]).helperInfo) {
												if (await (await (await attr[key]).helperInfo).name === "action") {
													let actionName = await (await (await (await attr[key]).helperInfo).args)[0];
													let boundName;
													if (await actionName.startsWith("\"") || await actionName.startsWith("'")) {
														boundName = await actionName.substring(1, await actionName.length - 1);
													} else {
														await _Lyte.warn("Deprecation warning. Action name " + actionName + " must be in quotes");
														boundName = actionName;
													}
													let actArgs = await this.processArgs(this, await attr[key], [], "__lyteEvent__", "__lyteNode__");
													let actualAttrName = await (await attr[key]).globalEvent ? await (await attr[key]).name : await (await (await attr[key]).name).indexOf("-") !== -1 ? await (await attr[key]).name : await (await (await attr[key]).name).substr(2);
													actionObj[actualAttrName] = {
														"name": boundName,
														"args": await (await (await attr[key]).helperInfo).args,
														"actArgs": actArgs,
														"globalEvent": await (await attr[key]).globalEvent ? true : false,
														"skipArgProcessing": true
													};
												} else if (await (await (await attr[key]).helperInfo).name === "method") {
													var methodsObj = compPreDef ? await compPreDef.methods : await (await this.component).methods;
													if (fastRenderProp) {
														let methods = fastRenderProp.methods = await fastRenderProp.methods || {};
														let parentComp = compPreDef ? await compPreDef.component : await this.component;
														let actArgs = await this.processArgs(this, await attr[key], [], "__lyteEvent__", "__lyteNode__");
														var methodFunc = async function () {
																let node = await this.$node;
																let args = await actArgs.slice(1);
																let functionName = await actArgs[0];
																let customArgs = await $Lt._gc.Array.from(arguments);
																let mainArgs = await args.concat(customArgs);
																return await (await (await (await parentComp.$node)._methods)[functionName]).apply(parentComp, mainArgs);
															};
														methods[await (await attr[key]).camelCase] = methodFunc;
													}
												} else {
													let nodeValue = await this.processHelper({
															name: await (await (await attr[key]).helperInfo).name,
															args: await this.processArgs(this, await attr[key], [], $Lt._gc.undefined, $Lt._gc.undefined, true)
														}, $Lt._gc.undefined);
													if (fastRenderProp) {
														(await fastRenderProp.data)[await (await attr[key]).camelCase] = nodeValue;
														if (typeof nodeValue == "string" && setAttr) {
															nodeValue = await this.formatValue(key, nodeValue);
															str = str + nodeValue + " ";
														}
													} else {
														nodeValue = await this.formatValue(key, nodeValue);
														str = str + nodeValue + " ";
													}
												}
											}
										}
										if (await (await $Lt._gc.Object.keys(actionObj)).length) {
											let locIndex = (_LC.fRC = await _LC.fRC + 1) - 1;
											str = str + "lyteaction=" + locIndex + " ";
											(await _LC.fRP)[locIndex] = actionObj;
											actionObj.componentName = await (await (await this.component).$node).localName || "undefined";
										}
										if (fastRenderProp && await nextDynamic.type !== "component" && await nextDynamic.type !== "insertYield") {
											str = str + "_lyteprop=" + fastRenderIndex + " ";
										}
										if (!await dynNode.attrHandling) {
											dynamicCompile[i + 1] = await (await dynamicCompile[i + 1]).substr(1);
											dynNode.attrHandling = true;
										}
									}
									break;
								case "insertYield": {
										let preDefObj = fastRenderIndex !== $Lt._gc.undefined ? await (await _LC.fRP)[fastRenderIndex] : $Lt._gc.undefined;
										if (preDefObj) {
											delete (await _LC.fRP)[fastRenderIndex];
										}
										fastRenderIndex = $Lt._gc.undefined;
										let yieldObj;
										let yieldName = await dynNode.yieldName || await (await preDefObj.data).yieldName;
										if (preDefObj) {
											delete (await preDefObj.data).yieldName;
										}
										let yieldCallee;
										if (!compPreDef || !await compPreDef.yields) {
											yieldObj = await (await this._yields)[yieldName];
											if (yieldObj) {
												yieldCallee = await yieldObj._callee;
											} else {
												break;
											}
										} else {
											yieldObj = await (await compPreDef.yields)[yieldName];
											yieldCallee = await compPreDef._yieldCallee;
										}
										if (yieldObj) {
											let parentScope;
											let locComp;
											if (await $Lt._iO(yieldCallee, $Lt._gc.HTMLElement)) {
												parentScope = yieldCallee;
											} else {
												parentScope = this;
												locComp = await this.component;
												this.component = await yieldCallee.component;
											}
											let contextSwitch = {};
											let contextSwitchArray = [];
											var psCmpData = await LyteComponent.getCmpData(await (await parentScope.component).data);
											if (await yieldObj._cx) {
												await _LC.adCx(yieldObj, contextSwitchArray);
											}
											if (preDefObj) {
												for (var key in await preDefObj.data) {
													contextSwitch[key] = await psCmpData[key];
													psCmpData[key] = await (await preDefObj.data)[key];
												}
											}
											var componentScope = await parentScope.component;
											if (prevComp && await prevComp.$node == yieldCallee) {
												componentScope = prevComp;
											}
											str = str + await parentScope.renderFast(await yieldObj.dynamicNodes || await yieldObj._dynamicNodes, await yieldObj._sta, componentScope, yieldCallee);
											for (let key in contextSwitch) {
												psCmpData[key] = await contextSwitch[key];
											}
											if (await yieldObj._cx) {
												await _LC.rmCx(yieldObj, contextSwitchArray);
											}
											if (locComp) {
												parentScope.component = locComp;
											}
										}
									}
									break;
								case "component": {
										if (fastRenderIndex !== $Lt._gc.undefined) {
											let preDefObj = await (await _LC.fRP)[fastRenderIndex];
											let componentName = await (await preDefObj.data).componentName;
											if (componentName) {
												if (await (await _LyteComponent.registeredComponents)[componentName]) {
													str = str + "<" + componentName + (await _Lyte.isWidgetBuild ? " lyte-widget " : "") + " _lyteprop=" + fastRenderIndex + ">";
													fastRenderIndex = $Lt._gc.undefined;
													str = str + await this.renderComponent({ "componentName": componentName }, preDefObj, compData);
													str = str + "</" + componentName + ">";
												} else {
													str = str + "component not registered";
												}
											}
										}
									}
									break;
								case "componentDynamic": {
										let preDefObj = fastRenderIndex !== $Lt._gc.undefined ? await (await _LC.fRP)[fastRenderIndex] : {};
										fastRenderIndex = $Lt._gc.undefined;
										str = str + await this.renderComponent(dynNode, preDefObj, compData);
									}
									break;
								case "registerYield": {
										let preDefObj;
										if (fastRenderIndex !== $Lt._gc.undefined) {
											preDefObj = await (await _LC.fRP)[fastRenderIndex];
										} else {
											fastRenderIndex = (_LC.fRC = await _LC.fRC + 1) - 1;
											preDefObj = (await _LC.fRP)[fastRenderIndex] = {};
										}
										preDefObj.yields = await preDefObj.yields || {};
										(await preDefObj.yields)[await (await dynNode._args)["yield-name"]] = dynNode;
										if (!await preDefObj._yieldCallee) {
											preDefObj._yieldCallee = compPreDef ? compPreDef : { "component": await this.component };
										}
									}
								}
							} else {
								str = str + await dynamicCompile[i];
							}
						} else {
							str = str + await dynamicCompile[i];
						}
					}
					if (comp) {
						this.component = prevComp;
					}
					return str;
				}
				async formatValue(key, nodeValue) {
					let type = typeof nodeValue;
					if (nodeValue === "") {
						type = "undefined";
					}
					let retVal;
					let isSpecialAttr = key == "src" || key == "href";
					switch (type) {
					case "boolean":
						return nodeValue ? key : "";
					case "object":
						retVal = typeof $Lt._gc.Record != "undefined" && await $Lt._iO(nodeValue, $Lt._gc.Record) ? await $Lt._gc.JSON.stringify(await (await nodeValue.$).toJSON()) : await $Lt._gc.JSON.stringify(nodeValue);
						return key + "=\"" + (isSpecialAttr ? retVal : await (await Lyte.Security).escape(retVal)) + "\"";
					case "undefined":
						return key;
					default: {
							return key + "=\"" + (isSpecialAttr ? nodeValue : await (await Lyte.Security).escape(nodeValue)) + "\"";
						}
					}
				}
				async renderNodes(toAppend, dynamicNodes, helperNode, options, establishBindings, returnVal, templateContent, yieldComp, initialRender) {
					options = options || {};
					let content;
					let constr = await this.constr;
					let templateDepthHandlingNeeded = false;
					if (await _Lyte._ms || !toAppend) {
						templateDepthHandlingNeeded = true;
						content = await _LC.getContentForIE(templateContent, constr);
					} else if (await toAppend.hasAttribute("depth")) {
						templateDepthHandlingNeeded = true;
						content = await _LC.getContentForIE(toAppend, constr);
					} else {
						content = await (await toAppend.content).cloneNode(true, "lyte");
					}
					let updateHelpers = [], processLast = [], helperFunc, stoppedNode;
					let cmpData = await LyteComponent.getCmpData(await (await this.component).data);
					let toBeInsMap = await $Lt._cO($Lt._gc.Map);
					for (let i = 0; i < await dynamicNodes.length; (i = i + 1) - 1) {
						let info = await dynamicNodes[i], type = await info.type, pos = await info.position, dynamicN = content, helperInfo;
						dynamicN = await getDynamicNode(dynamicN, pos);
						if (await info.trans) {
							dynamicN._hooksPresent = true;
						}
						if (!await dynamicNodes._cache && !(await this.registeredProp && await (await this.registeredProp).length)) {
							dynamicNodes._cache = {};
						}
						if (type === "componentDynamic") {
							if (await _Lyte.isWidgetBuild) {
								await dynamicN.setAttribute("lyte-widget", "");
							}
							if (helperNode) {
								dynamicN._parentHelper = helperNode;
							}
							if (await options.node) {
								dynamicN._cx = options;
							} else if (helperNode) {
								dynamicN._cx = await helperNode._cx;
							}
						} else if (type === "text") {
							await this.bindNode(dynamicN, $Lt._gc.undefined, helperNode, options, await dynamicNodes[i], processLast, establishBindings, $Lt._gc.undefined, await dynamicNodes._cache, type, $Lt._gc.undefined, toBeInsMap);
						} else if (type === "attr") {
							dynamicN._attributeDetails = await info.attr;
							if (await dynamicN.nodeName === "LYTE-YIELD") {
								dynamicN._callee = this;
								dynamicN.component = {};
								(await dynamicN.component).data = {};
								await $Lt._gcFn.defProp(await (await dynamicN.component).data, "__component__", {
									value: dynamicN,
									configurable: true,
									writable: true,
									enumerable: false
								});
								dynamicN._properties = {};
								for (let j = 0; j < await (await dynamicN.attributes).length; (j = j + 1) - 1) {
									let attr = await (await dynamicN.attributes)[j];
									if (await attr.nodeName !== "is" && await attr.nodeName !== "yield-name") {
										(await dynamicN._properties)[await (await _LC.String).toCamelCase(await attr.nodeName)] = {};
									}
								}
							}
							let toBeRemoved = [];
							let processDirectiveLazy = [];
							for (let key in await info.attr) {
								let attr = await (await info.attr)[key];
								attr._depthTemp = await info._depthTemp;
								let attrName = key;
								let node;
								if (attr && (await attr.dynamicValue || await attr.helperInfo)) {
									if (await options.node) {
										dynamicN._cx = options;
									} else if (helperNode) {
										dynamicN._cx = await helperNode._cx;
									}
									let actionName, boundName;
									if (await attr.helperInfo && await (await attr.helperInfo).name === "action") {
										dynamicN._boundEvents = await dynamicN._boundEvents || {};
										actionName = await (await (await attr.helperInfo).args)[0];
										if (await actionName.startsWith("\"") || await actionName.startsWith("'")) {
											boundName = await actionName.substring(1, await actionName.length - 1);
										} else {
											boundName = actionName;
										}
										let actualAttrName = await attr.globalEvent ? attrName : await attrName.indexOf("-") !== -1 ? attrName : await attrName.substr(2);
										(await dynamicN._boundEvents)[actualAttrName] = {
											"name": boundName,
											"args": await (await attr.helperInfo).args
										};
										let id;
										id = "A1_" + await $Lt._gc.Math.floor(await $Lt._gc.Math.random() * 1000);
									}
									if (!await attr.globalEvent) {
										if (!await dynamicN.hasAttribute(attrName)) {
											await dynamicN.setAttribute(attrName, "{{dummy}}");
										}
										node = await this.bindNode(await (await dynamicN.attributes).getNamedItem(attrName), toBeRemoved, helperNode, options, attr, $Lt._gc.undefined, establishBindings, $Lt._gc.undefined, await dynamicNodes._cache, type, i);
										if (node !== await (await dynamicN.attributes).getNamedItem(attrName)) {
											dynamicN._removedAttributes = await dynamicN._removedAttributes || {};
											(await dynamicN._removedAttributes)[attrName] = node;
										}
									}
								}
								if (await attr.hookNode) {
									await processDirectiveLazy.push({
										attr: attr,
										node: node
									});
								}
							}
							await _LCSV.addNodeLazy(processDirectiveLazy, this, info, dynamicN, helperNode, yieldComp, options);
							if (await info.attr && await (await $Lt._gc.Object.keys(await info.attr)).length) {
								dynamicN._callee = this;
							}
							for (let d = 0; d < await toBeRemoved.length; (d = d + 1) - 1) {
								await dynamicN.removeAttribute(await toBeRemoved[d]);
							}
						} else if (await (/^(for|forIn|component)$/).test(type)) {
							if (await window.isLyteWidget || await window.__lyteEnablePromise) {
								dynamicN._cases = await info.cases;
							}
							if (await options.node) {
								dynamicN._cx = options;
							} else if (helperNode) {
								dynamicN._cx = await helperNode._cx;
							}
							dynamicN._dynamicNodes = await info.dynamicNodes;
							if (await _Lyte._ms) {
								dynamicN._tC = await info.templateContent;
							}
							if (await info.actualTemplate) {
								dynamicN._tC = await info.actualTemplate;
							}
							if (!await dynamicN._hiddenTemplate) {
								dynamicN._hiddenTemplate = [];
							}
							let returnVal;
							switch (type) {
							case "for":
								dynamicN._ht = await info._ht;
								returnVal = await this.updateForHelper(dynamicN, { "type": "default" }, await options.node ? options : $Lt._gc.undefined, establishBindings, await info._sta, $Lt._gc.undefined, initialRender);
								break;
							case "forIn":
								dynamicN._ht = await info._ht;
								returnVal = await this.updateForInHelper(dynamicN, { "type": "default" }, await options.node ? options : $Lt._gc.undefined, establishBindings, $Lt._gc.undefined, initialRender);
								break;
							case "component":
								returnVal = await this.updateDynamicComponent(dynamicN, false, await options.node ? options : $Lt._gc.undefined, establishBindings, i, helperNode);
							}
							if (returnVal) {
								await updateHelpers.push(returnVal);
							}
						} else if (await (/^(if|switch)$/).test(type)) {
							var def = "default";
							dynamicN._cases = await info.cases;
							dynamicN._default = await info[def];
							dynamicN._ht = await info._ht;
							if (await options.node) {
								dynamicN._cx = options;
							} else if (helperNode) {
								dynamicN._cx = await helperNode._cx;
							}
							if (await info.actualTemplate) {
								dynamicN._tC = await info.actualTemplate;
								if (!await dynamicN._origTemplate) {
									if (await _Lyte._ie) {
										dynamicN._origTemplate = await createElement("template");
									} else {
										dynamicN._origTemplate = await (await info._depthTemp).cloneNode(true);
									}
									if (await dynamicN.hasAttribute("value")) {
										await (await dynamicN._origTemplate).setAttribute("value", await dynamicN.getAttribute("value"));
									}
								}
							}
							if (!await dynamicN._hiddenTemplate) {
								dynamicN._hiddenTemplate = [];
							}
							let id;
							let returnVal = await this.updateSwitchHelper(type, dynamicN, await options.node ? options : $Lt._gc.undefined, $Lt._gc.undefined, establishBindings, yieldComp, id, toBeInsMap);
							if (returnVal) {
								await updateHelpers.push(returnVal);
								let isBreak = await (await returnVal.toAppendMain).querySelector("template[is=break]");
								if (isBreak) {
									dynamicN._isStopped = "break";
									content = await (await Lyte.Compile).getTrimmedContent(content, await info.position, $Lt._gc.undefined);
									stoppedNode = await info.position;
									break;
								}
								let isContinue = await (await returnVal.toAppendMain).querySelector("template[is=continue]");
								if (isContinue) {
									dynamicN._isStopped = "continue";
									content = await (await Lyte.Compile).getTrimmedContent(content, await info.position, $Lt._gc.undefined);
									break;
								}
							}
						} else if (type === "registerYield") {
							if (await options.node) {
								dynamicN._cx = options;
							} else if (helperNode) {
								dynamicN._cx = await helperNode._cx;
							}
							dynamicN._dynamicNodes = await info.dynamicNodes;
							dynamicN._sta = await info._sta;
							dynamicN._ht = await info._ht;
							if (await _Lyte._ms) {
								dynamicN._tC = await info.templateContent;
							}
							dynamicN._callee = this;
						} else if (type === "insertYield") {
							if (helperNode) {
								dynamicN._parentHelper = helperNode;
							}
							if (await options.node) {
								dynamicN._cx = options;
							} else if (helperNode) {
								dynamicN._cx = await helperNode._cx;
							}
							if (!await dynamicN._hiddenTemplate) {
								dynamicN._hiddenTemplate = [];
							}
							dynamicN.component = await dynamicN.component || { "data": {} };
							dynamicN._properties = await dynamicN._properties || {};
							dynamicN.component = await dynamicN.component || { "data": {} };
							dynamicN._properties = await dynamicN._properties || {};
							let dData = await LyteComponent.getCmpData(await (await dynamicN.component).data);
							for (let x = 0; x < await (await dynamicN.attributes).length; (x = x + 1) - 1) {
								let attrObj = await (await dynamicN.attributes)[x];
								let attrName = await attrObj.name;
								let attrValue = await attrObj.value;
								if (attrName !== "yield-name") {
									if (await dynamicN._properties && !await (await dynamicN._properties)[attrName]) {
										(await dynamicN._properties)[attrName] = {};
									}
									if (await dynamicN._attributeDetails && !await (await dynamicN._attributeDetails)[attrName]) {
										dData[attrName] = attrValue;
									}
								}
							}
							await this.updateYield(dynamicN, false, await options.node ? options : $Lt._gc.undefined);
						}
					}
					dynamicNodes._cache = $Lt._gc.undefined;
					for (let i = 0; i < await processLast.length; (i = i + 1) - 1) {
						let dynamicPosition = await (await processLast[i]).dynamicPositions;
						let processNode = await dynamicPosition.initialNode;
						let nodeValue = await dynamicPosition.dynamicNodeValue;
						let childLen = await (await nodeValue.childNodes).length;
						if (!childLen) {
							await nodeValue.appendChild(await $Lt._gc.document.createTextNode(""));
							childLen = 1;
						}
						let startingNode = await (await nodeValue.childNodes)[0];
						if (await _Lyte._rwpf && await (await processNode.parentNode).nodeName === "#document-fragment") {
							while (await (await nodeValue.childNodes).length) {
								await insertBefore(await processNode.parentNode, await (await nodeValue.childNodes)[0], processNode);
							}
							await processNode.remove();
						} else {
							await (await processNode.replaceWith).apply(processNode, await nodeValue.childNodes);
						}
						(await processLast[i]).dynamicPositions = {
							startingNode: startingNode,
							length: childLen
						};
					}
					if (await toBeInsMap.size) {
						await $Lt._fE(toBeInsMap, async function (val, key) {
							await (await val.pN).insertBefore(key, await val.cN);
							if (await (await val.cN).nextSibling) {
								await (await val.pN).insertBefore(await $Lt._gc.document.createElement("textend"), await (await val.cN).nextSibling);
							} else {
								await (await val.pN).appendChild(await $Lt._gc.document.createElement("textend"));
							}
						});
					}
					if (stoppedNode) {
						returnVal = returnVal || {};
						returnVal.stop = true;
					}
					if (helperNode) {
						if (await options.type) {
							(await helperNode._helpers)[await options.itemIndex] = updateHelpers;
							if (templateDepthHandlingNeeded) {
								content = await constr.createDocFragment1(content);
							}
							return content;
						} else {
							helperNode._helpers = await helperNode._helpers || [];
							await (await (await helperNode._helpers).push).apply(await helperNode._helpers, updateHelpers);
							if (templateDepthHandlingNeeded) {
								content = await constr.createDocFragment1(content);
							}
							return content;
						}
					}
					await this.executeBlockHelpers(updateHelpers);
					if (templateDepthHandlingNeeded) {
						content = await constr.createDocFragment1(content);
					}
					return content;
				}
				async executeBlockHelpers(updateHelpers, node) {
					for (let i = 0; i < await updateHelpers.length; (i = i + 1) - 1) {
						var lastNode = await (await updateHelpers[i]).lastNode;
						var parentNode = await lastNode.parentNode;
						if (await lastNode._placeHolder) {
							lastNode = await lastNode._placeHolder;
							parentNode = await lastNode.parentNode;
						}
						await insertBefore(parentNode, await (await updateHelpers[i]).toAppendMain, lastNode);
						updateHelpers[i] = await (await updateHelpers[i]).lastNode;
					}
				}
				async updateBlockHelpers(updateHelpers, contextSwitchInfo) {
					for (let i = 0; i < await updateHelpers.length; (i = i + 1) - 1) {
						switch (await (await updateHelpers[i]).getAttribute("is")) {
						case "for":
							await this.updateForHelper(await updateHelpers[i], { "type": "default" }, contextSwitchInfo);
							break;
						case "if":
							await this.updateSwitchHelper("if", await updateHelpers[i], contextSwitchInfo);
							break;
						case "forIn":
							await this.updateForInHelper(await updateHelpers[i], { "type": "default" }, contextSwitchInfo);
							break;
						case "switch":
							await this.updateSwitchHelper("switch", await updateHelpers[i], contextSwitchInfo);
							break;
						case "component":
							await this.updateDynamicComponent(await updateHelpers[i], false, contextSwitchInfo);
							break;
						case "insertYield":
							break;
						case "yield":
						case "registerYield":
							if (contextSwitchInfo) {
								(await updateHelpers[i])._cx = contextSwitchInfo;
							}
							break;
						default:
							if (await (await updateHelpers[i]).tagName === "LYTE-YIELD") {
								await this.updateYield(await updateHelpers[i], false, contextSwitchInfo);
							}
						}
					}
				}
				static get observedAttributes() {
					return this._observedAttributesDasherized;
				}
				static async dasherizeObservedAttributes() {
					let newArr = [];
					for (let i = 0; i < await (await this._observedAttributes).length; (i = i + 1) - 1) {
						newArr[i] = await (await _LC.String).dasherize(await (await this._observedAttributes)[i]);
					}
					await $Lt._fE(await _LC.__dataNames, async function (name) {
						await newArr.push(await (await _LC.String).dasherize(name));
					});
					await $Lt._fE(await _LC.customPropHandlers, async function (item, index) {
						await newArr.push(await (await _LC.String).dasherize(item));
					});
					this._observedAttributesDasherized = newArr;
				}
				async attributeChangedCallback(attr, oldValue, newValue) {
					await this._attributeChangedCallback(attr, oldValue, newValue);
				}
				async _attributeChangedCallback(attr, oldValue, newValue) {
					if (await this.__lyteIgnore || await this.__v3lyteIgnore) {
						return;
					}
					let constr = await this.constructor;
					let compConstr = await (await this.component).constructor;
					if (await compConstr._observedMethodAttributes && await (await compConstr._observedMethodAttributes)[attr]) {
						return;
					}
					let actualAttr = await (await _LC.String).toCamelCase(attr);
					let isCustomProp = await (await _LC.customPropHandlers).indexOf(actualAttr);
					if (isCustomProp !== -1) {
						let propValue = await (await _LC.customPropHandlers)[isCustomProp];
						let lyteProps = newValue;
						if (lyteProps) {
							try {
								lyteProps = await $Lt._gc.JSON.parse(lyteProps);
								for (let key in lyteProps) {
									let actKey = propValue + await (await _LC.String).upperCaseFirstLetter(key);
									await this.set(actKey, await lyteProps[key]);
								}
							} catch (e) {
								await _Lyte.error("LC001", attr);
							}
						}
						return;
					}
					if (oldValue === newValue) {
						return;
					}
					var attrNode = await (await this.attributes).getNamedItem(attr);
					if (attrNode) {
						if (await attrNode.__lyteIgnore) {
							(await (await this.attributes).getNamedItem(attr)).__lyteIgnore = false;
							return;
						}
					} else if (await this["__" + attr]) {
						this["__" + attr] = false;
						return;
					}
					let compInstance = await this.component;
					let dataDef = await (await compInstance.__data)[actualAttr];
					if (dataDef && await dataDef.type) {
						let dataType = await dataDef.type;
						if (dataType !== "string") {
							let obj = {
									"attr": attr,
									"tagName": await this.tagName
								};
							newValue = await _LC.typeCast(newValue, dataType, obj);
							if (await obj.isError) {
								await _Lyte.warn("data type of the value provided for attribute " + attr + " of " + await this.tagName + " is not valid");
								return;
							}
						}
					}
					let compData = await compInstance.data;
					if (await compData[actualAttr] !== newValue) {
						await this.set(actualAttr, newValue === null ? $Lt._gc.undefined : newValue, $Lt._gc.undefined, $Lt._gc.undefined, true);
					} else {
						await _LC.clearError(compData, actualAttr);
					}
				}
				async removeHelpersSpecificIndex(node, index, destroyChild, type) {
					let isType = await node.getAttribute("is");
					if (await (await node._helpers)[index]) {
						for (let j = 0; j < await (await (await node._helpers)[index]).length; (j = j + 1) - 1) {
							await this.removeHelpers(await (await (await node._helpers)[index])[j], $Lt._gc.undefined, $Lt._gc.undefined, index, node, type);
						}
					}
					await _LCSV.removeAll(isType, this, node, index, destroyChild, index, node, type);
					await _LCHD.rmHelpersSpecificIndex(node, index);
					if (await (await node._forContent)[index]) {
						for (let i = 0; i < await (await (await node._forContent)[index]).length; (i = i + 1) - 1) {
							await (await (await (await node._forContent)[index])[i]).remove();
						}
						var self = this;
						await $Lt._fE(await $Lt._gc.Object.keys(await (await (await node._items)[index])._dynamicProperty), async function (key) {
							((await node._dynProps)[key] = await (await node._dynProps)[key] - 1) + 1;
							if (!await (await node._dynProps)[key]) {
								let prop = await self.getProperty(key);
								if (await prop._helperNodes) {
									await (await prop._helperNodes)[delStr](node);
								}
							}
						});
						(await node._items)[index] = {
							"_dynamicProperty": {},
							"itemProperty": {},
							"indexProperty": {},
							"propProperty": {},
							"propPropertyDyn": {},
							"propNodes": {}
						};
					}
				}
				async removeHelpers(node, update, direct, updateIndex, parentNode, type) {
					let isType = await node.getAttribute("is");
					if (!direct) {
						await node.remove();
						var helpersObj = await node.getAttribute("is") === "component" ? await this.__dc : await this.__h;
						let nodeId = await node.__lyteId;
						delete helpersObj[nodeId];
					}
					var del = "delete";
					let parent;
					var contextSwitchArray = [];
					await _LC.adCx(node, contextSwitchArray);
					if (await node._forContent) {
						if (await node.getAttribute("is") === "for") {
							if (await node._helpers) {
								for (let i = 0; i < await (await node._helpers).length; (i = i + 1) - 1) {
									for (let j = 0; j < await (await (await node._helpers)[i]).length; (j = j + 1) - 1) {
										await this.removeHelpers(await (await (await node._helpers)[i])[j], $Lt._gc.undefined, $Lt._gc.undefined, updateIndex, parentNode, type);
									}
									(await node._helpers)[i] = [];
								}
							}
							for (let s = 0; s < await (await node._forContent).length; (s = s + 1) - 1) {
								for (let i = 0; i < await (await (await node._forContent)[s]).length; (i = i + 1) - 1) {
									await (await (await (await node._forContent)[s])[i]).remove();
								}
							}
							let key = await node.getAttribute("item");
							if (await (await node._items).length) {
								let prop = await (await (await node._items)[0]).itemProperty;
								for (let i = 0; i < await (await node._items).length; (i = i + 1) - 1) {
									let dynProp = await (await (await node._items)[i])._dynamicProperty;
									for (let dP in dynProp) {
										let property = await this.getProperty(dP);
										if (await property._helperNodes) {
											await (await property._helperNodes)[del](node);
										}
									}
								}
								if (prop) {
									for (let i = 0; i < await (await node._items).length; (i = i + 1) - 1) {
										await this.removeBindings({ [key]: await (await (await node._items)[i]).itemProperty }, { [key]: await (await (await node._attributes).items)[i] });
									}
								}
							}
							await _LCSV.removeAll(isType, this, node, $Lt._gc.undefined, $Lt._gc.undefined, updateIndex, parentNode, type);
							if (!update) {
								if (await node._actualBinding) {
									if (await (await node._attributes).items && await (await (await node._attributes).items)._bindings && await (await node._actualBinding)._createdBinding) {
										await (await (await (await node._attributes).items)._bindings)[del](await node._actualBinding);
									}
									if (await (await node._actualBinding)._forHelpers) {
										await (await (await node._actualBinding)._forHelpers)[del](node);
									}
									var multiplePrpty = await (await (await node._removedAttributes).items)._multipleProperty;
									if (await node._removedAttributes && await (await node._removedAttributes).items && !await (await (await node._removedAttributes).items).helperValue && multiplePrpty && await (await (await multiplePrpty[0]).actProp)._forHelpers) {
										await (await (await (await multiplePrpty[0]).actProp)._forHelpers)[del](node);
									}
								}
							}
							node._items = [];
						} else {
							if (await node._helpers) {
								let keys = await $Lt._gc.Object.keys(await node._helpers);
								for (let i = 0; i < await keys.length; (i = i + 1) - 1) {
									for (let j = 0; j < await (await (await node._helpers)[await keys[i]]).length; (j = j + 1) - 1) {
										await this.removeHelpers(await (await (await node._helpers)[await keys[i]])[j], $Lt._gc.undefined, $Lt._gc.undefined, updateIndex, parentNode, type);
									}
									(await node._helpers)[await keys[i]] = [];
								}
							}
							for (var ind in await node._forContent) {
								for (let i = 0; i < await (await (await node._forContent)[ind]).length; (i = i + 1) - 1) {
									await (await (await (await node._forContent)[ind])[i]).remove();
								}
							}
							let items = await node._items;
							let key = await node.getAttribute("key");
							for (let index in items) {
								let item = await items[index];
								let prop = await item.itemProperty;
								let dynamicProp = await item._dynamicProperty;
								for (let dP in dynamicProp) {
									let property = await this.getProperty(dP);
									if (await property._helperNodes) {
										await (await property._helperNodes)[del](node);
									}
								}
								if (prop) {
									await this.removeBindings({ [key]: await (await (await node._items)[index]).itemProperty }, { [key]: await (await (await node._attributes).object)[index] });
								}
							}
							if (!update) {
								if (await node._actualBinding) {
									if (await (await node._attributes).object && await (await (await node._attributes).object)._bindings && await (await node._actualBinding)._createdBinding) {
										await (await (await (await node._attributes).object)._bindings)[del](await node._actualBinding);
									}
									if (await (await node._actualBinding)._forHelpers) {
										await (await (await node._actualBinding)._forHelpers)[del](node);
									}
								}
								var multiplePrpty = await (await (await node._removedAttributes).object)._multipleProperty;
								if (await (await node._removedAttributes).object && !await (await (await node._removedAttributes).object).helperValue && multiplePrpty && await (await (await multiplePrpty[0]).actProp)._forHelpers) {
									await (await (await (await multiplePrpty[0]).actProp)._forHelpers)[del](node);
								}
								if (await node._propBindingObject && await (await node._attributes).object && await (await (await node._attributes).object)._bindings) {
									await (await (await (await node._attributes).object)._bindings)[del](await node._propBindingObject);
								}
							}
							await _LCSV.removeAll(isType, this, node, $Lt._gc.undefined, $Lt._gc.undefined, updateIndex, parentNode, type);
							node._items = {};
						}
						if ((await window.isLyteWidget || await window.__lyteEnablePromise) && await node._promiseContent) {
							for (let s = 0; s < await (await node._promiseContent).length; (s = s + 1) - 1) {
								await (await (await node._promiseContent)[s]).remove();
							}
						}
						await _LCHD.forRmHelpers(node);
					} else if (await node._caseContent || await node._yieldContent) {
						if (await node._helpers) {
							for (let j = 0; j < await (await node._helpers).length; (j = j + 1) - 1) {
								await this.removeHelpers(await (await node._helpers)[j], $Lt._gc.undefined, $Lt._gc.undefined, updateIndex, parentNode, type);
							}
							node._helpers = [];
						}
						if (await node._caseContent) {
							for (let i = 0; i < await (await node._caseContent).length; (i = i + 1) - 1) {
								await (await (await node._caseContent)[i]).remove();
							}
							for (let key in await node._dynamicProperty) {
								if (await (await (await node._dynamicProperty)[key]).isActualNode) {
									await (await (await (await (await node._dynamicProperty)[key]).isActualNode)._helperNodes)[del](node);
								} else {
									let helperNodes = await (await this.getProperty(key))._helperNodes;
									if (helperNodes) {
										await helperNodes[del](node);
									}
								}
							}
							node._dynamicProperty = {};
						} else {
							for (let i = 0; i < await (await node._yieldContent).length; (i = i + 1) - 1) {
								await (await (await node._yieldContent)[i]).remove();
							}
							node._dynamicProperty = {};
						}
						await _LCHD.ifRmHelpers(node);
						var pve = await _LC.pendingViewPortElements;
						if (await node._inPve && await pve.length) {
							let ind = await pve.indexOf(await _LC.getFakeTemplate(node));
							if (ind != -1) {
								await pve.splice(ind, 1);
							}
						}
						await _LCSV.removeAll(isType, this, node, $Lt._gc.undefined, $Lt._gc.undefined, updateIndex, parentNode, type);
					} else if (await node._renderedComponent) {
						for (let key in await node._renderedComponent) {
							let comp = await (await node._renderedComponent)[key];
							if (comp) {
								await (await (await (await comp.constructor).prototype)._disconnectedCallback).call(comp);
								await comp.remove();
								(await node._renderedComponent)[key] = null;
							}
						}
					}
					await _LC.rmCx(node, contextSwitchArray);
				}
				async updateYield(node, update, contextSwitchInfo) {
					if (!await node._specialNodes) {
						node._specialNodes = [];
					}
					let constr = await this.constructor;
					let compConstr = await (await this.component).constructor;
					if (!await node._callee) {
						node._callee = this;
					}
					let toAppend = await (await (await node._callee)._yields)[await node.getAttribute("yield-name")];
					if (!toAppend) {
						return;
					}
					node._registerYield = toAppend;
					let parentScope = await toAppend._callee || await (await node._callee)._callee;
					if (!parentScope) {
						if (await _Lyte._ms) {
							var div = await createElement("div");
							div.innerHTML = await toAppend.outerHTML;
							if (await _Lyte._ie) {
								(await div.firstChild).innerHTML = await toAppend.innerHTML;
							}
							var content1 = await (await div.childNodes)[0];
							await constr.splitTextNodes(content1);
							content1 = await constr.createDocFragment1(content1);
							await node.appendChild(content1);
						} else {
							await node.appendChild(await (await toAppend.content).cloneNode(true, "lyte"));
						}
						node._helpers = [];
						return;
					}
					if (!await toAppend._callee) {
						toAppend._callee = parentScope;
					}
					node._dynamicProperty = await node._dynamicProperty || {};
					let obj = {}, contextSwitchingArray = {}, self = this, contextSwitchArray = [];
					await _LC.adCx(toAppend, contextSwitchArray);
					var cmpData = await LyteComponent.getCmpData(await (await parentScope.component).data);
					await $Lt._fE(await $Lt._gc.Object.keys(await node._properties), async function (key) {
						contextSwitchingArray[key] = {};
						(await contextSwitchingArray[key]).value = await cmpData[key];
						(await contextSwitchingArray[key]).property = await (await parentScope._properties)[key];
						(await parentScope._properties)[key] = await (await node._properties)[key];
						let nData = await LyteComponent.getCmpData(await (await node.component).data);
						cmpData[key] = await nData[key];
					});
					if (!await _Lyte._ms && await toAppend._ht && !await toAppend._htA) {
						toAppend._htA = true;
						await (await toAppend.content).append(await (await (await toAppend._ht).content).cloneNode(true));
					}
					let yieldComp = await node._callee;
					let content = await parentScope.renderNodes(toAppend, await toAppend._dynamicNodes || [], node, { "node": node }, true, $Lt._gc.undefined, await toAppend._tC, yieldComp);
					if (!await (await (await node.component).data).lyteUnbound) {
						let nData = await LyteComponent.getCmpData(await (await node.component).data);
						await _LC.establishBindings(await node._properties, nData);
					}
					await parentScope.executeBlockHelpers(await node._helpers);
					await $Lt._fE(await $Lt._gc.Object.keys(await node._properties), async function (key) {
						cmpData[key] = await (await contextSwitchingArray[key]).value;
						(await parentScope._properties)[key] = await (await contextSwitchingArray[key]).property;
					});
					await _LC.rmCx(toAppend, contextSwitchArray);
					await node.appendChild(content);
				}
				async updateDynamicComponent(node, update, contextSwitchInfo, establishBindings, idx, helperNode) {
					if (!await node._specialNodes) {
						node._specialNodes = [];
					}
					let returnVal;
					node._callee = this;
					let keepAlive = await node.hasAttribute("lyte-keep-alive");
					if (!await node._placeHolder) {
						let emptyTextNode = await $Lt._gc.document.createTextNode("");
						await _LC.replaceWithPf(node, emptyTextNode);
						node._placeHolder = emptyTextNode;
						emptyTextNode._helper = node;
						(await node._placeHolder)._actTemplate = node;
						await (await (await _LC.tDiv).content).appendChild(node);
						if (await this._removedTemplate) {
							await (await this._removedTemplate).push(node);
						} else {
							this._removedTemplate = [];
							await (await this._removedTemplate).push(node);
						}
					}
					if (!await node._renderedComponent) {
						node._renderedComponent = {};
						let id = await _LC.createLyteId(this);
						(await this.__dc)[id] = node;
						node.__lyteId = id;
					}
					node._cx = contextSwitchInfo || await node._cx;
					node._dynamicProperty = await node._dynamicProperty || {};
					let componentName = await node.getAttribute("component-name") || (await node._attributes ? await (await node._attributes)["component-name"] : $Lt._gc.undefined);
					if (!componentName) {
						return;
					}
					let component, newComponent = false;
					if (update) {
						if (keepAlive) {
							await _LyteComponent._setIgnoreDisconnect(true);
						}
						if (await (await node._renderedComponent)[await node._currentComponent]) {
							let activeComponent = await (await node._renderedComponent)[await node._currentComponent];
							keepAlive ? await (await (await _LC.hDiv).content).appendChild(activeComponent) : await activeComponent.remove();
						}
						await _LyteComponent._setIgnoreDisconnect(false);
						if (!keepAlive) {
							node._dynamicProperty = {};
						}
						if (await (await node._renderedComponent)[componentName] && keepAlive) {
							component = await (await node._renderedComponent)[componentName];
						} else {
							let wdFlag = false;
							if (await this.__widget) {
								ltCf.__widget = wdFlag = true;
							}
							component = await createElement(componentName);
							if (wdFlag) {
								ltCf.__widget = false;
							}
							newComponent = true;
						}
					} else {
						let wdFlag = false;
						if (await this.__widget) {
							ltCf.__widget = wdFlag = true;
						}
						component = await createElement(componentName);
						if (wdFlag) {
							ltCf.__widget = false;
						}
						newComponent = true;
					}
					if (!keepAlive && await node._currentComponent) {
						(await node._renderedComponent)[await node._currentComponent] = null;
					}
					if (newComponent) {
						for (let i = 0; i < await (await node.attributes).length; (i = i + 1) - 1) {
							if (await (await (await node.attributes)[i]).name !== "is" && await (await (await node.attributes)[i]).name !== "component-name" && await (await (await node.attributes)[i]).name !== "lyte-keep-alive") {
								await component.setAttribute(await (await (await node.attributes)[i]).name, await (await (await node.attributes)[i]).value);
							}
						}
						if (await node._attributes) {
							for (var key in await node._attributes) {
								if (key !== "component-name") {
									await component.setData(await (await _LC.String).toCamelCase(key), await (await node._attributes)[key]);
								}
							}
						}
						let toAppend = await this.renderNodes(node, await node._dynamicNodes, node, $Lt._gc.undefined, establishBindings, $Lt._gc.undefined, await node._tC);
						await component.appendChild(toAppend);
					}
					if (newComponent) {
						component._toRegEvnts = await node._toRegEvnts;
					}
					if (!update) {
						returnVal = {
							"toAppendMain": component,
							"lastNode": node
						};
					} else {
						await _LyteComponent._setIgnoreDisconnect(true);
						if (!await node._placeHolder) {
							await insertBefore(await node.parentNode, component, node);
						} else {
							await insertBefore(await (await node._placeHolder).parentNode, component, await node._placeHolder);
						}
						await _LyteComponent._setIgnoreDisconnect(false);
					}
					(await node._renderedComponent)[componentName] = component;
					node._currentComponent = componentName;
					component._callee = this;
					component._actions = await node._actions;
					await component.setMethods(await node._initMethods);
					component._attributeDetails = await node._attributeDetails;
					component._boundEvents = await node._boundEvents;
					component._cx = await node._cx;
					return returnVal;
				}
				async beforeUpdateFor(comp, helperNode, propValue, index) {
					let propObj = await (await (await helperNode._items)[index]).propProperty;
					if (!await propObj[propValue]) {
						propObj[propValue] = {};
					}
					if (!await (await comp._properties)[propValue]) {
						(await comp._properties)[propValue] = {};
					}
					helperNode._properties = { [propValue]: propValue };
					let oldProp = await propObj[propValue];
					propObj[propValue] = await (await comp._properties)[propValue];
					(await comp._properties)[propValue] = oldProp;
				}
				async afterUpdateFor(comp, helperNode, propValue, options) {
					let index = await options.itemIndex;
					let propObj = await (await (await helperNode._items)[index]).propProperty;
					let oldProp = await propObj[propValue];
					propObj[propValue] = await this.getProperty(propValue);
					(await comp._properties)[propValue] = oldProp;
				}
				async updateForHelper(node, options, contextSwitchInfo, establishBindings, staticTempArr, yieldComp, initialRender) {
					let hasChild = await node.hasAttribute("has-child");
					if (!await node._specialNodes) {
						node._specialNodes = [];
					}
					if (!await node._propNodes) {
						node._propNodes = {};
					}
					if (await node.tagName !== "TEMPLATE") {
						await $Lt._fE(await $Lt._gc.Object.keys(node), async function (item) {
							if (item !== "innerHTML" && item !== "innerText") {
								(await node._origTemplate)[item] = await node[item];
							}
						});
						if (await _Lyte._ie) {
							var div = await createElement("div");
							div.innerHTML = await node._tC;
							(await node._origTemplate).innerHTML = await (await (await div.children)[0]).innerHTML;
							await (await this.constr).splitTextNodes(await node._origTemplate);
							if (await node.hasAttribute("depth")) {
								await (await node._origTemplate).setAttribute("depth", await node.getAttribute("depth"));
							}
						}
						let placeHolder = (await node._origTemplate)._placeHolder = await $Lt._gc.document.createTextNode("");
						await (await node._origTemplate).setAttribute("item", await node.getAttribute("item"));
						await (await node._origTemplate).setAttribute("index", await node.getAttribute("index"));
						if ((await window.isLyteWidget || await window.__lyteEnablePromise) && await node.hasAttribute("has-child")) {
							await (await node._origTemplate).setAttribute("has-child", await node.getAttribute("has-child"));
						}
						if (await node.hasAttribute("unbound")) {
							await (await node._origTemplate).setAttribute("unbound", "true");
						}
						await _LC.replaceWithPf(node, await (await node._origTemplate)._placeHolder);
						node = await _LC.replaceWithOrigTemplate(node);
						await node.setAttribute("is", "for");
						await _LC.apdNode(node, this);
						placeHolder._helper = node;
					} else if (!await node._placeHolder) {
						var emptyTextNode, tnode;
						emptyTextNode = await $Lt._gc.document.createTextNode("");
						await _LC.replaceWithPf(node, emptyTextNode);
						node._placeHolder = emptyTextNode;
						emptyTextNode._helper = node;
						await _LC.apdNode(node, this);
					}
					node._sta = await node._sta || staticTempArr;
					let callee = this;
					node._callee = this;
					node._attributes = await node._attributes || {};
					if (await options.type === "update" && await node._currentItems === await (await node._attributes).items && (!options || !await options.force)) {
						return {};
					}
					node._cx = contextSwitchInfo || await node._cx;
					let indexValue = await node.getAttribute("index");
					if (!indexValue) {
						await node.setAttribute("index", "index");
						indexValue = "index";
					}
					let itemValue = await node.getAttribute("item");
					if (!itemValue) {
						await node.setAttribute("item", "item");
						itemValue = "item";
					}
					if (await node.hasAttribute("dir-obj")) {
						node._dirObj = await $Lt._gc.JSON.parse(await node.getAttribute("dir-obj"));
					}
					let cmpData = await LyteComponent.getCmpData(await (await callee.component).data);
					let initialItemValue = await cmpData[itemValue], initialIndexValue = await cmpData[indexValue];
					let initialItemProp = await (await callee._properties)[itemValue], initialIndexProp = await (await callee._properties)[indexValue];
					(await callee._properties)[itemValue] = (await callee._properties)[indexValue] = {};
					let items = await (await node._attributes).items, content = await node.content, dynamicNodes = await node._dynamicNodes, lastNode = node;
					if (!await node._items) {
						node._items = [];
					}
					node._dynProps = await node._dynProps || {};
					let lastIndexForIteration;
					let firstIndexForIteration;
					let firstIndex = await options.firstIndex;
					let secondIndex = await options.secondIndex;
					let thirdIndex = await options.thirdIndex;
					var totalNodeIndex = firstIndex + secondIndex;
					var updateIndexProperty = true;
					var indexPropertyStartIndex = 0;
					if (options) {
						switch (await options.type) {
						case "remove": {
								lastIndexForIteration = firstIndex;
								indexPropertyStartIndex = firstIndex;
								for (let i = firstIndex, v = secondIndex; v > 0; (v = v - 1) + 1, (i = i + 1) - 1) {
									await this.removeHelpersSpecificIndex(node, i);
								}
								await (await _LCSV.for).beforeUpdate(node, [
									firstIndex,
									secondIndex
								], [], []);
								for (let i = firstIndex + secondIndex; i < await (await node._items).length; (i = i + 1) - 1) {
									(await (await (await node._items)[i])._cx).itemIndex = await (await (await (await node._items)[i])._cx).itemIndex - secondIndex;
								}
								await (await node._items).splice(firstIndex, secondIndex);
								await (await node._helpers).splice(firstIndex, secondIndex);
								await (await _LCSV.for).afterUpdate(node, [
									firstIndex,
									secondIndex
								], []);
								await (await node._forContent).splice(firstIndex, secondIndex);
								await node._specialNodes && await (await node._specialNodes).splice(firstIndex, secondIndex);
								break;
							}
						case "insert": {
								firstIndexForIteration = firstIndex;
								lastIndexForIteration = secondIndex;
								indexPropertyStartIndex = firstIndex + secondIndex;
								if (await (await node._forContent)[firstIndex]) {
									lastNode = await (await (await node._forContent)[firstIndex])[0];
								}
								let newArr = [], newObj = [], newArr1 = [], newPropObj = [];
								for (let v = secondIndex, k = firstIndex; v > 0; (v = v - 1) + 1, (k = k + 1) - 1) {
									await newArr.push([]);
									await newObj.push({});
									await newArr1.push([]);
									await newPropObj.push({ __dummy: true });
								}
								await (await _LCSV.for).beforeUpdate(node, [
									firstIndex,
									0
								], newPropObj, newObj);
								await (await (await node._helpers).splice).apply(await node._helpers, await [
									firstIndex,
									0
								].concat(newArr));
								await (await (await node._items).splice).apply(await node._items, await [
									firstIndex,
									0
								].concat(newObj));
								await (await _LCSV.for).afterUpdate(node, [
									firstIndex,
									0
								], newPropObj);
								for (let i = firstIndex + secondIndex; i < await (await node._items).length; (i = i + 1) - 1) {
									(await (await (await node._items)[i])._cx).itemIndex = await (await (await (await node._items)[i])._cx).itemIndex + secondIndex;
								}
								await (await (await node._forContent).splice).apply(await node._forContent, await [
									firstIndex,
									0
								].concat(newArr1));
								await node._specialNodes && await (await (await node._specialNodes).splice).apply(await node._specialNodes, await [
									firstIndex,
									0
								].concat(newArr1));
							}
							break;
						case "replace": {
								firstIndexForIteration = firstIndex;
								lastIndexForIteration = secondIndex;
								indexPropertyStartIndex = firstIndex + secondIndex;
								await this.removeHelpersSpecificIndex(node, firstIndex);
								let newArr = [], newObj = [], newArr1 = [], newPropObj = [];
								for (let v = secondIndex, k = firstIndex; v > 0; (v = v - 1) + 1, (k = k + 1) - 1) {
									await newArr.push([]);
									await newArr1.push([]);
									await newObj.push({});
									await newPropObj.push({ __dummy: true });
								}
								await (await _LCSV.for).beforeUpdate(node, [
									await options.firstIndex,
									1
								], newPropObj, newObj);
								let toAppendMain = await createDocFragment();
								if (await (await node._forContent)[firstIndex + 1]) {
									lastNode = await (await (await node._forContent)[firstIndex + 1])[0];
								}
								await (await (await node._helpers).splice).apply(await node._helpers, await [
									firstIndex,
									1
								].concat(newArr));
								await (await (await node._items).splice).apply(await node._items, await [
									firstIndex,
									1
								].concat(newObj));
								await (await _LCSV.for).afterUpdate(node, [
									await options.firstIndex,
									1
								], newPropObj);
								for (let i = firstIndex + secondIndex; i < await (await node._items).length; (i = i + 1) - 1) {
									(await (await (await node._items)[i])._cx).itemIndex = await (await (await (await node._items)[i])._cx).itemIndex + secondIndex - 1;
								}
								await (await (await node._forContent).splice).apply(await node._forContent, await [
									firstIndex,
									1
								].concat(newArr1));
								await node._specialNodes && await (await (await node._specialNodes).splice).apply(await node._specialNodes, await [
									firstIndex,
									1
								].concat(newArr1));
								if (await options.secondIndex == 1) {
									updateIndexProperty = false;
								}
								break;
							}
						case "splice": {
								firstIndexForIteration = firstIndex;
								lastIndexForIteration = secondIndex;
								indexPropertyStartIndex = firstIndex + secondIndex;
								let newArr = [], newObj = [], newArr1 = [], newPropObj = [];
								for (let v = secondIndex, k = firstIndex; v > 0; (v = v - 1) + 1, (k = k + 1) - 1) {
									await newArr.push([]);
									await newArr1.push([]);
									await newObj.push({});
									await newPropObj.push({ __dummy: true });
								}
								for (let i = thirdIndex, j = 0; i > 0; (i = i - 1) + 1, (j = j + 1) - 1) {
									await this.removeHelpersSpecificIndex(node, firstIndex + j);
								}
								await (await _LCSV.for).beforeUpdate(node, [
									firstIndex,
									thirdIndex
								], newPropObj, newObj);
								let toAppendMain = await createDocFragment();
								if (await (await node._forContent)[firstIndex + thirdIndex]) {
									lastNode = await (await (await node._forContent)[firstIndex + thirdIndex])[0];
								}
								await (await (await node._helpers).splice).apply(await node._helpers, await [
									firstIndex,
									thirdIndex
								].concat(newArr));
								await (await (await node._items).splice).apply(await node._items, await [
									firstIndex,
									thirdIndex
								].concat(newObj));
								await (await _LCSV.for).afterUpdate(node, [
									firstIndex,
									thirdIndex
								], newPropObj);
								for (let i = firstIndex + secondIndex; i < await (await node._items).length; (i = i + 1) - 1) {
									(await (await (await node._items)[i])._cx).itemIndex = await (await (await (await node._items)[i])._cx).itemIndex + secondIndex - thirdIndex;
								}
								await (await (await node._forContent).splice).apply(await node._forContent, await [
									firstIndex,
									thirdIndex
								].concat(newArr1));
								await node._specialNodes && await (await (await node._specialNodes).splice).apply(await node._specialNodes, await [
									firstIndex,
									thirdIndex
								].concat(newArr1));
								if (await options.secondIndex == await options.thirdIndex) {
									updateIndexProperty = false;
								}
								break;
							}
							break;
						case "update": {
								let key = await node.getAttribute("item");
								for (let i = 0; i < await (await node._items).length; (i = i + 1) - 1) {
									await this.removeHelpersSpecificIndex(node, i);
									await (await _LCSV.for).update(node);
								}
								node._items = [];
							}
						case "default": {
								node._forContent = [];
								node._specialNodes = [];
								node._propNodes = {};
								node._helpers = [];
								firstIndexForIteration = 0;
								lastIndexForIteration = items ? await items.length : 0;
								indexPropertyStartIndex = items ? await items.length : 0;
							}
							break;
						default:
							await _Lyte.error("Error in updateForHelper");
						}
					}
					if (!lastNode) {
						lastNode = node;
					}
					if (lastNode != node && await (await node._helpers).length > 0 && (await options.type == "insert" || "replace" || "splice")) {
						lastNode = await _LC.findLastNodeL(lastNode, totalNodeIndex, node);
					}
					let returnVal;
					var localUnbound = false;
					var initialUnbound = await _LC.unbound;
					if (await node.hasAttribute("unbound") || await node._attributes && await (await node._attributes).unbound && await (await node._attributes).unbound !== "false") {
						localUnbound = true;
						_LC.unbound = true;
					}
					if (!await node._fRender && (await node.getAttribute("unbound") == "lyteFastRender" || await node._attributes && await (await node._attributes).unbound == "lyteFastRender")) {
						node._fRender = true;
					}
					node._currentItems = items;
					if (!await _Lyte._ms && lastIndexForIteration - firstIndexForIteration > 0 || (await window.isLyteWidget || await window.__lyteEnablePromise) && await $Lt._iO(items, $Lt._gc.Promise)) {
						if (await node._ht && !await node._htA) {
							await (await node.content).append(await (await (await node._ht).content).cloneNode(true));
							node._htA = true;
						}
					}
					let currentCaseName;
					var dirObjData = {
							data: {},
							prop: {}
						};
					var dirObjProp = {
							data: {},
							prop: {}
						};
					let trueNode = node;
					if (await options.type !== "remove") {
						var totalString = "";
						var domArr = [];
						var toAppendMain = await createDocFragment();
						if (hasChild && (await window.isLyteWidget || await window.__lyteEnablePromise)) {
							let scope, renderPromiseNodes = true;
							let status = await $Lt._iO(items, $Lt._gc.Promise) ? await (await items.__lyte).status : "resolved";
							switch (status) {
							case "init": {
									currentCaseName = "__lyteAwait__";
								}
								break;
							case "resolved": {
									currentCaseName = "true";
									renderPromiseNodes = false;
								}
								break;
							case "rejected": {
									currentCaseName = "__lyteFail__";
								}
								break;
							}
							if (await node._promiseContent && await (await node._promiseContent).length) {
								await this.removeHelpers(node, $Lt._gc.undefined, true);
							}
							trueNode = await (await node.content).querySelector("[case=" + currentCaseName + "]");
							scope = await (await node._cases)[currentCaseName];
							trueNode._ht = await scope._ht;
							if (await trueNode._ht && !await trueNode._htA) {
								await (await trueNode.content).append(await (await (await trueNode._ht).content).cloneNode(true));
								trueNode._htA = true;
							}
							dynamicNodes = await scope.dynamicNodes;
							if (renderPromiseNodes) {
								await this.renderPromiseNodes(trueNode, dynamicNodes, node, {}, establishBindings, $Lt._gc.undefined, await node._tC, yieldComp, toAppendMain);
							}
						}
						await _LCSV.beforeDirObj(node, dirObjData, dirObjProp);
						for (let k = firstIndexForIteration, v = lastIndexForIteration; v > 0; (k = k + 1) - 1, (v = v - 1) + 1) {
							(await node._helpers)[k] = [];
							(await node._specialNodes)[k] = [];
							(await node._items)[k] = {
								"_dynamicProperty": {},
								"itemProperty": {},
								"indexProperty": {},
								"propProperty": {},
								"propPropertyDyn": {},
								"propNodes": {}
							};
							cmpData[itemValue] = await items[k];
							cmpData[indexValue] = k;
							var cacheData = {};
							cacheData[itemValue] = {};
							(await cacheData[itemValue])._data = await items[k];
							(await cacheData[itemValue])._dyn = [itemValue];
							cacheData[indexValue] = {};
							(await cacheData[indexValue])._data = k;
							(await cacheData[indexValue])._dyn = [indexValue];
							(await callee._properties)[itemValue] = {};
							(await callee._properties)[indexValue] = {};
							let optns = {
									"itemValue": itemValue,
									"itemIndex": k,
									"type": "for",
									"node": node,
									"indexValue": indexValue
								};
							(await (await node._items)[k])._cx = optns;
							let breakCheck = {};
							let toAppend;
							if (await node._fRender) {
								let str = await this.renderFast(dynamicNodes, await node._sta, await this.component);
								totalString = totalString + str;
							} else {
								dynamicNodes._cache = cacheData;
								toAppend = await this.renderNodes(await trueNode.hasAttribute("depth") && await trueNode._depthTemp ? await trueNode._depthTemp : trueNode, dynamicNodes, node, optns, establishBindings, breakCheck, await node._tC, yieldComp);
							}
							let dynProps = await $Lt._gc.Object.keys(await (await (await node._items)[k])._dynamicProperty);
							for (let d = 0; d < await dynProps.length; (d = d + 1) - 1) {
								let key = await dynProps[d];
								await (await node._dynProps)[key] ? ((await node._dynProps)[key] = await (await node._dynProps)[key] + 1) - 1 : (await node._dynProps)[key] = 1;
							}
							(await (await node._items)[k]).itemProperty = await this.getProperty(itemValue);
							(await (await node._items)[k]).indexProperty = await this.getProperty(indexValue);
							if (!await _LC.unbound) {
								await _LC.establishBindings({ [itemValue]: await (await (await node._items)[k]).itemProperty }, { [itemValue]: await (await (await node._attributes).items)[k] });
							}
							if (!await node._fRender) {
								(await node._forContent)[k] = await $Lt._gc.Array.from(await toAppend.childNodes);
							} else {
								await domArr.push((await node._forContent)[k] = []);
							}
							await this.executeBlockHelpers(await (await node._helpers)[k], node);
							if (!await node._fRender) {
								await toAppendMain.appendChild(toAppend);
							}
							if (await breakCheck.stop) {
								break;
							}
						}
						if (await node._fRender) {
							var s = await $Lt._gc.document.createElement("template");
							s.innerHTML = totalString;
							await toAppendMain.appendChild(await s.content);
							await _LC.processAction(toAppendMain);
							var childrenArr;
							if (await _Lyte._ie) {
								childrenArr = [];
								var childNodes = await toAppendMain.childNodes;
								for (var i = 0; i < await childNodes.length; (i = i + 1) - 1) {
									if (await (await childNodes[i]).nodeType == 1) {
										await childrenArr.push(await childNodes[i]);
									}
								}
							} else {
								childrenArr = await toAppendMain.children;
							}
							for (var i = 0; i < await domArr.length; (i = i + 1) - 1) {
								await (await domArr[i]).push(await childrenArr[i]);
							}
							await $Lt._gcFn.requestAnimationFrame(async function () {
								await $Lt._gcFn.requestAnimationFrame(async function () {
									await _LC.callCC();
								});
							});
						}
						_LC.unbound = initialUnbound;
						if (await options.type === "default") {
							returnVal = {
								"toAppendMain": toAppendMain,
								"lastNode": lastNode
							};
						} else {
							if (await lastNode._placeHolder) {
								await insertBefore(await (await lastNode._placeHolder).parentNode, toAppendMain, await lastNode._placeHolder);
							} else {
								await insertBefore(await lastNode.parentNode, toAppendMain, lastNode);
							}
						}
						if (!localUnbound && await node._removedAttributes && await (await node._removedAttributes).items && !await (await (await node._removedAttributes).items).helperValue && await (await (await node._removedAttributes).items)._multipleProperty) {
							await _LC.establishBindings({ "items": await (await (await (await (await node._removedAttributes).items)._multipleProperty)[0]).actProp }, { "items": items });
						}
					}
					_LC.unbound = initialUnbound;
					if (updateIndexProperty) {
						for (let i = indexPropertyStartIndex; i < await (await node._items).length; (i = i + 1) - 1) {
							if (await (await (await node._items)[i]).indexProperty) {
								await _LC.affectChanges(await (await (await node._items)[i]).indexProperty);
							}
						}
					}
					cmpData[itemValue] = initialItemValue;
					cmpData[indexValue] = initialIndexValue;
					(await callee._properties)[itemValue] = initialItemProp;
					(await callee._properties)[indexValue] = initialIndexProp;
					await _LCSV.afterDirObj(node, dirObjData, dirObjProp);
					await _LCSV.afterRender(node, this, dirObjProp, options, initialRender);
					node._currentItems = items;
					return returnVal;
				}
				async renderPromiseNodes(trueNode, dynamicNodes, node, optns, establishBindings, returnVal, templateContent, yieldComp, toAppendMain) {
					let toAppend = await this.renderNodes(trueNode, dynamicNodes, $Lt._gc.undefined, {}, establishBindings, $Lt._gc.undefined, templateContent, yieldComp);
					node._promiseContent = [];
					let contentArr = [toAppend];
					for (let i = 0; i < await contentArr.length; (i = i + 1) - 1) {
						if (await (await contentArr[i]).nodeType == 11) {
							node._promiseContent = await (await node._promiseContent).concat(await $Lt._gc.Array.from(await (await contentArr[i]).childNodes));
						} else {
							await (await node._promiseContent).push(await contentArr[i]);
						}
						await toAppendMain.append(await contentArr[i]);
					}
				}
				async updateForInHelper(node, options, contextSwitchInfo, establishBindings, yieldComp, initialRender) {
					let hasChild = await node.hasAttribute("has-child");
					if (!await node._specialNodes) {
						node._specialNodes = [];
					}
					if (!await node._propNodes) {
						node._propNodes = {};
					}
					if (await node.tagName !== "TEMPLATE") {
						await $Lt._fE(await $Lt._gc.Object.keys(node), async function (item) {
							if (item !== "innerHTML" && item !== "innerText") {
								(await node._origTemplate)[item] = await node[item];
							}
						});
						if (await _Lyte._ie) {
							var div = await createElement("div");
							div.innerHTML = await node._tC;
							(await node._origTemplate).innerHTML = await (await (await div.children)[0]).innerHTML;
							await (await this.constr).splitTextNodes(await node._origTemplate);
							if (await node.hasAttribute("depth")) {
								await (await node._origTemplate).setAttribute("depth", await node.getAttribute("depth"));
							}
						}
						let placeHolder = (await node._origTemplate)._placeHolder = await $Lt._gc.document.createTextNode("");
						await (await node._origTemplate).setAttribute("key", await node.getAttribute("key"));
						await (await node._origTemplate).setAttribute("value", await node.getAttribute("value"));
						if (await node.hasAttribute("unbound")) {
							await (await node._origTemplate).setAttribute("unbound", "true");
						}
						if ((await window.isLyteWidget || await window.__lyteEnablePromise) && await node.hasAttribute("has-child")) {
							await (await node._origTemplate).setAttribute("has-child", await node.getAttribute("has-child"));
						}
						await _LC.replaceWithPf(node, await (await node._origTemplate)._placeHolder);
						node = await _LC.replaceWithOrigTemplate(node);
						await node.setAttribute("is", "forIn");
						await _LC.apdNode(node, this);
						placeHolder._helper = node;
					} else if (!await node._placeHolder) {
						var emptyTextNode;
						emptyTextNode = await $Lt._gc.document.createTextNode("");
						await _LC.replaceWithPf(node, emptyTextNode);
						node._placeHolder = emptyTextNode;
						await _LC.apdNode(node, this);
						emptyTextNode._helper = node;
					}
					let callee = this;
					node._callee = this;
					node._attributes = await node._attributes || {};
					if (await options.type === "update" && await node._currentObject === await (await node._attributes).object && (!options || !await options.force)) {
						return {};
					}
					contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : await node._cx;
					node._cx = contextSwitchInfo;
					let key = await node.getAttribute("key");
					if (!key) {
						key = "key";
						await node.setAttribute("key", "key");
					}
					let value = await node.getAttribute("value");
					if (!value) {
						value = "value";
						await node.setAttribute("value", "value");
					}
					await _LCSV.setDirObj(node);
					let cmpData = await LyteComponent.getCmpData(await (await callee.component).data);
					let initialKeyValue = await cmpData[key];
					let initialValueValue = await cmpData[value];
					let initialKeyProp = await (await callee._properties)[key];
					let initialValueProp = await (await callee._properties)[value];
					(await callee._properties)[key] = (await callee._properties)[value] = {};
					let object = await (await node._attributes).object;
					let content = await node.content;
					let dynamicNodes = await node._dynamicNodes;
					let lastNode = node;
					let keysArray = [];
					if (!await node._items) {
						node._items = {};
					}
					node._dynProps = await node._dynProps || {};
					if (options) {
						switch (await options.type) {
						case "delete": {
								await this.removeHelpersSpecificIndex(node, await options.property, $Lt._gc.undefined, await options.type);
								await (await _LCSV.forIn).delete(node, options);
								var delIndex = await (await node._keysArray).indexOf(await options.property);
								if (delIndex > -1) {
									await (await node._keysArray).splice(delIndex, 1);
								}
								if (await node._helpers) {
									delete (await node._helpers)[await options.property];
								}
								delete (await node._propBindingObject)[await options.property];
								(await node._forContent)[await options.property] = null;
								delete (await node._forContent)[await options.property];
							}
							break;
						case "add": {
								let replace = false;
								keysArray = [await options.property];
								replace = await (await node._keysArray).indexOf(await options.property) != -1 ? true : false;
								!replace && await (await node._keysArray).push(await options.property);
								let returnedLastNode = await (await _LCSV.forIn).add(node, options, keysArray, replace);
								if (returnedLastNode) {
									lastNode = returnedLastNode;
								}
							}
							break;
						case "update": {
								await $Lt._fE(await node._keysArray, async function (itemKey, index, array) {
									await this.removeHelpersSpecificIndex(node, itemKey, $Lt._gc.undefined, await options.type);
								}, this);
								await (await _LCSV.forIn).update(node);
								node._keysArray = keysArray = object ? await $Lt._gc.Object.keys(object) : [];
								node._helpers = {};
								node._items = {};
								node._propBindingObject = {};
							}
						case "default": {
								node._forContent = {};
								node._specialNodes = {};
								node._propNodes = {};
								node._helpers = {};
								node._keysArray = keysArray = object ? await $Lt._gc.Object.keys(object) : [];
							}
							break;
						default:
							await _Lyte.error("Error in updateForHelper");
						}
					}
					let returnVal;
					if (!object) {
						let toAppendMain = await createDocFragment();
						if (await options.type !== "default") {
							await insertBefore(await lastNode.parentNode, toAppendMain, lastNode);
						} else {
							returnVal = {
								"toAppendMain": toAppendMain,
								"lastNode": lastNode
							};
						}
					}
					let localUnbound = false;
					let initialUnbound = await _LC.unbound;
					if (await node.hasAttribute("unbound") || await node._attributes && await (await node._attributes).unbound) {
						localUnbound = true;
						_LC.unbound = true;
					}
					node._currentObject = object;
					if (!await _Lyte._ms && (await keysArray.length || (await window.isLyteWidget || await window.__lyteEnablePromise) && await $Lt._iO(object, $Lt._gc.Promise)) && await node._ht && !await node._htA) {
						await (await node.content).append(await (await (await node._ht).content).cloneNode(true));
						node._htA = true;
					}
					let currentCaseName;
					let trueNode = node;
					var dirObjData = {
							data: {},
							prop: {}
						};
					var dirObjProp = {
							data: {},
							prop: {}
						};
					if (object && await options.type !== "remove") {
						var toAppendMain = await createDocFragment();
						node._propBindingObject = await node._propBindingObject || {};
						if (hasChild && (await window.isLyteWidget || await window.__lyteEnablePromise)) {
							let scope, renderPromiseNodes = true;
							let status = await $Lt._iO(object, $Lt._gc.Promise) ? await (await object.__lyte).status : "resolved";
							switch (status) {
							case "init": {
									currentCaseName = "__lyteAwait__";
								}
								break;
							case "resolved": {
									currentCaseName = "true";
									renderPromiseNodes = false;
								}
								break;
							case "rejected": {
									currentCaseName = "__lyteFail__";
								}
								break;
							}
							if (await node._promiseContent && await (await node._promiseContent).length) {
								await this.removeHelpers(node, $Lt._gc.undefined, true);
							}
							trueNode = await (await node.content).querySelector("[case=" + currentCaseName + "]");
							scope = await (await node._cases)[currentCaseName];
							trueNode._ht = await scope._ht;
							if (await trueNode._ht && !await trueNode._htA) {
								await (await trueNode.content).append(await (await (await trueNode._ht).content).cloneNode(true));
								trueNode._htA = true;
							}
							dynamicNodes = await scope.dynamicNodes;
							if (renderPromiseNodes) {
								await this.renderPromiseNodes(trueNode, dynamicNodes, node, {}, establishBindings, $Lt._gc.undefined, await node._tC, yieldComp, toAppendMain);
							}
						}
						await _LCSV.beforeDirObj(node, dirObjData, dirObjProp);
						await $Lt._fE(keysArray, async function (itemKey, index, array) {
							(await node._helpers)[itemKey] = [];
							(await node._specialNodes)[itemKey] = [];
							(await node._items)[itemKey] = {
								"_dynamicProperty": {},
								"itemProperty": {},
								"propProperty": {},
								"propPropertyDyn": {},
								"propNodes": {}
							};
							cmpData[key] = itemKey;
							cmpData[value] = await object[itemKey];
							(await callee._properties)[key] = {};
							(await callee._properties)[value] = {};
							var cacheData = {};
							cacheData[key] = {};
							(await cacheData[key])._data = itemKey;
							(await cacheData[key])._dyn = [key];
							cacheData[value] = {};
							(await cacheData[value])._data = await object[itemKey];
							(await cacheData[value])._dyn = [value];
							let optns = {
									"itemIndex": itemKey,
									"itemValue": value,
									"keyValue": key,
									"type": "forIn",
									"node": node
								};
							(await (await node._items)[itemKey])._cx = optns;
							dynamicNodes._cache = cacheData;
							let toAppend = await this.renderNodes(await trueNode.hasAttribute("depth") && await trueNode._depthTemp ? await trueNode._depthTemp : trueNode, dynamicNodes, node, optns, establishBindings, $Lt._gc.undefined, await node._tC, yieldComp);
							await $Lt._fE(await $Lt._gc.Object.keys(await (await (await node._items)[itemKey])._dynamicProperty), async function (key) {
								await (await node._dynProps)[key] ? ((await node._dynProps)[key] = await (await node._dynProps)[key] + 1) - 1 : (await node._dynProps)[key] = 1;
							});
							(await (await node._items)[itemKey]).itemProperty = await this.getProperty(value);
							(await node._propBindingObject)[itemKey] = await (await (await node._items)[itemKey]).itemProperty;
							(await node._forContent)[itemKey] = await $Lt._gc.Array.from(await toAppend.childNodes);
							await this.executeBlockHelpers(await (await node._helpers)[itemKey], node);
							await toAppendMain.appendChild(toAppend);
						}, this);
						if (!await _LC.unbound) {
							await addBindings(await (await node._attributes).object, await node._propBindingObject);
							await _LC.establishBindings(await node._propBindingObject, await (await node._attributes).object);
						}
						_LC.unbound = initialUnbound;
						if (await options.type !== "default") {
							if (await lastNode._placeHolder) {
								await insertBefore(await (await lastNode._placeHolder).parentNode, toAppendMain, await lastNode._placeHolder);
							} else {
								await insertBefore(await lastNode.parentNode, toAppendMain, lastNode);
							}
						} else {
							returnVal = {
								"toAppendMain": toAppendMain,
								"lastNode": lastNode
							};
						}
					}
					_LC.unbound = initialUnbound;
					cmpData[key] = initialKeyValue;
					cmpData[value] = initialValueValue;
					(await callee._properties)[key] = initialKeyProp;
					(await callee._properties)[value] = initialValueProp;
					await _LCSV.afterDirObj(node, dirObjData, dirObjProp);
					await _LCSV.afterRender(node, this, dirObjProp, options, initialRender);
					node._currentObject = object;
					return returnVal;
				}
				async updateSwitchHelper(type, node, contextSwitchInfo, update, establishBindings, yieldComp, id, toBeInsMap) {
					if (!await node._specialNodes) {
						node._specialNodes = [];
					}
					if (!await _Lyte._ms && await node._ht && !await node._htA) {
						await (await node.content).append(await (await (await node._ht).content).cloneNode(true));
						node._htA = true;
					}
					if (await node.tagName !== "TEMPLATE") {
						await $Lt._fE(await $Lt._gc.Object.keys(node), async function (item) {
							if (item !== "innerHTML" && item !== "innerText") {
								(await node._origTemplate)[item] = await node[item];
							}
						});
						if (await _Lyte._ie) {
							var div = await createElement("div");
							div.innerHTML = await node._tC;
							(await node._origTemplate).innerHTML = await (await (await div.children)[0]).innerHTML;
							await (await this.constr).splitTextNodes(await node._origTemplate);
							if (await node.hasAttribute("depth")) {
								await (await node._origTemplate).setAttribute("depth", await node.getAttribute("depth"));
							}
						}
						let placeHolder = (await node._origTemplate)._placeHolder = await $Lt._gc.document.createTextNode("");
						await _LC.replaceWithPf(node, await (await node._origTemplate)._placeHolder);
						node = await _LC.replaceWithOrigTemplate(node);
						await node.setAttribute("is", type);
						await _LC.apdNode(node, this);
						placeHolder._helper = node;
					} else if (!await node._placeHolder) {
						var emptyTextNode;
						emptyTextNode = await $Lt._gc.document.createTextNode("");
						await _LC.replaceWithPf(node, emptyTextNode);
						node._placeHolder = emptyTextNode;
						emptyTextNode._helper = node;
						await _LC.apdNode(node, this);
					}
					let isNew = false;
					let lastNode = node;
					if (!await node._callee) {
						node._callee = this;
						isNew = true;
					}
					contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : await node._cx;
					node._cx = contextSwitchInfo;
					node._dynamicProperty = await node._dynamicProperty ? await node._dynamicProperty : {};
					let currentCaseName;
					let value;
					if (await node.getAttribute("value") === "" || await node.getAttribute("value")) {
						value = await node.getAttribute("value");
					} else if (await node._attributes) {
						value = await (await node._attributes).value;
					}
					if (value) {
						let status = await $Lt._iO(value, $Lt._gc.Promise) ? await (await value.__lyte).status : "resolved";
						switch (status) {
						case "init": {
								currentCaseName = "__lyteAwait__";
							}
							break;
						case "rejected": {
								currentCaseName = "__lyteFail__";
							}
							break;
						case "resolved": {
								currentCaseName = type === "if" ? "true" : await value.toString();
							}
						}
					} else {
						if (type === "if") {
							currentCaseName = "false";
						} else {
							switch (value) {
							case $Lt._gc.undefined:
								currentCaseName = "undefined";
								break;
							case null:
								currentCaseName = "null";
								break;
							case false:
								currentCaseName = "false";
								break;
							case "":
								currentCaseName = "\"\"";
								break;
							case 0:
								currentCaseName = "0";
							}
						}
					}
					if (currentCaseName === await node._currentCase) {
						return;
					}
					node._currentCase = currentCaseName;
					var nodeTemp = await node._depthTemp || node;
					let scope = await (await node._cases)[currentCaseName];
					let defaultContent;
					if (!scope) {
						scope = await node._default;
						defaultContent = await _Lyte._ms ? await scope.templateContent : await (await nodeTemp.content).querySelector("[default]");
						if (!await _Lyte._ms && await scope._ht && !await defaultContent._htA) {
							defaultContent._htA = true;
							await (await defaultContent.content).append(await (await (await scope._ht).content).cloneNode(true));
						}
						node._isDefault = true;
						if (!defaultContent) {
							if (await node._caseContent && await (await node._caseContent).length) {
								await this.removeHelpers(node, $Lt._gc.undefined, true);
							}
							node._caseContent = [];
							let emptyTextNode = await $Lt._gc.document.createTextNode("");
							await (await node._caseContent).push(emptyTextNode);
							node._currentCaseName = currentCaseName;
							node._helpers = await node._helpers || [];
							if (update) {
								if (await lastNode._placeHolder) {
									await insertBefore(await (await lastNode._placeHolder).parentNode, emptyTextNode, await lastNode._placeHolder);
								} else {
									await insertBefore(await lastNode.parentNode, emptyTextNode, node);
								}
								return;
							} else {
								let toAppendMain = await createDocFragment();
								await toAppendMain.append(emptyTextNode);
								return {
									lastNode: lastNode,
									toAppendMain: toAppendMain
								};
							}
						}
					}
					if (await node._caseContent && await (await node._caseContent).length) {
						await this.removeHelpers(node, $Lt._gc.undefined, true);
					}
					let dummyScope = scope;
					let additionalContentArr = [];
					let cnt = 0;
					let dummyCaseName = currentCaseName;
					let template;
					if (defaultContent) {
						template = defaultContent;
					} else {
						template = await _Lyte._ms ? {} : await (await nodeTemp.content).querySelector("[case='" + await _LC.cssEscape(dummyCaseName) + "']");
					}
					let contentArr = [];
					while (dummyScope) {
						if (!await _Lyte._ms && await dummyScope._ht && !await template._htA) {
							template._htA = true;
							await (await template.content).append(await (await (await dummyScope._ht).content).cloneNode(true));
						}
						let dynamicNodes = await dummyScope.dynamicNodes;
						let compName = await template.getAttribute("render-view-port-template");
						if (compName) {
							let compConstr = await (await LyteComponent._registeredComponents)[compName];
							if (compConstr) {
								let preTemp = await (await compConstr.component)._preRenderTemplate;
								if (!preTemp) {
									await _Lyte.error("Viewport template for the component '" + compName + "' not found.");
								}
								let root = await preTemp.getAttribute("root");
								let viewTempContent = await (await preTemp.content).cloneNode(true);
								!root && await (await template.content).appendChild(await $Lt._gc.document.createElement("dummy-view-port"));
								await (await template.content).appendChild(viewTempContent);
								root && await (await template.content).appendChild(await $Lt._gc.document.createElement("dummy-view-port"));
							} else {
								await _Lyte.error("Unable to load viewport template for the component '" + compName + "' . Since it is not registered yet.");
							}
						}
						let processedContent = await this.renderNodes(template, dynamicNodes, node, $Lt._gc.undefined, establishBindings, $Lt._gc.undefined, await dummyScope.templateContent, yieldComp);
						await contentArr.push(processedContent);
						if (await dummyScope.additional) {
							if (await (await dummyScope.additional).next) {
								template = await _Lyte._ms ? {} : await (await node.content).querySelector("[case='" + await _LC.cssEscape(await (await dummyScope.additional).next) + "']");
								dummyScope = await (await node._cases)[await (await dummyScope.additional).next];
							} else {
								template = await _Lyte._ms ? {} : await (await node.content).querySelector("[default]");
								dummyScope = await node._default;
							}
						} else {
							break;
						}
					}
					node._caseContent = [];
					let toAppendMain = await createDocFragment();
					;
					for (let i = 0; i < await contentArr.length; (i = i + 1) - 1) {
						if (await (await contentArr[i]).nodeType == 11) {
							node._caseContent = await (await node._caseContent).concat(await $Lt._gc.Array.from(await (await contentArr[i]).childNodes));
						} else {
							await (await node._caseContent).push(await contentArr[i]);
						}
						await toAppendMain.append(await contentArr[i]);
					}
					await this.executeBlockHelpers(await node._helpers, node);
					if (update) {
						let returnVal;
						if (await toAppendMain.querySelector("template[is=break]")) {
							returnVal = "break";
						} else if (await toAppendMain.querySelector("template[is=continue]")) {
							returnVal = "continue";
						}
						if (await node._placeHolder) {
							await insertBefore(await (await node._placeHolder).parentNode, toAppendMain, await node._placeHolder);
						} else {
							await insertBefore(await node.parentNode, toAppendMain, node);
						}
						return returnVal;
					} else {
						return {
							"toAppendMain": toAppendMain,
							"lastNode": node
						};
					}
				}
				async dummy(a, b) {
					let dummy = await (await (await (await this.constr)._properties)[$Lt._gc.boundValue]).observer;
				}
				async callObservers(boundValue, key) {
					let property = await (await (await this.constr)._properties)[boundValue];
					let observers = property ? await property.observer : $Lt._gc.undefined;
					if (observers) {
						for (let i = 0; i < await observers.length; (i = i + 1) - 1) {
							if (await key.indexOf(".") === -1 || await (await observers[i]).path === key) {
								await (await this["_" + await (await observers[i]).functionName]).apply(this);
							}
						}
					}
				}
				static async updateValue(property, path, value) {
					let pathVals = await path.split(".");
					let context = property;
					for (let i = 0; i < await pathVals.length - 1; (i = i + 1) - 1) {
						context = await context[await pathVals[i]];
					}
					context[await pathVals[$Lt._gc.i]] = value;
				}
				static async createDocFragment1(template) {
					if (await template.content) {
						return await template.content;
					}
					let childNodes = await template.childNodes;
					let frag = await createDocFragment();
					let len = await childNodes.length;
					for (let i = 0; i < len; (i = i + 1) - 1) {
						await frag.appendChild(await childNodes[0]);
					}
					return frag;
				}
				static *_registerComponentFn(a, b, widget) {
					if (_LC._reRegisteredComponents.indexOf(a) != -1) {
						b.component._template = $Lt._gc.JSON.parse(b.component._template);
						if (Lyte.getConfig("lazyComponentRegister")) {
							_LC._reRegisteredComponents.splice(_LC._reRegisteredComponents.indexOf(a), 1);
						}
					}
					if (widget) {
						window.widgetComps = window.widgetComps || {};
						var currWidgetComps = window.widgetComps[widget] = window.widgetComps[widget] || [];
						currWidgetComps.push(a);
					}
					this.__widgetName = widget;
					let componentsDiv = _LC.lyteComponentsDiv;
					let styleDiv = _Lyte.$.assetsDiv;
					let origTemplateValue = this.component._template;
					var clonedDummyTemp;
					var newCompile;
					var ta;
					var _temp;
					var styleTags;
					let div = createElement("div");
					var hasUnbound, s;
					yield () => {
						if (this.component._template && typeof this.component._template === "string") {
							this.component._template.replace((/\\'/g), "'");
							div.innerHTML = this.component._template;
							if (widget) {
								styleTags = $Lt._gc.document.createElement("template");
							}
							while (div.firstChild) {
								if (div.firstChild.nodeName === "STYLE") {
									if (styleDiv.querySelector("style[from-component='" + a + "']")) {
										styleDiv.querySelector("style[from-component='" + a + "']").remove();
									}
									div.firstChild.setAttribute("from-component", a);
									styleTags && styleTags.content.appendChild(div.firstChild.cloneNode(true));
									styleDiv.appendChild(div.firstChild);
								} else {
									if (div.firstChild.tagName == "TEMPLATE") {
										_temp = div.firstChild;
									}
									componentsDiv.appendChild(div.firstChild);
								}
							}
						} else if ($Lt._gc.document.querySelector("template[tag-name='" + a + "']")) {
							_temp = $Lt._gc.document.querySelector("template[tag-name='" + a + "']");
							componentsDiv.appendChild(_temp);
						}
						this.component._template = _temp;
						if (widget) {
							this.component._template.setAttribute("widget", widget);
							this.component._template._widgetStyles = styleTags;
						}
						this.component._template.class = this;
						this.component._template.widget = widget;
						this._helperTemplate = $Lt._gc.document.createElement("template");
						this._helperTemplate.setAttribute("_lyteht", a);
						_LC.h1Div.content.appendChild(this._helperTemplate);
						if (!this.component._template) {
							return;
						}
						if (_LC.needDummyComponentsDiv) {
							if (_Lyte._ie) {
								let temp = _Lyte.Compile.getTemplateFromString(origTemplateValue);
								_LC.dummyLyteComponentsDiv.appendChild(temp);
							} else {
								clonedDummyTemp = this.component._template.cloneNode(true);
							}
						}
						if (this.component._template && !this.component._template.content) {
						}
						hasUnbound = this.component._observedAttributes.indexOf("lyteUnbound") !== -1;
						s = _Lyte._ie ? this.component._template : this.component._template.content;
						if (hasUnbound) {
							if (_Lyte._ie) {
								newCompile = $Lt._gc.document.createElement("div");
								newCompile.innerHTML = this._template.outerHTML;
								newCompile = newCompile.childNodes[0];
							} else {
								newCompile = this.component._template.cloneNode(true);
							}
						}
						this.splitTextNodes(s);
						if (hasUnbound) {
							this.splitTextNodes(newCompile);
						}
						if (!this.component._dynamicNodes) {
							if (_Lyte.Compile.getDynamicNodes) {
								var returnVal = _Lyte.Compile.getDynamicNodes(a, $Lt._gc.undefined, _Lyte._ie ? s : $Lt._gc.undefined);
								if (returnVal.errors) {
									$Lt._gc.console.error("Error in the component", returnVal.componentName, returnVal.errors);
									return false;
								} else {
									this.component._dynamicNodes = returnVal.dynamicNodes;
								}
							} else {
								_Lyte.error("LC002", a);
							}
						}
					};
					if (!this.component._dynamicNodes) {
						yield "";
					} else {
						yield* doCompile(s, this.component._dynamicNodes, a, this, newCompile ? _Lyte._ie ? newCompile : newCompile.content : $Lt._gc.undefined);
						yield () => {
							if (_Lyte._ed) {
								this._tC = this.component._tC = this.component._template.outerHTML;
							} else if (_Lyte._ie) {
								this._tC = this.component._tC = s.outerHTML;
							}
							this.component._templateAttributes = this.component._templateAttributes || {
								type: "attr",
								"attr": {},
								position: []
							};
							ta = [this.component._templateAttributes];
						};
						yield* doCompile(this.component._template, ta, a, this);
						yield () => {
							this.component._templateAttributes = ta[0];
							if (this.component._templateAttributes && this.component._templateAttributes.attr) {
								var attributesT = this.component._template.attributes;
								try {
									for (let i = 0; i < attributesT.length; (i = i + 1) - 1) {
										let attrName = attributesT[i].name;
										if (!this.component._templateAttributes.attr[attrName] && attrName !== "tag-name" && attrName !== "use-strict") {
											this.component._templateAttributes.attr[attrName] = {
												"name": attrName,
												"staticValue": attributesT[i].value
											};
											this.component._template.removeAttribute(attrName);
											clonedDummyTemp && clonedDummyTemp.removeAttribute(attrName);
											(i = i - 1) + 1;
										}
									}
								} catch (e) {
									_Lyte.error("Error with templateAttributes. ");
								}
							}
							clonedDummyTemp && _LC.dummyLyteComponentsDiv.appendChild(clonedDummyTemp);
							this.component._sta = newCompile ? _LC.processStatic(newCompile) : $Lt._gc.undefined;
						};
					}
					yield () => {
						this.component.__isRegistered = true;
					};
				}
				static async _registerComponent(a, b, widget) {
					var gen = await this._registerComponentFn(a, b, widget);
					var gnxt = await gen.next(), gval;
					while (await gnxt.done == false) {
						gval = await gnxt.value;
						if (typeof gval == "function") {
							await gval();
						}
						gnxt = await gen.next();
					}
				}
				static async splitTextNodes(node) {
					if (node && await node.childNodes && await (await node.childNodes).length) {
						for (let i = await (await node.childNodes).length - 1; i >= 0; (i = i - 1) + 1) {
							await this.splitTextNodes(await (await node.childNodes)[i]);
						}
					}
					if (await node.tagName === "TEMPLATE" && !await _Lyte._ie) {
						await this.splitTextNodes(await node.content);
					}
					if (await node.nodeType === await node.TEXT_NODE) {
						let nodeValue = await node.nodeValue;
						if (nodeValue) {
							let mustacheValues = await nodeValue.match((/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g));
							if (!mustacheValues) {
								return;
							}
							let newNodeArray = [];
							for (let i = 0; i < await mustacheValues.length; (i = i + 1) - 1) {
								let mustacheStartIndex = await nodeValue.indexOf(await mustacheValues[i]);
								let mustacheEndIndex = mustacheStartIndex + await (await mustacheValues[i]).length;
								if (mustacheStartIndex) {
									await newNodeArray.push(await $Lt._gc.document.createTextNode(await nodeValue.substring(0, mustacheStartIndex)));
								}
								await newNodeArray.push(await $Lt._gc.document.createTextNode(await nodeValue.substring(mustacheStartIndex, mustacheEndIndex)));
								nodeValue = await nodeValue.substring(mustacheEndIndex);
							}
							if (!(!await nodeValue.trim() && await node.nextSibling && await (await node.nextSibling).nodeType === 3 && !await (await (await node.nextSibling).nodeValue).trim())) {
								await newNodeArray.push(await $Lt._gc.document.createTextNode(nodeValue));
							}
							if (await _Lyte._rwpf && await (await node.parentNode).nodeName === "#document-fragment") {
								for (let i = 0; i < await newNodeArray.length; (i = i + 1) - 1) {
									await insertBefore(await node.parentNode, await newNodeArray[i], node);
								}
								await node.remove();
							} else {
								await (await node.replaceWith).apply(node, newNodeArray);
							}
						}
					}
				}
				async bindNode(node, toBeRemoved, helperNode, options, nodeInfo, processLast, establishBindings, isTemplate, cache, type, idx, toBeInsMap) {
					let itemValue = await options.itemValue;
					let forIndex = await options.itemIndex;
					let forType = await options.type;
					let indexValue = await options.indexValue;
					let dynamicValue = await nodeInfo.dynamicValue;
					let directiveValue = await nodeInfo.directiveValue;
					let helperFunc = await nodeInfo.helperInfo;
					let nodeValue, ownerElement = await node.ownerElement;
					let dynamicValuesArray = [];
					let cmpData = await LyteComponent.getCmpData(await (await this.component).data);
					let isDirectiveNode;
					if (await node.nodeType === 2) {
						node = {
							nodeName: await node.nodeName,
							ownerElement: await node.ownerElement,
							nodeType: 2,
							nodeValue: await node.nodeValue,
							_attributeDetails: await node._attributeDetails,
							_isDirectiveNode: await nodeInfo._isDirectiveNode
						};
						isDirectiveNode = await (await _LC.directive).isDirectiveNode(nodeInfo);
					}
					let hel_name = helperFunc ? await helperFunc.name : $Lt._gc.undefined;
					node._callee = this;
					let isHelper = false;
					if (!directiveValue && helperFunc && await (await $Lt._gc.Object.keys(helperFunc)).length) {
						isHelper = true;
						let attrName = await node.nodeName;
						nodeValue = node.helperValue = helperFunc;
						let helperArgs = [];
						if (await helperFunc.name === "action") {
							let actName = await (await helperFunc.args)[0];
							(await helperFunc.args)[0] = await actName.startsWith("'") ? await actName.replace((/'/g), "") : actName;
							actName = await (await (await helperFunc.args).slice(0, 1))[0];
							let args = await (await helperFunc.args).slice(1, await (await helperFunc.args).length), isCustom = false;
							let attrName = await node.nodeName;
							if (await attrName.indexOf("-") != -1) {
								isCustom = true;
							}
							helperArgs = [
								ownerElement,
								attrName,
								isCustom,
								{
									name: actName,
									args: args
								}
							];
							await this.processHelper({
								"name": await helperFunc.name,
								"args": helperArgs
							}, node);
							return;
						} else {
							if (await helperFunc.name === "method") {
								helperArgs = await helperFunc.args;
							} else {
								helperArgs = await this.processArgs(this, { "helperInfo": helperFunc }, dynamicValuesArray, $Lt._gc.undefined, node, $Lt._gc.undefined, cache);
							}
						}
						nodeValue = await this.processHelper({
							"name": await helperFunc.name,
							"args": helperArgs
						}, node);
						if (await helperFunc.name === "unescape") {
							let obj = {
									initialNode: node,
									dynamicNodeValue: nodeValue
								};
							node = {
								dynamicPositions: obj,
								"_callee": await node._callee,
								helperValue: await node.helperValue
							};
							nodeValue = $Lt._gc.undefined;
							await processLast.push(node);
						}
					} else {
						helperFunc = {};
						if (directiveValue) {
							dynamicValue = directiveValue;
						}
						node.syntaxValue = dynamicValue;
						let dynamicValues = [];
						nodeValue = await _LC.get(cmpData, dynamicValue, dynamicValues, cache, this);
						await dynamicValuesArray.push(dynamicValues);
					}
					if (await node.nodeType == 2) {
						let tagName = await (await node.ownerElement).tagName;
						if (tagName == "INPUT" || tagName == "TEXTAREA" || tagName == "DIV" && await (await node.ownerElement).hasAttribute("contenteditable")) {
							var rA = (await node.ownerElement)._rA = await (await node.ownerElement)._rA || [];
							await (await (await node.ownerElement)._rA).push(node);
						}
						if (!await ownerElement._origTemplate) {
							if ((await ownerElement.hasAttribute("lyte-for") || await ownerElement.hasAttribute("lyte-if") || await ownerElement.hasAttribute("lyte-switch") || await ownerElement.hasAttribute("lyte-forin")) && await ownerElement.tagName !== "TEMPLATE") {
								if (await _Lyte._ie) {
									node.ownerElement = await createElement("template");
									await (await node.ownerElement).setAttribute("is", await nodeInfo._depthTemp);
								} else {
									node.ownerElement = await (await nodeInfo._depthTemp).cloneNode(true);
								}
								ownerElement._origTemplate = await node.ownerElement;
							}
						} else {
							node.ownerElement = await ownerElement._origTemplate;
						}
					}
					let estuh = false;
					let actMultiProp;
					if (!await _LC.unbound) {
						let dynamicProp;
						if (helperNode) {
							dynamicProp = forType ? await (await (await helperNode._items)[forIndex])._dynamicProperty : await helperNode._dynamicProperty;
						}
						let obj, helperId;
						for (let d = 0; d < await dynamicValuesArray.length; (d = d + 1) - 1) {
							let dynamicValues = await dynamicValuesArray[d];
							let lazyProp = [];
							let nodeFreezed;
							for (let v = 0; v < await dynamicValues.length; (v = v + 1) - 1) {
								var _nes = false;
								if (nodeFreezed) {
									continue;
								}
								;
								if (await (await dynamicValues[v]).startsWith("$dataAttributes") || await (await dynamicValues[v]).startsWith("$methodAttributes")) {
									nodeFreezed = true;
									continue;
								}
								let boundValue;
								let actProperty = await this.getProperty(await dynamicValues[v]);
								if (helperNode) {
									let ind = await (await dynamicValues[v]).search((/\W/));
									if (ind !== -1) {
										boundValue = await (await dynamicValues[v]).substring(0, ind);
									} else {
										boundValue = await dynamicValues[v];
									}
									let doHp = true;
									if (helperNode && await helperNode._dirObj && forType && boundValue) {
										if (await (await helperNode._dirObj).prop && await (await (await helperNode._dirObj).prop).indexOf(boundValue) != -1) {
											doHp = false;
											estuh = true;
										} else if (await (await helperNode._dirObj).data && await (await (await helperNode._dirObj).data).indexOf(boundValue) != -1) {
											doHp = false;
											estuh = true;
										} else {
											estuh = false;
										}
									}
									if (doHp && boundValue !== itemValue && boundValue !== indexValue && (!await options.node || !await (await options.node)._properties || !await (await (await options.node)._properties)[boundValue])) {
										await makeSet(actProperty, "_helperNodes");
										await (await actProperty._helperNodes).add(helperNode);
										await dynamicProp[await dynamicValues[v]] ? await (await dynamicProp[await dynamicValues[v]]).push(node) : await (dynamicProp[await dynamicValues[v]] = []).push(node);
									} else {
										node._cx = options;
										await makeArray(actProperty, "_dynamicNodes");
										await (await actProperty._dynamicNodes).push(node);
										if (boundValue !== indexValue) {
											actMultiProp = actProperty;
										}
									}
								} else {
									await makeArray(actProperty, "_dynamicNodes");
									await (await actProperty._dynamicNodes).push(node);
								}
								if (ownerElement && (await ownerElement.hasAttribute("lyte-for") || await ownerElement.hasAttribute("lyte-if") || await ownerElement.hasAttribute("lyte-switch") || await ownerElement.hasAttribute("lyte-forin")) || ownerElement && await ownerElement.tagName === "TEMPLATE" && await (/^(for|forIn)$/).test(await ownerElement.getAttribute("is")) && !isHelper) {
									let type = await ownerElement.getAttribute("is");
									if (type === "for" && await node.nodeName === "items" || type === "forIn" && await node.nodeName === "object") {
										if (!await actProperty._forHelpers) {
											await makeSet(actProperty, "_forHelpers");
										}
										(await node.ownerElement)._actualBinding = actProperty;
										await (await actProperty._forHelpers).add(await node.ownerElement);
									}
								}
								if (establishBindings) {
									await _LC.establishSelectedBinding(actProperty, cmpData, this);
								} else {
									if (estuh) {
										await (await _LCSV.lazyProp).add(lazyProp, node, helperNode, forIndex, boundValue, dynamicValuesArray, await dynamicValues[v]);
									}
								}
							}
							if (await dynamicValues.length > 1 && !nodeFreezed) {
								node._multipleProperty = await node._multipleProperty || [];
								await (await node._multipleProperty).push({
									"dynamicProp": actMultiProp ? $Lt._gc.undefined : dynamicProp,
									"actProp": await this.getProperty(await dynamicValues[0]),
									"helperNode": helperNode,
									"dynamicValues": dynamicValues,
									index: d
								});
							}
							await (await _LCSV.lazyProp).iterate(this, lazyProp);
						}
					}
					nodeValue = !typeof nodeValue === "boolean" && !typeof nodeValue === "number" ? nodeValue ? nodeValue : "" : nodeValue;
					if (isDirectiveNode) {
						if (!directiveValue) {
							await (await _LC.directive).setNodeArgs(node, nodeValue, this);
						}
					} else if (await node.nodeType === 2) {
						let parentNode = await node._parentNode ? await node._parentNode : await node.ownerElement;
						if (await parentNode.tagName) {
							let is = await parentNode.getAttribute("is");
						}
						let isCustomElement = await _LC.isCustomElementV3(parentNode, true);
						if (isCustomElement && !isDirectiveNode) {
							if (await parentNode.set) {
								await parentNode.set(await (await _LC.String).toCamelCase(await node.nodeName), nodeValue);
							} else {
								parentNode._initProperties = await parentNode._initProperties || {};
								(await parentNode._initProperties)[await (await _LC.String).toCamelCase(await node.nodeName)] = nodeValue;
							}
						}
						let origNodeValue = nodeValue;
						if (isCustomElement && typeof nodeValue !== "string" && !isTemplate) {
							parentNode._attributes = await parentNode._attributes || {};
							(await parentNode._attributes)[await node.nodeName] = nodeValue;
							if (await parentNode.nodeName === "TEMPLATE" && isHelper) {
								if (await parentNode.getAttribute("is") === "for" && await node.nodeName === "items" || await parentNode.getAttribute("is") === "forIn" && await node.nodeName === "object" && !await _LC.unbound) {
									(await node.ownerElement)._actualBinding = {
										"_forHelpers": await (await $Lt._cO($Lt._gc.Set)).add(parentNode),
										"_createdBinding": true
									};
									if (nodeValue) {
										await addBindings(nodeValue, await (await node.ownerElement)._actualBinding);
									}
								}
							}
							await toBeRemoved.push(await node.nodeName);
						} else {
							if (isDirectiveNode && await window.isLyteWidget && await (await node.tagName).indexOf("-") != -1) {
								if (!await node.$data) {
									node.$data = {};
								}
								(await node.$data)[await (await _LC.String).toCamelCase(await node.nodeName)] = nodeValue;
							}
							if (typeof nodeValue === "boolean") {
								parentNode._attributes = await (await node.ownerElement)._attributes || {};
								(await parentNode._attributes)[await node.nodeName] = nodeValue;
								if (!nodeValue) {
									await toBeRemoved.push(await node.nodeName);
								} else {
									await parentNode.setAttribute(await node.nodeName, "");
								}
							} else {
								if (nodeValue && typeof nodeValue === "object") {
									var res;
									if (typeof $Lt._gc.Record != "undefined" && await $Lt._iO(nodeValue, $Lt._gc.Record)) {
										res = await $Lt._gc.JSON.stringify(await (await nodeValue.$).toJSON());
									} else {
										try {
											res = await $Lt._gc.JSON.stringify(nodeValue);
										} catch (exp) {
											await Lyte.error("Data passed for property '" + await node.nodeName + "' of '" + await (await (await node.ownerElement).nodeName).toLocaleLowerCase() + "' cannot be serialized. The component '" + await (await (await node.ownerElement).nodeName).toLocaleLowerCase() + "' might not be registered before its use.");
										}
									}
								} else if (nodeValue == null || nodeValue == $Lt._gc.undefined) {
									res = "";
								} else {
									res = nodeValue;
								}
								nodeValue = res;
								if (await _LC.isControlHelper(await node.ownerElement)) {
									parentNode._attributes = await (await node.ownerElement)._attributes || {};
									(await parentNode._attributes)[await node.nodeName] = nodeValue;
									await toBeRemoved.push(await node.nodeName);
								} else {
									let locNodeVal = nodeValue === $Lt._gc.undefined ? "" : nodeValue;
									await (await node.ownerElement).setAttribute(await node.nodeName, locNodeVal);
								}
							}
						}
						if (await parentNode.tagName === "LYTE-YIELD") {
							let pData = await LyteComponent.getCmpData(await (await parentNode.component).data);
							pData[await (await _LC.String).toCamelCase(await node.nodeName)] = origNodeValue;
						}
						if (await (/^(INPUT|TEXTAREA|SELECT)$/).test(await parentNode.nodeName)) {
							if (await node.nodeName === "value") {
								parentNode.value = nodeValue === $Lt._gc.undefined ? "" : nodeValue;
							} else if (await node.nodeName === "checked") {
								parentNode.checked = nodeValue;
							}
						}
						if (!nodeValue && await (await _LC.booleanAttrList).indexOf(await node.nodeName) !== -1) {
							await toBeRemoved.push(await node.nodeName);
						}
					} else {
						node.nodeValue = nodeValue === $Lt._gc.undefined ? "" : nodeValue;
					}
					return node;
				}
				async debounce(func, threshold) {
					var timeout;
					return async function debounced() {
						async function delayed() {
							await func.apply(obj, args);
							timeout = null;
						}
						var obj = this, args = arguments;
						;
						if (timeout) {
							await $Lt._gcFn.clearTimeout(timeout);
						}
						timeout = await $Lt._gcFn.setTimeout(delayed, threshold || 100);
					};
				}
				getProperty(key) {
					var arr = key.match((/([^[\].]+|\[\])/g));
					let property = this;
					if (!property._properties[arr[0]]) {
						property._properties[arr[0]] = {};
					}
					property = property._properties[arr[0]];
					defProp(property, "_path", {
						enumerable: false,
						value: arr[0]
					});
					for (let i = 1; i < arr.length; (i = i + 1) - 1) {
						if (arr[i].startsWith("'") || arr[i].startsWith("\"")) {
							arr[i] = arr[i].substring(1, arr[i].length - 1);
						}
						if (!property[arr[i]]) {
							property[arr[i]] = {};
							defProp(property[arr[i]], "_path", {
								enumerable: false,
								value: property._path + "." + arr[i]
							});
						}
						property = property[arr[i]];
					}
					return property;
				}
				async updateNode(node, updatePath, options) {
					let compInstance = await this.component;
					var del = "delete";
					let multiplePropNode = [];
					let multipleProp;
					let isDirectiveNode;
					if (await node.nodeType == 2) {
						isDirectiveNode = await (await _LC.directive).isDirectiveNode(node);
					}
					if (await node._multipleProperty) {
						for (var i = 0; i < await (await node._multipleProperty).length; (i = i + 1) - 1) {
							if (await (await node._multipleProperty)[i] && await (await (await (await node._multipleProperty)[i]).dynamicValues).lastIndexOf(updatePath) > 0) {
								multiplePropNode[i] = false;
								multipleProp = await (await node._multipleProperty)[i];
								let nodes;
								if (await multipleProp.dynamicProp) {
									multiplePropNode[i] = multipleProp;
									nodes = await (await multipleProp.dynamicProp)[await (await multipleProp.actProp)._path];
									if (nodes) {
										let index = await nodes.indexOf(node);
										await nodes.splice(index, 1);
									}
									let helperNode = await multipleProp.helperNode;
									if (await nodes.length === 0) {
										if (await helperNode.getAttribute("is") === "if") {
											await (await (await multipleProp.actProp)._helperNodes)[del](helperNode);
											delete (await multipleProp.dynamicProp)[await (await multipleProp.actProp)._path];
										} else {
											delete (await multipleProp.dynamicProp)[await (await multipleProp.actProp)._path];
											if (await helperNode._items) {
												let removeHelper = true;
												for (let i = 0; i < await (await helperNode._items).length; (i = i + 1) - 1) {
													if (await (await (await helperNode._items)[i])._dynamicProperty && await (await (await (await helperNode._items)[i])._dynamicProperty)[await (await multipleProp.actProp)._path]) {
														removeHelper = false;
														break;
													}
												}
												if (removeHelper) {
													await (await (await multipleProp.actProp)._helperNodes)[del](helperNode);
												}
											}
										}
									}
								}
								if (!await multiplePropNode[i]) {
									multiplePropNode[i] = "dynamicNodes";
									nodes = await (await multipleProp.actProp)._dynamicNodes;
									if (nodes) {
										let index = await nodes.indexOf(node);
										await nodes.splice(index, 1);
										if (!await nodes.length) {
											delete (await multipleProp.actProp)._dynamicNodes;
										}
									}
								}
							}
						}
					}
					if (!await node.syntaxValue && !await node.helperValue) {
						return;
					}
					let contextSwitchInfo;
					let isYieldContext;
					if (await node._cx || await node.nodeType === 2 && await (await node.ownerElement)._cx) {
						contextSwitchInfo = await node._cx || await (await node.ownerElement)._cx;
						var contextSwitchArray = [];
						await _LC.changeContext(await contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo);
					} else if (await node.tagName === "LYTE-YIELD" && await (await node._callee)._cx) {
						isYieldContext = true;
						contextSwitchInfo = await (await node._callee)._cx;
						var contextSwitchArray = [];
						await _LC.changeContext(await contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, true);
					}
					let nodeValue;
					let dynamicValues = [];
					var isHelper = false;
					if (await node.helperValue) {
						isHelper = true;
						nodeValue = await node.helperValue;
						let helperFunc = nodeValue;
						let helperRetVal = await this.processHelper({
								name: await helperFunc.name,
								args: await this.processArgs(this, { "helperInfo": helperFunc }, dynamicValues, $Lt._gc.undefined, node)
							}, node);
						nodeValue = helperRetVal;
						if (await helperFunc.name === "unescape") {
							let oldDynamicPosition = await node.dynamicPositions;
							let oldStartingNode = await oldDynamicPosition.startingNode;
							let oldChldLen = await oldDynamicPosition.length;
							while (oldChldLen > 1) {
								let next = await oldStartingNode.nextSibling;
								await oldStartingNode.remove();
								oldStartingNode = next;
								(oldChldLen = oldChldLen - 1) + 1;
							}
							let childLen = await (await nodeValue.childNodes).length;
							if (!childLen) {
								await nodeValue.appendChild(await $Lt._gc.document.createTextNode(""));
								childLen = 1;
							}
							let startingNode = await (await nodeValue.childNodes)[0];
							await (await oldStartingNode.replaceWith).apply(oldStartingNode, await nodeValue.childNodes);
							let obj = {
									startingNode: startingNode,
									length: childLen
								};
							node.dynamicPositions = obj;
							nodeValue = $Lt._gc.undefined;
						}
					} else {
						let boundValue = await node.syntaxValue;
						let path;
						if (await boundValue.indexOf(".") !== -1 || await boundValue.indexOf("[") !== -1) {
							path = boundValue;
							boundValue = await boundValue.substring(0, await boundValue.indexOf("."));
						}
						let cmpData = await LyteComponent.getCmpData(await compInstance.data);
						let value = path ? await _LC.get(cmpData, path, dynamicValues, $Lt._gc.undefined, await compInstance.$node) : await cmpData[boundValue];
						nodeValue = !typeof value === "boolean" && !typeof value === "number" ? value ? value : "" : value;
					}
					if (!await $Lt._iO(await dynamicValues[0], $Lt._gc.Array)) {
						dynamicValues = [dynamicValues];
					}
					if (multiplePropNode) {
						for (var i = 0; i < await multiplePropNode.length; (i = i + 1) - 1) {
							if (await multiplePropNode[i]) {
								let multipleProp = await (await node._multipleProperty)[i];
								let dynamicValIndex = await (await (await node._multipleProperty)[i]).index;
								let boundName = await (await (await dynamicValues[dynamicValIndex])[0]).substring(0, await (await (await dynamicValues[dynamicValIndex])[0]).indexOf("."));
								let beforeProp;
								if (await node._propNode) {
									beforeProp = await (await this._properties)[boundName];
									(await this._properties)[boundName] = null;
								}
								let prop = await this.getProperty(await (await dynamicValues[dynamicValIndex])[0]);
								let totalProp = await this.getProperty(boundName);
								var value = await this.getData(boundName);
								if (await multiplePropNode[i] === "dynamicNodes") {
									await makeArray(prop, "_dynamicNodes");
									await (await prop._dynamicNodes).push(node);
								} else {
									await makeSet(prop, "_helperNodes");
									await (await prop._helperNodes).add(await multipleProp.helperNode);
									let dynamicProp = await multipleProp.dynamicProp;
									await dynamicProp[await prop._path] ? await (await dynamicProp[await prop._path]).push(node) : await (dynamicProp[await prop._path] = []).push(node);
								}
								if (await node.ownerElement && (await (await node.ownerElement).hasAttribute("lyte-for") || await (await node.ownerElement).hasAttribute("lyte-if") || await (await node.ownerElement).hasAttribute("lyte-switch") || await (await node.ownerElement).hasAttribute("lyte-forin")) || await node.ownerElement && await (await node.ownerElement).tagName === "TEMPLATE" && await (/^(for|forIn)$/).test(await (await node.ownerElement).getAttribute("is")) && !isHelper) {
									var type = await (await node.ownerElement).getAttribute("is");
									if (type === "for" && await node.nodeName === "items" || type === "forIn" && await node.nodeName === "object") {
										if (await (await (await multipleProp.actProp)._forHelpers).has(await node.ownerElement)) {
											await (await (await multipleProp.actProp)._forHelpers).delete(await node.ownerElement);
										}
										if (!await prop._forHelpers) {
											await makeSet(prop, "_forHelpers");
										}
										(await node.ownerElement)._actualBinding = prop;
										await (await prop._forHelpers).add(await node.ownerElement);
									}
								}
								if (value != $Lt._gc.undefined) {
									await _LC.establishBindings(totalProp, value);
									if (await node._propNode) {
										await _LCSV.updateMulProp(node, multipleProp, boundName, totalProp, prop);
									}
								}
								if (beforeProp) {
									(await this._properties)[boundName] = beforeProp;
								}
								(await (await node._multipleProperty)[i]).actProp = prop;
								(await (await node._multipleProperty)[i]).dynamicValues = await dynamicValues[dynamicValIndex];
							}
						}
					}
					if (isDirectiveNode) {
						await (await _LC.directive).setNodeArgs(node, nodeValue, this);
						if (await (await node.ownerElement).hasAttribute("comp-in-parent")) {
							await (await Lyte.Component).set(await (await node.ownerElement).$data, await (await _LC.String).toCamelCase(await node.nodeName), nodeValue);
						}
						if (await node._saveNode) {
							await _LCSV.updateName(this, node, nodeValue);
						} else if (await (await node.ownerElement)._initialClassValue) {
							await (await (await _LC.directive).class).updateValue(await node.ownerElement);
						}
					} else if (await node.nodeType === 2) {
						let parentNodes = [];
						let pN = await node._parentNode ? await node._parentNode : await node.ownerElement;
						if (await pN.tagName === "TEMPLATE" && await pN.getAttribute("is") === "component" && await node.nodeName !== "component-name") {
							let isKeepAlive = await pN.hasAttribute("lyte-keep-alive");
							if (isKeepAlive) {
								for (var key in await pN._renderedComponent) {
									await parentNodes.push(await (await pN._renderedComponent)[key]);
								}
							} else {
								var compName = await pN._currentComponent;
								if (compName && await (await pN._renderedComponent)[compName]) {
									await parentNodes.push(await (await pN._renderedComponent)[compName]);
								}
							}
						}
						await parentNodes.push(pN);
						for (let i = 0; i < await parentNodes.length; (i = i + 1) - 1) {
							let parentNode = await parentNodes[i];
							if (await parentNode.set) {
								await parentNode.set(await (await _LC.String).toCamelCase(await node.nodeName), nodeValue, $Lt._gc.undefined, true);
							} else {
								parentNode._initProperties = await parentNode._initProperties || {};
								let keyName = await (await _LC.String).toCamelCase(await node.nodeName);
								if (await window.isLyteWidget && await parentNode.tagName != "TEMPLATE") {
									await $Lt._gc.DataBindingLayer.updateInitProperties(parentNode, keyName, nodeValue);
								} else {
									(await parentNode._initProperties)[keyName] = nodeValue;
								}
							}
							let pData = parentNode && await parentNode.tagName === "LYTE-YIELD" ? await LyteComponent.getCmpData(await (await parentNode.component).data) : $Lt._gc.undefined;
							if (await parentNode.tagName === "LYTE-YIELD" && pData && await node.nodeName && await pData[await node.nodeName] !== nodeValue) {
								await _LC.set(pData, await (await _LC.String).toCamelCase(await node.nodeName), nodeValue, $Lt._gc.undefined, $Lt._gc.undefined, parentNode);
							}
							parentNode._attributes = await parentNode._attributes || {};
							if (await _LC.isCustomElementV3(parentNode, true) && typeof nodeValue !== "string") {
								if (await (await node.ownerElement).nodeName === "TEMPLATE") {
									if (await node.helperValue) {
										if (await (await node.ownerElement).getAttribute("is") === "for" && await node.nodeName === "items" || await (await node.ownerElement).getAttribute("is") === "forIn" && await node.nodeName === "object") {
											let oldValue = await (await (await node.ownerElement)._attributes)[await node.nodeName];
											let newValue = nodeValue;
											await _LC.removeSelectedBindingDeep(await (await node.ownerElement)._actualBinding, oldValue);
											if (newValue) {
												await addBindings(newValue, await (await node.ownerElement)._actualBinding);
												await _LC.establishBindings(await (await node.ownerElement)._actualBinding, newValue);
											}
											if (await node.nodeName === "object") {
												await _LC.removeSelectedBindingDeep(await (await node.ownerElement)._propBindingObject, oldValue);
											}
										}
									} else {
										if (await (await node.ownerElement).getAttribute("is") === "for" && await node.nodeName === "items" || await (await node.ownerElement).getAttribute("is") === "forIn" && await node.nodeName === "object") {
											let oldValue = await (await (await node.ownerElement)._attributes)[await node.nodeName];
											if (await node.nodeName === "object") {
												await _LC.removeSelectedBindingDeep(await (await node.ownerElement)._propBindingObject, oldValue);
											}
										}
									}
									parentNode["__" + await node.nodeName] = true;
									await parentNode.removeAttribute(await node.nodeName);
								} else {
								}
							} else {
								if (typeof nodeValue === "boolean") {
									parentNode._attributes = await parentNode._attributes || {};
									(await parentNode._attributes)[await node.nodeName] = nodeValue;
									if (!nodeValue) {
										await parentNode.removeAttribute(await node.nodeName);
									} else {
										await parentNode.setAttribute(await node.nodeName, "");
									}
								} else {
									if (nodeValue && typeof nodeValue === "object") {
										var res;
										if (typeof $Lt._gc.Record != "undefined" && await $Lt._iO(nodeValue, $Lt._gc.Record)) {
											res = await $Lt._gc.JSON.stringify(await (await nodeValue.$).toJSON());
										} else {
											try {
												res = await $Lt._gc.JSON.stringify(nodeValue);
											} catch (exp) {
												await Lyte.error("Data passed for property '" + await node.nodeName + "' of '" + await (await (await node.ownerElement).nodeName).toLocaleLowerCase() + "' cannot be serialized. The component '" + await (await (await node.ownerElement).nodeName).toLocaleLowerCase() + "' might not be registered before its use.");
											}
										}
									} else if (nodeValue == null || nodeValue == $Lt._gc.undefined) {
										res = "";
									} else {
										res = nodeValue;
									}
									nodeValue = res;
									let locNodeVal = nodeValue === $Lt._gc.undefined ? "" : nodeValue;
									let oE = await node.ownerElement;
									if (await oE.hasAttribute(await node.nodeName)) {
										if (await oE.tagName != "INPUT" || await node.nodeName != "value" || !await (await oE.validity).badInput) {
											await oE.setAttribute(await node.nodeName, locNodeVal);
										}
									} else {
										node.nodeValue = locNodeVal;
									}
								}
							}
							(await parentNode._attributes)[await node.nodeName] = nodeValue;
							if (await (/^(INPUT|TEXTAREA|SELECT)$/).test(await parentNode.nodeName)) {
								if (await node.nodeName === "value") {
									let val = nodeValue === $Lt._gc.undefined ? "" : nodeValue;
									if (await parentNode.value !== val) {
										parentNode.value = val;
									}
								} else if (await node.nodeName === "checked") {
									parentNode.checked = nodeValue;
								}
							}
							if (!nodeValue && await (await _LC.booleanAttrList).indexOf(await node.nodeName) !== -1) {
								await parentNode.removeAttribute(await node.nodeName);
							}
							let isStopped = await parentNode._isStopped;
							let result;
							switch (await parentNode.getAttribute("is")) {
							case "for":
								if (!options) {
									options = { "type": "update" };
								} else {
									options.type = "update";
								}
								await this.updateForHelper(parentNode, options);
								break;
							case "if":
								result = await this.updateSwitchHelper("if", parentNode, $Lt._gc.undefined, true, true);
								break;
							case "forIn":
								if (!options) {
									options = { "type": "update" };
								} else {
									options.type = "update";
								}
								await this.updateForInHelper(parentNode, options);
								break;
							case "switch":
								await this.updateSwitchHelper("switch", parentNode, $Lt._gc.undefined, true, true);
								break;
							case "component":
								if (await node.nodeName === "component-name") {
									await this.updateDynamicComponent(parentNode, "update");
								}
								break;
							default:
							}
							let handleBreakOptions;
							if (isStopped && isStopped !== result) {
								if (!result) {
									if (isStopped === "break") {
										handleBreakOptions = "SM";
									} else {
										handleBreakOptions = "SS";
									}
								} else if (result === "break") {
									handleBreakOptions = "MS";
								} else {
									handleBreakOptions = "SM";
								}
							} else if (result === "break") {
								handleBreakOptions = "MS";
							} else if (result === "continue") {
								handleBreakOptions = "SS";
							}
							if (handleBreakOptions) {
								await this.handleBreak(await parentNode._cx, handleBreakOptions);
							}
						}
					} else {
						node.nodeValue = nodeValue === $Lt._gc.undefined ? "" : nodeValue;
					}
					if (await node.ownerElement && await (await node.ownerElement)._hooksPresent) {
						let saveAttr = await _LCSV.getAttr(await (await node.ownerElement)._specialAttributeDetails);
						if (saveAttr) {
							await _LCSV.triggerAllListeners(this, saveAttr, await node.ownerElement);
						}
					}
					if (contextSwitchInfo) {
						await _LC.removeContext(await contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, isYieldContext);
					}
				}
				async handleBreak(contextSwitchInfo, options) {
					if (contextSwitchInfo) {
						let forTemplate = await contextSwitchInfo.node;
						let breakIndex = await contextSwitchInfo.itemIndex;
						let itemValue = await forTemplate.getAttribute("item");
						let forContent = await (await contextSwitchInfo.node)._forContent;
						let endIndex = await options[0] === "M" ? await forContent.length : breakIndex + 1;
						for (let j = breakIndex; j < endIndex; (j = j + 1) - 1) {
							let currentForContent = await forContent[j];
							for (let i = 0; i < await currentForContent.length; (i = i + 1) - 1) {
								await (await currentForContent[i]).remove();
								if (await (await currentForContent[i])._forContent || await (await currentForContent[i])._caseContent) {
									await this.removeHelpers(await currentForContent[i]);
								}
							}
							forContent[j] = [];
							await _LC.removeSelectedBindingDeep(await (await (await forTemplate._items)[j]).itemProperty, await (await (await forTemplate._attributes).items)[j]);
							(await forTemplate._helpers)[j] = [];
							(await forTemplate._items)[j] = {
								"_dynamicProperty": {},
								"itemProperty": {},
								"indexProperty": {}
							};
							(await forTemplate._items)[j] = {
								"_dynamicProperty": {},
								"itemProperty": {},
								"indexProperty": {},
								"propProperty": {},
								"propPropertyDyn": {},
								"propNodes": {}
							};
						}
						let length = await (await (await forTemplate._attributes).items).length;
						if (await options[1] === "M") {
							await this.updateForHelper(forTemplate, {
								firstIndex: breakIndex,
								secondIndex: length - breakIndex,
								"type": "replace"
							}, $Lt._gc.undefined, {});
						} else {
							await this.updateForHelper(forTemplate, {
								firstIndex: breakIndex,
								secondIndex: 1,
								"type": "replace"
							}, $Lt._gc.undefined, {});
						}
					}
				}
				async createCustomEvent(eventName, parentNode, actObj) {
					const customEvent = await $Lt._cO($Lt._gc.CustomEvent, eventName);
					(await parentNode._actions)[eventName] = customEvent;
					(await (await parentNode._actions)[eventName]).processAction = actObj;
				}
				isEmptyString(str) {
					return !(typeof str === "string") || str === "";
				}
				async processArgs(scope, dynN, dynamicValues, event, node, newCompile, cache, unboundFlag) {
					unboundFlag = await (await dynN.helperInfo).name == "unbound" ? true : unboundFlag;
					let args = await dynN.newHelperInfo && newCompile ? await (await dynN.newHelperInfo).args : await (await dynN.helperInfo).args;
					let helpers, j;
					dynamicValues = dynamicValues || [];
					let scpData = await LyteComponent.getCmpData(await (await scope.component).data);
					args = await $Lt._gc.Array.isArray(args) ? await $Lt._gc.Array.from(args) : args;
					let widget = await scope.__lyteWidget;
					for (let i = 0; i < await args.length; (i = i + 1) - 1) {
						if (await args[i] && await (await args[i]).type) {
							await this.internalHelpers(scope, args, i, dynamicValues, event, node, newCompile, cache, unboundFlag);
						} else {
							if (!await this.isEmptyString(await args[i])) {
								if (await (await args[i]).startsWith("'") && await (await args[i]).endsWith("'")) {
									args[i] = await (await args[i]).substr(1, await (await args[i]).length - 2);
								} else {
									args[i] = await (await args[i]).trim();
									let dynamicVals = [];
									if (await args[i] === "event" && event) {
										args[i] = widget && await $Lt._gc.widgetMap.has(widget) ? await (await $Lt._gc.widgetMap.get(widget)).getClone(event) : event;
									} else if (await args[i] === "this" && node) {
										let thisNode = await node.nodeType === 2 ? await node.ownerElement : node;
										args[i] = widget && await $Lt._gc.widgetMap.has(widget) ? await (await $Lt._gc.widgetMap.get(widget)).getClone(thisNode) : thisNode;
									} else {
										args[i] = await _LC.get(await (await scope.component).data, await args[i], dynamicVals, cache);
									}
									if (unboundFlag !== true) {
										await dynamicValues.push(dynamicVals);
									}
								}
							} else if (newCompile) {
								if (await $Lt._iO(await args[i], $Lt._gc.Array)) {
									args[i] = await _LC.getDD(scpData, await args[i]);
								}
							}
						}
					}
					return args;
				}
				async internalHelpers(scope, args, i, dynamicValues, event, node, newCompile, cache, unboundFlag) {
					let helperFunc = await (await args[i]).value;
					let helperVal = await this.processHelper({
							"name": await helperFunc.name,
							"args": await this.processArgs(scope, { "helperInfo": helperFunc }, dynamicValues, event, node, newCompile, cache, unboundFlag)
						}, node);
					args[i] = helperVal;
				}
				async processHelper(helperFunc, node) {
					let args = [];
					let helperName = await helperFunc.name;
					let compConstr;
					let helperFn = await (await _LyteComponent.registeredHelpers)[helperName];
					if (await window.isLyteWidget && await (await _LC.defaultHelpers).indexOf(helperName) == -1) {
						compConstr = await (await this.component).constructor;
						if (await compConstr._widget) {
							helperFn = await (await compConstr._helpers)[helperName] || helperFn;
							if (!helperFn) {
								await _Lyte.error("LC003", await helperFunc.name);
								return;
							}
						}
					}
					if (!helperFn) {
						await _Lyte.error("LC003", await helperFunc.name);
						return;
					}
					switch (await helperFunc.name) {
					case "method":
						await args.push(this, node);
						break;
					case "lbind":
						await args.push(this, await node.ownerElement);
						break;
					case "lyteViewPort":
						if (node && await node.ownerElement) {
							await args.push(await node.ownerElement);
							if (!await (await helperFunc.args).length) {
								await args.push(false);
							}
						} else {
							return false;
						}
					}
					return await helperFn.apply(this, await args.concat(await helperFunc.args));
				}
				async getActionProperty(prop) {
					let hostProp = await this._properties;
					let value = hostProp ? await (await hostProp[prop]).value : $Lt._gc.undefined;
					return value;
				}
				async hasInternalBindings(content) {
					return await content.match((/[(]{1}[^)]+[)]{1}/));
				}
				async getArgValues(argNames, properties) {
					let argValueArray = [];
					for (let i = 0; i < await argNames.length; (i = i + 1) - 1) {
						await argValueArray.push(await (await properties[await argNames[i]]).value);
					}
					return argValueArray;
				}
				async createEventListeners(node, actionType, actObj) {
					let self = this;
					if (!await node._callee && node !== this) {
						node._callee = this;
					}
					if (await globalDOMEvents.indexOf(actionType) == -1) {
						let infoAttr = await actionType.substr(2);
						let infoAttrVal = await node.getAttribute(infoAttr);
						if (await (await _LyteComponent.registeredComponents)[await node.localName] && !await node.component || await node.tagName === "TEMPLATE" && await node.getAttribute("is") === "component") {
							node._toRegEvnts = await node._toRegEvnts || {};
							(await node._toRegEvnts)[await actionType.substr(2)] = {
								"listener": globalEventHandler,
								"attrVal": await (await this.tagName).toLowerCase() + " => " + await actObj.name
							};
						} else {
							await node.setAttribute(infoAttr, await (await this.tagName).toLowerCase() + " => " + await actObj.name);
							await node.addEventListener(await actionType.substr(2), globalEventHandler);
						}
						if (await node.hasAttribute(actionType)) {
							node[actionType] = $Lt._gc.undefined;
						}
						await node.removeAttribute(actionType);
					}
				}
				async registerParentYield(yieldName) {
					let parentYield = await (await (await this._callee)._yields)[yieldName];
					let locYield;
					if (parentYield) {
						if (await _Lyte._ie) {
							locYield = await $Lt._gc.document.createElement("div");
							locYield.innerHTML = await parentYield.outerHTML;
							locYield = await (await locYield.childNodes)[0];
							await (await this.constructor).splitTextNodes(locYield);
						} else {
							locYield = await parentYield.cloneNode(true);
						}
						await $Lt._fE(await $Lt._gc.Object.keys(parentYield), async function (item) {
							locYield[item] = await parentYield[item];
						});
						(await this._yields)[yieldName] = locYield;
					}
				}
				async registerYields() {
					this._yields = {};
					let yields = await this.querySelectorAll("template[is=registerYield],template[is=yield]");
					let lazyYields = [];
					for (let i = 0; i < await yields.length; (i = i + 1) - 1) {
						var yld = await yields[i];
						while (await yld.hasChildNodes()) {
							await (await yld.content).appendChild(await (await yld.childNodes)[0]);
						}
						if (await yld.hasAttribute("from-parent") && await this._callee) {
							if (await (await this._callee)._yields) {
								await this.registerParentYield(await yld.getAttribute("yield-name"));
							} else {
								await lazyYields.push(yld);
							}
						} else {
							(await this._yields)[await yld.getAttribute("yield-name")] = yld;
						}
						await _LCHD.setTxtNode(this, yld);
					}
					if (await lazyYields.length && await this._callee) {
						var self = this;
						this.lazyYield = async function () {
							if (await self._callee) {
								for (let j = 0; j < await lazyYields.length; (j = j + 1) - 1) {
									let lYield = await lazyYields[j];
									await self.registerParentYield(await lYield.getAttribute("yield-name"));
								}
								await (await self._callee).removeEventListener("onReady", await self.lazyYield);
								delete self.lazyYield;
							}
						};
						await (await this._callee).addEventListener("onReady", await this.lazyYield);
					}
				}
				async connectedCallback() {
					if (await this._connectedCalled || await this.__lyteIgnore || await this.__v3lyteIgnore) {
						return;
					}
					this._connectedCalled = true;
					await this._connectedCallback();
				}
				async _connectedCallback() {
					if (await this.hasAttribute("lyte-rendered") || !await (await _LyteComponent.registeredComponents)[await this.localName] || await this._ccCalled) {
						return;
					}
					let fastRenderProp = await this._fR;
					if (!fastRenderProp) {
						this._callee = await this._callee || await this.getCallee(await this.parentNode);
					}
					this.__h = {};
					this.__counter = 0;
					this.__dc = {};
					if (fastRenderProp) {
						if (await _LyteComponent.shouldIgnoreDisconnect()) {
							return;
						}
						let methods = await fastRenderProp.methods;
						if (methods) {
							await this.setMethods(methods);
						}
						await (await _LC.ccDelay).push(this);
						this._ccCalled = true;
					} else {
						await this.actualConnectedCallback();
					}
					var isViewPort;
					let cmpData = await LyteComponent.getCmpData(await (await this.component).data);
					if (await this._initProperties && await (await this._initProperties).hasOwnProperty("lyteViewPort")) {
						isViewPort = await (await this._initProperties).lyteViewPort;
					} else {
						isViewPort = await cmpData.lyteViewPort;
					}
					if (isViewPort) {
						if (!await _LC.isViewPortPending) {
							await $Lt._gcFn.requestAnimationFrame(async function () {
								await $Lt._gcFn.requestAnimationFrame(async function () {
									await _LC.executePendingViewPort();
								});
							});
							_LC.isViewPortPending = true;
						}
						await (await _LC.pendingViewPortElements).push(this);
					}
				}
				async cmpBind(fastRenderProp) {
					let compData = await LyteComponent.getCmpData(await (await this.component).data);
					if (!await _LC.unbound && !fastRenderProp) {
						await (await Lyte.establishObserverBindings).call(this, await (await (await this.component).constructor)._observers);
						await (await Lyte.establishWatchScope).call(this, await (await this.constructor)._deepWatchProperties);
						await addBindings(compData, await this._properties);
						await _LC.establishBindings(await this._properties, compData);
					}
				}
				async actualConnectedCallback() {
					this._transitionHelperNodes = [];
					this._specialNodes = [];
					this._propProperty = {};
					this._propList = [];
					this._propNodes = {};
					this._hiddenTemplate = [];
					let compData = await LyteComponent.getCmpData(await (await this.component).data);
					let fastRenderProp = await this._fR;
					if (fastRenderProp) {
						this._callee = await this._callee || await this.getCallee(await this.parentNode);
					}
					let templateAttributes = await (await (await this.component).constructor)._templateAttributes;
					if (templateAttributes && await templateAttributes.attr) {
						for (let key in await templateAttributes.attr) {
							let attr = await (await templateAttributes.attr)[key];
							if (!await this.hasAttribute(await attr.name) && !await compData.hasOwnProperty(await attr.name) || await attr.globalEvent) {
								if (await attr.helperInfo && await (await attr.helperInfo).name === "action") {
									this._evBoundEvents = await this._evBoundEvents || {};
									let actionName = await (await (await attr.helperInfo).args)[0];
									let boundName;
									if (await actionName.startsWith("\"") || await actionName.startsWith("'")) {
										boundName = await actionName.substring(1, await actionName.length - 1);
									} else {
										boundName = actionName;
									}
									let actualAttrName = await attr.globalEvent ? await attr.name : await (await attr.name).indexOf("-") !== -1 ? await attr.name : await (await attr.name).substr(2);
									(await this._evBoundEvents)[actualAttrName] = {
										"name": boundName,
										"args": await (await attr.helperInfo).args,
										"from": "component"
									};
									let prevAttribute = await this.getAttribute(await attr.name);
									let currentAttribute = await (await (await (await this.component).constructor)._template).getAttribute(await attr.name);
									await this.setAttribute(await attr.name, currentAttribute + (prevAttribute ? " ; " + prevAttribute : ""));
								}
								if (!await attr.globalEvent) {
									attr.from = "component";
									if (await attr.staticValue) {
										await this.setAttribute(await (await (await templateAttributes.attr)[key]).name, await attr.staticValue);
									} else {
										await this.setAttribute(await (await (await templateAttributes.attr)[key]).name, "{{dummy}}");
										await this.bindNode(await (await this.attributes).getNamedItem(await (await (await templateAttributes.attr)[key]).name), [], $Lt._gc.undefined, {}, await (await templateAttributes.attr)[key], $Lt._gc.undefined, $Lt._gc.undefined, true);
									}
								}
							}
						}
					}
					for (let key in await this._toRegEvnts) {
						await this.addEventListener(key, await (await (await this._toRegEvnts)[key]).listener);
						if (await this.hasAttribute(key)) {
							await this.setAttribute(key, await this.getAttribute(key) + " ; " + await (await (await this._toRegEvnts)[key]).attrVal);
						} else {
							await this.setAttribute(key, await (await (await this._toRegEvnts)[key]).attrVal);
						}
					}
					this._toRegEvnts = {};
					let initialUnbound = await _LC.unbound;
					let ssrBind = await this.getAttribute("ssrbindservernode");
					if (ssrBind && !await (await (await this.component).data).lyteUnbound) {
						await this.bindServerData();
						await this.removeAttribute("ssrbindservernode");
					}
					let content = await this.afterConnected(fastRenderProp, ssrBind);
					!ssrBind && await this.cmpBind(fastRenderProp);
					_LC.unbound = initialUnbound;
					if (typeof content === "string") {
						if (content) {
							if (await _LC.frSpecial) {
								let temp = await $Lt._gc.document.createElement("template");
								temp.innerHTML = content;
								this.innerHTML = "";
								await this.appendChild(await temp.content);
							} else {
								this.innerHTML = content;
							}
						}
						await _LC.processAction(this);
					} else {
						if (await (await (await this.component).data).lyteViewPort) {
							this._vpc = true;
							if (await _Lyte._ie) {
								for (var i = 0; i < await (await content.childNodes).length; (i = i + 1) - 1) {
									if (await (await (await content.childNodes)[i]).tagName) {
										this._dummyViewPortF = await (await content.childNodes)[i];
										break;
									}
								}
								for (var i = await (await content.childNodes).length - 1; i >= 0; (i = i - 1) + 1) {
									if (await (await (await content.childNodes)[i]).tagName) {
										this._dummyViewPortL = await (await content.childNodes)[i];
										break;
									}
								}
							} else {
								this._dummyViewPortF = await (await content.children)[0];
								this._dummyViewPortL = await (await content.children)[await (await content.children).length - 1];
							}
						}
						if (await (await _LC.directive).getTransitionArg(this, "hide-tag")) {
							await _LCHD.connect(this, content);
						} else {
							await this.appendChild(content);
						}
					}
					let dataDef = await (await this.component).__data;
					let attributes = await this.attributes;
					this.__lyteIgnore = true;
					for (let i = await attributes.length - 1; i > -1; (i = i - 1) + 1) {
						let camelCase = await (await LyteComponent.String).toCamelCase(await (await attributes[i]).nodeName);
						if (await dataDef[camelCase] && await (await dataDef[camelCase]).hideAttr) {
							await this.removeAttribute(await (await attributes[i]).nodeName);
						}
					}
					for (let dataName in await this._hideAttr) {
						let attrName = await (await _LC.String).dasherize(dataName);
						let dataVal = await (await this._hideAttr)[dataName];
						if (dataVal == false) {
							if (await this.getAttribute(attrName) != await (await (await this.component).data)[dataName]) {
								await this.setAttribute(attrName, await (await (await this.component).data)[dataName]);
							}
						}
					}
					this.__lyteIgnore = false;
					if (await this._callee && await (await this._callee).serverCall) {
						this.serverCall = true;
					}
					if (await this.serverCall && !await this.hasAttribute("server-rendered")) {
						await this.setAttribute("server-rendered", "");
						var newData = await (await LyteComponent.sendtoclient).call(this, this, true, await (await this.component).__data);
						await this.setAttribute("component-data", await $Lt._gc.JSON.stringify(newData));
					}
					if (!await this.hasAttribute("server-rendered")) {
						await this.setAttribute("lyte-rendered", "");
					}
					if (!fastRenderProp && !await Lyte._ignoreOnReady) {
						await this.dispatchEvent(await $Lt._cO($Lt._gc.CustomEvent, "onReady"));
					}
					let _config_flag;
					if (await (await this.component)._config) {
						if (await (await (await this.component)._config).clientLifeCycleHooks != $Lt._gc.undefined) {
							_config_flag = await (await (await this.component)._config).clientLifeCycleHooks == true || (typeof await (await (await this.component)._config).clientLifeCycleHooks == "object" ? await (await (await (await this.component)._config).clientLifeCycleHooks).includes("didConnect") : false);
						}
					}
					if (!await window.isLyteWidget) {
						await _LCSV.connect(this);
					}
					let _overrides = await (await this.component)._ssr ? await (await (await this.component)._ssr).overrides : $Lt._gc.undefined;
					if (!await this.hasAttribute("server-rendered") || await this.serverCall || _config_flag) {
						if (_overrides && await _overrides.didConnect && await this.serverCall) {
							await (await _overrides.didConnect).apply(this);
						} else {
							await this.callback("didConnect");
						}
						await this.onCallBack("didConnect");
					}
					if (await this.serverCall == $Lt._gc.undefined) {
						await this.callback("didRender");
					}
					if (fastRenderProp) {
						await this.removeAttribute("_lyteprop");
					}
				}
				async onCallBack(name) {
					let callbacks = await (await (await (await this.component).constructor)._callBacks)[name];
					if (callbacks) {
						for (let i = 0; i < await callbacks.length; (i = i + 1) - 1) {
							try {
								await (await (await callbacks[i]).value).call(await this.component);
							} catch (e) {
								await _Lyte.error(e);
							}
						}
					}
				}
				async callback(name) {
					var func = await (await this.component)[name];
					var args;
					if (func) {
						if (await arguments.length > 1) {
							args = await $Lt._gc.Array.from(arguments);
							await args.splice(0, 1);
						}
						try {
							var context = await this.component;
							if (await this.__lyteWidget && await $Lt._gc.widgetMap.has(await this.__lyteWidget)) {
								context = await (await $Lt._gc.widgetMap.get(await this.__lyteWidget)).getClone(context);
							}
							await func.apply(context, args || []);
						} catch (e) {
							await _Lyte.error(e);
						}
					}
				}
				async establishObserverBindings() {
					let observers = await (await (await this.component).constructor)._observers;
					for (let i = 0; i < await observers.length; (i = i + 1) - 1) {
						let props = await (await observers[i]).properties;
						for (let j = 0; j < await props.length; (j = j + 1) - 1) {
							let actProp;
							let isArrayObserver = false;
							if (await (await props[j]).indexOf(".[]") !== -1) {
								isArrayObserver = true;
								actProp = await this.getProperty(await (await props[j]).substring(0, await (await props[j]).indexOf(".[]")));
							} else {
								actProp = await this.getProperty(await props[j]);
							}
							await makeSet(actProp, "_observers");
							await (await actProp._observers).add({
								callee: this,
								observer: await observers[i],
								isArrayObserver: isArrayObserver
							});
						}
					}
				}
				async removeBindings(properties, actualData) {
					var del = "delete";
					for (let i in properties) {
						let actData = await actualData[i];
						if (actData && await actData._bindings) {
							await (await actData._bindings)[del](await properties[i]);
						}
						if (typeof await properties[i] === "object" && actData) {
							await this.removeBindings(await properties[i], actData);
						}
					}
				}
				async actualDisconnected() {
					try {
						var self = this;
						if (!await self.component) {
							return;
						}
						self._cx = null;
						self._callee = null;
						(await self.component).$node = null;
						(await self.component).__data = null;
						if (await (await (await self.component).data).__target__) {
							(await (await (await self.component).data).__target__).__component__ = null;
						} else {
							(await (await self.component).data).__component__ = null;
						}
						(await self.component).data = null;
						self.component = null;
						self.__dc = await self.__dc || {};
						self.__h = await self.__h || {};
						for ($Lt._gc.key in await self.__dc) {
							var helper = await (await self.__dc)[$Lt._gc.key];
							if (await helper.hasAttribute("lyte-keep-alive")) {
								var objKeys = await $Lt._gc.Object.keys(await helper._renderedComponent);
								for (var j = 0; j < await objKeys.length; (j = j + 1) - 1) {
									let key = await objKeys[j];
									if (key !== await helper._currentComponent) {
										let comp = await (await helper._renderedComponent)[key];
										await (await (await (await comp.constructor).prototype)._disconnectedCallback).call(comp);
										await comp.remove();
									}
								}
							}
						}
						for ($Lt._gc.key in await self.__h) {
							await (await (await self.__h)[$Lt._gc.key]).remove();
						}
						self.__h = {};
						self.__dc = {};
						let yields = await self._yields;
						for (var key in yields) {
							(await yields[key])._callee = null;
						}
						self = null;
					} catch (exp) {
						await $Lt._gc.console.error(exp);
					}
				}
				async disconnectedCallback() {
					await this._disconnectedCallback();
				}
				async _disconnectedCallback() {
					if (await this.__v3lyteIgnore) {
						await (await (await _LC.V3).pendingComp).remove(this);
						return;
					}
					if (await _LyteComponent.shouldIgnoreDisconnect() || !await this.component || await this.__lyteIgnore || await this._ignoreDisconnect) {
						return;
					}
					if (await (await $Lt._gc.Array.from(await (await (await _LC.hiddenComponentsDiv).content).childNodes)).indexOf(this) != -1) {
						await (await (await _LC.hiddenComponentsDiv).content).removeChild(this);
					}
					if (await this._hiddenTemplate && await (await this._hiddenTemplate).length) {
						await _LCHD.callDisconnectedCallback(this);
					}
					var widget = this.constructor.__widgetName;
					var map;
					if (widget) {
						map = widgetMap;
						widget = map.get(widget);
						widget.additionalComps.delete(this.parentElement);
					}
					if (await this._removedTemplate) {
						await $Lt._fE(await this._removedTemplate, async el => {
							if (await (await (await _LC.tDiv).content).contains(el)) {
								await (await (await _LC.tDiv).content).removeChild(el);
							}
						});
						this._removedTemplate = [];
					}
					var pve = await _LC.pendingViewPortElements;
					if (await (await (await this.component).data).lyteViewPort) {
						var index = await pve.indexOf(this);
						if (index != -1) {
							await pve.splice(index, 1);
						}
					}
					if (await (await _LyteComponent.viewPortSettings).handlePendingItems && await this._vpc) {
						_LC.executeVpe = true;
					}
					if (await pve.length) {
						for (let i = 0; i < await pve.length; (i = i + 1) - 1) {
							let actTemp = await _LC.getActViewPortTemplate(await pve[i]);
							if (actTemp && await actTemp.tagName == "TEMPLATE" && await actTemp.getAttribute("is") == "if" && await actTemp._callee == this) {
								await pve.splice(i, 1);
								(i = i - 1) + 1;
							}
						}
					}
					if (await this.__elmCnt) {
						delete (await $Lt._gc.DataBindingLayer.parentMap)[await this.__elmCnt];
					}
					if (await this.__elmCntW) {
						delete (await $Lt._gc.DataBindingLayer.childMap)[await this.__elmCntW];
					}
					this._destroyed = true;
					if (await this.__toRemoveLazy) {
						for (var __key in await this.__toRemoveLazy) {
							var __arr = await (await this.__toRemoveLazy)[__key];
							await $Lt._fE(__arr, async function (id) {
								await (await Lyte.$).toRemoveFromRequiredServices(id);
							});
						}
						delete this.__toRemoveLazy;
					}
					(await this.component)._bindings = null;
					this._parentHelper = null;
					var scpObj = await this.__scpObj;
					let cmpData = await LyteComponent.getCmpData(await (await this.component).data);
					if (scpObj) {
						for (var key in scpObj) {
							var propData = await cmpData[key], id = await scpObj[key], idArr = await id.split("_");
							if (propData) {
								await Lyte.removeNestScp(await cmpData[key], await idArr[0], await idArr[1], $Lt._gc.undefined, this);
							}
						}
					}
					if (!await this._fR) {
						await _LC.removeSelectedBindingDeep(await this._properties, cmpData, true);
					}
					var h = await this.__h;
					for (key in h) {
						if (await (await h[key])._actualBinding || await (await h[key])._hiddenTemplate && await (await (await h[key])._hiddenTemplate).length) {
							await this.removeHelpers(await h[key]);
						}
					}
					h = {};
					for (let key in await this._properties) {
						(await this._properties)[key] = {};
					}
					await _LCSV.removeAll("comp", this, this);
					await _LCSV.removeData(this);
					this._specialNodes = null;
					await this.callback("didDestroy");
					await this.onCallBack("didDestroy");
					this._didDestroyCalled = true;
					if (await this.__lyteWidget) {
						var wIns = await $Lt._gc.widgetMap.get(await this.__lyteWidget);
						if (wIns) {
							await wIns.removeComponent(this);
						}
					}
					if (!await _LC.dcc) {
						_LC.dcc = [];
						await $Lt._gcFn.requestAnimationFrame(async function () {
							await $Lt._gcFn.requestAnimationFrame(async function () {
								try {
									if (await _LC.executeVpe) {
										await (await _LyteComponent.viewPortSettings).executePendingViewPortElements();
										_LC.executeVpe = false;
									}
									for (var i = 0, item; item = await (await _LC.dcc)[i]; (i = i + 1) - 1) {
										await item.actualDisconnected();
									}
								} catch (e) {
									await $Lt._gc.console.error(e);
								}
								_LC.dcc = $Lt._gc.undefined;
							});
						});
					}
					await (await _LC.dcc).push(this);
					if (await this.lazyYield) {
						await this.removeEventListener("onReady", await this.registerParentYield);
					}
					((await this.constr).activeInstances = await (await this.constr).activeInstances - 1) + 1;
					((await (await this.component).constructor).activeInstances = await (await (await this.component).constructor).activeInstances - 1) + 1;
				}
			}
			customElementPrototype._V4InsApi = [
				"getData",
				"getDirectiveObj",
				"getShadowObj",
				"getFastObj",
				"cmpBind",
				"component",
				"actualConstructor",
				"_connectedCallback",
				"actualConnectedCallback",
				"getMethods",
				"hasAction",
				"setActions",
				"setMethods",
				"getCallee",
				"afterConnected",
				"bindServerData",
				"bindServerNode",
				"getServerTemplates",
				"bindServerFor",
				"bindServerIf",
				"getRandomId",
				"getssrType",
				"renderComponent",
				"renderFast",
				"formatValue",
				"renderNodes",
				"executeBlockHelpers",
				"updateBlockHelpers",
				"_attributeChangedCallback",
				"removeHelpersSpecificIndex",
				"removeHelpers",
				"updateYield",
				"updateDynamicComponent",
				"updateForHelper",
				"updateForInHelper",
				"rmCaseBindings",
				"getCaseTemplate",
				"getCaseIndexScope",
				"getSwitchScope",
				"updateSwitchHelper",
				"callObservers",
				"bindNode",
				"debounce",
				"getProperty",
				"updateNode",
				"handleBreak",
				"createCustomEvent",
				"isEmptyString",
				"processArgs",
				"internalHelpers",
				"internalArray",
				"processHelper",
				"getActionProperty",
				"hasInternalBindings",
				"getArgValues",
				"createEventListeners",
				"registerParentYield",
				"getYieldName",
				"registerYields",
				"onCallBack",
				"callback",
				"establishObserverBindings",
				"removeBindings",
				"actualDisconnected",
				"_disconnectedCallback",
				"throwAction",
				"get",
				"set"
			];
			customElementPrototype._V3InsApi = [
				"getData",
				"cmpBind",
				"component",
				"actualConstructor",
				"_connectedCallback",
				"actualConnectedCallback",
				"getMethods",
				"hasAction",
				"setActions",
				"setMethods",
				"getCallee",
				"afterConnected",
				"renderComponent",
				"renderFast",
				"formatValue",
				"renderNodes",
				"executeBlockHelpers",
				"updateBlockHelpers",
				"_attributeChangedCallback",
				"removeHelpersSpecificIndex",
				"removeHelpers",
				"updateYield",
				"updateDynamicComponent",
				"updateForHelper",
				"updateForInHelper",
				"updateSwitchHelper",
				"callObservers",
				"bindNode",
				"debounce",
				"getProperty",
				"updateNode",
				"handleBreak",
				"createCustomEvent",
				"isEmptyString",
				"processArgs",
				"internalHelpers",
				"processHelper",
				"getActionProperty",
				"hasInternalBindings",
				"getArgValues",
				"createEventListeners",
				"registerParentYield",
				"registerYields",
				"onCallBack",
				"callback",
				"establishObserverBindings",
				"removeBindings",
				"actualDisconnected",
				"_disconnectedCallback",
				"throwAction",
				"get",
				"set",
				"initializeMethod"
			];
			customElementPrototype._V4StaticApi = [
				"_observers",
				"_callBacks",
				"_properties",
				"activeInstances",
				"_depthTemp",
				"_bindsIds",
				"_ssr",
				"_config",
				"_mixins",
				"_serviceToBeUsed",
				"_actions",
				"_template",
				"_dynamicNodes",
				"_templateAttributes",
				"_observedAttributes",
				"_observedMethodAttributes",
				"_data",
				"_methods",
				"_pendingComponents",
				"splitTextNodes",
				"_registerComponent",
				"createDocFragment1",
				"updateValue",
				"seperateStyle",
				"getFastRenderSupported",
				"setTemplateAttributes"
			];
			customElementPrototype.version = { v3: { component: $Lt._gc.undefined } };
			let _stringReplacer = await (await $Lt._gc.String.prototype)._replace ? await (await $Lt._gc.String.prototype)._replace : await (await $Lt._gc.String.prototype).replace;
			let LyteComponent = {
					"_windowEvNeeded": false,
					"defaultHelpers": [
						"unbound",
						"action",
						"lbind",
						"method",
						"stringifyHTML",
						"unescape",
						"escape",
						"debugger",
						"log",
						"ifEquals",
						"if",
						"negate",
						"ifNotEquals",
						"concat",
						"encAttr",
						"expHandlers",
						"lyteViewPort"
					],
					"baseCompClass": class Component {
						constructor() {
							$Lt.getCp(this).push(async function () {
								if (!await this.$) {
									this.$ = {};
								}
								await $Lt._gc.Object.assign(await this.$, await this.$functions);
								(await this.$)._ins = this;
								(await this.$).validate = async function () {
									var compInstance = await this._ins;
									var data = await compInstance.data;
									for (var key in data) {
										await LyteComponent.handleValidation(data, key, await data[key], compInstance);
									}
								};
								if (await this._setWidget) {
									await this._setWidget();
								}
							}.call(this));
						}
					},
					"fRP": {},
					"fRC": 0,
					"customPropRegex": "",
					"customPropHandlers": [],
					"_registeredComponents": {},
					"_reRegisteredComponents": [],
					"toBeRegistered": [],
					"getCmpData": async function (data) {
						return data && await data.__target__ ? await data.__target__ : data;
					},
					"getCmpData": async function (data) {
						return data && await data.__target__ ? await data.__target__ : data;
					},
					"updateCustomCrmComponent": async function (def, customCrmComponent) {
						for (let key in def) {
							if (await def[key] && await (await def[key]).type === "observer") {
								(await def[key]).fnName = key;
								await (await (await customCrmComponent.component)._observers).push(await def[key]);
							} else if (await def[key] && await (await def[key]).type === "callBack") {
								var props = await (await def[key]).properties;
								for (var k = 0; k < await props.length; (k = k + 1) - 1) {
									if (!await (await (await customCrmComponent.component)._callBacks)[await props[k]]) {
										(await (await customCrmComponent.component)._callBacks)[await props[k]] = [];
									}
									(await def[key]).fnName = key;
									await (await (await (await customCrmComponent.component)._callBacks)[await props[k]]).push(await def[key]);
								}
								if (await (await def[key]).observes) {
									(await (await def[key]).observes).fnName = key;
									await (await (await customCrmComponent.component)._observers).push(await (await def[key]).observes);
								}
							} else {
								(await (await customCrmComponent.component).prototype)[key] = await def[key];
							}
						}
						return def;
					},
					"dataFromMixin": async function (mixinsToBeUsed, actionsFromMixin, methodsFromMixin, newDefinition) {
						var mixinslen = await mixinsToBeUsed.length;
						for (let i = 0; i < mixinslen; (i = i + 1) - 1) {
							for (let item in await mixinsToBeUsed[i]) {
								if (item === "actions") {
									await $Lt._gc.Object.assign(actionsFromMixin, await (await mixinsToBeUsed[i])[item]);
								} else if (item === "methods") {
									await $Lt._gc.Object.assign(methodsFromMixin, await (await mixinsToBeUsed[i])[item]);
								} else {
									newDefinition[item] = await (await mixinsToBeUsed[i])[item];
								}
							}
						}
						return {
							"actionsFromMixin": actionsFromMixin,
							"methodsFromMixin": methodsFromMixin,
							"newDefinition": newDefinition
						};
					},
					"throwEvent": async function (eventName) {
						let self = await this.$node ? await this.$node : this;
						const evt = await self._actions ? await (await self._actions)[eventName] : $Lt._gc.undefined;
						let customArgs = [];
						if (await arguments.length > 1) {
							for (let i = 1; i < await arguments.length; (i = i + 1) - 1) {
								await customArgs.push(await arguments[i]);
							}
						}
						await (await _LC.throwAction).call(self, await self._callee, eventName, $Lt._gc.undefined, true, customArgs, self);
						if (await this.$node) {
							await self.dispatchEvent(evt ? evt : await $Lt._cO($Lt._gc.CustomEvent, eventName, { "detail": customArgs }));
						}
					},
					"throwAction": async function (scope, eventName, actObj, isCustom, customArgs, node, event, hasHandled, fromEv) {
						let actionsObj;
						let stopBubble = false;
						if (await this._route && isCustom) {
							scope = await (await _Lyte.Router).getRouteInstance(await this._route);
							actionsObj = await scope.actions || (scope.actions = {});
						} else if (await this.routeName) {
							let parentRoute = await this.parent;
							if (parentRoute) {
								if (await parentRoute.component) {
									scope = await parentRoute.component;
									if (await scope.component) {
										actionsObj = await (await (await scope.component).constructor)._actions;
									} else {
										scope = await (await _Lyte.Router).getRouteInstance(await scope._route);
										actionsObj = await scope.actions || (scope.actions = {});
									}
								} else {
									scope = parentRoute;
									actionsObj = await scope.actions || (scope.actions = {});
								}
							}
						} else if (scope) {
							if (await scope.component && !await scope._didDestroyCalled) {
								actionsObj = await (await (await scope.component).constructor)._actions;
							} else {
								return;
							}
						}
						if (!scope) {
							if (!hasHandled) {
								await _Lyte.warn("Nothing handled the action " + eventName + ".");
							}
							return;
						}
						if (await _Lyte.isWidgetBuild) {
							if (!await this.__widget) {
								return;
							}
						} else if (await this.__widget) {
							return;
						}
						actObj = actObj ? actObj : await this._actions && await (await this._actions)[eventName] ? await (await (await this._actions)[eventName]).processAction : void 0;
						let args = customArgs ? customArgs : [];
						if (actObj) {
							var contextSwitchArray = [];
							if (node) {
								await _LC.adCx(node, contextSwitchArray);
							}
							let concatArgs;
							if (await actObj.skipArgProcessing) {
								concatArgs = await actObj.args;
							} else {
								concatArgs = await this.processArgs(scope, { "helperInfo": actObj }, $Lt._gc.undefined, event, node);
							}
							await (await args.splice).apply(args, await [
								0,
								0
							].concat(concatArgs));
							if (node) {
								await _LC.rmCx(node, contextSwitchArray);
							}
							if (await actionsObj[await actObj.name]) {
								if (!isCustom) {
									let parent = await node.parentNode;
									let context = await this.component;
									if (await this.__lyteWidget && await $Lt._gc.widgetMap.has(await this.__lyteWidget)) {
										context = await (await $Lt._gc.widgetMap.get(await this.__lyteWidget)).getClone(await this.component);
									}
									let val = await (await actionsObj[await actObj.name]).apply(context, args);
									if (!await $Lt._iO(await event.currentTarget, $Lt._gc.DocumentFragment) && await event.currentTarget != await $Lt._gc.document.body && !fromEv) {
										val = false;
									}
									hasHandled = true;
									stopBubble = await _LCHD.shouldStop(node, event);
									if (val !== false && !await event.cancelBubble && !stopBubble) {
										if (await actObj.from && await node.getAttribute(await event.type) && await node._boundEvents && await (await node._boundEvents)[await event.type]) {
											let actions = await (await (await (await node._callee).component).constructor)._actions;
											let actObj = await (await node._boundEvents)[await event.type];
											let cloneActObj = await _Lyte.deepCopyObject(actObj);
											await _LC.skipArgProcessing(cloneActObj, event, node);
											await (await _LC.throwAction).call(await node._callee, await node._callee, await event.type, cloneActObj, $Lt._gc.undefined, $Lt._gc.undefined, node, event, hasHandled);
										} else {
											if (await _LC.hasLyteEvents(node, eventName)) {
												let eventStopped = await _LC.handleLyteEvents(node, event);
												val = eventStopped ? false : true;
											}
											if (val === false) {
												return;
											}
											if (await _LC.isCustomElement(node)) {
												scope = parent;
											}
											if (parent && !(await event.currentTarget !== await $Lt._gc.document.body)) {
												let eventStopped;
												while (parent && await parent.getAttribute && (!await parent.getAttribute(eventName) || await parent.hasAttribute("disabled")) && await parent.tagName != "BODY") {
													if (await parent._hiddenBoundEvents && await (await parent._hiddenBoundEvents)[eventName]) {
														break;
													}
													if (await _LC.hasLyteEvents(parent, eventName)) {
														eventStopped = await _LC.handleLyteEvents(parent, event);
														if (eventStopped) {
															break;
														}
													}
													parent = await parent.parentNode;
												}
												if (eventStopped || !parent || await parent.tagName === "BODY") {
													return;
												}
												if (!await parent._callee) {
													parent._callee = await parent.getCallee ? await parent.getCallee(parent) : await _LC.getCallee(parent);
												}
												if (parent && await event.type === eventName && !await event.cancelBubble) {
													if (await parent._evBoundEvents && await (await parent._evBoundEvents)[eventName]) {
														let actObj = await (await parent._evBoundEvents)[eventName];
														let cloneActObj = await _Lyte.deepCopyObject(actObj);
														await _LC.skipArgProcessing(cloneActObj, event, parent);
														await (await _LC.throwAction).call(parent, parent, eventName, cloneActObj, $Lt._gc.undefined, $Lt._gc.undefined, parent, event, hasHandled);
													} else if (parent && await parent._boundEvents && await (await parent._boundEvents)[eventName]) {
														let actObj = await (await parent._boundEvents)[eventName];
														let cloneActObj = await _Lyte.deepCopyObject(actObj);
														await _LC.skipArgProcessing(cloneActObj, event, parent);
														await (await _LC.throwAction).call(await parent._callee, await parent._callee, eventName, cloneActObj, $Lt._gc.undefined, $Lt._gc.undefined, parent, event, hasHandled);
													}
													await _LCHD.triggerGlobalEvent(parent, eventName, event, hasHandled, true);
												}
											}
										}
									}
								} else {
									let context = await (await this._callee).component;
									if (await this.__lyteWidget && await $Lt._gc.widgetMap.has(await this.__lyteWidget)) {
										context = await (await $Lt._gc.widgetMap.get(await this.__lyteWidget)).getClone(await (await this._callee).component);
									}
									await (await actionsObj[await actObj.name]).apply(await (await this._callee).component, args);
									hasHandled = true;
								}
							} else {
								await _Lyte.error("LC004", await actObj.name);
							}
						} else if (isCustom && actionsObj) {
							var eventsObj = await actionsObj[eventName] || await actionsObj[await (await _LC.String).toCamelCase(eventName)] || await actionsObj[await (await _LC.String).dasherize(eventName)];
							if (eventsObj) {
								var scopeS = await _LC.isCustomElement(scope) ? await scope.component : scope;
								let context = scopeS;
								if (await this.__lyteWidget && await $Lt._gc.widgetMap.has(await this.__lyteWidget)) {
									context = await (await $Lt._gc.widgetMap.get(await this.__lyteWidget)).getClone(scopeS);
								}
								let val = await eventsObj.apply(context, args);
								hasHandled = true;
								if (val !== false) {
									await (await _LC.throwAction).call(scope, await scope._callee, eventName, actObj, isCustom, customArgs, $Lt._gc.undefined, $Lt._gc.undefined, hasHandled);
								}
							} else {
								await (await _LC.throwAction).call(scope, await scope._callee, eventName, actObj, isCustom, customArgs, $Lt._gc.undefined, $Lt._gc.undefined, hasHandled);
							}
						}
					},
					"isControlHelper": async function (ownerElement) {
						return await ownerElement.tagName === "TEMPLATE" && await ownerElement.getAttribute("is") && await ownerElement.getAttribute("is") !== "component" || (await ownerElement.hasAttribute("lyte-for") || await ownerElement.hasAttribute("lyte-if") || await ownerElement.hasAttribute("lyte-switch") || await ownerElement.hasAttribute("lyte-forin"));
					},
					"isCustomElement": async function (node, isTemplate) {
						return await node.hasAttribute && ((await node.tagName === "TEMPLATE" || await (await node.attributes)["lyte-for"] || await (await node.attributes)["lyte-if"] || await (await node.attributes)["lyte-switch"] || await (await node.attributes)["lyte-forin"]) && isTemplate || await node.nodeName && await (await node.nodeName).indexOf("-") !== -1 && (await (await node.localName).startsWith("lyte-") || await (await node.localName).startsWith("crux-") || await (await _LyteComponent.registeredComponents)[await node.localName] || await node.tagName === "LYTE-YIELD" || await node.hasAttribute("lyte-v4") || await node.hasAttribute("lyte-widget") || await node.hasAttribute("lyte-registry") || (await node._attributes ? await (await node._attributes)["lyte-registry"] : $Lt._gc.undefined)));
					},
					"isCustomElementV3": async function (node, isTemplate) {
						return await node.hasAttribute && ((await node.tagName === "TEMPLATE" || await (await node.attributes)["lyte-for"] || await (await node.attributes)["lyte-if"] || await (await node.attributes)["lyte-switch"] || await (await node.attributes)["lyte-forin"]) && isTemplate || await node.nodeName && await (await node.nodeName).indexOf("-") !== -1 && (await (await _LyteComponent.registeredComponents)[await node.localName] || await node.tagName === "LYTE-YIELD"));
					},
					"componentSet": async function (key, value, options, forceExecute, fromParent, fromAttr) {
						if (!forceExecute && await this.get(key) === value) {
							await _LC.clearError(await this.data, key);
							return;
						} else if ((await window.isLyteWidget || await window.__lyteEnablePromise) && await $Lt._iO(value, $Lt._gc.Promise) && !await value.__lyte) {
							await _LC.listenPromise(await this.data, key, value);
							if (!options) {
								options = {};
							}
							options.skipTypeCast = true;
							options.skipValidation = true;
						}
						await _LC.set(await this.data, key, value, options, $Lt._gc.undefined, fromParent, fromAttr);
					},
					"componentGet": function (key) {
						return key ? _LC.get(this.data, key) : this.data;
					},
					"nodeGet": async function (key) {
						return key ? await (await this.component).get(key) : await (await this.component).data;
					},
					"nodeSet": async function (key, value, options, fromParent, fromAttr) {
						if (await window.isLyteWidget && await this.hasAttribute("comp-in-parent")) {
							if (typeof value == "object") {
								await this.setAttribute(await (await _LC.String).dasherize(key), await $Lt._gc.JSON.stringify(value));
							} else {
								await this.setAttribute(await (await _LC.String).dasherize(key), value);
							}
						}
						if (!await this.component && await window.isLyteWidget) {
							await $Lt._gc.DataBindingLayer.valueSet(await this.$data, key, value);
						} else {
							await (await this.component).set(key, value, options, $Lt._gc.undefined, fromParent, fromAttr);
						}
					},
					"registerComponentWrapper": async function () {
						try {
							let rt = await (await _LC.registerComponent).apply(_LC, arguments);
							await _Lyte._postRegister();
							return rt;
						} catch (e) {
							await _Lyte._postRegister();
						}
					},
					"registerComponent": async function (componentName, definition, options, widget, compClass) {
						var Component;
						if (compClass) {
							Component = compClass;
							definition.data = await (await Component.prototype).data;
							definition.actions = await Component.actions ? await Component.actions() : {};
							definition.methods = await Component.methods ? await Component.methods() : {};
							definition._helpers = await Component.helpers ? await Component.helpers() : {};
							var observers = await Component.observers ? await Component.observers() : {};
							for (var key in observers) {
								definition[key] = await observers[key];
							}
						}
						if (await (await _LC._reRegisteredComponents).indexOf(componentName) == -1 && await (await _LyteComponent.registeredComponents)[componentName]) {
							if (!widget || widget && await _LyteComponent.registeredWidgetComponents && await (await _LyteComponent.registeredWidgetComponents)[widget] && await (await (await _LyteComponent.registeredWidgetComponents)[widget])[componentName]) {
								await _Lyte.warn("Component " + componentName + " already registered");
								return;
							}
						}
						let customCrmComponent;
						let alreadyRegistered;
						if (!widget && await (await _LC._registeredComponents)[componentName] || widget && await _LyteComponent.registeredWidgetComponents && await (await _LyteComponent.registeredWidgetComponents)[widget] && await (await (await _LyteComponent.registeredWidgetComponents)[widget])[componentName]) {
							customCrmComponent = await (await _LC._registeredComponents)[componentName];
							alreadyRegistered = true;
						} else {
							customCrmComponent = class extends customElementPrototype {
							};
							customCrmComponent._properties = {};
							customCrmComponent.activeInstances = 0;
							(await customCrmComponent.prototype).throwAction = await this.throwAction;
							customCrmComponent.compName = componentName;
							(await (await _LC.directive).registeredProp)[componentName] = [];
						}
						await (await _LCHD.define).remove(customCrmComponent);
						await (await _LCHD.define).getContent(customCrmComponent);
						await $Lt._gc.Object.defineProperty(await customCrmComponent.prototype, "setData", {
							configurable: true,
							writable: true,
							value: async function (arg0, arg1, options) {
								return await (await this.component).setData(arg0, arg1, options);
							}
						});
						await $Lt._gc.Object.defineProperty(await customCrmComponent.prototype, "toggleData", {
							configurable: true,
							writable: true,
							value: async function (arg0) {
								return await (await this.component).toggleData(arg0);
							}
						});
						await $Lt._gc.Object.defineProperty(await customCrmComponent.prototype, "getData", {
							configurable: true,
							writable: true,
							value: async function (arg0) {
								return await (await this.component).getData(arg0);
							}
						});
						await $Lt._gc.Object.defineProperty(await customCrmComponent.prototype, "setMethods", {
							configurable: true,
							writable: true,
							value: async function (arg0, arg1) {
								return await (await this.component).setMethods(arg0, arg1);
							}
						});
						(await customCrmComponent.prototype).get = await this.nodeGet;
						(await customCrmComponent.prototype).set = await this.nodeSet;
						customCrmComponent._bindsIds = [];
						options = options ? options : {};
						let aliasName = await options.alias;
						let mixinsToBeUsed = [];
						let wdgtScp = widget ? await $Lt._gc.widgetScopeMap.get(widget) : $Lt._gc.undefined;
						let scp = wdgtScp ? await wdgtScp.Lyte : Lyte;
						var laterToBeUsed = {};
						let toBeUsed = {};
						for (var key in options) {
							if (key == "services") {
								toBeUsed[key] = {};
								await $Lt._fE(await options.services, async function (service) {
									if (typeof service == "string") {
										(await toBeUsed[key])[service] = service;
									} else if (service && typeof service === "object") {
										var srKey = await service.as, srVal = await service.service;
										if (!await (await Lyte._keywords).is(srKey, "component")) {
											if (!await service.scope || await service.scope == "static") {
												(await toBeUsed[key])[srKey] = srVal;
											} else if (await service.scope == "instance") {
												var srKey = await service.as, srVal = await service.service;
												laterToBeUsed[key] = await laterToBeUsed[key] || {};
												(await laterToBeUsed[key])[srKey] = srVal;
											}
										} else {
											await Lyte.warn("Service cannot be used in any keywords of Lyte.");
										}
									}
								});
							}
							if (key == "mixins") {
								toBeUsed[key] = [];
								await $Lt._fE(await options.mixins, async function (element) {
									if (await (await _Lyte.Mixin).exists(element)) {
										await (await toBeUsed[key]).push(await (await _Lyte.registeredMixins)[element]);
									} else {
										await (await _Lyte.$).requiredMixins(element, componentName, "component");
									}
								});
							}
							if (key == "ssr") {
								customCrmComponent._ssr = await options[key];
								if (await (await options[key]).config) {
									customCrmComponent._config = await (await options[key]).config;
								}
							}
						}
						if (!Component) {
							let baseCompClass = LyteComponent.baseCompClass;
							Component = class extends baseCompClass {
							};
						}
						let $functions = (await Component.prototype).$functions = {};
						$functions.validate = async function () {
							var compInstance = await this._ins;
							var data = await compInstance.data;
							for (var key in data) {
								await _LC.handleValidation(data, key, await data[key], compInstance);
							}
						};
						$functions.getError = async function (path) {
							return await _LC.getErrorStructure(await this._ins, path);
						};
						$functions.addEventListener = async function (eventName, func, options, wName) {
							if (await eventName.indexOf("-") != -1) {
								await $Lt._gc.console.error("Event Name can't be hypenated");
							}
							let widgetName = await (await this._ins).__wName;
							let widgetInstance = await (await (await window.LyteWidgetClass)._widgetInstances)[widgetName];
							let listenerId = widgetName + "-" + ((widgetInstance.eventCounter = await widgetInstance.eventCounter + 1) - 1) + "-" + eventName;
							if (!options || !await options.origin) {
								options = { "origin": [widgetName] };
							} else if (typeof await options.origin != "string") {
								await $Lt._fE(await options.origin, async function (item, index) {
									if (item == "_self") {
										(await options.origin)[index] = widgetName;
									}
								});
							}
							options.componentName = await (await (await this._ins).$node).localName;
							await (await window.LyteWidgetClass).addEventListener(eventName, func, options, widgetName || await (await this._ins).__wName, listenerId);
							return listenerId;
						};
						$functions.removeEventListener = async function (listenerId) {
							let widgetName = await (await this._ins).__wName;
							await (await window.LyteWidgetClass).removeEventListener(listenerId, widgetName);
						};
						$functions.triggerEvent = async function (eventName, data, options, wName) {
							let widgetName = await (await this._ins).__wName;
							if (!options || !await options.target) {
								options = { "target": [widgetName] };
							} else if (typeof await options.target != "string") {
								await $Lt._fE(await options.target, async function (item, index) {
									if (item == "_self") {
										(await options.target)[index] = widgetName;
									}
								});
							}
							await (await window.LyteWidgetClass).triggerEvent(eventName, data, options, widgetName || await (await this._ins).__wName);
						};
						Component.prototype._setWidget = function () {
							if (widget) {
								Object.defineProperty(this, "__wName", {
									"enumerable": false,
									"configurable": false,
									"writable": false,
									"value": widget
								});
							}
						};
						Component._v3 = true;
						Component._widget = widget;
						customCrmComponent.component = Component;
						Component._helpers = await definition._helpers || {};
						delete definition.helpers;
						let compPrototype = await Component.prototype;
						compPrototype.$lg = await Lyte.__gl;
						compPrototype.set = await this.componentSet;
						compPrototype.get = await this.componentGet;
						if (await window.requireValidateInComponent) {
							compPrototype.validate = async function () {
								var data = await this.data;
								for (var key in data) {
									await _LC.handleValidation(data, key, await data[key], this);
								}
							};
						}
						compPrototype.throwEvent = await this.throwEvent;
						compPrototype.executeMethod = await _LC.executeMethod;
						compPrototype.getData = await _LC.componentGetData;
						compPrototype.setData = await _LC.componentSetData;
						compPrototype.toggleData = await _LC.componentToggleData;
						compPrototype.getMethods = await _LC.componentGetMethods;
						compPrototype.setMethods = await _LC.componentSetMethods;
						compPrototype.hasAction = await _LC.componentHasAction;
						compPrototype.setActions = await _LC.componentsetActions;
						customCrmComponent._mixins = await options.mixins;
						customCrmComponent._serviceToBeUsed = laterToBeUsed ? await laterToBeUsed.services : $Lt._gc.undefined;
						var actionsFromMixin = {};
						var ltInjServ = await Lyte.toBeInjectedServices;
						if (ltInjServ) {
							for (var injServ in ltInjServ) {
								await (await (await Lyte.$).injectServices).component(injServ, await ltInjServ[injServ], $Lt._gc.undefined, await (await Lyte.__gS)[injServ], customCrmComponent);
							}
						}
						for (var tKey in toBeUsed) {
							if (tKey == "mixins") {
								var aFromMixin = {}, methodsFromMixin = {}, newDefinition = {};
								await _LC.dataFromMixin(await toBeUsed.mixins, actionsFromMixin, methodsFromMixin, newDefinition);
								definition = await $Lt._gc.Object.assign(newDefinition, definition);
								actionsFromMixin = await $Lt._gc.Object.assign(actionsFromMixin, aFromMixin);
							} else if (tKey == "services") {
								var serviceToBeUsed = await toBeUsed[tKey];
								for (var serv in serviceToBeUsed) {
									if (await (await Lyte.registeredServices).hasOwnProperty(await serviceToBeUsed[serv])) {
										definition[serv] = await (await Lyte.$).instantiateService(await serviceToBeUsed[serv]);
									} else {
										await (await Lyte.$).requiredServices(serv, await serviceToBeUsed[serv], async function (serviceData, serviceKey, cname, sname) {
											var customCrmComponent = await (await _LC._registeredComponents)[componentName];
											(await (await customCrmComponent.component).prototype)[serviceKey] = await (await Lyte.$).instantiateService(sname);
										});
									}
								}
							}
						}
						customCrmComponent._actions = await $Lt._gc.Object.assign({}, actionsFromMixin, await definition.actions);
						customCrmComponent._dynamicNodes = await definition._dynamicNodes;
						customCrmComponent._templateAttributes = await definition._templateAttributes;
						customCrmComponent._callBacks = {};
						customCrmComponent._observers = [];
						Component._callBacks = {};
						Component._observers = [];
						Component._properties = {};
						Component.activeInstances = 0;
						Component._depthTemp = await $Lt._gc.document.createElement("template");
						Component._mixins = await options.mixins;
						Component._actions = await customCrmComponent._actions;
						Component._template = await definition._template;
						Component._dynamicNodes = await definition._dynamicNodes;
						Component._templateAttributes = await definition._templateAttributes;
						if (await definition._preRenderTemplate) {
							let html = await definition._preRenderTemplate;
							let div = await $Lt._gc.document.createElement("div");
							div.innerHTML = html;
							Component._preRenderTemplate = await div.firstChild;
							definition._preRenderTemplate = null;
						}
						delete definition._template;
						delete definition._dynamicNodes;
						delete definition._templateAttributes;
						let properties = await definition.data ? await definition.data : $Lt._gc.undefined;
						let methods = await $Lt._gc.Object.assign({}, methodsFromMixin, await definition.methods);
						customCrmComponent._observedAttributes = await definition._observedAttributes || [];
						await customCrmComponent.dasherizeObservedAttributes();
						customCrmComponent._observedMethodAttributes = await definition._observedMethodAttributes || {};
						Component._observedAttributes = await definition._observedAttributes || [];
						Component._observedMethodAttributes = await definition._observedMethodAttributes || {};
						customCrmComponent._deepWatchProperties = await definition._deepWatchProperties || {};
						delete definition._observedAttributes;
						delete definition._observedMethodAttributes;
						delete definition.data;
						delete definition.methods;
						definition = await _LC.updateCustomCrmComponent(definition, customCrmComponent);
						customCrmComponent._data = properties;
						customCrmComponent._methods = methods;
						Component._data = properties;
						Component._methods = methods;
						if (!await Lyte.getConfig("lazyComponentRegister")) {
							await customCrmComponent._registerComponent(componentName, customCrmComponent, widget);
						} else {
							if (await (await idleScheduler.tasks).get(componentName)) {
								await idleScheduler.deleteTask(componentName);
							}
							await idleScheduler.enqueueTask(await customCrmComponent._registerComponentFn(componentName, customCrmComponent, widget), [], componentName);
						}
						(await _LyteComponent.registeredComponents)[componentName] = true;
						if (aliasName) {
							(await _LyteComponent.registeredComponents)[aliasName] = true;
						}
						if (await _Lyte.isWidgetBuild) {
							await (await window._wrapperComponents).push(await componentName.toUpperCase());
							if (aliasName) {
								await (await window._wrapperComponents).push(await aliasName.toUpperCase());
							}
						}
						let aliasClass;
						if (!await (await _LC._registeredComponents)[componentName]) {
							if (await $Lt._gc.document.readyState === "complete" || await $Lt._gc.document.readyState === "interactive" || await window.preLoadLyteComponents) {
								await $Lt._gc.customElements.define(componentName, customCrmComponent, $Lt._gc.undefined, await _Lyte.isWidgetBuild ? { "widget": true } : { v3: true });
								if (aliasName) {
									aliasClass = class extends customCrmComponent {
									};
									await $Lt._gc.customElements.define(aliasName, aliasClass, $Lt._gc.undefined, await _Lyte.isWidgetBuild ? { "widget": true } : { v3: true });
								}
							} else {
								await (await _LC.toBeRegistered).push({
									name: componentName,
									def: customCrmComponent,
									_lyteOptions: await _Lyte.isWidgetBuild ? { "widget": true } : { v3: true }
								});
								if (aliasName) {
									aliasClass = class extends customCrmComponent {
									};
									await (await _LC.toBeRegistered).push({
										name: aliasName,
										def: aliasClass,
										_lyteOptions: await _Lyte.isWidgetBuild ? { "widget": true } : { v3: true }
									});
								}
							}
							(await _LC._registeredComponents)[componentName] = customCrmComponent;
							if (aliasName) {
								(await _LC._registeredComponents)[aliasName] = aliasClass;
							}
						}
						if (!await Lyte.getConfig("lazyComponentRegister")) {
							await _LC.postRegistration(componentName, customCrmComponent);
						}
						if (widget) {
							var wObj = _LyteComponent.registeredWidgetComponents = await _LyteComponent.registeredWidgetComponents || {};
							var wObj1 = wObj[widget] = await wObj[widget] || {};
							wObj1[componentName] = customCrmComponent;
						}
						let pendComps = await (await (await _LC.V3).pendingComp).find(componentName);
						if (pendComps && await pendComps.length) {
							await (await (await _LC.V3).pendingComp).execute($Lt._gc.pendingComps);
						}
						if (alreadyRegistered) {
							var pendingComps = await customCrmComponent._pendingComponents || [];
							await $Lt._fE(pendingComps, async function (item) {
								delete item.__lyteIgnore;
								await item.actualConstructor();
								var arr = await $Lt._gc.Array.from(await item.attributes);
								await $Lt._fE(arr, async function (attr) {
									if (await (await (await item.constructor).observedAttributes).indexOf(await attr.name) != -1) {
										await item.attributeChangedCallback(await attr.name, null, await attr.value);
									}
								});
								await item.connectedCallback();
							});
							customCrmComponent._pendingComponents = [];
						}
						return customCrmComponent;
					},
					"postRegistration": async function (componentName, customCrmComponent) {
						let depthTemp = await (await customCrmComponent.component)._depthTemp;
						if (!await _LC._ie && depthTemp && await (await (await depthTemp.content).childNodes).length) {
							await depthTemp.setAttribute("data-id", "depthTemp_" + componentName);
							await (await _LC.lyteComponentsDiv).appendChild(depthTemp);
						} else {
							delete (await customCrmComponent.component)._depthTemp;
						}
					},
					"registerHelper": async function (name, helper) {
						(await _LyteComponent.registeredHelpers)[name] = helper;
					},
					"registerMixin": async function (name, mixin) {
						await (await (await _Lyte.Mixin).register).call(_Lyte, name, mixin);
					},
					"typeCast": async function (value, dataType, obj) {
						if (value === null) {
							return value;
						}
						try {
							switch (dataType) {
							case "string":
								return typeof value === "object" ? await $Lt._gc.JSON.stringify(value) : await value.toString();
								break;
							case "number": {
									if (value == "") {
										return $Lt._gc.undefined;
									}
									let val = +value;
									if (await $Lt._gcFn.isNaN(val)) {
										throw "TypeCast exception";
									}
									return val;
								}
								break;
							case "array":
							case "object":
								return await $Lt._gc.JSON.parse(value);
								break;
							case "boolean":
								return !value && value !== "" || value === "false" ? false : true;
								break;
							default:
								return value;
							}
						} catch (e) {
							if (obj) {
								obj.isError = true;
							}
							return value;
						}
					},
					"sendtoclient": async function (prop, server, node) {
						var data = server ? await (await prop.component).data : prop;
						var newData = {};
						var data_prop = node;
						for (var i in data) {
							if (server) {
								var def = await (await (await prop.component).__data)[i];
								if (i == "bindIds") {
									newData[i] = { value: await data[i] };
								}
								if (def && await (/^(object|array)$/).test(await def.type) && await prop._attributeDetails && await (await prop._attributeDetails).hasOwnProperty(await (await LyteComponent.String).dasherize(i))) {
									newData[i] = { "fP": true };
								} else if (await $Lt._iO(await data[i], $Lt._gc.Date)) {
									newData[i] = {
										"value": await data[i],
										"type": "Date"
									};
								} else if (await data_prop[i]) {
									newData[i] = {
										"value": await data[i],
										"type": await (await data_prop[i]).type
									};
								} else {
									var type = typeof await data[i];
									if (await data[i] == $Lt._gc.undefined) {
										type = $Lt._gc.undefined;
									}
									newData[i] = {
										"value": await data[i],
										"type": type
									};
								}
							} else {
								if (await (await data[i]).type == "Date") {
									newData[i] = await $Lt._cO($Lt._gc.Date, await (await data[i]).value);
								} else if (!await (await data[i]).fP) {
									newData[i] = await (await data[i]).value;
								}
							}
						}
						return newData;
					},
					"getDataType": async function (value) {
						var type = typeof value;
						if (type === "object") {
							if (await $Lt._gc.Array.isArray(value)) {
								return "array";
							}
						}
						return type;
					},
					"handleValidation": async function (object, property, value, component, init) {
						let error = await _Lyte.validate(object, property, value, component, init);
						let cmpData = await LyteComponent.getCmpData(await component.data);
						if (error) {
							await _LC.set(await cmpData.errors, property, error);
							if (await (await component.$node).callback) {
								await (await component.$node).callback("onError", property, error);
							}
						} else {
							await _LC.clearError(object, property);
						}
						return error;
					},
					"clearError": async function (data, property) {
						if (await data.errors && await (await data.errors)[property]) {
							await _Lyte.objectUtils(await data.errors, "delete", property);
						}
					},
					"createLyteId": async function (comp) {
						(comp.__counter = await comp.__counter + 1) - 1;
						return "__lyteId" + await comp.__counter;
					},
					"apdNode": async function (node, comp) {
						await (await (await _LC.tDiv).content).appendChild(node);
						let id = await this.createLyteId(comp);
						(await comp.__h)[id] = node;
						node.__lyteId = id;
					},
					"update": async function (object, property, value, options, fromStore, oldValue, setterScope, actualProperty, fromParent, storeRecord, fromAttr) {
						let fromComponent = await object.__component__;
						let updateAttr = true;
						let dataType, dataDef, estObjBind = false;
						if (!oldValue) {
							oldValue = await object[property];
							if (fromComponent && await fromComponent.tagName !== "LYTE-YIELD") {
								dataDef = await (await (await fromComponent.component).__data)[property];
								if (!options || typeof options == "object" && await options.skipValidation != true) {
									if (dataDef && (dataType = await dataDef.type)) {
										updateAttr = !await dataDef.hideAttr;
										if (dataType !== await _LC.getDataType(value) && (value !== $Lt._gc.undefined || dataType === "boolean")) {
											value = await _LC.typeCast(value, dataType);
										}
									}
								}
								if (value === oldValue && (!options || !await options.force)) {
									await _LC.clearError(object, property);
									return;
								}
								if (!options || typeof options == "object" && await options.skipValidation != true) {
									let error = await _LC.handleValidation(object, property, value, await fromComponent.component);
									if (error) {
										return;
									}
								}
							}
							if (!await object.hasOwnProperty(property) && !await $Lt._gc.Array.isArray(object)) {
								await _LC.oF(object, "add", property, value, true);
							} else {
								if (await window.isLyteWidget && (!options || await options.postmessage != false)) {
									await $Lt._gc.DataBindingLayer.valueSet(object, property, value);
								} else if (await Lyte.isWidgetBuild && (!options || await options.postmessage != false) && await object.__component__ && await (await object.__component__).hasAttribute("comp-in-parent") && !fromAttr) {
									await $Lt._gc.DataBindingLayer.sendDataUpdateToFrame(await object.__component__, { [property]: value });
								}
								object[property] = value;
							}
						}
						if (await window.isLyteWidget && options && await options.postmessage === false) {
							updateAttr = false;
						}
						let toBeExecuted = fromComponent ? true : false;
						let dasherizedAttr = await (await _LC.String).dasherize(property);
						let callDeepObs = false;
						if (await object._scp) {
							if (!await Lyte.cmpData(oldValue, value)) {
								callDeepObs = true;
							}
							if (oldValue && (await $Lt._gc.Array.isArray(oldValue) || typeof oldValue == "object")) {
								var keys = await $Lt._gc.Array.from(await (await object._scp).keys());
								await $Lt._fE(keys, async function (id) {
									var nestObj = await (await Lyte.nestScp)[id];
									var isCyclic = await nestObj.cyclic;
									await Lyte.removeNestScp(oldValue, id);
									if (isCyclic) {
										await Lyte.bindObj(await nestObj._data, $Lt._gc.undefined, id, [], await $Lt._cO($Lt._gc.Map), $Lt._gc.undefined, $Lt._gc.undefined, true);
									}
								});
							}
						}
						if (await Lyte.isRecord(object) && await (await object.$).__scpObj || await object.hasOwnProperty("__component__") && await (await object.__component__).__scpObj) {
							var _scpObj, kmpKey;
							if (await Lyte.isRecord(object)) {
								_scpObj = await (await object.$).__scpObj;
								kmpKey = object;
							} else {
								_scpObj = await (await object.__component__).__scpObj;
								kmpKey = await object.__component__;
							}
							if (await _scpObj.hasOwnProperty(property)) {
								var _sId = await (await _scpObj[property]).split("_");
								await Lyte.removeNestScp(oldValue, await _sId[0], await _sId[1], $Lt._gc.undefined, kmpKey, $Lt._gc.undefined, await Lyte.isRecord(value) || await $Lt._gc.Array.isArray(value) && await value.model && await value.add ? value : $Lt._gc.undefined);
								delete _scpObj[property];
							}
						}
						var customDtype;
						if (dataDef && await (await Lyte.Transform)[await dataDef.type]) {
							var customDataType = await (await Lyte.Transform)[await dataDef.type];
							if (await (/^(object|array)$/).test(await customDataType.extends) && (await customDataType.hasOwnProperty("properties") || await customDataType.hasOwnProperty("items"))) {
								customDtype = true;
							}
						}
						if (fromStore && await Lyte.isRecord(object) || object && await object.hasOwnProperty("_scp") && await (await object._scp).size || dataDef && await (/^(object|array)$/).test(await dataDef.type) && await dataDef.watch == true || customDtype) {
							await Lyte.establishObjectBinding(object, property, fromStore, true, storeRecord, dataDef && await dataDef.watch ? await dataDef.watch : $Lt._gc.undefined);
						}
						if (fromComponent && actualProperty && (typeof value === "string" && await fromComponent.getAttribute(dasherizedAttr) !== value || await fromComponent.hasAttribute(dasherizedAttr))) {
							if ((!await (await _LC.customPropRegex).exec(property) || await fromComponent.hasAttribute(dasherizedAttr)) && updateAttr) {
								if (value && typeof value === "object") {
									let jsonString;
									try {
										jsonString = await $Lt._gc.JSON.stringify(value);
										let attrNode1 = await (await fromComponent.attributes).getNamedItem(dasherizedAttr);
										attrNode1.__lyteIgnore = true;
										await fromComponent.setAttribute(dasherizedAttr, jsonString);
										attrNode1.__lyteIgnore = false;
									} catch (e) {
									}
								} else {
									let attributeString = await _LC.typeCast(value, "string");
									if (await fromComponent.getAttribute(dasherizedAttr) !== attributeString) {
										let detAttr = await (await fromComponent.attributes).getNamedItem(dasherizedAttr);
										if (detAttr) {
											detAttr.__lyteIgnore = true;
										}
										attributeString = attributeString || "";
										await fromComponent.setAttribute(dasherizedAttr, attributeString);
										if (detAttr) {
											detAttr.__lyteIgnore = false;
										}
									}
								}
							}
						}
						if (value && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number") {
							if (oldValue && typeof oldValue === "object" && await oldValue._bindings) {
								if (!await value._bindings) {
									await $Lt._gcFn.defProp(value, "_bindings", {
										enumerable: false,
										writable: true,
										value: await $Lt._cO($Lt._gc.Set),
										configurable: true
									});
								}
								let fcmpData = fromComponent ? await LyteComponent.getCmpData(await (await fromComponent.component).data) : $Lt._gc.undefined;
								if (fromComponent && fcmpData === object && await property.indexOf(".") === -1 && !await window.isLyteWidget) {
									let bindings = await fromComponent.getProperty(property);
									await this.removeSelectedBindingDeep(bindings, oldValue);
									await addBindings(value, bindings);
									await this.establishBindings(bindings, value);
									if (await bindings._forHelpers) {
										let bindfor = await (await bindings._forHelpers).toArrayLyte();
										for (var i = 0; i < await bindfor.length; (i = i + 1) - 1) {
											let item = await bindfor[i];
											if (await item._propBindingObject) {
												await this.removeSelectedBindingDeep(await item._propBindingObject, oldValue);
											}
										}
									}
									await this.affectChanges(bindings, $Lt._gc.undefined, oldValue, setterScope, await object[property], $Lt._gc.undefined, options);
								} else {
									if (await object._bindings) {
										let oldbind = await (await object._bindings).toArrayLyte();
										for (let i = 0; i < await oldbind.length; (i = i + 1) - 1) {
											let item = await (await oldbind[i])[property];
											if (item) {
												await this.removeSelectedBindingDeep(item, oldValue);
												await addBindings(value, item);
												await this.establishBindings(item, value);
												if (await item._forHelpers) {
													let forbind = await (await item._forHelpers).toArrayLyte();
													for (let j = 0; j < await forbind.length; (j = j + 1) - 1) {
														let itemBinding = await forbind[j];
														if (await itemBinding._propBindingObject) {
															await this.removeSelectedBindingDeep(await itemBinding._propBindingObject, oldValue);
														}
													}
												}
												await this.affectChanges(item, $Lt._gc.undefined, oldValue, setterScope, await object[property], $Lt._gc.undefined, options);
											}
										}
									}
								}
							} else {
								if (await object._bindings) {
									let objbind = await (await object._bindings).toArrayLyte();
									for (let i = 0; i < await objbind.length; (i = i + 1) - 1) {
										let item = await objbind[i];
										if (await item[property]) {
											await addBindings(value, await item[property]);
											await this.establishBindings(await item[property], value);
											await this.affectChanges(await item[property], $Lt._gc.undefined, oldValue, setterScope, await object[property], $Lt._gc.undefined, options);
										}
									}
								}
							}
							dataDef = dataDef || (fromComponent && await fromComponent.tagName !== "LYTE-YIELD" ? await (await (await fromComponent.component).__data)[property] : $Lt._gc.undefined);
							if (fromStore && await Lyte.isRecord(object) || object && await object.hasOwnProperty("_scp") && await (await object._scp).size || dataDef && await (/^(object|array)$/).test(await dataDef.type) && (await dataDef.watch || (await dataDef.hasOwnProperty("items") || await dataDef.hasOwnProperty("properties")))) {
								estObjBind = true;
							}
						} else {
							if (oldValue && typeof oldValue === "object" && await oldValue._bindings && await object._bindings) {
								let objbind = await (await object._bindings).toArrayLyte();
								for (let i = 0; i < await objbind.length; (i = i + 1) - 1) {
									let item = await objbind[i];
									if (await item[property]) {
										await this.removeSelectedBindingDeep(await item[property], oldValue);
										if (await (await item[property])._forHelpers) {
											let forbind = await (await (await item[property])._forHelpers).toArrayLyte();
											for (let j = 0; j < await forbind.length; (j = j + 1) - 1) {
												let itemBinding = await forbind[j];
												if (await itemBinding._propBindingObject) {
													await this.removeSelectedBindingDeep(await itemBinding._propBindingObject, oldValue);
												}
											}
										}
									}
								}
							}
							if (await object._bindings) {
								let objbind = await (await object._bindings).toArrayLyte();
								for (let i = 0; i < await objbind.length; (i = i + 1) - 1) {
									let item = await objbind[i];
									if (await item[property]) {
										await this.affectChanges(await item[property], $Lt._gc.undefined, oldValue, setterScope, await object[property], $Lt._gc.undefined, options);
									}
								}
							}
						}
						if (callDeepObs && await object._scp) {
							await this.callDeepObservers(object, {
								type: "deepChange",
								oldValue: oldValue,
								newValue: value
							}, property);
						}
						let dasherizedProperty = await (await _LC.String).dasherize(property);
						if (fromComponent && await fromComponent.__widgetP) {
							await $Lt._gc.DataBindingLayer.sendLbindUpdate(fromComponent, dasherizedProperty, value);
						}
						if (toBeExecuted && !fromParent && await fromComponent._attributeDetails && await fromComponent._callee) {
							let dasherizedProperty = await (await _LC.String).dasherize(property);
							let attrDetail = await (await fromComponent._attributeDetails)[dasherizedProperty];
							let syntaxValue;
							if (attrDetail && await attrDetail.isLbind) {
								syntaxValue = await attrDetail.dynamicValue;
							}
							if (syntaxValue) {
								let contextSwitchArray;
								if (await fromComponent._cx) {
									contextSwitchArray = [];
									await _LC.changeContext(await (await fromComponent._cx).node, contextSwitchArray, await fromComponent._cx);
								}
								let fclData = await LyteComponent.getCmpData(await (await (await fromComponent._callee).component).data);
								let obj = await _LC.getNew(fclData, syntaxValue);
								if (!await obj.context) {
									return;
								}
								let exec = false;
								if (await obj.context === fclData) {
									if (await (await (await fromComponent._callee)._properties)[await obj.lastKey] && await (await (await (await fromComponent._callee)._properties)[await obj.lastKey]).__fromComponent) {
										exec = true;
									}
								} else {
									exec = true;
								}
								if (exec) {
									let lastKeyIndex = +await obj.lastKey;
									if (await $Lt._gc.Array.isArray(await obj.context) && typeof lastKeyIndex == "number") {
										let callReplaceAt = lastKeyIndex < await (await obj.context).length;
										if (await (await obj.context)[lastKeyIndex] !== value || !callReplaceAt) {
											await _LC.aF(await obj.context, callReplaceAt ? "replaceAt" : "insertAt", lastKeyIndex, value);
										}
									} else {
										await _LC.set(await obj.context, await obj.lastKey, value, options);
									}
								}
								if (contextSwitchArray) {
									await _LC.removeContext(await (await fromComponent._cx).node, contextSwitchArray, await fromComponent._cx);
								}
							}
						}
					},
					"getContentForIE": async function getContentForIE(content, constr, newlyCreated, info) {
						if (typeof content === "string") {
							newlyCreated = true;
							var div = await createElement("div");
							div.innerHTML = content;
							content = await (await div.childNodes)[0];
							await constr.splitTextNodes(content);
						}
						if (await content.getAttribute && await content.getAttribute("depth")) {
							if (await Lyte._ms && info) {
								info._content = div;
							}
							var itr = await $Lt._gcFn.parseInt(await content.getAttribute("depth"));
							content = await _Lyte._ie ? content : newlyCreated ? await content.content : await (await content.content).cloneNode(true);
							for (var i = 0; i < itr; (i = i + 1) - 1) {
								content = await (await content.childNodes)[0];
							}
						}
						return content;
					},
					"replaceWithPf": async function (node1, node2) {
						if (await _Lyte._rwpf) {
							await insertBefore(await node1.parentNode, node2, node1);
							await node1.remove();
						} else {
							await node1.replaceWith(node2);
						}
					},
					"getCallee": async function (callee, self) {
						while (callee && !await _LC.isCustomElementV3(callee) && await callee.tagName !== "LYTE-YIELD") {
							if (await callee.tagName === "BODY") {
								callee = null;
								break;
							}
							callee = await callee.parentNode;
						}
						if (callee && await callee.tagName === "LYTE-YIELD") {
							return await callee._registerYield ? await (await callee._registerYield)._callee : $Lt._gc.undefined;
						}
						return self === callee ? $Lt._gc.undefined : callee;
					},
					"set": async function (object, property, value, options, fromStore, fromParent, fromAttr) {
						let lastIndex = -1;
						var s_rec, check = {}, recDottedProp;
						if (await Lyte.isRecord(object) && fromStore) {
							s_rec = object;
						}
						if (!(typeof property === "object") || !property) {
							property = property + "";
							lastIndex = await property.lastIndexOf(".");
						}
						let actualProperty = property;
						if (lastIndex !== -1) {
							let outerPropertyPath = await property.substring(0, lastIndex);
							property = await property.substring(lastIndex + 1);
							object = await _LC.get(object, outerPropertyPath);
							recDottedProp = true;
						}
						if (object && await object.__ltPrx__) {
							object = await object.__target__;
						}
						let val1 = await object[property] && await (await object[property]).__target__ ? await (await object[property]).__target__ : await object[property];
						let val2 = value && await value.__target__ ? await value.__target__ : value;
						if (typeof property === "string" && val1 === val2 && (!options || !await options.force)) {
							if (await object.__component__) {
								await _LC.clearError(object, property);
							} else if (await _Lyte.isRecord(object) && !await (await object.$).isCloned) {
								await (await $Lt._gc.store.$).clrRecErr(await object.$, property);
								await (await object.$).emit ? await (await object.$).emit("set", [
									object,
									property
								]) : $Lt._gc.undefined;
								await (await object.$).model && await (await (await object.$).model).emit ? await (await (await object.$).model).emit("set", [
									await (await (await object.$).model)._name,
									object,
									property
								]) : $Lt._gc.undefined;
								await $Lt._gc.store.emit ? await $Lt._gc.store.emit("set", [
									await (await (await object.$).model)._name,
									object,
									property
								]) : $Lt._gc.undefined;
							}
							return;
						}
						let oldValues = [];
						if (await object._setterScope) {
							var setterScope = await object._setterScope;
						}
						var checkSim = false, watch = [];
						if (await object._scp && await (await object._scp).size) {
							var keys = await $Lt._gc.Array.from(await (await object._scp).keys());
							await $Lt._fE(keys, async function (id) {
								var _obj = await (await object._scp).get(id);
								$Lt._gc.obj = await _obj.paths;
								var recObj = await (await Lyte.nestScp)[id], model, field, rec, attr, wobj = {};
								var pathArr = await $Lt._gc.Object.keys($Lt._gc.obj), aPath;
								if (await pathArr.length > 1) {
									aPath = "*";
								} else if (await pathArr.length == 1) {
									aPath = await pathArr[0];
								}
								wobj.path = aPath;
								wobj.id = id;
								if (await pathArr.length > 1) {
									wobj.paths = pathArr;
								}
								wobj.attr = attr;
								wobj.data = await recObj.data;
								wobj.PropsInfo = await recObj.PropsInfo || $Lt._gc.undefined;
								if (await recObj.model) {
									var mMap = await recObj.model;
									wobj.Error = await recObj.Error;
									var mKeys = await $Lt._gc.Array.from(await (await recObj.model).keys());
									for (var i = 0; i < await mKeys.length; (i = i + 1) - 1) {
										var mName = await mKeys[i];
										var pkMap = await mMap.get(mName);
										if (pkMap) {
											var pkArr = await $Lt._gc.Array.from(await pkMap.keys());
											var pkLen = await pkArr.length;
											for (var j = 0; j < pkLen; (j = j + 1) - 1) {
												var mPk = await pkArr[j];
												var attrMap = await pkMap.get(mPk);
												var attrArr = await $Lt._gc.Array.from(await attrMap.keys());
												var attrLen = await attrArr.length;
												for ($Lt._gc.k = 0; $Lt._gc.k < attrLen; ((await $Lt._gc.$Lt._gc).k = await (await $Lt._gc.$Lt._gc).k + 1) - 1) {
													var mAttr = await attrArr[$Lt._gc.k];
													var mObj = await $Lt._gc.Object.assign({}, wobj);
													var mRec = await $Lt._gc.store.peekRecord(mName, mPk);
													if (mRec) {
														model = await (await mRec.$).model;
														field = await (await model.fieldList)[mAttr];
														if (field && (await field.properties || await field.items || await field.watch == true || await (await Lyte.Transform)[await field.type])) {
															mObj.data = await Lyte.deepCopyObject(await mRec[mAttr]);
															mObj.rec = mRec;
															mObj.isRec = true;
															mObj.attr = mAttr;
															mObj.dtype = await (await model.fieldList)[mAttr];
															mObj._cmpErr = await (await mRec.$).error;
															mObj.key = mAttr;
														}
														await watch.push(mObj);
													}
												}
											}
										}
									}
								} else {
									await watch.push(wobj);
								}
							});
							await $Lt._fE(watch, async function (val) {
								if (!options || typeof options == "object" && await options.skipValidation != true) {
									var id = await val.id, path = await (await val.path).split("."), dtype = await val.dtype, errs;
									if (await val.isRec) {
										if (fromStore) {
											path = await actualProperty.split(".");
											await path.splice(-1);
											await path.shift();
										}
										path = await path.length == 1 && await path[0] == property ? [] : path;
										check.Prop = dtype;
										await Lyte.checkNestedProp(id, path, dtype, val, object, property, value, check, fromStore);
									}
									if (await val.PropsInfo) {
										await $Lt._fE(await val.PropsInfo, async function (props) {
											props.path = await val.path;
											props.attr = await val.attr;
											dtype = await props.dtype;
											check.Prop = dtype;
											await Lyte.checkNestedProp(id, path, dtype, props, object, property, value, check, fromStore);
										});
									}
								}
							});
							if (await check.value && await (await check.value).code) {
								await _Lyte.error("ERR35", await (await check.Prop).type);
								return;
							}
						}
						actualProperty = actualProperty === property ? actualProperty : $Lt._gc.undefined;
						var shareObj = {};
						if (typeof property === "object") {
							if (await _Lyte.isRecord(object) && !fromStore && !await (await object.$).isCloned) {
								for (let key in property) {
									let locValue = await property[key];
									let dataType = await (await (await (await object.$).model).fieldList)[key];
									dataType = dataType ? await dataType.type : $Lt._gc.undefined;
									if (dataType && (locValue !== $Lt._gc.undefined || dataType === "boolean") && dataType !== await _LC.getDataType(locValue)) {
										property[key] = await _LC.typeCast(locValue, dataType);
									}
								}
								let record = await (await $Lt._gc.store.$).setData(await object.$, property, $Lt._gc.undefined, options, $Lt._gc.undefined, $Lt._gc.undefined, shareObj);
								if (await (await record.$).isError) {
									return record;
								}
							} else {
								for (let key in property) {
									await _LC.set(object, key, await property[key], value, fromStore, fromParent);
								}
							}
						} else {
							if (await _Lyte.isRecord(object) && (!fromStore || fromStore && recDottedProp) && !await (await object.$).isCloned) {
								let old = await object[property];
								let dataType = await (await (await (await object.$).model).fieldList)[property];
								dataType = dataType ? await dataType.type : $Lt._gc.undefined;
								if (dataType && (value !== $Lt._gc.undefined || dataType === "boolean") && dataType !== await _LC.getDataType(value)) {
									value = await _LC.typeCast(value, dataType);
								}
								let record = await (await $Lt._gc.store.$).setData(await object.$, property, value, options, $Lt._gc.undefined, $Lt._gc.undefined, shareObj);
								if (await (await record.$).isError) {
									return record;
								}
							} else {
								await _LC.update(object, property, value, options, fromStore, $Lt._gc.undefined, setterScope, actualProperty, fromParent, s_rec, fromAttr);
							}
						}
						if (watch && await watch.length) {
							await $Lt._fE(watch, async function (obj) {
								if (await obj.isRec) {
									await (await $Lt._gc.store.$).deepValueChange(await obj.rec, await obj.attr, await (await obj.rec)[await obj.attr], obj);
								}
							});
						}
					},
					"adCx": async function (node, contextSwitchArray) {
						let isYield = await node.tagName === "LYTE-YIELD";
						if (await node._cx && (!isYield || await (await (await node._cx).node).tagName !== "LYTE-YIELD")) {
							await _LC.changeContext(await (await node._cx).node, contextSwitchArray, await node._cx, isYield);
						} else if (isYield && await (await node._callee)._cx) {
							await _LC.changeContext(await (await (await node._callee)._cx).node, contextSwitchArray, await (await node._callee)._cx, true);
						}
					},
					"rmCx": async function (node, contextSwitchArray, oneLevel) {
						let isYield = await node.tagName === "LYTE-YIELD";
						if (await node._cx && (!isYield || await (await (await node._cx).node).tagName !== "LYTE-YIELD")) {
							await _LC.removeContext(await (await node._cx).node, contextSwitchArray, await node._cx, isYield, oneLevel);
						} else if (isYield && await (await node._callee)._cx) {
							await _LC.removeContext(await (await (await node._callee)._cx).node, contextSwitchArray, await (await node._callee)._cx, true, oneLevel);
						}
					},
					"changeContext": async function (node, contextSwitchArray, contextSwitchInfo, proceedFurther) {
						if (!contextSwitchInfo) {
							return;
						}
						let isYield = await node.tagName === "LYTE-YIELD";
						if (await node._cx && (!isYield || await (await (await node._cx).node).tagName !== "LYTE-YIELD")) {
							await _LC.changeContext(await (await node._cx).node, contextSwitchArray, await node._cx, await node.tagName === "LYTE-YIELD" || proceedFurther);
						} else if ((await node.tagName === "LYTE-YIELD" || proceedFurther) && await node._callee && await (await node._callee)._cx) {
							await _LC.changeContext(await (await (await node._callee)._cx).node, contextSwitchArray, await (await node._callee)._cx);
						}
						if (isYield) {
							let insertYield = await node._registerYield;
							let callee = await insertYield._callee;
							if (callee && await callee._cx) {
								await _LC.changeContext(await (await callee._cx).node, contextSwitchArray, await callee._cx);
							}
						}
						let indexValue, itemValue;
						if (await contextSwitchInfo.type) {
							if (await contextSwitchInfo.type === "for") {
								indexValue = await node.getAttribute("index");
								itemValue = await node.getAttribute("item");
								if (await (await node._items).length === 0) {
									return;
								}
							} else {
								indexValue = await node.getAttribute("key");
								itemValue = await node.getAttribute("value");
								if (await (await $Lt._gc.Object.keys(await node._items)).length === 0) {
									return;
								}
							}
							let callee = await node._callee;
							let cmpData = await LyteComponent.getCmpData(await (await callee.component).data);
							let initialItemValue = await cmpData[itemValue];
							let initialIndexValue = await cmpData[indexValue];
							let initialItemProp = await (await callee._properties)[itemValue];
							let initialIndexProp = await (await callee._properties)[indexValue];
							let initialPropDetails = {};
							if (await node._childProp && await (await node._childProp).length) {
								await $Lt._fE(await node._childProp, async function (propName) {
									if (await (await (await contextSwitchInfo.node)._propNodes)[propName]) {
										initialPropDetails[propName] = {
											data: await (await (await callee.component).data)[propName],
											prop: await (await callee._properties)[propName]
										};
										let itInd = await contextSwitchInfo.itemIndex;
										(await (await callee.component).data)[propName] = await (await (await (await contextSwitchInfo.node)._propNodes)[propName])[itInd];
										(await callee._properties)[propName] = await (await (await (await node._items)[itInd]).propProperty)[propName];
										contextSwitchInfo.__prop = true;
									}
								});
							} else if (await node._currentProp && await (await node._currentProp).length) {
								await $Lt._fE(await node._currentProp, async function (propName) {
									if (await (await (await contextSwitchInfo.node)._propNodes)[propName]) {
										initialPropDetails[propName] = {
											data: await (await (await callee.component).data)[propName],
											prop: await (await callee._properties)[propName]
										};
										let itInd = await contextSwitchInfo.itemIndex;
										(await (await callee.component).data)[propName] = await (await (await (await contextSwitchInfo.node)._propNodes)[propName])[itInd];
										(await callee._properties)[propName] = await (await (await (await node._items)[itInd]).propProperty)[propName];
										contextSwitchInfo.__prop = true;
									}
								});
							}
							let items = await contextSwitchInfo.type === "for" ? await node._currentItems : await node._currentObject;
							cmpData[itemValue] = await items[await contextSwitchInfo.itemIndex];
							cmpData[indexValue] = await contextSwitchInfo.itemIndex;
							(await callee._properties)[itemValue] = await (await (await node._items)[await contextSwitchInfo.itemIndex]).itemProperty;
							(await callee._properties)[indexValue] = await (await (await node._items)[await contextSwitchInfo.itemIndex]).indexProperty;
							let dummyObject = {
									"initialItemValue": initialItemValue,
									"initialIndexValue": initialIndexValue,
									"initialItemProp": initialItemProp,
									"initialIndexProp": initialIndexProp,
									"initialPropDetails": initialPropDetails
								};
							await contextSwitchArray.push(dummyObject);
						} else {
							let dummyObject = {};
							let callee = await (await node._registerYield)._callee;
							let cmpData = await LyteComponent.getCmpData(await (await callee.component).data);
							await $Lt._fE(await $Lt._gc.Object.keys(await (await contextSwitchInfo.node)._properties), async function (key) {
								dummyObject[key] = {};
								(await dummyObject[key]).value = await cmpData[key];
								(await dummyObject[key]).property = await (await callee._properties)[key];
								(await callee._properties)[key] = await (await (await contextSwitchInfo.node)._properties)[key];
								let ctxtData = await LyteComponent.getCmpData(await (await (await contextSwitchInfo.node).component).data);
								cmpData[key] = await ctxtData[key];
							});
							await contextSwitchArray.push(dummyObject);
						}
					},
					"removeContext": async function (node, contextSwitchArray, contextSwitchInfo, proceedFurther, oneLevel) {
						if (!contextSwitchInfo) {
							return;
						}
						let isYield = await node.tagName === "LYTE-YIELD";
						if (!oneLevel) {
							if (await node._cx && (!isYield || await (await (await node._cx).node).tagName !== "LYTE-YIELD")) {
								await _LC.removeContext(await (await node._cx).node, contextSwitchArray, await node._cx, await node.tagName === "LYTE-YIELD" || proceedFurther);
							} else if ((await node.tagName === "LYTE-YIELD" || proceedFurther) && await node._callee && await (await node._callee)._cx) {
								await _LC.removeContext(await (await (await node._callee)._cx).node, contextSwitchArray, await (await node._callee)._cx);
							}
						}
						if (isYield) {
							let insertYield = await node._registerYield;
							let callee = await insertYield._callee;
							if (callee && await callee._cx) {
								await _LC.removeContext(await (await callee._cx).node, contextSwitchArray, await callee._cx);
							}
						}
						let indexValue, itemValue;
						if (await contextSwitchInfo.type) {
							if (await contextSwitchInfo.type === "for") {
								indexValue = await node.getAttribute("index");
								itemValue = await node.getAttribute("item");
								if (await (await node._items).length === 0) {
									return;
								}
							} else {
								indexValue = await node.getAttribute("key");
								itemValue = await node.getAttribute("value");
								if (await (await $Lt._gc.Object.keys(await node._items)).length === 0) {
									return;
								}
							}
							let callee = await node._callee;
							let items = await (await node._attributes).items;
							let removedObject;
							let cmpData = await LyteComponent.getCmpData(await (await callee.component).data);
							if (await contextSwitchInfo.__prop) {
								removedObject = await contextSwitchArray.pop();
							} else {
								removedObject = await contextSwitchArray.shift();
							}
							cmpData[itemValue] = await removedObject.initialItemValue;
							let initialPropDetails = await removedObject.initialPropDetails;
							if (initialPropDetails) {
								for (let propName in initialPropDetails) {
									let propDetails = await initialPropDetails[propName];
									cmpData[propName] = await propDetails.data;
									(await callee._properties)[propName] = await propDetails.prop;
								}
							}
							cmpData[itemValue] = await removedObject.initialItemValue;
							cmpData[indexValue] = await removedObject.initialIndexValue;
							(await callee._properties)[itemValue] = await removedObject.initialItemProp;
							(await callee._properties)[indexValue] = await removedObject.initialIndexProp;
						} else {
							let callee = await (await node._registerYield)._callee;
							let removedObject = await contextSwitchArray.shift();
							let cmpData = await LyteComponent.getCmpData(await (await callee.component).data);
							await $Lt._fE(await $Lt._gc.Object.keys(await (await contextSwitchInfo.node)._properties), async function (key) {
								cmpData[key] = await (await removedObject[key]).value;
								(await callee._properties)[key] = await (await removedObject[key]).property;
							});
						}
					},
					"sortCommands": async function (array1, arrayB) {
						var retVal = {};
						if (array1 && await array1.__target__) {
							array1 = await array1.__target__;
						}
						let arrayA = await array1.slice();
						retVal.origianlArray = array1;
						var commands = [];
						for (let i = 0; i < await arrayB.length; (i = i + 1) - 1) {
							let arrBi = await arrayB[i];
							if (await arrayB[i] && await (await arrayB[i]).__target__) {
								arrBi = await (await arrayB[i]).__target__;
							}
							var targetIndex = await arrayA.indexOf(arrBi);
							if (targetIndex === -1) {
								await commands.push({
									type: "Add",
									element: arrBi,
									toIndex: i
								});
								await arrayA.splice(i, 0, arrBi);
							} else {
								if (targetIndex !== i) {
									await commands.push({
										type: "Move",
										element: arrBi,
										fromIndex: targetIndex,
										toIndex: i
									});
									await arrayA.splice(targetIndex, 1);
									await arrayA.splice(i, 0, arrBi);
								}
							}
						}
						for (let i = await arrayA.length - 1; i >= await arrayB.length; (i = i - 1) + 1) {
							await commands.push({
								type: "Remove",
								element: await arrayA[i]
							});
							await arrayA.splice(i, 1);
						}
						retVal.commands = commands;
						retVal.changedArray = arrayB;
						return retVal;
					},
					"oF": async function () {
						let object = await arguments[0];
						if (object && await object.__target__) {
							object = await object.__target__;
						}
						let functionName = await arguments[1];
						let property = await arguments[2];
						let newValue = await arguments[3];
						if (newValue && await newValue.__target__) {
							newValue = await newValue.__target__;
						}
						let fromComponent = await arguments[4];
						let fromStore = await arguments[5];
						if (functionName === "add" && !fromComponent && !await object._propNodes) {
							await _LC.set(object, property, newValue, $Lt._gc.undefined, fromStore);
							return;
						}
						let options = {};
						options.type = functionName;
						options.property = property;
						if (!await (/^(add|delete)$/).test(functionName)) {
							await _Lyte.error("LC005", functionName);
							return;
						}
						let bindings = await object._bindings;
						if (functionName === "delete") {
							await _LC.set(object, property, $Lt._gc.undefined, $Lt._gc.undefined, fromStore);
						} else {
							object[property] = newValue;
						}
						if (bindings) {
							let bind = await bindings.toArrayLyte();
							for (let i = 0; i < await bind.length; (i = i + 1) - 1) {
								let binding = await bind[i];
								let forHelpers = await binding._forHelpers;
								if (forHelpers) {
									let helperBind = await forHelpers.toArrayLyte();
									for (let j = 0; j < await helperBind.length; (j = j + 1) - 1) {
										let forHelper = await helperBind[j];
										if (await forHelper.getAttribute("is") != "forIn") {
											continue;
										}
										let itemValue = await forHelper.getAttribute("key");
										let contextSwitchArray = [];
										if (functionName === "add") {
											await _LC.adCx(forHelper, contextSwitchArray);
										}
										await (await forHelper._callee).updateForInHelper(forHelper, options);
										if (functionName === "add") {
											await _LC.rmCx(forHelper, contextSwitchArray);
										}
										await _LCSV.affectChangesComp(forHelper);
									}
								}
							}
						}
						if (functionName === "delete") {
							delete object[property];
						}
					},
					"aF": async function () {
						let array = await arguments[0];
						if (array && await array.__target__) {
							array = await array.__target__;
						}
						let initialArrLength = await array.length;
						let callLengthObserver = true;
						let functionName = await arguments[1];
						let value = await arguments[3], check = {};
						if (value && await value.__target__) {
							value = await value.__target__;
						}
						if (await (/^(replaceAt|removeAt|shift)$/).test(functionName) && !await array.length) {
							await _Lyte.warn(functionName + " operation cannot be performed on empty array");
							return;
						}
						let commands;
						if (functionName == "sort") {
							var originalArray = await arguments[0];
							var sortFunction = await arguments[2];
							var addedArguments = await arguments[3] || [];
							var dummyArray = await originalArray.slice();
							await $Lt._fE(addedArguments, async function (item) {
								await dummyArray.push(item);
							});
							if (typeof await arguments[2] == "function") {
								await dummyArray.sort(sortFunction);
							} else {
								async function sorting(item1, item2) {
									var item1 = key ? await Lyte.isRecord(item1) ? await (await item1.$).get(key) : await item1[key] : item1;
									var item2 = key ? await Lyte.isRecord(item2) ? await (await item2.$).get(key) : await item2[key] : item2;
									if (item1 > item2) {
										return order ? 1 : -1;
									} else if (item1 < item2) {
										return order ? -1 : 1;
									} else {
										return 0;
									}
								}
								var obj = await arguments[2];
								var key = await obj.sortBy;
								var order = await obj.sortOrder;
								await dummyArray.sort(sorting);
							}
							commands = await (await this.sortCommands(originalArray, dummyArray)).commands;
						}
						let commArgs = await arguments[2], oldVal, obsObj, watch = [];
						if (await array._scp && await (/^(replaceAt|splice|removeAt|remove|insertAt)$/).test(functionName)) {
							await $Lt._fE(await array._scp, async function (_obj, id) {
								var rec, attr, wobj = {};
								var recObj = await (await Lyte.nestScp)[id];
								var obj = await _obj.paths;
								var pathArr = await $Lt._gc.Object.keys(obj), aPath;
								if (await pathArr.length > 1) {
									aPath = "*";
								} else if (await pathArr.length == 1) {
									aPath = await pathArr[0];
								}
								wobj.path = aPath;
								wobj.id = id;
								if (await pathArr.length > 1) {
									wobj.paths = pathArr;
								}
								wobj.attr = attr;
								wobj.data = await recObj.data;
								wobj.reInit = await Lyte.isRecord(await recObj.data) || await $Lt._gc.Array.isArray(await recObj.data) && await (await recObj.data).model && await (await recObj.data).add;
								wobj.PropsInfo = await recObj.PropsInfo || $Lt._gc.undefined;
								wobj.index = commArgs;
								if (await recObj.model) {
									var mMap = await recObj.model;
									wobj.Error = await recObj.Error;
									var mKeys = await $Lt._gc.Array.from(await (await recObj.model).keys());
									for (var i = 0; i < await mKeys.length; (i = i + 1) - 1) {
										var mName = await mKeys[i];
										var pkMap = await mMap.get(mName);
										if (pkMap) {
											var pkArr = await $Lt._gc.Array.from(await pkMap.keys());
											var pkLen = await pkArr.length;
											for (var j = 0; j < pkLen; (j = j + 1) - 1) {
												var mPk = await pkArr[j];
												var attrMap = await pkMap.get(mPk);
												var attrArr = await $Lt._gc.Array.from(await attrMap.keys());
												var attrLen = await attrArr.length;
												for ($Lt._gc.k = 0; $Lt._gc.k < attrLen; ((await $Lt._gc.$Lt._gc).k = await (await $Lt._gc.$Lt._gc).k + 1) - 1) {
													var mAttr = await attrArr[$Lt._gc.k];
													var mObj = await $Lt._gc.Object.assign({}, wobj);
													var mRec = await $Lt._gc.store.peekRecord(mName, mPk);
													if (mRec) {
														$Lt._gc.model = await (await mRec.$).model;
														$Lt._gc.field = await (await $Lt._gc.model.fieldList)[mAttr];
														if ($Lt._gc.field && (await $Lt._gc.field.properties || await $Lt._gc.field.items || await $Lt._gc.field.watch == true || await (await Lyte.Transform)[await $Lt._gc.field.type])) {
															mObj.data = await Lyte.deepCopyObject(await mRec[mAttr]);
															mObj.rec = mRec;
															mObj.isRec = true;
															mObj.attr = mAttr;
															mObj.dtype = await (await $Lt._gc.model.fieldList)[mAttr];
															mObj._cmpErr = await (await mRec.$).error;
															mObj.key = mAttr;
														}
														await watch.push(mObj);
													}
												}
											}
										}
									}
								} else {
									wobj.reInit = await Lyte.isRecord(await recObj.data) || await $Lt._gc.Array.isArray(await recObj.data) && await (await recObj.data).model && await (await recObj.data).add;
									await watch.push(wobj);
								}
							});
							await $Lt._fE(watch, async function (val) {
								var id = await val.id, path = await val.path == "" ? [] : await (await val.path).split("."), dtype = await val.dtype || $Lt._gc.undefined;
								if (await val.isRec) {
									check.Prop = dtype;
									await Lyte.checkNestedProp(id, path, dtype, val, array, await val.index, value, check);
								}
								if (await val.PropsInfo) {
									await $Lt._fE(await val.PropsInfo, async function (props) {
										props.path = await val.path;
										dtype = await props.dtype;
										props.index = await val.index;
										check.Prop = dtype;
										await Lyte.checkNestedProp(id, path, dtype, props, array, await val.index, value, check);
									});
								}
							});
							if (await check.value && await (await check.value).code) {
								await _Lyte.error("ERR35", await (await check.Prop).type);
								return;
							}
						}
						switch (functionName) {
						case "replaceAt": {
								let index = await $Lt._gcFn.parseInt(await arguments[2]);
								if (index > await array.length) {
									await _Lyte.warn("index provided for replaceAt is greater than array length");
									return [];
								}
								let args = await arguments[3];
								if (!await $Lt._gc.Array.isArray(args)) {
									args = [args];
								}
								let deletedItems = await (await array.splice).apply(array, await [
										index,
										1
									].concat(args));
								let options = {
										"firstIndex": index,
										"secondIndex": await args.length,
										"type": "replace"
									};
								if (await options.secondIndex == 1) {
									callLengthObserver = false;
								}
								if (await array._bindings) {
									let objbind = await (await array._bindings).toArrayLyte();
									for (let i = 0; i < await objbind.length; (i = i + 1) - 1) {
										let item = await objbind[i];
										if (await item._forHelpers) {
											let helperbind = await (await item._forHelpers).toArrayLyte();
											for (let j = 0; j < await helperbind.length; (j = j + 1) - 1) {
												let helper = await helperbind[j];
												if (await helper.getAttribute("is") != "for") {
													continue;
												}
												let finalIndex = index + await deletedItems.length;
												let itemValue = await helper.getAttribute("item");
												for (let i = index, j = 0; i < finalIndex; (i = i + 1) - 1, (j = j + 1) - 1) {
													await _LC.removeSelectedBindingDeep({ [itemValue]: await (await (await helper._items)[i]).itemProperty }, { [itemValue]: await deletedItems[j] });
												}
												let contextSwitchArray = [];
												await _LC.adCx(helper, contextSwitchArray);
												await (await helper._callee).updateForHelper(helper, options);
												await _LC.rmCx(helper, contextSwitchArray);
												await _LCSV.affectChangesComp(helper);
											}
										}
										for (let key in item) {
											let parsedKey = await $Lt._gcFn.parseInt(key);
											let cond = await options.secondIndex == 1 ? parsedKey == await options.firstIndex : parsedKey >= await options.firstIndex;
											if (!await $Lt._gcFn.isNaN(parsedKey) && cond) {
												let diff = parsedKey - await options.firstIndex;
												let oldObject;
												if (diff < 1) {
													oldObject = await deletedItems[diff];
												} else {
													oldObject = await array[await options.firstIndex - 1 + await options.secondIndex + diff];
												}
												await this.removeSelectedBindingDeep(await item[key], oldObject);
												if (await (await item[key])._forHelpers) {
													let bindfor = await (await (await item[key])._forHelpers).toArrayLyte();
													for (var j = 0; j < await bindfor.length; (j = j + 1) - 1) {
														let item1 = await bindfor[j];
														if (await item1._propBindingObject) {
															await this.removeSelectedBindingDeep(await item1._propBindingObject, oldObject);
														}
													}
												}
												if (await array[parsedKey] && typeof await array[parsedKey] === "object") {
													await makeSet(await array[parsedKey], "_bindings");
													await this.establishBindings({ "dummy": await item[key] }, { "dummy": await array[parsedKey] });
												}
												await this.affectChanges(await item[key], $Lt._gc.undefined, oldObject, $Lt._gc.undefined, await array[parsedKey]);
												if (await options.secondIndex == 1) {
													break;
												}
											}
										}
									}
								}
								obsObj = {
									type: "array",
									insertedItems: args,
									removedItems: deletedItems,
									index: index
								};
								await _LC.bindWatchObj(watch, array, args, deletedItems, index);
								await _LC.callArrayObservers(array, obsObj, callLengthObserver, initialArrLength);
								return await deletedItems[0];
							}
							break;
						case "splice": {
								let index = await $Lt._gcFn.parseInt(await arguments[2]);
								if (index > await array.length) {
									await _Lyte.warn("index provided is greater than array length");
									return [];
								}
								let toBeDeleted = await arguments.length > 3 ? await arguments[3] : await array.length - index;
								let args = await arguments.length > 4 ? await arguments[4] : [];
								if (!await $Lt._gc.Array.isArray(args)) {
									args = [args];
								}
								let deletedItems = await (await array.splice).apply(array, await [
										index,
										toBeDeleted
									].concat(args));
								let options = {
										"firstIndex": index,
										"secondIndex": await args.length,
										"thirdIndex": toBeDeleted,
										"type": "splice"
									};
								if (await options.secondIndex == await options.thirdIndex) {
									callLengthObserver = false;
								}
								if (await array._bindings) {
									let objbind = await (await array._bindings).toArrayLyte();
									for (let i = 0; i < await objbind.length; (i = i + 1) - 1) {
										let item = await objbind[i];
										if (await item._forHelpers) {
											let helperbind = await (await item._forHelpers).toArrayLyte();
											for (let j = 0; j < await helperbind.length; (j = j + 1) - 1) {
												let helper = await helperbind[j];
												if (await helper.getAttribute("is") != "for") {
													continue;
												}
												let finalIndex = index + await deletedItems.length;
												let itemValue = await helper.getAttribute("item");
												for (let i = index, j = 0; i < finalIndex; (i = i + 1) - 1, (j = j + 1) - 1) {
													await _LC.removeSelectedBindingDeep({ [itemValue]: await (await (await helper._items)[i]).itemProperty }, { [itemValue]: await deletedItems[j] });
												}
												let contextSwitchArray = [];
												await _LC.adCx(helper, contextSwitchArray);
												await (await helper._callee).updateForHelper(helper, options);
												await _LC.rmCx(helper, contextSwitchArray);
												await _LCSV.affectChangesComp(helper);
											}
										}
										for (let key in item) {
											let parsedKey = await $Lt._gcFn.parseInt(key);
											var cond = await options.secondIndex == await options.thirdIndex ? key >= await options.firstIndex && key < await options.firstIndex + await options.secondIndex : parsedKey >= await options.firstIndex;
											if (!await $Lt._gcFn.isNaN(parsedKey) && cond) {
												let diff = parsedKey - await options.firstIndex;
												let oldObject;
												if (diff < await options.thirdIndex) {
													oldObject = await deletedItems[diff];
												} else {
													oldObject = await array[await options.firstIndex - await options.thirdIndex + await options.secondIndex + diff];
												}
												await this.removeSelectedBindingDeep(await item[key], oldObject);
												if (await (await item[key])._forHelpers) {
													let bindfor = await (await (await item[key])._forHelpers).toArrayLyte();
													for (var j = 0; j < await bindfor.length; (j = j + 1) - 1) {
														let item1 = await bindfor[j];
														if (await item1._propBindingObject) {
															await this.removeSelectedBindingDeep(await item1._propBindingObject, oldObject);
														}
													}
												}
												if (await array[parsedKey] && typeof await array[parsedKey] === "object") {
													await makeSet(await array[parsedKey], "_bindings");
													await this.establishBindings({ "dummy": await item[key] }, { "dummy": await array[parsedKey] });
												}
												await this.affectChanges(await item[key], $Lt._gc.undefined, oldObject, $Lt._gc.undefined, await array[parsedKey]);
											}
										}
									}
								}
								obsObj = {
									type: "array",
									index: index,
									insertedItems: args,
									removedItems: deletedItems
								};
								await _LC.bindWatchObj(watch, array, args, deletedItems, index);
								await _LC.callArrayObservers(array, obsObj, callLengthObserver, initialArrLength);
								return deletedItems;
							}
							break;
						case "push": {
								let toPush = await arguments[2];
								if (!await $Lt._gc.Array.isArray(toPush)) {
									toPush = [toPush];
								}
								await _LC.aF(array, "insertAt", await array.length, toPush);
							}
							break;
						case "pop":
							return await (await _LC.aF(array, "remove", await array.length - 1))[0];
							break;
						case "shift":
						case "shiftObject":
							return await (await _LC.aF(array, "remove", 0))[0];
							break;
						case "removeAt":
						case "remove": {
								let index = await $Lt._gcFn.parseInt(await arguments[2]);
								if (index > await array.length) {
									await _Lyte.warn("index provided for removeAt is greater than array length");
									return [];
								}
								let length = await arguments[3] ? await $Lt._gcFn.parseInt(await arguments[3]) : 1;
								let options = {
										"firstIndex": index,
										"secondIndex": length,
										"type": "remove"
									};
								let deletedItems = await array.splice(index, length);
								if (await array._bindings) {
									let objbind = await (await array._bindings).toArrayLyte();
									for (let i = 0; i < await objbind.length; (i = i + 1) - 1) {
										let item = await objbind[i];
										if (await item._forHelpers) {
											let helperbind = await (await item._forHelpers).toArrayLyte();
											for (let j = 0; j < await helperbind.length; (j = j + 1) - 1) {
												let helper = await helperbind[j];
												if (await helper.getAttribute("is") != "for") {
													continue;
												}
												let finalIndex = index + await deletedItems.length;
												let itemValue = await helper.getAttribute("item");
												for (let i = index, j = 0; i < finalIndex; (i = i + 1) - 1, (j = j + 1) - 1) {
													await _LC.removeSelectedBindingDeep({ [itemValue]: await (await (await helper._items)[i]).itemProperty }, { [itemValue]: await deletedItems[j] });
												}
												let contextSwitchArray = [];
												await _LC.adCx(helper, contextSwitchArray);
												await (await helper._callee).updateForHelper(helper, options);
												await _LC.rmCx(helper, contextSwitchArray);
												await _LCSV.affectChangesComp(helper);
											}
										}
										for (let key in item) {
											let parsedKey = await $Lt._gcFn.parseInt(key);
											if (!await $Lt._gcFn.isNaN(parsedKey) && parsedKey >= await options.firstIndex) {
												let diff = parsedKey - await options.firstIndex;
												let oldObject;
												if (diff < await options.secondIndex) {
													oldObject = await deletedItems[diff];
												} else {
													oldObject = await array[await options.firstIndex - await options.secondIndex + diff];
												}
												await this.removeSelectedBindingDeep(await item[key], oldObject);
												if (await (await item[key])._forHelpers) {
													let bindfor = await (await (await item[key])._forHelpers).toArrayLyte();
													for (var j = 0; j < await bindfor.length; (j = j + 1) - 1) {
														let item1 = await bindfor[j];
														if (await item1._propBindingObject) {
															await this.removeSelectedBindingDeep(await item1._propBindingObject, oldObject);
														}
													}
												}
												if (await array[parsedKey] && typeof await array[parsedKey] === "object") {
													await makeSet(await array[parsedKey], "_bindings");
													await this.establishBindings({ "dummy": await item[key] }, { "dummy": await array[parsedKey] });
												}
												await this.affectChanges(await item[key], $Lt._gc.undefined, oldObject, $Lt._gc.undefined, await array[parsedKey]);
											}
										}
									}
								}
								obsObj = {
									type: "array",
									removedItems: deletedItems,
									index: index
								};
								await _LC.bindWatchObj(watch, array, $Lt._gc.undefined, deletedItems, index);
								await _LC.callArrayObservers(array, obsObj, callLengthObserver, initialArrLength);
								return deletedItems;
							}
							break;
						case "removeObject":
							commArgs = [commArgs];
						case "removeObjects":
							if (!await $Lt._gc.Array.isArray(commArgs)) {
								commArgs = [commArgs];
							}
							if (commArgs == array) {
								commArgs = await $Lt._gc.Array.from(commArgs);
							}
							for (var i = 0; i < await commArgs.length; (i = i + 1) - 1) {
								var indVal = await commArgs[i];
								if (indVal && await indVal.__target__) {
									indVal = await indVal.__target__;
								}
								let inde = await array.indexOf(indVal);
								if (inde !== -1) {
									await _LC.aF(array, "removeAt", inde);
								}
							}
							break;
						case "unshift":
						case "unshiftObject":
						case "unshiftObjects": {
								let toPush = await arguments[2];
								if (!await $Lt._gc.Array.isArray(toPush)) {
									toPush = [toPush];
								}
								await _LC.aF(array, "insertAt", 0, toPush);
							}
							break;
						case "insertAt": {
								let index = await $Lt._gcFn.parseInt(await arguments[2]);
								let args = await arguments[3];
								let len = await args.length;
								if (!await $Lt._gc.Array.isArray(args)) {
									args = [args];
								}
								for (let i = index; i > await array.length; (i = i - 1) + 1) {
									await args.unshift($Lt._gc.undefined);
									(index = index - 1) + 1;
								}
								let options = {
										"firstIndex": index,
										"secondIndex": await args.length,
										"type": "insert"
									};
								await (await array.splice).apply(array, await [
									index,
									0
								].concat(args));
								if (await array._bindings) {
									let arrbind = await (await array._bindings).toArrayLyte();
									for (let i = 0; i < await arrbind.length; (i = i + 1) - 1) {
										let item = await arrbind[i];
										if (await item._forHelpers) {
											let forbind = await (await item._forHelpers).toArrayLyte();
											for (let j = 0; j < await forbind.length; (j = j + 1) - 1) {
												let helper = await forbind[j];
												if (await helper.getAttribute("is") != "for") {
													continue;
												}
												let contextSwitchArray = [];
												await _LC.adCx(helper, contextSwitchArray);
												await (await helper._callee).updateForHelper(helper, options);
												await _LC.rmCx(helper, contextSwitchArray);
												await _LCSV.affectChangesComp(helper);
											}
										}
										for (let key in item) {
											let parsedKey = await $Lt._gcFn.parseInt(key);
											if (!await $Lt._gcFn.isNaN(parsedKey) && parsedKey >= await options.firstIndex) {
												await this.removeSelectedBindingDeep(await item[key], await array[parsedKey + await options.secondIndex]);
												if (await (await item[key])._forHelpers) {
													let bindfor = await (await (await item[key])._forHelpers).toArrayLyte();
													for (var j = 0; j < await bindfor.length; (j = j + 1) - 1) {
														let item1 = await bindfor[j];
														if (await item1._propBindingObject) {
															await this.removeSelectedBindingDeep(await item1._propBindingObject, $Lt._gc.oldObject);
														}
													}
												}
												if (await array[parsedKey] && typeof await array[parsedKey] === "object") {
													await makeSet(await array[parsedKey], "_bindings");
													await this.establishBindings({ "dummy": await item[key] }, { "dummy": await array[parsedKey] });
												}
												await this.affectChanges(await item[key], $Lt._gc.undefined, await array[parsedKey + await options.secondIndex], $Lt._gc.undefined, await array[parsedKey]);
											}
										}
									}
								}
								let position = await $Lt._gcFn.parseInt(await arguments[2]);
								obsObj = {
									type: "array",
									insertedItems: !await $Lt._gc.Array.isArray(await arguments[3]) ? [await arguments[3]] : await (await arguments[0]).slice(position, position + len),
									index: position
								};
								await _LC.bindWatchObj(watch, array, args, $Lt._gc.undefined, position);
								await _LC.callArrayObservers(array, obsObj, callLengthObserver, initialArrLength);
							}
							break;
						case "concat":
							await _LC.aF(array, "insertAt", await array.length, await arguments[2]);
							break;
						case "sort": {
								let optionsArray = [];
								await $Lt._fE(commands, async function (command) {
									switch (await command.type) {
									case "Remove": {
											let removedItems = await array.splice(await command.toIndex, 1);
											await optionsArray.push({
												"firstIndex": await command.toIndex,
												"secondIndex": 1,
												"type": "remove",
												"removedItem": await removedItems[0]
											});
										}
										break;
									case "Move": {
											let removedItems = await array.splice(await command.fromIndex, 1);
											await array.splice(await command.toIndex, 0, await command.element);
											await optionsArray.push({
												"firstIndex": await command.fromIndex,
												"secondIndex": 1,
												"type": "remove",
												"removedItem": await removedItems[0]
											});
											await optionsArray.push({
												"firstIndex": await command.toIndex,
												"secondIndex": 1,
												"type": "insert"
											});
										}
										break;
									case "Add": {
											await array.splice(await command.toIndex, 0, await command.element);
											await optionsArray.push({
												"firstIndex": await command.toIndex,
												"secondIndex": 1,
												"type": "insert"
											});
										}
										break;
									}
								});
								if (await array._bindings) {
									let arrbind = await (await array._bindings).toArrayLyte();
									for (let i = 0; i < await arrbind.length; (i = i + 1) - 1) {
										let item = await arrbind[i];
										if (await item._forHelpers) {
											let forbind = await (await item._forHelpers).toArrayLyte();
											for (let j = 0; j < await forbind.length; (j = j + 1) - 1) {
												let helper = await forbind[j];
												if (await helper.getAttribute("is") != "for") {
													continue;
												}
												let contextSwitchArray = [];
												await _LC.adCx(helper, contextSwitchArray);
												for (let j = 0; j < await optionsArray.length; (j = j + 1) - 1) {
													let optionItem = await optionsArray[j];
													let itemValue = await helper.getAttribute("item");
													if (await optionItem.type == "remove") {
														await this.removeSelectedBindingDeep({ [itemValue]: await (await (await helper._items)[await optionItem.firstIndex]).itemProperty }, { [itemValue]: await optionItem.removedItem });
													}
													await (await helper._callee).updateForHelper(helper, optionItem);
												}
												await _LC.rmCx(helper, contextSwitchArray);
												await _LCSV.affectChangesComp(helper);
											}
										}
									}
								}
								if (await $Lt._gc.Array.isArray(await arguments[3]) && await (await arguments[3]).length) {
									obsObj = {
										type: "array",
										insertedItems: await arguments[3]
									};
									var indices = [];
									await $Lt._fE(await arguments[3], async function (item) {
										await indices.push(await array.indexOf(item));
									});
									obsObj.indices = indices;
									await _LC.callArrayObservers(array, obsObj, callLengthObserver, initialArrLength);
								}
							}
							break;
						default:
							await _Lyte.error("LC006", functionName);
							return;
						}
					},
					"callDeepObservers": async function (data, args, property, callLengthObserver) {
						var self = this;
						var keys = await $Lt._gc.Array.from(await (await data._scp).keys());
						await $Lt._fE(keys, async function (id) {
							var _scp = await (await data._scp).get(id), scp = await _scp.paths, pathArr = await $Lt._gc.Object.keys(scp), aPath;
							if (await pathArr.length == 1) {
								aPath = await pathArr[0];
							} else if (await pathArr.length > 1) {
								aPath = pathArr;
							}
							var recObj = await (await Lyte.nestScp)[id], attr, rec, isRec = false;
							if (await recObj.model) {
								var mMap = await recObj.model;
								var mKeys = await $Lt._gc.Array.from(await (await recObj.model).keys());
								for (var i = 0; i < await mKeys.length; (i = i + 1) - 1) {
									var mName = await mKeys[i];
									var pkMap = await mMap.get(mName);
									if (pkMap) {
										var pkArr = await $Lt._gc.Array.from(await pkMap.keys());
										var pkLen = await pkArr.length;
										for (var j = 0; j < pkLen; (j = j + 1) - 1) {
											var mPk = await pkArr[j];
											var attrMap = await pkMap.get(mPk);
											var attrArr = await $Lt._gc.Array.from(await attrMap.keys());
											var attrLen = await attrArr.length;
											for ($Lt._gc.k = 0; $Lt._gc.k < attrLen; ((await $Lt._gc.$Lt._gc).k = await (await $Lt._gc.$Lt._gc).k + 1) - 1) {
												var mAttr = await attrArr[$Lt._gc.k];
												var mRec = await $Lt._gc.store.peekRecord(mName, mPk);
												await self.deepObsBind(mRec, true, mAttr, args, pathArr, aPath, data, property, callLengthObserver);
											}
										}
									}
								}
							} else {
								rec = await recObj.data;
								await self.deepObsBind(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver);
							}
						});
					},
					"deepObsBind": async function (rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver) {
						var type = await args.type;
						var watchPath, propPath;
						if (await rec._bindings) {
							var newArgs = await $Lt._gc.Object.assign({}, args);
							var objbind = await (await rec._bindings).toArrayLyte();
							for (var _i65 = 0; _i65 < await objbind.length; (_i65 = _i65 + 1) - 1) {
								propPath = aPath;
								var binding = await objbind[_i65], obj = $Lt._gc.undefined;
								watchPath = await (await objbind[_i65])._path;
								if (isRec) {
									if (await binding.hasOwnProperty(attr) && await (await binding[attr]).hasOwnProperty("*")) {
										obj = await (await binding[attr])["*"];
										watchPath = await (await binding[attr])._path;
									}
								} else if (await binding.hasOwnProperty("*")) {
									obj = await binding["*"];
								}
								if (obj) {
									var obsbind = await obj._observers ? await (await obj._observers).toArrayLyte() : [], path;
									if (property) {
										if (await pathArr.length > 1) {
											var len = await pathArr.length, nPathArr = [];
											for (var i = 0; i < len; (i = i + 1) - 1) {
												await nPathArr.push(await pathArr[i] ? await pathArr[i] + "." + property : property);
											}
											propPath = nPathArr;
										} else if (await pathArr.length == 1) {
											propPath = aPath ? await aPath.concat("." + property) : property;
										}
									}
									for (var j = 0; j < await obsbind.length; (j = j + 1) - 1) {
										var observer = await obsbind[j];
										newArgs.path = propPath;
										newArgs.type = "deepChange";
										newArgs.data = rec;
										var argPath = await (await obj._path).split(".");
										await argPath.pop();
										newArgs.item = await argPath.join(".");
										var exactPath = await newArgs.index != $Lt._gc.undefined ? (propPath != "" ? propPath + "." : propPath) + await newArgs.index : propPath;
										if (await observer.callee && await (await observer.callee).component) {
											var calldeep = true;
											var _data = await (await (await (await observer.callee).component).__data)[await newArgs.item];
											var _watch = _data ? await _data.watch : $Lt._gc.undefined;
											if (_data && typeof _watch != "boolean") {
												var watchArr = await (await (await (await obsbind[j]).observer).Jpath)[watchPath];
												calldeep = await Lyte.checkWatchPath(exactPath, watchArr);
											}
											if (calldeep) {
												await (await (await observer.observer).value).call(await (await observer.callee).component, newArgs);
											}
										} else {
											var scope = await data._setterScope ? await data._setterScope : window;
											if (await $Lt._gc.Array.isArray(scope)) {
												var sLen = await scope.length;
												for (var k = 0; k < sLen; (k = k + 1) - 1) {
													var itm = await scope[k];
													var calldeep = true;
													if (await newArgs.data && await newArgs.hasOwnProperty("item")) {
														var watchArr = await (await (await (await (await (await (await newArgs.data).$).model)._fldGrps).watch)[await newArgs.item]).watch;
														if (await $Lt._gc.Array.isArray(watchArr)) {
															watchArr = await (await (await (await obsbind[j]).observer).Jpath)[watchPath];
															calldeep = await Lyte.checkWatchPath(exactPath, watchArr);
														}
													}
													if (calldeep) {
														await (await (await observer.observer).value).call(itm, newArgs);
													}
												}
											} else {
												var calldeep = true;
												if (await newArgs.data && await newArgs.hasOwnProperty("item")) {
													var watchArr = await (await (await (await (await (await (await newArgs.data).$).model)._fldGrps).watch)[await newArgs.item]).watch;
													if (await $Lt._gc.Array.isArray(watchArr)) {
														watchArr = await (await (await (await obsbind[j]).observer).Jpath)[watchPath];
														calldeep = await Lyte.checkWatchPath(exactPath, watchArr);
													}
												}
												if (calldeep) {
													await (await (await observer.observer).value).call(scope, newArgs);
												}
											}
										}
									}
								}
								if (!callLengthObserver && type == "array" && await binding.length) {
									await this.affectChanges(await binding.length, $Lt._gc.undefined, $Lt._gc.initialArrLength, $Lt._gc.undefined, await $Lt._gc.array.length, callLengthObserver);
								}
							}
						}
					},
					"callArrayObservers": async function (array, args, callLengthObserver, initialArrLength) {
						if (await array._scp && await (await array._scp).size) {
							await this.callDeepObservers(array, await $Lt._gc.Object.assign({}, args), $Lt._gc.undefined, true);
						}
						if (await array._bindings) {
							let objbind = await (await array._bindings).toArrayLyte();
							for (let i = 0; i < await objbind.length; (i = i + 1) - 1) {
								let binding = await objbind[i];
								let path = await (await objbind[i])._path;
								if (await binding._observers) {
									let obsbind = await (await binding._observers).toArrayLyte();
									for (let j = 0; j < await obsbind.length; (j = j + 1) - 1) {
										let observer = await obsbind[j];
										if (await observer.isArrayObserver) {
											if (args) {
												args.item = path;
											}
											if (await observer.callee && await (await observer.callee).component) {
												await (await (await observer.observer).value).call(await (await observer.callee).component, args);
											} else {
												var scope = await array._setterScope ? await array._setterScope : window;
												if (await $Lt._gc.Array.isArray(scope)) {
													var sLen = await scope.length;
													for (var k = 0; k < sLen; (k = k + 1) - 1) {
														var itm = await scope[k];
														await (await (await observer.observer).value).call(itm, args);
													}
												} else {
													await (await (await observer.observer).value).call(scope, args);
												}
											}
										}
									}
								}
								if (await binding.length) {
									await this.affectChanges(await binding.length, $Lt._gc.undefined, initialArrLength, $Lt._gc.undefined, await array.length, callLengthObserver);
								}
							}
						}
					},
					"bindWatchObj": async function (watch, data, insItems, remItems, pos) {
						if (watch && await watch.length) {
							await $Lt._fE(watch, async function (wObj) {
								if (await wObj.isRec) {
									await (await $Lt._gc.store.$).deepValueChange(await wObj.rec, await wObj.attr, data, wObj);
								}
								if (remItems) {
									await $Lt._fE(remItems, async function (itm) {
										await Lyte.removeNestScp(itm, await wObj.id, $Lt._gc.undefined, $Lt._gc.undefined, $Lt._gc.undefined, $Lt._gc.undefined, await wObj.reInit ? await wObj.data : $Lt._gc.undefined);
									});
								}
								if (insItems) {
									await $Lt._fE(insItems, async function (itm, idx) {
										if (itm && (await $Lt._gc.Array.isArray(itm) || typeof itm == "object")) {
											var pth = await (await wObj.path).split(",");
											await pth.push(pos + idx);
											await Lyte.bindObj(itm, $Lt._gc.undefined, await wObj.id, pth && await pth.length ? pth : [], $Lt._gc.undefined, $Lt._gc.undefined, $Lt._gc.undefined, true);
										}
									});
								}
								if (pos !== $Lt._gc.undefined) {
									var nestObj = await (await Lyte.nestScp)[await wObj.id];
									if (nestObj && await nestObj.cyclic) {
										await Lyte.removeNestScp(await nestObj._data, await wObj.id);
										await Lyte.bindObj(await nestObj._data, $Lt._gc.undefined, await wObj.id, [], $Lt._gc.undefined, $Lt._gc.undefined, $Lt._gc.undefined, true);
									} else {
										var insLen = insItems ? await insItems.length : 0, newInd = pos + insLen;
										var arr = await data.slice(newInd);
										await $Lt._fE(arr, async function (itm) {
											await Lyte.removeNestScp(itm, await wObj.id);
										});
										await $Lt._fE(arr, async function (itm, idx) {
											if (itm && (await $Lt._gc.Array.isArray(itm) || typeof itm == "object")) {
												var pth = await (await wObj.path).split(",");
												await pth.push(newInd + idx);
												await Lyte.bindObj(itm, $Lt._gc.undefined, await wObj.id, pth && await pth.length ? pth : [], $Lt._gc.undefined, $Lt._gc.undefined, $Lt._gc.undefined, true);
											}
										});
									}
								}
							});
						}
					},
					"establishUpdateBindings": async function (bindings, property, actualData) {
						let objbind = await bindings.toArrayLyte();
						for (let i = 0; i < await objbind.length; (i = i + 1) - 1) {
							let item = await objbind[i];
							if (await item[property]) {
								await addBindings(actualData, await item[property]);
								await this.establishBindings(await item[property], actualData);
							}
						}
					},
					"establishSelectedBinding": async function (property, actualData, node) {
						if (!property) {
							return;
						}
						let propName = await property._path;
						let props = await propName.split(".");
						let currentProp = await node.getProperty(await props[0]);
						let currentValue = await actualData[await props[0]];
						for (let i = 0; i < await props.length; (i = i + 1) - 1) {
							if (!currentValue || typeof currentValue !== "object") {
								break;
							}
							await addBindings(currentValue, currentProp);
							currentProp = await currentProp[await props[i + 1]];
							currentValue = await currentValue[await props[i + 1]];
						}
					},
					"establishBindings": async function (properties, actualData) {
						if (await properties._helperNodes) {
							let path = await properties._path;
							let arr = await (await properties._helperNodes).toArrayLyte();
							for (let s = 0; s < await arr.length; (s = s + 1) - 1) {
								let nodes = await (await arr[s])._dynamicProperty ? await (await (await arr[s])._dynamicProperty)[path] : $Lt._gc.undefined;
								if (nodes) {
									for (let j = 0; j < await nodes.length; (j = j + 1) - 1) {
										let node = await nodes[j];
										let helper = await node.ownerElement;
										if (helper && await helper.tagName === "TEMPLATE" && await helper.getAttribute("is") === "for") {
											if (await helper._items) {
												let item = await helper.getAttribute("item");
												for (let i = 0; i < await (await helper._items).length; (i = i + 1) - 1) {
													let data = await actualData[i];
													let item = await helper.getAttribute("item");
													if (data) {
														if (typeof await (await helper._items)[i] === "object") {
															await this.establishBindings(await (await (await helper._items)[i]).itemProperty, { [item]: data });
														}
													}
												}
											}
										}
									}
								}
							}
						}
						for (let i in properties) {
							let actData = await actualData[i];
							if (!actData || typeof actData === "string" || typeof actData === "number" || typeof actData === "boolean") {
								await addBindings(actualData, properties);
							} else {
								await addBindings(actData, await properties[i]);
								if (typeof await properties[i] === "object") {
									await this.establishBindings(await properties[i], actData);
								}
							}
						}
					},
					"removeSelectedBindingDeep": async function (binding, actualData, fromDisConnect) {
						var del = "delete";
						if (!actualData && !fromDisConnect) {
							return;
						}
						if (actualData && await actualData._bindings) {
							await deleteBindingCheckSize(actualData, "_bindings", binding);
						}
						for (let i in binding) {
							let actData;
							if (actualData) {
								actData = await actualData[i];
							}
							if (actData && await actData._bindings) {
								await deleteBindingCheckSize(actData, "_bindings", await binding[i]);
							}
							if (typeof await binding[i] === "object") {
								await this.removeSelectedBindingDeep(await binding[i], actData, fromDisConnect);
							}
						}
						if (fromDisConnect) {
							let dynNodes = await binding._dynamicNodes;
							let helperNodes = await binding._helperNodes;
							if (dynNodes && await dynNodes.length) {
								await (await binding._dynamicNodes).splice(0, await dynNodes.length);
							}
							if (helperNodes && await helperNodes.size) {
								await helperNodes.clear();
							}
						}
						if (binding && await binding._forHelpers) {
							let objbind = await (await binding._forHelpers).toArrayLyte();
							for (let i = 0; i < await objbind.length; (i = i + 1) - 1) {
								let fH = await objbind[i];
								if (await fH.getAttribute("is") === "for") {
									let item = await fH.getAttribute("item");
									let items = await (await fH._attributes).items;
									let itemCases = await fH._items;
									for (let i = 0; i < await itemCases.length; (i = i + 1) - 1) {
										await this.removeSelectedBindingDeep(await (await itemCases[i]).itemProperty, await items[i], fromDisConnect);
									}
								} else {
									if (await fH._propBindingObject) {
										if (actualData && await actualData._bindings) {
											await deleteBindingCheckSize(actualData, "_bindings", await fH._propBindingObject);
											await this.removeSelectedBindingDeep(await fH._propBindingObject, actualData, fromDisConnect);
										}
									}
								}
							}
						}
					},
					"removeAllBindings": async function (properties, data) {
						var del = "delete";
						for (let key in properties) {
							if (await data[key] && await (await data[key])._bindings) {
								await deleteBindingCheckSize(await data[key], "_bindings", await properties[key]);
							}
							if (await data[key] && typeof await data[key] !== "string") {
								await _LC.removeAllBindings(await properties[key], await data[key]);
							}
						}
					},
					"affectChanges": async function (item, contextAlreadySwitched, oldValue, setterScope, newValue, callLengthObserver, options) {
						if (await item._dynamicNodes) {
							for (let i = 0; i < await (await item._dynamicNodes).length; (i = i + 1) - 1) {
								await (await (await (await item._dynamicNodes)[i])._callee).updateNode(await (await item._dynamicNodes)[i], await item._path, options);
							}
						}
						let propPath = await item._path;
						if (await item._helperNodes) {
							let nodes = [], itemHelperNodes = await (await item._helperNodes).toArrayLyte();
							for (let s = 0; s < await itemHelperNodes.length; (s = s + 1) - 1) {
								if (!await (await item._helperNodes).has(await itemHelperNodes[s])) {
									continue;
								}
								if (await (await itemHelperNodes[s]).getAttribute("is") === "for" && await (await itemHelperNodes[s])._items) {
									let innerContextSwitchArray = [];
									await _LC.adCx(await itemHelperNodes[s], innerContextSwitchArray);
									let indexValue = await (await itemHelperNodes[s]).getAttribute("index");
									let itemValue = await (await itemHelperNodes[s]).getAttribute("item");
									let callee = await (await itemHelperNodes[s])._callee;
									let cmpData = await LyteComponent.getCmpData(await (await callee.component).data);
									let initialItemValue = await cmpData[itemValue];
									let initialIndexValue = await cmpData[indexValue];
									let initialItemProp = await (await callee._properties)[itemValue];
									let initialIndexProp = await (await callee._properties)[indexValue];
									let items = await (await (await itemHelperNodes[s])._attributes).items;
									var dirObjData = {
											data: {},
											prop: {}
										};
									var dirObjProp = {
											data: {},
											prop: {}
										};
									await _LCSV.beforeDirObj(await itemHelperNodes[s], dirObjData, dirObjProp);
									for (let i = 0; i < await (await (await itemHelperNodes[s])._items).length; (i = i + 1) - 1) {
										cmpData[itemValue] = await items[i];
										cmpData[indexValue] = i;
										(await callee._properties)[itemValue] = await (await (await (await itemHelperNodes[s])._items)[i]).itemProperty;
										if (await (await (await (await (await itemHelperNodes[s])._items)[i])._dynamicProperty)[propPath]) {
											nodes = await (await (await (await (await itemHelperNodes[s])._items)[i])._dynamicProperty)[propPath];
											for (let i = 0; i < await nodes.length; (i = i + 1) - 1) {
												await (await (await nodes[i])._callee).updateNode(await nodes[i], propPath, options);
											}
										}
									}
									cmpData[itemValue] = initialItemValue;
									cmpData[indexValue] = initialIndexValue;
									(await callee._properties)[itemValue] = initialItemProp;
									(await callee._properties)[indexValue] = initialIndexProp;
									await _LCSV.afterDirObj(await itemHelperNodes[s], dirObjData, dirObjProp);
									await _LC.rmCx(await itemHelperNodes[s], innerContextSwitchArray);
								} else if (await (await itemHelperNodes[s]).getAttribute("is") === "forIn" && await (await itemHelperNodes[s])._items) {
									let innerContextSwitchArray = [];
									await _LC.adCx(await itemHelperNodes[s], innerContextSwitchArray);
									let indexValue = await (await itemHelperNodes[s]).getAttribute("key");
									let itemValue = await (await itemHelperNodes[s]).getAttribute("value");
									let callee = await (await itemHelperNodes[s])._callee;
									let cmpData = await LyteComponent.getCmpData(await (await callee.component).data);
									let initialItemValue = await cmpData[itemValue];
									let initialIndexValue = await cmpData[indexValue];
									let initialItemProp = await (await callee._properties)[itemValue];
									let initialIndexProp = await (await callee._properties)[indexValue];
									let object = await (await (await itemHelperNodes[s])._attributes).object;
									for (let key in await (await itemHelperNodes[s])._items) {
										cmpData[itemValue] = await object[key];
										cmpData[indexValue] = key;
										(await callee._properties)[itemValue] = await (await (await (await itemHelperNodes[s])._items)[key]).itemProperty;
										if (await (await (await (await (await itemHelperNodes[s])._items)[key])._dynamicProperty)[propPath]) {
											nodes = await (await (await (await (await itemHelperNodes[s])._items)[key])._dynamicProperty)[propPath];
											for (let i = 0; i < await nodes.length; (i = i + 1) - 1) {
												await (await (await nodes[i])._callee).updateNode(await nodes[i], propPath, options);
											}
										}
									}
									cmpData[itemValue] = initialItemValue;
									cmpData[indexValue] = initialIndexValue;
									(await callee._properties)[itemValue] = initialItemProp;
									(await callee._properties)[indexValue] = initialIndexProp;
									await _LC.rmCx(await itemHelperNodes[s], innerContextSwitchArray);
								} else {
									nodes = await (await (await itemHelperNodes[s])._dynamicProperty)[await item._path] || [];
									let contextSwitchArray = [];
									if (await nodes.length) {
										await _LC.adCx(await itemHelperNodes[s], contextSwitchArray);
										for (let i = 0; i < await nodes.length; (i = i + 1) - 1) {
											await (await (await nodes[i])._callee).updateNode(await nodes[i], await item._path, options);
										}
										await _LC.rmCx(await itemHelperNodes[s], contextSwitchArray);
									}
								}
								await _LCSV.affectChangesComp(await itemHelperNodes[s]);
							}
						}
						if (await item._observers) {
							let objbind = await (await item._observers).toArrayLyte();
							let cond = callLengthObserver == false ? false : oldValue != $Lt._gc.undefined || newValue != $Lt._gc.undefined;
							if (cond) {
								for (let i = 0; i < await objbind.length; (i = i + 1) - 1) {
									let observer = await objbind[i];
									let obsObj = {
											type: "change",
											oldValue: oldValue,
											newValue: newValue,
											item: await item._path
										};
									if (await observer.callee && await (await observer.callee).component) {
										await (await (await observer.observer).value).call(await (await observer.callee).component, obsObj);
									} else {
										var scope = setterScope ? setterScope : window;
										if (await $Lt._gc.Array.isArray(scope)) {
											var sLen = await scope.length;
											for (var k = 0; k < sLen; (k = k + 1) - 1) {
												var itm = await scope[k];
												await (await (await observer.observer).value).call(itm, obsObj);
											}
										} else {
											await (await (await observer.observer).value).call(scope, obsObj);
										}
									}
								}
							}
						}
						if (await $Lt._gc.Array.isArray(item)) {
							for (var i = 0; i < await item.length; (i = i + 1) - 1) {
								for (let key in await item[i]) {
									await this.affectChanges(await (await item[i])[key], true, oldValue ? await oldValue[i] ? await (await oldValue[i])[key] : await oldValue[i] : oldValue, setterScope, newValue ? await newValue[i] ? await (await newValue[i])[key] : await newValue[i] : newValue);
								}
							}
						} else {
							for (let key in item) {
								var oldV = oldValue ? await oldValue[key] : oldValue, newV = newValue ? await newValue[key] : newValue;
								if (key == "*" && await (await item[key]).hasOwnProperty("_observers")) {
									oldV = oldValue;
									newV = newValue;
								}
								await this.affectChanges(await item[key], true, oldV, setterScope, newV);
							}
						}
					},
					"skipArgProcessing": async function (cloneActObj, ev, target) {
						if (await cloneActObj.skipArgProcessing) {
							let args = cloneActObj.args = await cloneActObj.actArgs;
							await args.shift();
							var eventIndex = await args.indexOf("__lyteEvent__");
							var nodeIndex = await args.indexOf("__lyteNode__");
							if (eventIndex !== -1) {
								args[eventIndex] = ev;
							}
							if (nodeIndex !== -1) {
								args[nodeIndex] = target;
							}
						} else {
							await (await cloneActObj.args).shift();
						}
					},
					"getDV": async function (value) {
						var result = [], ref = result, arr = [], data = "", strStack = [], arrayStack = [], refStack = [], strLast, str;
						for (var i = 0; i < await value.length; (i = i + 1) - 1) {
							if (await value[i] === ".") {
								if (await data.length) {
									await ref.push(data);
								}
								data = "";
								continue;
							} else if (await value[i] === "[") {
								await arrayStack.push(i);
								if (await data.length) {
									await ref.push(data);
								}
								while (await value[i + 1] === "s") {
									(i = i + 1) - 1;
								}
								if (await value[i + 1] === "\"" || await value[i + 1] === "'") {
									await strStack.push(await value[i + 1]);
									strLast = await value[i + 1];
									(i = i + 1) - 1;
								} else if (await arr.length) {
									await ref.push([]);
									await refStack.push(ref);
									ref = await ref[await ref.length - 1];
								} else {
									await arr.push([]);
									await refStack.push(ref);
									ref = await arr[await arr.length - 1];
								}
								data = "";
								continue;
							} else if ((await value[i] === "\"" || await value[i] === "'") && await value[(i = i + 1) - 1] === strLast) {
								while (await value[i] === "s" && await value[i] != "]") {
									(i = i + 1) - 1;
								}
								await strStack.pop();
								str = true;
							}
							if (await value[i] === "]") {
								await arrayStack.pop();
								if (await data.length) {
									if (str === true) {
										await ref.push(data);
									} else if (!await $Lt._gcFn.isNaN(await $Lt._gcFn.parseInt(data))) {
										if (await refStack.length) {
											ref = await refStack.pop();
											if (await arr.length && await $Lt._gc.Array.isArray(await ref[await ref.length - 1]) && !await (await ref[await ref.length - 1]).length) {
												await ref.pop();
											}
											await ref.push(data);
											if (!await arrayStack.length && await arr.length) {
												await arr.shift();
											}
										}
									} else {
										await ref.push(data);
									}
								}
								if (!await arrayStack.length && await arr.length) {
									await result.push(await arr.shift());
									ref = result;
								} else if (await refStack.length && !await arr.length) {
									ref = await refStack.pop();
								}
								data = "";
								str = "";
								continue;
							}
							data = await data.concat(await value[i]);
						}
						if (await data.length) {
							await result.push(data);
						}
						if (await strStack.length || await arrayStack.length) {
							await $Lt._gc.console.log("check the syntax", strStack, arrayStack);
						}
						return result;
					},
					"ccDelay": [],
					"callCC": async function () {
						await $Lt._fE(await this.ccDelay, async function (item) {
							if (await item.component) {
								await item.actualConnectedCallback();
							}
						});
						this.ccDelay = [];
					},
					"getDD": async function (context, dataArr) {
						var self = context;
						await $Lt._fE(dataArr, async function (item, index) {
							if (await $Lt._gc.Array.isArray(item)) {
								if (context == $Lt._gc.undefined) {
									return $Lt._gc.undefined;
								}
								var inner = await _LC.getDD(self, item);
								if (inner == $Lt._gc.undefined) {
									return $Lt._gc.undefined;
								}
								context = await context[inner];
							} else {
								if (context == $Lt._gc.undefined) {
									return $Lt._gc.undefined;
								}
								context = await context[item];
							}
						});
						return context;
					},
					"processStatic": async function (temp) {
						let arr = await (await temp.innerHTML).split("__**");
						let newArr = [];
						for (var i = 0; i < await arr.length; (i = i + 1) - 1) {
							if (await (await arr[i]).startsWith("--Lyte")) {
								await newArr.push(await $Lt._gcFn.parseInt(await (await arr[i]).substring(6)));
							} else {
								await newArr.push($Lt._gc.undefined);
							}
						}
						arr.cc = newArr;
						return arr;
					},
					"findLastNodeL": async function (lastNode1, count, node) {
						var totalNodeIndex = 0;
						if (count != $Lt._gc.undefined) {
							totalNodeIndex = count;
						}
						var helperNode;
						switch (await node.getAttribute("is")) {
						case "for":
							if (await (await node._helpers)[totalNodeIndex]) {
								helperNode = await (await (await node._helpers)[totalNodeIndex])[0];
							}
							if (!lastNode1) {
								if (await (await node._forContent)[0]) {
									lastNode1 = await (await (await node._forContent)[0])[0];
								}
							}
							break;
						case "forIn":
							if (await (await node._helpers)[await (await node._keysArray)[0]]) {
								helperNode = await (await (await node._helpers)[await (await node._keysArray)[0]])[0];
							}
							if (!lastNode1) {
								if (await (await node._forContent)[await (await node._keysArray)[0]]) {
									lastNode1 = await (await (await node._forContent)[await (await node._keysArray)[0]])[0];
								}
							}
							break;
						case "if":
						case "switch":
							helperNode = await (await node._helpers)[totalNodeIndex];
							if (!lastNode1) {
								lastNode1 = await (await node._caseContent)[0];
							}
							break;
						case "component":
							lastNode1 = await (await lastNode1._renderedComponent)[await lastNode1._currentComponent] || lastNode1;
							return lastNode1;
						}
						if (!lastNode1) {
							lastNode1 = await node._placeHolder;
						}
						if (helperNode && lastNode1 == await helperNode._placeHolder) {
							lastNode1 = await this.findLastNodeL($Lt._gc.undefined, $Lt._gc.undefined, helperNode);
						}
						return lastNode1;
					},
					"processAction": async function (node) {
						await $Lt._fE(await $Lt._gc.Array.from(await node.querySelectorAll("[lyteaction]")), async function (item) {
							let locIndex = await (await (await item.attributes).lyteaction).value;
							item._boundEvents = await (await _LC.fRP)[locIndex];
							delete (await _LC.fRP)[locIndex];
							var _cx = await (await item._boundEvents)._cx;
							let boundEvents = await item._boundEvents;
							delete boundEvents._cx;
							let componentName = await boundEvents.componentName;
							delete boundEvents.componentName;
							for (var key in await item._boundEvents) {
								if (await key.indexOf("-") !== -1) {
									item._actions = await item._actions || {};
									(await item._actions)[key] = await $Lt._cO($Lt._gc.CustomEvent, key);
									(await (await item._actions)[key]).processAction = await (await item._boundEvents)[key];
									await (await (await (await item._boundEvents)[key]).actArgs).shift();
									let nodeIndex = await (await (await (await item._boundEvents)[key]).actArgs).indexOf("__lyteNode__");
									if (nodeIndex !== -1) {
										(await (await (await item._boundEvents)[key]).actArgs)[nodeIndex] = item;
									}
									(await (await item._boundEvents)[key]).args = await (await (await item._boundEvents)[key]).actArgs;
									delete (await item._boundEvents)[key];
								} else {
									let actArgs = await _Lyte.deepCopyObject(await (await (await item._boundEvents)[key]).args);
									let actName = await (await actArgs.splice(0, 1))[0];
									actName = await actName.startsWith("'") ? await actName.replace((/'/g), "") : actName;
									let actString = await getArgString(actName, actArgs);
									await item.setAttribute(await key.startsWith("on") ? await key.substr(2) : key, componentName + " => " + actString);
									if (!await (await (await item._boundEvents)[key]).globalEvent) {
										await item.addEventListener(key, globalEventHandler);
									}
								}
							}
							(await item._boundEvents)._cx = _cx;
							await item.removeAttribute("lyteaction");
						});
					},
					"getCtxVal": function (context, val, self) {
						if (context != undefined) {
							if (window.isLyteWidget || window.__lyteEnablePromise) {
								if (context && context[val] instanceof Promise && !context[val].__lyte) {
									_LC.listenPromise(context, val, context[val]);
								}
							}
							return context[val];
						} else {
							return undefined;
						}
					},
					"listenPromise": async function (context, key, actVal) {
						await actVal.then(async function (resolvedData) {
							actVal.__lyteUserResolved = true;
							(await actVal.__lyte).status = "resolved";
							await (await Lyte.Component).set(context, key, resolvedData);
						}, async function () {
							actVal.__lyteUserRejected = true;
							(await actVal.__lyte).status = "rejected";
							await (await Lyte.Component).set(context, key, await context[key], {
								force: true,
								skipTypeCast: true,
								skipValidation: true
							});
						});
						await $Lt._gcFn.defProp(actVal, "__lyte", { value: { status: "init" } });
					},
					"get": function (context, path, ac, cache, comp) {
						if (!ac) {
							ac = [];
						}
						if (cache && cache.hasOwnProperty(path)) {
							nodeValue = cache[path]._data;
							if (cache[path]._dyn) {
								cache[path]._dyn.forEach(function (item) {
									ac.push(item);
								});
							}
							return nodeValue;
						} else {
							try {
								let arr = path.match((/([^[\]]+|\[\])/g));
								let initialContext = context;
								ac.push(arr[0]);
								let locArr = arr[0].split(".");
								for (let k = 0; k < locArr.length; (k = k + 1) - 1) {
									context = _LC.getCtxVal(context, locArr[k], comp);
								}
								for (let i = 1; i < arr.length; (i = i + 1) - 1) {
									let locVal = arr[i];
									if (locVal.startsWith(".")) {
										let locArr = locVal.substring(1).split(".");
										for (let k = 0; k < locArr.length; (k = k + 1) - 1) {
											context = _LC.getCtxVal(context, locArr[k], comp);
										}
										ac[0] = ac[0] + locVal;
									} else if (locVal.startsWith("'") || locVal.startsWith("\"") || !isNaN(locVal)) {
										if (!isNaN(locVal)) {
											ac[0] = ac[0] + "." + locVal;
											context = _LC.getCtxVal(context, locVal, comp);
										} else {
											ac[0] = ac[0] + "." + locVal.substring(1, locVal.length - 1);
											context = _LC.getCtxVal(context, locVal.substring(1, locVal.length - 1), comp);
										}
									} else {
										let length = ac.length;
										let val = _LC.get(initialContext, locVal, ac);
										ac[0] = ac[0] + "." + val;
										context = _LC.getCtxVal(context, val, comp);
									}
								}
								if (cache) {
									cache[path] = {};
									cache[path]._data = context;
									cache[path]._dyn = ac;
								}
								return context;
							} catch (e) {
								return undefined;
							}
						}
					},
					"getNew": async function (context, path) {
						try {
							let arr = await path.match((/([^[\]]+|\[\])/g));
							let initialContext = context;
							let locArr = await (await arr[0]).split(".");
							if (await arr.length < 2) {
								if (await locArr.length < 2) {
									return {
										"context": initialContext,
										"lastKey": await locArr[0]
									};
								} else {
									for (var k = 0; k < await locArr.length - 1; (k = k + 1) - 1) {
										context = await context[await locArr[k]];
									}
									return {
										"context": context,
										"lastKey": await locArr[k]
									};
								}
							}
							for (let k = 0; k < await locArr.length; (k = k + 1) - 1) {
								context = await context[await locArr[k]];
							}
							for (var i = 1; i < await arr.length - 1; (i = i + 1) - 1) {
								let locVal = await arr[i];
								if (await locVal.startsWith(".")) {
									let locArr = await (await locVal.substring(1)).split(".");
									for (let k = 0; k < await locArr.length; (k = k + 1) - 1) {
										context = await context[await locArr[k]];
									}
								} else if (await locVal.startsWith("'") || await locVal.startsWith("\"") || !await $Lt._gcFn.isNaN(locVal)) {
									context = await context[await locVal.substring(1, await locVal.length - 1)];
								} else {
									let val = await this.get(initialContext, locVal);
									context = await context[val];
								}
							}
							let lastKey = await arr[i];
							if (await lastKey.startsWith(".")) {
								let locArr = await (await lastKey.substring(1)).split(".");
								let k = 0;
								for (; k < await locArr.length - 1; (k = k + 1) - 1) {
									context = await context[await locArr[k]];
								}
								lastKey = await locArr[k];
							} else if (await lastKey.startsWith("'") || await lastKey.startsWith("\"") || !await $Lt._gcFn.isNaN(lastKey)) {
								lastKey = await lastKey.substring(1, await lastKey.length - 1);
							} else {
								lastKey = await this.get(initialContext, lastKey);
							}
							return {
								"context": context,
								"lastKey": lastKey
							};
						} catch (e) {
							return $Lt._gc.undefined;
						}
					},
					"componentGetData": function (key) {
						if (key && key.match((/^\$\./g))) {
							if ($L && $L.Jwalk) {
								return $L.Jwalk(this.data, key);
							} else {
								_Lyte.warn("For using JSON path synatx , include the Jwalk file from the lyte-plugins");
							}
						}
						if (key) {
							return this.get(key);
						} else {
							return this.data;
						}
					},
					"componentSetData": async function (arg0, arg1, options) {
						if (typeof arg0 === "string") {
							await this.set(arg0, arg1, options);
						} else if (typeof arg0 === "object") {
							for (let key in arg0) {
								await this.set(key, await arg0[key], arg1);
							}
						}
					},
					"componentToggleData": async function (dataName) {
						await this.set(dataName, !await this.get(dataName));
					},
					"componentGetMethods": async function (key) {
						let node = await this.$node;
						if (node) {
							if (key && await node._methods) {
								return await (await node._methods)[key];
							} else {
								return await node._methods;
							}
						}
					},
					"componentHasAction": async function (key) {
						let node = await this.$node;
						if (node) {
							if (key && await (await node._actions)[key]) {
								return true;
							} else {
								return false;
							}
						}
					},
					"componentsetActions": async function (arg0, arg1) {
						let actions = await (await this.$node)._actions;
						if (typeof arg0 === "string") {
							actions[arg0] = arg1;
						} else if (typeof arg0 === "object") {
							for (let key in arg0) {
								actions[key] = await arg0[key];
							}
						}
					},
					"componentSetMethods": async function (arg0, arg1) {
						let node = await this.$node;
						if (node) {
							if (typeof arg0 === "string") {
								(await node._methods)[arg0] = arg1;
							} else if (typeof arg0 === "object") {
								for (let key in arg0) {
									(await node._methods)[key] = await arg0[key];
								}
							}
						}
					},
					"render": async function (componentName, data, outlet, options) {
						var component;
						_LC.fromV3Render = true;
						var actDocument = $Lt._gc.document;
						if (await Lyte.isWidgetBuild) {
							actDocument = await window._widgetDocument;
						} else {
							actDocument = $Lt._gc.document;
						}
						if (ltCf && await _Lyte.isWidgetBuild) {
							ltCf.fromWidgetRender = true;
						}
						if (componentName) {
							if (typeof componentName == "string") {
								component = await createElement(componentName);
							} else if (await componentName.compName) {
								component = await createElement(await componentName.compName);
							} else {
								await _Lyte.error("LC007");
								_LC.fromV3Render = false;
								if (ltCf && await _Lyte.isWidgetBuild) {
									ltCf.fromWidgetRender = false;
								}
								return;
							}
						} else {
							await _Lyte.error("LC007");
							_LC.fromV3Render = false;
							if (ltCf && await _Lyte.isWidgetBuild) {
								ltCf.fromWidgetRender = false;
							}
							return;
						}
						if (data) {
							await component.setData(data);
						}
						if (options && await options.methods) {
							await component.setMethods(await options.methods);
						}
						if (options && await options.attributes) {
							await $Lt._fE(await options.attributes, async function (attr) {
								if (typeof attr == "object") {
									await component.setAttribute(await attr.name, await attr.value);
								} else {
									await component.setAttribute(attr, "");
								}
							});
						}
						if (outlet) {
							let actOutlet;
							if (typeof outlet == "string") {
								actOutlet = await actDocument.querySelector(outlet);
							} else {
								actOutlet = outlet;
							}
							if (actOutlet) {
								if (options && await options.dataType) {
									(await component.component).__data = await options.dataType;
								}
								await actOutlet.appendChild(component);
								component._callee = await component.getCallee ? await component.getCallee(actOutlet) : $Lt._gc.undefined;
							} else {
								await _Lyte.error("LC008", outlet);
							}
						}
						_LC.fromV3Render = false;
						if (ltCf && await _Lyte.isWidgetBuild) {
							ltCf.fromWidgetRender = false;
						}
						return component;
					},
					"String": {
						"cache_c": {},
						"cache_d": {},
						"upperCaseFirstLetter": function (string) {
							return string.charAt(0).toUpperCase() + string.slice(1);
						},
						"lowerCaseFirstLetter": function (string) {
							return string.charAt(0).toLowerCase() + string.slice(1);
						},
						"toCamelCase": function (string) {
							if (!this.cache_c[string]) {
								this.cache_c[string] = _stringReplacer.call(string, (/(-\w)/g), function (m) {
									return m[1].toUpperCase();
								});
							}
							return this.cache_c[string];
						},
						"dasherize": function (string) {
							if (!this.cache_d[string]) {
								this.cache_d[string] = _stringReplacer.call(string, (/([a-z])([A-Z])/g), "$1-$2").toLowerCase();
							}
							return this.cache_d[string];
						}
					},
					"appendChild": async function (outlet, component) {
						await _LyteComponent._setIgnoreDisconnect(true);
						await outlet.appendChild(component);
						await _LyteComponent._setIgnoreDisconnect(false);
					},
					"replaceWith": async function () {
						var argumentsArr = await $Lt._gc.Array.from(arguments);
						var oldNode = await argumentsArr.shift();
						await _LyteComponent._setIgnoreDisconnect(true);
						var parentNode = await oldNode.parentNode;
						for (var i = 0, node; node = await argumentsArr[i]; (i = i + 1) - 1) {
							await parentNode.insertBefore(node, oldNode);
						}
						await oldNode.remove();
						await _LyteComponent._setIgnoreDisconnect(false);
					},
					"insertBefore": async function (referenceNode, newNode, parentNode) {
						await _LyteComponent._setIgnoreDisconnect(true);
						if (!parentNode) {
							if (!referenceNode) {
								await _Lyte.error("LC010");
								await _LyteComponent._setIgnoreDisconnect(false);
								return;
							} else {
								parentNode = await referenceNode.parentNode;
							}
						}
						await insertBefore(parentNode, newNode, referenceNode ? referenceNode : null);
						await _LyteComponent._setIgnoreDisconnect(false);
					},
					"insertAfter": async function () {
						var argumentsArr = await $Lt._gc.Array.from(arguments);
						var referenceNode = await argumentsArr.shift();
						await _LyteComponent._setIgnoreDisconnect(true);
						await (await referenceNode.after).apply(referenceNode, argumentsArr);
						await _LyteComponent._setIgnoreDisconnect(false);
					},
					"executeMethod": async function () {
						let node = await this.$node;
						if (node) {
							let args = await (await (await $Lt._gc.Array.prototype).slice).call(arguments, 1);
							var methodName = await (await _LC.String).toCamelCase(await arguments[0]);
							if (!await (await node._methods)[methodName]) {
								await _Lyte.error("LC009", methodName, await (await this.$node).tagName);
								return;
							}
							return await (await (await node._methods)[methodName]).apply(this, args);
						}
					},
					"getProperData": async function (obj) {
						var dataType = await obj.dataType;
						var attr = await obj.attr;
						var newValue = await obj.newValue;
						var tagName = await obj.tagName;
						switch (dataType) {
						case "boolean": {
								if (!newValue || newValue === "false") {
									newValue = false;
								} else {
									newValue = true;
								}
							}
							break;
						case "object":
							try {
								newValue = await $Lt._gc.JSON.parse(newValue);
								if (!await $Lt._iO(newValue, $Lt._gc.Object)) {
									await _Lyte.warn("data type of the value provided for attribute " + attr + " of " + tagName + " is not valid");
								}
							} catch (e) {
								await _Lyte.warn("attribute " + attr + " is not a valid JSON string.");
								return;
							}
							break;
						case "array":
							try {
								newValue = await $Lt._gc.JSON.parse(newValue);
								if (!await $Lt._iO(newValue, $Lt._gc.Array)) {
									await _Lyte.warn("data type of the value provided for attribute " + attr + " of " + tagName + " is not valid");
								}
							} catch (e) {
								await _Lyte.warn("attribute " + attr + " is not a valid JSON string.");
								return;
							}
							break;
						case "number": {
								let numValue = +newValue;
								if (newValue === numValue + "") {
									newValue = numValue;
								} else {
									await _Lyte.warn("data type of the value provided for attribute " + attr + " of " + tagName + " is not valid");
									return;
								}
							}
							break;
						}
						obj.newValue = newValue;
						return true;
					},
					"cssEscape": async function (string) {
						if (string) {
							return await string.replace((/['"]/g), "\\$&");
						} else {
							return string;
						}
					},
					"shadow": {
						"shadowList": [],
						"toAddEvents": [],
						"attachEvents": async function (thisRef) {
							var bodyEvents = await LyteComponent.globalDOMEvents;
							for (var _i = 0; _i < await bodyEvents.length; (_i = _i + 1) - 1) {
								var evnt = await bodyEvents[_i];
								await window.__lyteEnableDelayAction && await thisRef.addEventListener(evnt, await LyteComponent.docCaptureGlobalEventHandler, true);
								await thisRef.addEventListener(evnt, await LyteComponent.globalEventHandler, true);
								await window.__lyteEnableDelayAction && await thisRef.addEventListener(evnt, await LyteComponent.docBubbleGlobalEventHandler);
							}
							var toAddEvents = await this.toAddEvents;
							var len = await toAddEvents.length;
							for (let i = 0; i < len; (i = i + 1) - 1) {
								await thisRef.addEventListener(await (await toAddEvents[i]).eventName, await (await toAddEvents[i]).listener, await (await toAddEvents[i]).options);
							}
							await thisRef.addEventListener("change", await LyteComponent.changeEventHandler);
						},
						"createLessDiv": async function (shadow, comp) {
							var div = await $Lt._gc.document.createElement("div");
							await div.setAttribute("id", "lessDiv");
							await shadow.appendChild(div);
							comp._lessDiv = div;
							(await comp._lessDiv)._impNames = [];
						},
						"insertInLessDiv": async function (shadowParent, lessDiv) {
							var self = this;
							if (shadowParent && await (await shadowParent._lessDiv)._impNames) {
								await $Lt._fE(await (await shadowParent._lessDiv)._impNames, async function (item) {
									await (await lessDiv._impNames).$push(item);
									var sty = await $Lt._gc.document.createElement("style");
									await sty.setAttribute("placeHolder", await (await (await self.importStyle)[item]).src);
									await sty.setAttribute("id", item);
									await lessDiv.appendChild(sty);
								});
							}
						},
						"updateLessDiv": async function (lessDiv, compNames) {
							var self = this;
							await $Lt._fE(await lessDiv._impNames, async function (id) {
								await $Lt._fE(compNames, async function (tagName) {
									if (await (await self.importStyle)[id] && await (await (await self.importStyle)[id]).status == "resolved" && await (await (await (await self.importStyle)[id]).response)[tagName]) {
										var a = await $Lt._gc.document.createElement("style");
										await a.setAttribute("lyte-id-imported", "shadow-style-" + tagName);
										await a.setAttribute("impSrc", id);
										a.innerHTML = await (await (await (await self.importStyle)[id]).response)[tagName];
										var ele = await lessDiv.querySelector("[id=" + id + "]");
										await LyteComponent.insertBeforeNative(lessDiv, a, ele);
									}
								});
							});
						},
						"getHostElement": async function (node) {
							if (node) {
								let host = await node.host;
								if (host && await host.tagName) {
									return host;
								}
							}
						},
						"appendChild": async function (outlet, ele, obj) {
							let componentParent;
							if (obj && await $Lt._iO(obj, $Lt._gc.Object) && await obj.referenceNode) {
								componentParent = await obj.referenceNode;
							} else {
								componentParent = $Lt._gc.undefined;
							}
							let igDisconnect = false;
							if (!obj || !await obj.native) {
								await _LyteComponent._setIgnoreDisconnect(true);
								igDisconnect = true;
							}
							var shadowParent = componentParent ? await componentParent.getRootNode() : ele ? await ele.getRootNode() : $Lt._gc.undefined;
							var nonShadowParent = ele;
							let hostEleParent = await this.getHostElement(shadowParent);
							if (shadowParent && hostEleParent) {
								nonShadowParent = await this.looping(nonShadowParent);
							}
							if (await Lyte.isWidgetBuild & shadowParent && hostEleParent && outlet && hostEleParent != (await outlet.lastElementChild ? await this.getHostElement(await (await outlet.lastElementChild).getRootNode()) : await this.getHostElement(await outlet.getRootNode()))) {
								var a = {
										"type": "appendChild",
										"shadowParent": hostEleParent,
										"outlet": outlet,
										"element": ele,
										"nonShadowParent": nonShadowParent
									};
								await this.addElements(a);
							} else {
								await outlet.appendChild(ele);
							}
							if (igDisconnect) {
								await _LyteComponent._setIgnoreDisconnect(false);
							}
						},
						"looping": async function (parent) {
							while (parent) {
								if (await parent.component && await parent.tagName != "LYTE-YIELD") {
									return parent;
								}
								parent = await parent.parentNode;
							}
						},
						"addElements": async function (obj, registryInstance) {
							var ele = await obj.element;
							var wrapper = await (await Lyte.$).widgetWrapper;
							if (await $Lt._gc.Array.isArray(ele)) {
								await $Lt._fE(ele, async function (item, index) {
									await (await wrapper.shadowRoot).appendChild(item);
								});
							} else {
								await (await wrapper.shadowRoot).append(ele);
							}
						},
						async "prependStyle"(shadowParent, style) {
							var nodes = await shadowParent.querySelectorAll("[lyte-id^='shadow-']");
							var last = await nodes[await nodes.length - 1];
							if (last) {
								await _LC.insertBeforeNative(shadowParent, style, await last.nextSibling);
							} else {
								await _LC.insertBeforeNative(shadowParent, style, await (await shadowParent.childNodes)[0]);
							}
						}
					},
					"V3": { pendingComp: {
							remove: async function (node) {
									let found;
									let ltCfPend = await (await window.__lyteConfig)._pendingV3Components;
									if (await ltCfPend[await node.localName]) {
										let ind = await (await ltCfPend[await node.localName]).indexOf(node);
										if (ind != -1) {
											await (await ltCfPend[await node.localName]).splice(ind, 1);
											found = true;
										}
									}
									return found;
								},
							add: async function (node) {
								let ltCfPend = await (await window.__lyteConfig)._pendingV3Components;
								if (await ltCfPend[await node.localName]) {
									if (await (await ltCfPend[await node.localName]).indexOf(node) == -1) {
										await (await ltCfPend[await node.localName]).push(node);
									}
								} else {
									ltCfPend[await node.localName] = [node];
								}
							},
							find: async function (name) {
								return await (await (await window.__lyteConfig)._pendingV3Components)[name];
							},
							execute: async function (arr) {
								await $Lt._fE(arr, async function (item) {
									delete item.__v3lyteIgnore;
									await item.decideConstructor();
									var arr = await $Lt._gc.Array.from(await item.attributes);
									await $Lt._fE(arr, async function (attr) {
										if (await (await (await item.constructor).observedAttributes).indexOf(await attr.name) != -1) {
											await item._attributeChangedCallback(await attr.name, null, await attr.value);
										}
									});
									await item._connectedCallback();
								});
								await arr.splice(0, await arr.length);
							},
							firstRegister: async function (name, v) {
								let firstObj = await (await window.__lyteConfig)._firstRegisteredComp;
								if (!await firstObj[name]) {
									firstObj[name] = v;
								}
							}
						} },
					"directive": {
						"save": {
								triggerMap: {
										"input": [
												"value",
												"checked",
												"disabled"
											],
										"select": [
											"value",
											"selectedIndex"
										],
										"textarea": ["value"],
										"div": ["id"],
										"span": ["id"]
									},
								addNode: async function (self, attr, dynamicN, gonnaSave, node, staticProp, helperNode, options) {
									let nodeVal = await (await _LC.directive).getExactTransitionArg(attr, dynamicN) || await dynamicN.id;
									if (nodeVal) {
										await self.setData(nodeVal, gonnaSave);
										await (await _LC.object).initalize(dynamicN, "__updateProp");
										await (await _LC.array).initalize(await dynamicN.__updateProp, await attr.hookName);
										if (await (await (await dynamicN.__updateProp)[await attr.hookName]).indexOf(nodeVal) == -1) {
											await (await (await dynamicN.__updateProp)[await attr.hookName]).push(nodeVal);
										}
										if (node) {
											node._saveNode = nodeVal;
										}
										attr._saveNode = nodeVal;
										if (await attr.hookName == "prop") {
											await this.addData(gonnaSave, attr);
										}
										let cxObj = await dynamicN._cx;
										let forHelperNode = cxObj ? await cxObj.node : false;
										if (staticProp) {
											if (forHelperNode) {
												dynamicN._helperNode = forHelperNode;
												if (options) {
													let type = await cxObj.type;
													let ind = await cxObj.itemIndex;
													switch (type) {
													case "forIn":
													case "for": {
															if (await helperNode._dirObj) {
																if (await (await helperNode._dirObj).prop) {
																	if (await (await (await helperNode._dirObj).prop).indexOf(nodeVal) != -1) {
																		await this.estBndPrevNode(self, helperNode, nodeVal, gonnaSave, cxObj);
																	}
																}
																if (await (await helperNode._dirObj).data) {
																	if (await (await (await helperNode._dirObj).data).indexOf(nodeVal) != -1) {
																		await this.estBndPrevNode(self, helperNode, nodeVal, gonnaSave, cxObj);
																	}
																}
															}
															await (await _LC.array).initalize(forHelperNode, "_currentProp");
															await (await _LC.array).checkAndPush(await forHelperNode._currentProp, nodeVal);
															if (!await (await forHelperNode._propNodes)[nodeVal]) {
																if (await forHelperNode.getAttribute("is") == "forIn") {
																	(await forHelperNode._propNodes)[nodeVal] = {};
																} else {
																	(await forHelperNode._propNodes)[nodeVal] = [];
																}
															}
															if (await (await (await forHelperNode._propNodes)[nodeVal])[ind]) {
																await (await this.for).beforeUpdateSpecific(forHelperNode, [
																	ind,
																	1
																], [gonnaSave], nodeVal, true);
																await (await this.for).afterUpdateSpecific(forHelperNode, [
																	ind,
																	1
																], [gonnaSave], nodeVal);
															} else {
																(await (await forHelperNode._propNodes)[nodeVal])[ind] = gonnaSave;
															}
														}
													}
												}
											} else {
												let beforeProp = await self.getProperty(nodeVal);
												await (await _LC.array).initalize(await self._propNodes, nodeVal);
												await (await (await self._propNodes)[nodeVal]).push(beforeProp);
											}
										}
									} else {
										await Lyte.error("No value provided for save directive");
									}
								},
								addData: async function (element, attr) {
									if (!await element.$data) {
										let listenerArr = await (await this.triggerMap)[await element.localName];
										if (listenerArr) {
											element.$data = {};
											await $Lt._fE(listenerArr, async function (prop) {
												(await element.$data)[prop] = await element[prop];
											});
										} else if (await (await (await Lyte.Component).registeredComponents)[await element.localName]) {
											let directiveName = await attr.hookName;
											let directiveVal = await (await _LC.directive).getExactTransitionArg(attr, element) || await element.id;
											element.$data = {};
											await $Lt._gc.Object.defineProperty(await element.$data, "__lyteDirective", {
												"enumerable": false,
												"value": {
													name: directiveName,
													value: directiveVal,
													node: element
												}
											});
										} else {
											element.$data = {};
										}
										for (var i = 0; i < await (await element.attributes).length; (i = i + 1) - 1) {
											var attrib = await (await element.attributes)[i];
											let name = await (await _LC.String).toCamelCase(await attrib.name);
											if (!await (await element._attributeDetails)[await attrib.name] && !await (await element.$data)[name]) {
												(await element.$data)[name] = await attrib.value;
											}
										}
									}
								},
								updateName: async function (self, node, nodeValue) {
									let oldSave = await node._saveNode;
									let fullDirectiveName = await node.nodeName;
									let actualData;
									if (fullDirectiveName == "@data") {
										actualData = await (await node.ownerElement).$data;
									} else {
										actualData = await node.ownerElement;
									}
									if (await self.getData(oldSave) == actualData) {
										await self.setData(oldSave, null);
									}
									node._saveNode = nodeValue;
									await self.setData(nodeValue, actualData);
									let spAttr = await (await node.ownerElement)._specialAttributeDetails;
									await $Lt._fE(spAttr, async function (attr) {
										if (await attr.hookName == "prop") {
											attr._saveNode = nodeValue;
										} else if (await attr.hookName == "data") {
											attr._saveNode = nodeValue;
										}
									});
								},
								removeNode: async function (self, dynamicN) {
									if (await dynamicN._specialAttributeDetails) {
										await $Lt._fE(await dynamicN._specialAttributeDetails, async function (attr) {
											if (await attr.hookName == "prop" || await attr.hookName == "data") {
												let dataName = await (await _LC.directive).getActualTransitionArg(attr, dynamicN);
												(await (await self.component).data)[dataName] = null;
											}
										});
									}
								},
								removeAllNode: async function (isType, self, spNodes) {
									await _LC.iterator(isType, spNodes, async function (dynamicN) {
										if (await $Lt._gc.Array.isArray(dynamicN)) {
											await $Lt._fE(dynamicN, async function (dynN) {
												await _LCSV.removeNode(self, dynN);
											});
										} else {
											await _LCSV.removeNode(self, dynamicN);
										}
									});
								},
								getAttr: async function (spAttr) {
									let saveAttr = false;
									if (spAttr) {
										await $Lt._fE(spAttr, async function (attr) {
											if (await attr.hookName == "prop") {
												saveAttr = attr;
											} else if (await attr.hookName == "data") {
												saveAttr = attr;
											}
										});
									}
									return saveAttr;
								},
								triggerAllListeners: async function (self, directiveName, target, switchContext) {
									let saveNodeName = await target.localName;
									let listenerArr = await (await this.triggerMap)[saveNodeName];
									if (listenerArr) {
										await $Lt._fE(listenerArr, async function (prop) {
											await _LCSV.setData(prop, target);
										});
										if (await self._cx) {
											await _LCSV.updateCxNodes(self);
										}
									}
								},
								setData: async function (eleProp, target) {
									await (await Lyte.Component).set(await target.$data, eleProp, await target[eleProp]);
								},
								addNodeLazy: async function (arr, comp, info, dynamicN, helperNode, yieldComp, options) {
									await $Lt._fE(arr, async function (obj) {
										let attr = await obj.attr;
										let node = await obj.node;
										let staticProp;
										if (attr && await attr.stringValue) {
											staticProp = true;
										}
										if (await attr.hookNode) {
											await (await _LC.directive).infoA(comp, info, dynamicN, helperNode, attr, yieldComp, options);
											if (await attr.hookName == "prop" || await attr.hookName == "data") {
												if (options && await options.node) {
													dynamicN._cx = options;
												} else if (helperNode) {
													dynamicN._cx = await helperNode._cx;
												}
												let gonnaSave = dynamicN;
												await _LCSV.addData(dynamicN, attr);
												if (await attr.hookName == "data") {
													gonnaSave = await dynamicN.$data;
												}
												await _LCSV.addNode(comp, attr, dynamicN, gonnaSave, node, staticProp, helperNode, options);
											} else if (await attr.hookName == "class") {
												if (staticProp) {
													await (await (await _LC.directive).class).addStaticValue(dynamicN);
												} else {
													await (await (await _LC.directive).class).addValue(await node.ownerElement);
												}
											}
										}
									});
								},
								updateCxNodes: async function (comp) {
									let cx = await comp._cx;
									let initial = true;
									while (cx) {
										if (await cx.type == "for" || await cx.type == "forIn") {
											let forNode = await cx.node;
											let ind = await cx.itemIndex;
											if (await (await comp.__updateProp).data) {
												await $Lt._fE(await (await comp.__updateProp).data, async function (propVal) {
													if (await (await forNode._propNodes)[propVal]) {
														if (initial) {
															await (await Lyte.Component).set(await (await forNode._propNodes)[propVal], ind, await comp.$data, { force: true });
														}
														await _LCSV.affectChangesArr(await (await (await (await forNode._items)[ind]).propProperty)[propVal]);
														await _LCSV.establishBindingsArr(await (await (await (await forNode._items)[ind]).propProperty)[propVal], await (await (await forNode._propNodes)[propVal])[ind]);
													}
													await _LCSV.affectChangesComp(forNode);
												});
											} else if (await (await comp.__updateProp).prop) {
												await $Lt._fE(await (await comp.__updateProp).prop, async function (propVal) {
													if (await (await forNode._propNodes)[propVal]) {
														if (initial) {
															await (await Lyte.Component).set(await (await (await forNode._propNodes)[propVal])[ind], "$data", await comp.$data, { force: true });
														}
														await _LCSV.affectChangesArr(await (await (await (await forNode._items)[ind]).propProperty)[propVal], await (await forNode._propNodes)[propVal]);
													}
												});
											}
										}
										initial = false;
										cx = await (await cx.node)._cx;
									}
									if (await (await comp.__updateProp).data) {
										await $Lt._fE(await (await comp.__updateProp).data, async function (propVal) {
											if (await comp._callee && await (await comp._callee)._propProperty && await (await (await comp._callee)._propProperty)[propVal] && await (await (await (await comp._callee)._propProperty)[propVal]).length) {
												await _LCSV.affectChangesArr(await (await (await comp._callee)._propProperty)[propVal]);
												await _LCSV.establishBindingsArr(await (await (await comp._callee)._propProperty)[propVal], await (await (await comp._callee).$data)[propVal], true);
											}
										});
									}
								},
								setDataInParentComp: async function (comp) {
									if (await (await comp.__updateProp).data) {
										await $Lt._fE(await (await comp.__updateProp).data, async function (propVal) {
											await (await Lyte.Component).set(await (await (await comp._callee).component).data, propVal, await comp.$data, { force: true });
										});
									} else if (await (await comp.__updateProp).prop) {
										await $Lt._fE(await (await comp.__updateProp).prop, async function (propVal) {
											await (await Lyte.Component).set(await (await (await comp._callee).component).data, propVal, comp, { force: true });
										});
									}
								},
								affectChangesArr: async function (bindingArr) {
									if (bindingArr) {
										await $Lt._fE(bindingArr, async function (binding) {
											binding && await _LC.affectChanges(binding);
										});
									}
								},
								establishBindingsArr: async function (bindingArr, data, addBinding) {
									if (bindingArr) {
										await $Lt._fE(bindingArr, async function (binding) {
											await _LC.establishBindings(binding, data);
											if (addBinding) {
												await addBindings(data, binding);
											}
										});
									}
								},
								afterRender: async function (node, comp, dirObjProp, options, initialRender) {
									for (let key in await node._propNodes) {
										let cxObj = await node._cx;
										let parentForNode = node;
										while (cxObj) {
											if (await cxObj.type == "for" || await cxObj.type == "forIn") {
												parentForNode = await cxObj.node;
												let parentPropNodes = await (await (await cxObj.node)._propNodes)[key];
												if (await (await (await cxObj.node)._propNodes)[key]) {
													if (await options.type != "default" && await node.getAttribute("is") == "for") {
														let oldbindings = await (await parentPropNodes[await cxObj.itemIndex])._bindings;
														if (oldbindings) {
															let bindArr = await oldbindings.toArrayLyte();
															await this.establishBindingsArr(bindArr, await (await node._propNodes)[key]);
														}
													}
													parentPropNodes[await cxObj.itemIndex] = await (await node._propNodes)[key];
													await this.affectChangesArr(await (await (await (await parentForNode._items)[await cxObj.itemIndex]).propProperty)[key]);
													if (await node.getAttribute("is") == "for") {
														await this.establishBindingsArr(await (await (await (await parentForNode._items)[await cxObj.itemIndex]).propProperty)[key], await (await (await parentForNode._propNodes)[key])[await cxObj.itemIndex]);
													}
												} else if (!await (await (await cxObj.node)._propNodes)[key]) {
													if (await (await cxObj.node).getAttribute("is") == "forIn") {
														parentPropNodes = (await (await cxObj.node)._propNodes)[key] = {};
													} else {
														parentPropNodes = (await (await cxObj.node)._propNodes)[key] = [];
													}
													parentPropNodes[await cxObj.itemIndex] = await (await node._propNodes)[key];
												}
												if (!await (await cxObj.node)._childProp) {
													(await cxObj.node)._childProp = [key];
												} else if (await (await (await (await cxObj.node)._childProp).indexOf)[key] == -1) {
													await (await (await cxObj.node)._childProp).push(key);
												}
											}
											cxObj = await (await cxObj.node)._cx;
											node = parentForNode;
										}
										if (parentForNode) {
											(await comp.$data)[key] = await (await parentForNode._propNodes)[key];
											if (!await (await comp._propProperty)[key]) {
												(await comp._propProperty)[key] = [];
											}
											if (await options.type == "update" || await options.type == "default") {
												if (await options.type == "update") {
													let bind = await (await (await comp.$data)[key])._bindings;
													if (bind) {
														let bindArr = await bind.toArrayLyte();
														await $Lt._fE(bindArr, async function (bind) {
															if (await (await (await comp._propProperty)[key]).indexOf(bind) == -1) {
																await (await (await comp._propProperty)[key]).push(bind);
																await (await (await comp._propProperty)[key]).push([]);
															}
															if (await node.getAttribute("is") == "forIn") {
																await _LCSV.establishBindingsArr(bindArr, await (await parentForNode._propNodes)[key]);
															}
														});
													}
												} else {
													let compProp = await (await dirObjProp.data)[key];
													if (initialRender && compProp && await (await $Lt._gc.Object.keys(compProp)).length && await (await (await comp._propProperty)[key]).indexOf(compProp) == -1) {
														if (await $Lt._gc.Array.isArray(compProp)) {
															await $Lt._fE(compProp, async function (bind) {
																await (await (await comp._propProperty)[key]).push(bind);
															});
														} else {
															await (await (await comp._propProperty)[key]).push(compProp);
														}
													}
												}
											}
										}
									}
								},
								estBndPrevNode: async function (self, helperNode, nodeVal, gonnaSave, cxObj) {
									await this.addFlagInData(helperNode);
									let hpNode = helperNode;
									let savedNode = gonnaSave;
									let childInd = await cxObj.itemIndex;
									let beforeProp = await (await (await (await hpNode._items)[childInd]).propProperty)[nodeVal];
									if (beforeProp) {
										await $Lt._fE(beforeProp, async function (prop) {
											if (await prop._path == nodeVal && !await savedNode._establish) {
												await _LC.establishBindings({ [nodeVal]: prop }, { [nodeVal]: savedNode });
												savedNode._establish = true;
											}
										});
									}
									(await self._properties)[nodeVal] = {};
								},
								removeAll: async function (isType, self, node, index, destroyChild, updateIndex, parentNode, type) {
									if (await (/^(if|switch|for)$/).test(isType)) {
										await node._specialNodes && await (await node._specialNodes).length && await this.removeAllNode("for", self, await node._specialNodes);
									} else if (isType == "forIn") {
										await node._specialNodes && await (await $Lt._gc.Object.keys(await node._specialNodes)).length && await this.removeAllNode("forIn", self, await node._specialNodes);
									}
									if (await node._propNodes && await (await $Lt._gc.Object.keys(await node._propNodes)).length) {
										for (let propName in await node._propNodes) {
											if (index != $Lt._gc.undefined) {
												await this.removeInIndex(self, node, propName, index, await (await (await node._propNodes)[propName])[index], true, destroyChild, updateIndex, parentNode, type);
											} else {
												await _LC.iterator(isType, await (await node._propNodes)[propName], async function (index, item) {
													await _LCSV.removeInIndex(self, node, propName, index, item, true, destroyChild, updateIndex, parentNode, type);
												});
												(await node._propNodes)[propName] = {};
											}
										}
									}
								},
								addFlagInData: async function (node) {
									while (node) {
										if (await node.getAttribute("is") == "forIn") {
											await makeVal(await node._currentObject, "_propNodes", true);
										}
										node = await node._cx && await (await node._cx).node;
									}
								},
								removeInIndex: async function (comp, node, propName, index, data, destroy, destroyChild, updateIndex, updateNode, type) {
									if (await (await node._items)[index]) {
										let propPropertyArr = await (await (await (await node._items)[index]).propProperty)[propName];
										if (propPropertyArr) {
											await $Lt._fE(propPropertyArr, async function (binding) {
												await _LC.removeSelectedBindingDeep(binding, data);
											});
											(await (await (await node._items)[index]).propProperty)[propName] = [];
											(await (await (await node._items)[index]).propPropertyDyn)[propName] = [];
										}
										if (type && type == "update" && updateNode == node) {
											return;
										}
										let parentStarted;
										if (node == updateNode) {
											parentStarted = true;
										}
										let cx = await node._cx;
										while (cx) {
											if (await cx.type == "for" || await cx.type == "forIn") {
												let ind = await cx.itemIndex;
												let node = await cx.node;
												if (await (await node._items)[ind]) {
													let propPropertyArr = await (await (await (await node._items)[ind]).propProperty)[propName];
													let propPropertyDynArr = await (await (await (await node._items)[ind]).propPropertyDyn)[propName];
													if (propPropertyArr) {
														await this.affectChangesArr(propPropertyArr);
														await $Lt._fE(propPropertyArr, async function (binding, ix) {
															let removePropNodes = await (await (await node._propNodes)[propName])[ind];
															let remove;
															let arr = await (await propPropertyDynArr[ix]).split(".");
															await $Lt._fE(arr, async function (dynName) {
																if (await dynName.indexOf(updateIndex) != -1) {
																	remove = true;
																}
															});
															if (remove || !parentStarted) {
																await _LC.removeSelectedBindingDeep(binding, removePropNodes);
															}
														});
														if (destroyChild) {
															(await (await (await node._items)[ind]).propProperty)[propName] = [];
														}
													}
												}
												if (node == updateNode) {
													parentStarted = true;
												}
											}
											cx = await (await cx.node)._cx;
										}
										if (comp && await (await comp._propProperty)[propName]) {
											if (await (await (await comp._propProperty)[propName]).indexOf(propName) != -1) {
												let propNode = await this.getActualPropData(node, propName);
												if (await propNode._bindings) {
													let bindArr = await (await propNode._bindings).toArrayLyte();
													await $Lt._fE(bindArr, async function (bnd) {
														await _LC.removeSelectedBindingDeep(bnd, propNode);
													});
												}
											}
										}
									}
								},
								removeInParent: async function (comp, node, propName, index, data, destroy) {
									let cx = await node._cx;
									while (cx) {
										if (await cx.type == "for" || await cx.type == "forIn") {
											let ind = await cx.itemIndex;
											let node = await cx.node;
											let propPropertyArr = await (await (await (await node._items)[ind]).propProperty)[propName];
											if (propPropertyArr) {
												await $Lt._fE(propPropertyArr, async function (binding) {
													await _LC.removeSelectedBindingDeep(binding, await (await (await node._propNodes)[propName])[ind]);
												});
											}
										}
										cx = await (await cx.node)._cx;
									}
									if (comp && await (await comp._propProperty)[propName]) {
										if (await (await (await comp._propProperty)[propName]).indexOf(propName) != -1) {
											let propNode = await this.getActualPropData(node, propName);
											if (await propNode._bindings) {
												let bindArr = await (await propNode._bindings).toArrayLyte();
												await $Lt._fE(bindArr, async function (bnd) {
													await _LC.removeSelectedBindingDeep(bnd, propNode);
												});
											}
										}
									}
								},
								removeInChild: async function (comp, node, propName, index, data, destroy) {
									if (await node._helpers) {
										for (let i = 0; i < await (await node._helpers).length; (i = i + 1) - 1) {
											for (let j = 0; j < await (await (await node._helpers)[i]).length; (j = j + 1) - 1) {
												let currentNode = await (await (await node._helpers)[i])[j];
												await this.removeInChild(comp, currentNode, propName, i, data, destroy);
												let propPropertyArr = await (await (await (await node._items)[i]).propProperty)[propName];
												if (propPropertyArr) {
													await $Lt._fE(propPropertyArr, async function (binding) {
														await _LC.removeSelectedBindingDeep(binding, await (await (await node._propNodes)[propName])[i]);
													});
												}
											}
										}
									}
								},
								addInParent: async function (comp, node, propName) {
									let cx = await node._cx;
									if (cx) {
										let ind = await cx.itemIndex;
										let forNode = await cx.node;
										while (cx) {
											if (await cx.type == "for" || await cx.type == "forIn") {
												forNode = await cx.node;
												ind = await cx.itemIndex;
												await this.affectChangesArr(await (await (await (await forNode._items)[ind]).propProperty)[propName]);
												await this.establishBindingsArr(await (await (await (await forNode._items)[ind]).propProperty)[propName], await (await (await forNode._propNodes)[propName])[ind]);
											}
											cx = await (await cx.node)._cx;
										}
									}
								},
								addInChild: async function (comp, node, propName, i) {
									if (await node._helpers) {
										for (let i = 0; i < await (await node._helpers).length; (i = i + 1) - 1) {
											for (let j = 0; j < await (await (await node._helpers)[i]).length; (j = j + 1) - 1) {
												let currentNode = await (await (await node._helpers)[i])[j];
												await this.addInChild(comp, currentNode, propName);
												let ind = await (await currentNode._cx).itemIndex;
												await this.establishBindingsArr(await (await (await (await currentNode._items)[ind]).propProperty)[propName], await (await (await currentNode._propNodes)[propName])[ind]);
											}
										}
									}
								},
								affectChangesComp: async function (node) {
									let arr = await node._currentProp ? await node._currentProp : await node._childProp;
									if (arr) {
										await $Lt._fE(arr, async function (propName) {
											let comp = await node._callee;
											if (await (await comp._propProperty)[propName]) {
												await $Lt._fE(await (await comp._propProperty)[propName], async function (binding) {
													await _LC.affectChanges(binding);
												});
											}
										});
									}
								},
								getActualPropData: async function (node, propName) {
									let parentMostNode = node;
									let cx = await node._cx;
									while (cx) {
										parentMostNode = await cx.node;
										cx = await (await cx.node)._cx;
									}
									return await (await parentMostNode._propNodes)[propName];
								},
								forIn: {
									delete: async function (node, options) {
											if (await node._propNodes && await (await $Lt._gc.Object.keys(await node._propNodes)).length) {
												for (let propName in await node._propNodes) {
													let propArr = await (await node._propNodes)[propName];
													propArr[await options.property] = null;
													delete propArr[await options.property];
													if (await propArr._bindings) {
														let bindings = await (await propArr._bindings).toArrayLyte();
														await _LCSV.affectChangesArr(bindings);
													}
												}
											}
										},
									add: async function (node, options, keysArray, replace) {
										let self = await node._callee;
										let lastNode;
										if (await node._propNodes && await (await $Lt._gc.Object.keys(await node._propNodes)).length) {
											if (replace) {
												await $Lt._fE(keysArray, async function (itemKey, index, array) {
													await self.removeHelpersSpecificIndex(node, itemKey, $Lt._gc.undefined, await options.type);
												});
											}
											if (await (await node._forContent)[await options.property]) {
												let ind = await (await node._keysArray).indexOf(await options.property);
												if (await (await node._forContent)[await (await node._keysArray)[ind + 1]]) {
													lastNode = await (await (await node._forContent)[await (await node._keysArray)[ind + 1]])[0];
												} else {
													lastNode = node;
												}
											}
										}
										return lastNode;
									},
									update: async function (node) {
										if (await node._propNodes && await (await $Lt._gc.Object.keys(await node._propNodes)).length) {
											for (let key in await node._items) {
												for (let propName in await node._propNodes) {
													let propArr = await (await node._propNodes)[propName];
													propArr[key] = null;
													delete propArr[key];
													if (await node._cx && (await (await node._cx).type == "for" || await (await node._cx).type == "forIn")) {
														await _LCSV.addInParent(await node._callee, node, propName);
													}
													if (await propArr._bindings) {
														let bindings = await (await propArr._bindings).toArrayLyte();
														await _LCSV.affectChangesArr(bindings);
													}
												}
											}
										}
									}
								},
								for: {
									update: async function (node) {
											if (await node._propNodes && await (await $Lt._gc.Object.keys(await node._propNodes)).length) {
												for (let propName in await node._propNodes) {
													let propArr = await (await node._propNodes)[propName];
													await propArr.shift();
													if (await node._cx && (await (await node._cx).type == "for" || await (await node._cx).type == "forIn")) {
														await _LCSV.addInParent(await node._callee, node, propName);
													}
													if (await propArr._bindings) {
														let bindings = await (await propArr._bindings).toArrayLyte();
														await _LCSV.affectChangesArr(bindings);
													}
												}
											}
										},
									beforeUpdate: async function (node, spliceArr, newPropObj, newItemObj) {
										if (await node._propNodes && await (await $Lt._gc.Object.keys(await node._propNodes)).length) {
											for (let propName in await node._propNodes) {
												await $Lt._fE(newItemObj, async function (obj, index) {
													if (obj) {
														if (!await obj.propProperty) {
															obj.propProperty = {};
														}
														if (!await (await obj.propProperty)[propName]) {
															if (await node.getAttribute("is") == "forIn") {
																(await obj.propProperty)[propName] = {};
															} else {
																(await obj.propProperty)[propName] = [];
															}
														}
													}
												});
												await this.beforeUpdateSpecific(node, spliceArr, newPropObj, propName);
											}
										}
									},
									beforeUpdateSpecific: async function (node, spliceArr, newPropObj, propName, addNode) {
										let gonnaInsertPos = await spliceArr[0];
										if (await newPropObj.length) {
											if (await node.getAttribute("is") == "for") {
												if (await spliceArr[1] == 0) {
													for (let i = gonnaInsertPos; i < await (await (await node._propNodes)[propName]).length; (i = i + 1) - 1) {
														await _LCSV.removeInParent(await node._callee, node, propName, i, await (await (await node._propNodes)[propName])[i]);
													}
												} else if (await newPropObj.length != await spliceArr[1]) {
													for (let i = gonnaInsertPos; i < await (await (await node._propNodes)[propName]).length; (i = i + 1) - 1) {
														await _LCSV.removeInParent(await node._callee, node, propName, i, await (await (await node._propNodes)[propName])[i]);
													}
												}
											}
										}
										let comp = await node._callee;
										if (!addNode && comp && await (await comp._propProperty)[propName]) {
											let propNode = await _LCSV.getActualPropData(node, propName);
											if (await propNode._bindings) {
												let bindArr = await (await propNode._bindings).toArrayLyte();
												await $Lt._fE(bindArr, async function (bnd) {
													await _LC.removeSelectedBindingDeep(bnd, propNode);
												});
											}
										}
										let propArr = await (await node._propNodes)[propName];
										if (await node.getAttribute("is") == "forIn") {
											if (await newPropObj.length) {
												propArr[gonnaInsertPos] = await newPropObj[0];
											} else {
												propArr[gonnaInsertPos] = null;
												delete propArr[gonnaInsertPos];
											}
										} else {
											await (await propArr.splice).apply(propArr, await spliceArr.concat(newPropObj));
										}
									},
									afterUpdate: async function (node, spliceArr, newPropObj) {
										if (await node._propNodes && await (await $Lt._gc.Object.keys(await node._propNodes)).length) {
											for (let propName in await node._propNodes) {
												await this.afterUpdateSpecific(node, spliceArr, newPropObj, propName);
											}
										}
									},
									afterUpdateSpecific: async function (node, spliceArr, newPropObj, propName) {
										let gonnaInsertPos = await spliceArr[0];
										if (await spliceArr[1] == 0) {
											for (let i = gonnaInsertPos + await newPropObj.length; i < await (await (await node._propNodes)[propName]).length; (i = i + 1) - 1) {
												await _LCSV.addInParent(await node._callee, node, propName, i, await (await (await node._propNodes)[propName])[i]);
												await _LCSV.addInChild(await node._callee, node, propName, i, await (await (await node._propNodes)[propName])[i]);
											}
										} else if (await newPropObj.length) {
											if (await newPropObj.length != await spliceArr[1]) {
												for (let i = gonnaInsertPos + await newPropObj.length; i < await (await (await node._propNodes)[propName]).length; (i = i + 1) - 1) {
													await _LCSV.addInParent(await node._callee, node, propName, i, await (await (await node._propNodes)[propName])[i]);
													await _LCSV.addInChild(await node._callee, node, propName, i, await (await (await node._propNodes)[propName])[i]);
												}
											}
										} else {
											await _LCSV.addInParent(await node._callee, node, propName);
											await _LCSV.addInChild(await node._callee, node, propName);
										}
										let comp = await node._callee;
										if (comp && await (await comp._propProperty)[propName]) {
											let propNode = await _LCSV.getActualPropData(node, propName);
											await _LCSV.affectChangesArr(await (await comp._propProperty)[propName]);
											await _LCSV.establishBindingsArr(await (await comp._propProperty)[propName], propNode, true);
										}
									}
								},
								beforeDirObj: async function (node, dirObjData, dirObjProp) {
									if (await node._dirObj) {
										if (await (await node._dirObj).data) {
											let callee = await node._callee;
											await $Lt._fE(await (await node._dirObj).data, async function (dataPropName) {
												(await dirObjData.data)[dataPropName] = await (await (await callee.component).data)[dataPropName];
												(await (await callee.component).data)[dataPropName] = null;
												(await dirObjProp.data)[dataPropName] = await (await callee._properties)[dataPropName];
												(await callee._properties)[dataPropName] = null;
											});
										}
									}
								},
								afterDirObj: async function (node, dirObjData, dirObjProp) {
									if (await node._dirObj) {
										if (await (await node._dirObj).data) {
											let callee = await node._callee;
											await $Lt._fE(await (await node._dirObj).data, async function (dataPropName) {
												(await (await callee.component).data)[dataPropName] = await (await dirObjData.data)[dataPropName];
												(await callee._properties)[dataPropName] = await (await dirObjProp.data)[dataPropName];
											});
										}
									}
								},
								updateMulProp: async function (node, multipleProp, boundName, totalProp, prop) {
									if (await node._cx && await multipleProp.helperNode && await (await (await (await (await multipleProp.helperNode)._items)[await (await node._cx).itemIndex]).propProperty)[boundName]) {
										await (await (await (await (await (await multipleProp.helperNode)._items)[await (await node._cx).itemIndex]).propProperty)[boundName]).push(totalProp);
										await (await (await (await (await (await multipleProp.helperNode)._items)[await (await node._cx).itemIndex]).propPropertyDyn)[boundName]).push(await prop._path);
									}
								},
								lazyProp: {
									add: async function (lazyProp, node, helperNode, forIndex, boundValue, dynamicValuesArray, dynamicValues) {
											await lazyProp.push({
												node: node,
												helperNode: helperNode,
												forIndex: forIndex,
												boundValue: boundValue,
												dynamicValuesArray: dynamicValuesArray,
												dynamicValues: dynamicValues
											});
										},
									iterate: async function (self, lazyProp) {
										await $Lt._fE(lazyProp, async function (obj) {
											let node = await obj.node;
											let helperNode = await obj.helperNode;
											let boundValue = await obj.boundValue;
											let forIndex = await obj.forIndex;
											let dynamicValuesArray = await obj.dynamicValuesArray;
											let dynVals = await obj.dynamicValues;
											node._propNode = true;
											let propPropertyDyn = await (await (await helperNode._items)[forIndex]).propPropertyDyn;
											if (!await propPropertyDyn[boundValue]) {
												propPropertyDyn[boundValue] = [];
											}
											await (await propPropertyDyn[boundValue]).push(dynVals);
											let propProperty = await (await (await helperNode._items)[forIndex]).propProperty;
											if (!await propProperty[boundValue]) {
												propProperty[boundValue] = [];
											}
											let prop = await self.getProperty(boundValue);
											await (await propProperty[boundValue]).push(prop);
											let dta = await _LC.get(await (await self.component).data, boundValue);
											if (dta && await dta._establish) {
												await _LC.establishBindings({ [boundValue]: prop }, { [boundValue]: dta });
											}
											(await self._properties)[boundValue] = {};
										});
									}
								},
								afterConnect: async function (comp) {
									if (await comp._callee) {
										let propSave = await comp.hasAttribute("lyte-directive-prop");
										let dataSave = await comp.hasAttribute("lyte-directive-data");
										if ((propSave || dataSave) && !await comp.__updateProp) {
											let obj = {
													attr: {
															hookName: propSave ? "prop" : "data",
															hookNode: true,
															stringValue: propSave ? await comp.getAttribute("lyte-directive-prop") : await comp.getAttribute("lyte-directive-data")
														},
													node: comp
												};
											await this.addNodeLazy([obj], await comp._callee, $Lt._gc.undefined, comp, await comp._cx ? await (await comp._cx).node : $Lt._gc.undefined, $Lt._gc.undefined, await comp._cx);
										}
									}
								},
								setDirObj: async function (node) {
									if (await node.hasAttribute("dir-obj")) {
										node._dirObj = await $Lt._gc.JSON.parse(await node.getAttribute("dir-obj"));
									}
								},
								connect: async function (comp) {
									if (await comp.__updateProp && await comp._callee && await (await comp._callee).component) {
										if (await comp._cx) {
											await this.updateCxNodes(comp);
										} else {
											await this.setDataInParentComp(comp);
										}
									}
								},
								removeData: async function (comp) {
									if (await comp._propProperty) {
										for (let key in await comp._propProperty) {
											(await comp._propProperty)[key] = null;
										}
									}
								}
							},
						"hide": {
							appendTemp: async function () {
									await (await $Lt._gc.document.body).appendChild(await _LC.hiddenComponentsDiv);
									await (await $Lt._gc.document.body).appendChild(await _LC.hiddenYieldsDiv);
								},
							triggerGlobalEvent: async function (target, eventName, ev, hasHandled, ignore) {
								if (target && await target._hiddenBoundEvents && await (await target._hiddenBoundEvents)[eventName] && !await ev.cancelBubble && (ignore || await ev.currentTarget == await $Lt._gc.document.body)) {
									let actObj = await (await target._hiddenBoundEvents)[eventName];
									let cloneActObj = await _Lyte.deepCopyObject(actObj);
									await _LC.skipArgProcessing(cloneActObj, eventName, target);
									await (await _LC.throwAction).call(await (await target.parentElement)._callee, await (await target.parentElement)._callee, eventName, cloneActObj, $Lt._gc.undefined, $Lt._gc.undefined, target, ev, hasHandled);
								}
							},
							connect: async function (comp, content) {
								let tempParent = await comp._callee;
								if (tempParent) {
									await _LCHD.template(comp, await _LC.hiddenComponentsDiv, content);
								} else {
									await $Lt._gc.console.error(" Error:Parent node of current template is not of type TEMPLATE . Cannot hide this template");
								}
							},
							yield: {
								connect: async function (comp) {
										if (await comp._callee && await (await _LC.directive).getTransitionArg(await comp._callee, "hide-tag")) {
											await _LCHD.template(comp, await _LC.hiddenYieldsDiv);
										}
									},
								disConnect: async function (comp) {
									if (await (await $Lt._gc.Array.from(await (await (await _LC.hiddenYieldsDiv).content).childNodes)).indexOf(comp) != -1) {
										await (await (await _LC.hiddenYieldsDiv).content).removeChild(comp);
									}
									if (await comp._hiddenTemplate && await (await comp._hiddenTemplate).length) {
										await _LCHD.callDisconnectedCallback(comp);
									}
								}
							},
							rmHelpersSpecificIndex: async function (node, index) {
								if (typeof index == "number" && await (await node._hiddenTemplate)[index] && await (await node._hiddenTemplate).length) {
									for (let i in await (await node._hiddenTemplate)[index]) {
										await (await (await (await node._hiddenTemplate)[index])[i]).disconnectedCallback();
									}
									if (await node.getAttribute("is") == "for") {
										await (await node._hiddenTemplate).splice(index, 1);
									} else {
										delete (await node._hiddenTemplate)[index];
									}
								}
							},
							forRmHelpers: async function (node) {
								if (await node._hiddenTemplate && await (await node._hiddenTemplate).length) {
									for (let i = 0; i < await (await node._hiddenTemplate).length; (i = i + 1) - 1) {
										for (let j = 0; j < await (await (await node._hiddenTemplate)[i]).length; (j = j + 1) - 1) {
											await (await (await (await node._hiddenTemplate)[i])[j]).disconnectedCallback();
										}
										(await node._hiddenTemplate)[i] = [];
									}
									node._hiddenTemplate = [];
								}
							},
							ifRmHelpers: async function (node) {
								if (await node._hiddenTemplate && await (await node._hiddenTemplate).length) {
									await _LCHD.callDisconnectedCallback(node);
								}
							},
							setTxtNode: async function (comp, yld) {
								if (await (await _LC.directive).getTransitionArg(comp, "hide-tag")) {
									var emptyTextNode = await $Lt._gc.document.createTextNode("");
									await _LC.replaceWithPf(yld, emptyTextNode);
								}
							},
							shouldStop: async function (node, event) {
								let stopBubble = false;
								if (await node._hiddenBoundEvents && await (await node._hiddenBoundEvents)[await event.type] && await node._hiddenBoundFlag) {
									stopBubble = true;
									node._hiddenBoundFlag = false;
								}
								return stopBubble;
							},
							define: {
								remove: async function (classDef) {
										const $remove = await (await $Lt._gc.Element.prototype).remove;
										await $Lt._gc.Object.defineProperty(await classDef.prototype, "remove", {
											configurable: true,
											writable: true,
											value: async function () {
												if (await this._firstChild == $Lt._gc.undefined || await (await this._firstChild).parentElement == null) {
													await $remove.call(this);
													this._firstChild = $Lt._gc.undefined;
													this._lastChild = $Lt._gc.undefined;
													return;
												}
												$Lt._gc.firstNode = await this._firstChild;
												$Lt._gc.parent = await $Lt._gc.firstNode.parentElement;
												$Lt._gc.lastNode = await this._lastChild;
												while (await $Lt._gc.firstNode.nextSibling != $Lt._gc.lastNode) {
													await $Lt._gc.parent.removeChild(await $Lt._gc.firstNode.nextSibling);
												}
												this._firstChild = $Lt._gc.undefined;
												this._lastChild = $Lt._gc.undefined;
												await $Lt._gc.parent.removeChild($Lt._gc.firstNode);
												await $Lt._gc.parent.removeChild($Lt._gc.lastNode);
												return;
											}
										});
									},
								getContent: async function (customCrmComponent) {
									await $Lt._gc.Object.defineProperty(await customCrmComponent.prototype, "getContent", {
										configurable: true,
										writable: true,
										value: async function () {
											$Lt._gc.arr = [];
											if (await this._firstChild == $Lt._gc.undefined) {
												await $Lt._gc.console.error("Cannot access template through getContent");
											}
											$Lt._gc.firstNode = await this._firstChild;
											$Lt._gc.lastNode = await this._lastChild;
											$Lt._gc.firstNode = await $Lt._gc.firstNode.nextSibling;
											while ($Lt._gc.firstNode != $Lt._gc.lastNode) {
												await $Lt._gc.arr.push($Lt._gc.firstNode);
												$Lt._gc.firstNode = await $Lt._gc.firstNode.nextSibling;
											}
											return $Lt._gc.arr;
										}
									});
								}
							},
							addHiddenBoundEvents: async function (compNode, content) {
								if (!await compNode._boundEvents) {
									return;
								}
								for (let i = 0; i < await (await content.childNodes).length; (i = i + 1) - 1) {
									if (await compNode._boundEvents) {
										(await (await content.childNodes)[i])._hiddenBoundEvents = await compNode._boundEvents;
										if (await (await (await content.childNodes)[i])._boundEvents) {
											(await (await content.childNodes)[i])._hiddenBoundFlag = true;
										}
									}
								}
							},
							callDisconnectedCallback: async function (node) {
								for (let i = 0; i < await (await node._hiddenTemplate).length; (i = i + 1) - 1) {
									await (await (await node._hiddenTemplate)[i]).disconnectedCallback();
								}
								node._hiddenTemplate = [];
							},
							template: async function (compNode, hiddenDomDiv, content) {
								await _LyteComponent._setIgnoreDisconnect(true);
								compNode._ignoreDisconnect = true;
								compNode.__lyteIgnore = true;
								let parentElement = await compNode._callee;
								let parentEle = await compNode.parentElement;
								let domContent = await $Lt._gc.document.createDocumentFragment();
								let len = await (await compNode.childNodes).length;
								let firstChild = await $Lt._gc.document.createTextNode("");
								let lastChild = await $Lt._gc.document.createTextNode("");
								compNode._firstChild = firstChild;
								compNode._lastChild = lastChild;
								for (let i = 0; i < len; (i = i + 1) - 1) {
									(await (await compNode.childNodes)[0])._hiddenBoundEvents = await compNode._boundEvents;
									if (await (await (await compNode.childNodes)[0])._boundEvents) {
										(await (await compNode.childNodes)[0])._hiddenBoundFlag = true;
									}
									await domContent.append(await (await compNode.childNodes)[0]);
								}
								let elePos = await (await $Lt._gc.Array.from(await parentEle.childNodes)).indexOf(compNode);
								await parentEle.insertBefore(firstChild, await (await parentEle.childNodes)[elePos]);
								elePos = await (await $Lt._gc.Array.from(await parentEle.childNodes)).indexOf(compNode);
								if (await (await domContent.childNodes).length) {
									await parentEle.insertBefore(domContent, await (await parentEle.childNodes)[elePos]);
									elePos = await (await $Lt._gc.Array.from(await parentEle.childNodes)).indexOf(compNode);
								}
								if (content) {
									await this.addHiddenBoundEvents(compNode, content);
									await parentEle.insertBefore(content, await (await parentEle.childNodes)[elePos]);
								}
								elePos = await (await $Lt._gc.Array.from(await parentEle.childNodes)).indexOf(compNode);
								await parentEle.insertBefore(lastChild, await (await parentEle.childNodes)[elePos]);
								let parentHelper = await compNode._parentHelper;
								if (parentHelper) {
									if (await parentHelper.tagName == "LYTE-YIELD") {
										await (await parentHelper._hiddenTemplate).push(compNode);
									} else if (await parentHelper._forContent) {
										if (await compNode._cx) {
											let ind = await (await compNode._cx).itemIndex;
											if (!await (await parentHelper._hiddenTemplate)[ind]) {
												(await parentHelper._hiddenTemplate)[ind] = [];
											}
											await (await (await parentHelper._hiddenTemplate)[ind]).push(compNode);
										}
									} else if (await parentHelper._caseContent) {
										await (await parentHelper._hiddenTemplate).push(compNode);
									}
								} else if (await compNode._callee) {
									await (await (await compNode._callee)._hiddenTemplate).push(compNode);
								}
								await (await hiddenDomDiv.content).appendChild(compNode);
								compNode._ignoreDisconnect = false;
								await _LyteComponent._setIgnoreDisconnect(false);
								compNode.__lyteIgnore = false;
							}
						},
						"class": {
							addStaticValue: async function (node) {
									if (await node.hasAttribute("lyte-directive-class")) {
										let classVal = await node.getAttribute("lyte-directive-class");
										await node.setAttribute("class", classVal);
										node._initialClassValue = classVal;
									}
								},
							addValue: async function (node) {
								if (await node._transitionArgs && await (await node._transitionArgs).class) {
									await node.setAttribute("class", await (await node._transitionArgs).class);
									node._initialClassValue = await (await node._transitionArgs).class;
								}
							},
							updateValue: async function (node) {
								if (await node._transitionArgs && await (await node._transitionArgs).class) {
									let currentClassVal = await node.getAttribute("class");
									let oldClassVal = await node._initialClassValue;
									let externalClassVal = await currentClassVal.substr(await oldClassVal.length);
									let newClassValue = await (await node._transitionArgs).class;
									let finalclassVal = newClassValue + externalClassVal;
									await node.setAttribute("class", finalclassVal);
									node._initialClassValue = newClassValue;
								}
							}
						},
						registeredProp: {},
						compileNode: async function (node, attr, toBeRemoved, toBeAdded, i, componentName) {
							node._special = true;
							let attrToPush = {};
							attrToPush.name = await (await (await node.attributes)[i]).name;
							if (await attr[await attrToPush.name] && await (await attr[await attrToPush.name]).dynamicValue) {
								attrToPush.dynamicValue = await (await attr[await attrToPush.name]).dynamicValue;
							} else if (await attr[await attrToPush.name] && await (await attr[await attrToPush.name]).helperInfo) {
								attrToPush.helperInfo = await (await attr[await attrToPush.name]).helperInfo;
							} else {
								attrToPush.stringValue = await (await (await node.attributes)[i]).nodeValue;
								let ndName = await (await (await node.attributes)[i]).nodeName;
								await toBeRemoved.push(ndName);
								await toBeAdded.push({
									name: "lyte-directive-" + await ndName.slice(1, await ndName.length),
									value: await attrToPush.stringValue
								});
								if (await (await (await this.registeredProp)[componentName]).indexOf(await attrToPush.stringValue) == -1) {
									await (await (await this.registeredProp)[componentName]).push(await attrToPush.stringValue);
								}
							}
							attr[await attrToPush.name] = attrToPush;
							attrToPush.hookNode = true;
							let hookName = await (await (await (await node.attributes)[i]).name).slice(1, await (await (await (await node.attributes)[i]).name).length);
							attrToPush.hookName = hookName;
							return {
								add: true,
								specialAttr: true,
								attrToPush: attrToPush
							};
						},
						isDirectiveNode: async function (node) {
							if (await node.hookNode || await node.nodeName && await (await node.nodeName).startsWith("@") || await node._isDirectiveNode) {
								return true;
							}
							return false;
						},
						getActualTransitionArg: async function (attr, node) {
							if (await attr.hasOwnProperty("dynamicValue") || await attr.hasOwnProperty("helperInfo")) {
								if (await node.hasOwnProperty("_transitionArgs")) {
									if (await (await node._transitionArgs).hasOwnProperty(await attr.hookName)) {
										return await (await node._transitionArgs)[await attr.hookName];
									}
								}
							} else if (await attr.hasOwnProperty("stringValue")) {
								if (await attr.hasOwnProperty("stringValue")) {
									if (await attr.stringValue === "") {
										return true;
									}
									if (await attr.stringValue === "true") {
										return true;
									} else if (await attr.stringValue === "false") {
										return false;
									} else {
										return await attr.stringValue;
									}
								}
							}
						},
						getExactTransitionArg: async function (attr, node) {
							if (await attr.hasOwnProperty("dynamicValue") || await attr.hasOwnProperty("helperInfo")) {
								if (await node.hasOwnProperty("_transitionArgs")) {
									if (await (await node._transitionArgs).hasOwnProperty(await attr.hookName)) {
										return await (await node._transitionArgs)[await attr.hookName];
									}
								}
							} else if (await attr.hasOwnProperty("stringValue")) {
								if (await attr.hasOwnProperty("stringValue")) {
									if (await attr.stringValue === "") {
										if (await node.id) {
											attr.stringValue = await node.id;
										}
									}
									return await attr.stringValue;
								}
							}
						},
						getTransitionArg: async function (node, directiveName, returnAttr) {
							let transitionArg;
							if (await node.component && await (await (await node.component).constructor)._options) {
								await this.setAttrFromRender(node);
							}
							var self = this;
							if (await node._specialAttributeDetails) {
								await $Lt._fE(await node._specialAttributeDetails, async function (attr) {
									if (directiveName == await attr.hookName) {
										transitionArg = returnAttr ? attr : await self.getActualTransitionArg(attr, node);
										return;
									}
								});
							}
							return transitionArg;
						},
						setNodeArgs: async function (node, nodeValue, comp) {
							let nodeName = await node.nodeName;
							await (await node.ownerElement).removeAttribute(nodeName);
							if (!await (await node.ownerElement)._transitionArgs) {
								(await node.ownerElement)._transitionArgs = {};
							}
							let actNodeName = nodeName;
							if (await nodeName.startsWith("@")) {
								actNodeName = await nodeName.slice(1, await nodeName.length);
							}
							(await (await node.ownerElement)._transitionArgs)[actNodeName] = nodeValue;
							await (await node.ownerElement).setAttribute("lyte-directive-" + actNodeName, actNodeName == "prop" || actNodeName == "data" ? nodeValue : "");
						},
						infoA: async function (comp, info, dynamicN, helperNode, attr, yieldComp, options) {
							await this.setSpecialNodes(comp, helperNode, dynamicN, info, options);
							if (await dynamicN._specialAttributeDetails && await (await dynamicN._specialAttributeDetails).length) {
								await (await dynamicN._specialAttributeDetails).push(attr);
							} else {
								dynamicN._specialAttributeDetails = [attr];
							}
						},
						setSpecialNodes: async function (comp, helperNode, dynamicN, info, options) {
							if (helperNode && (await helperNode._hooksPresent || await helperNode._defaultSetSpecialNode || await dynamicN.hasAttribute("lyte-directive-prop") || await dynamicN.hasAttribute("lyte-directive-data"))) {
								if (await helperNode._specialNodes) {
									if (await helperNode.getAttribute("is") == "for") {
										await (await (await helperNode._specialNodes)[await options.itemIndex]).push(dynamicN);
									} else if (await helperNode.getAttribute("is") == "forIn") {
										await (await (await helperNode._specialNodes)[await options.itemIndex]).push(dynamicN);
									} else if (helperNode && await (/if|switch/g).test(await helperNode.getAttribute("is"))) {
										await (await helperNode._specialNodes).push(dynamicN);
									} else if (helperNode && await helperNode.tagName == "LYTE-YIELD") {
										await (await helperNode._specialNodes).push(dynamicN);
									}
								}
							} else if (dynamicN && await dynamicN._hooksPresent && await comp._specialNodes) {
								await (await comp._specialNodes).push(dynamicN);
								comp._hooksPresent = true;
								comp.hc = true;
							} else if (dynamicN && await dynamicN._defaultSetSpecialNode && await comp._specialNodes) {
								await (await comp._specialNodes).push(dynamicN);
								comp._defaultSetSpecialNode = true;
							}
						}
					},
					"iterator": async function (isType, data, def) {
						if (isType == "for") {
							await $Lt._fE(data, async function (item, index) {
								await def.apply(this, [
									item,
									index
								]);
							});
						} else if (isType == "forIn") {
							for (let index in data) {
								let item = await data[index];
								await def.apply(this, [
									item,
									index
								]);
							}
						}
					},
					"array": {
						initalize: async function (data, key) {
								if (!await data[key]) {
									data[key] = [];
								}
							},
						checkAndPush: async function (arr, val) {
							if (await arr.indexOf(val) == -1) {
								await arr.push(val);
							}
						}
					},
					"object": { initalize: async function (data, key) {
							if (!await data[key]) {
								data[key] = {};
							}
						} },
					"styleSheet": { "preload": async function (href) {
							var link = await $Lt._gc.document.createElement("link");
							link.rel = "preload";
							link.href = href;
							link.as = "style";
							let _res, _rej;
							var promise = await $Lt._cO($Lt._gc.Promise, async function (res, rej) {
									_res = res;
									_rej = rej;
								});
							link.onload = async function () {
								await _res();
							};
							link.onerror = async function () {
								await _rej();
							};
							await (await (await _Lyte.$).assetsDiv).appendChild(link);
							return promise;
						} }
				};
			let _LCSV = await (await LyteComponent.directive).save;
			let _LCHD = await (await LyteComponent.directive).hide;
			(await _Lyte.Component).appendChild = async function () {
				return await (await (await LyteComponent.shadow).appendChild).apply(await LyteComponent.shadow, await $Lt._gc.Array.from(arguments));
			};
			LyteComponent.appendChild = await (await _Lyte.Component).appendChild;
			LyteComponent.globalEventHandler = globalEventHandler;
			LyteComponent.docCaptureGlobalEventHandler = docCaptureGlobalEventHandler;
			LyteComponent.docBubbleGlobalEventHandler = docBubbleGlobalEventHandler;
			LyteComponent.globalDOMEvents = globalDOMEvents;
			LyteComponent.changeEventHandler = changeEventHandler;
			if (await window.isLyteWidget) {
				window.Component = await LyteComponent.baseCompClass;
				(await window.Component).registerHelper = async function () {
					return await (await _LC.registerHelper).apply(_LC, arguments);
				};
			}
			_Lyte.typeCast = await LyteComponent.typeCast;
			_Lyte.getDataType = await LyteComponent.getDataType;
			(await _Lyte.Component)._get = await LyteComponent.get;
			_LyteComponent.chromeBugFix = async function () {
				var version = await userAgent.match((/Chrom(e|ium)\/([0-9]+)\./));
				;
				version = version ? await $Lt._gcFn.parseInt(await version[2], 10) : 0;
				if (version > 62) {
					this.chI = [];
					await $Lt._gc.document.addEventListener("focus", async function (event) {
						var target = await event.target;
						if (await target.tagName === "INPUT" || await target.tagName === "TEXTAREA" || await target.tagName === "DIV") {
							if (await (await (await Lyte.Component).chI).indexOf(target) == -1) {
								await (await (await Lyte.Component).chI).push(target);
							}
						}
					}, true);
					this.chromeBugFix = async function () {
						var tags = await (await Lyte.Component).chI;
						var tagsL = await tags.length;
						var toRemove = [
								"_callee",
								"_attributeDetails",
								"_attributes",
								"_removedAttributes",
								"_yields",
								"_rA",
								"_cx"
							];
						var toBeRemoved = [];
						var keepAliveInputs = [];
						await $Lt._fE(await $Lt._gc.document.querySelectorAll("[lyte-keep-alive]"), async function (item, index) {
							for (var key in await item._renderedComponent) {
								await (await keepAliveInputs.push).apply(keepAliveInputs, await $Lt._gc.Array.from(await (await (await item._renderedComponent)[key]).querySelectorAll("input")));
							}
						});
						await $Lt._fE(await (await (await _LC.tDiv).content).querySelectorAll("[lyte-keep-alive]"), async function (item, index) {
							for (var key in await item._renderedComponent) {
								await (await keepAliveInputs.push).apply(keepAliveInputs, await $Lt._gc.Array.from(await (await (await item._renderedComponent)[key]).querySelectorAll("input")));
							}
						});
						for (var i = tagsL - 1, item; item = await tags[i]; (i = i - 1) + 1) {
							if (await $Lt._gc.document.compareDocumentPosition(item) % 2 && await keepAliveInputs.indexOf(item) == -1) {
								await tags.splice(i, 1);
								await item.remove();
								await toBeRemoved.push(item);
								item._rA = await item._rA || [];
								await $Lt._fE(await item._rA, async function (remAttr) {
									remAttr.ownerElement = $Lt._gc.undefined;
								});
								await $Lt._fE(toRemove, async function (key) {
									item[key] = $Lt._gc.undefined;
								});
								await $Lt._fE(await $Lt._gc.Array.from(await item.attributes), async function (itemVal) {
									await item.removeAttribute(await itemVal.nodeName);
								});
							}
						}
					};
					await Lyte.addEventListener("afterRouteTransition", async function () {
						await (await Lyte.Component).chromeBugFix();
					});
					await Lyte.addEventListener("beforeRouteTransition", async function () {
						await (await (await Lyte.Component).viewPortSettings).resetLazy();
					});
					if (!await Lyte.Router) {
						await $Lt._gcFn.setInterval(async function () {
							(await LyteComponent.String).cache_c = {};
							(await LyteComponent.String).cache_d = {};
						}, 300000);
					}
				}
			};
			LyteComponent.__data = [];
			LyteComponent.__dataNames = [];
			_LyteComponent.defineData = async function (def) {
				await (await _LC.__data).push(def);
				let dataNames = await $Lt._gc.Object.keys(def);
				await $Lt._fE(dataNames, async function (name) {
					await (await _LC.__dataNames).push(name);
				});
			};
			_Lyte.__lc = LyteComponent;
			let _LC = LyteComponent;
			await (await _LCHD.define).remove(LyteYield);
			await ltCf.instanciateBridge();
			var someFlag = false;
			await $Lt._gc.customElements.define("lyte-safari-test-component", Test, $Lt._gc.undefined, await _Lyte.isWidgetBuild ? { "widget": true } : { v3: true });
			var divTest = await $Lt._gc.document.createElement("div");
			divTest.innerHTML = "<lyte-safari-test-component t></lyte-safari-test-component>";
			_LyteComponent.render = await _LC.render;
			_LyteComponent.insertBefore = await _LC.insertBefore;
			_LyteComponent.insertAfter = await _LC.insertAfter;
			_LyteComponent.replaceWith = await _LC.replaceWith;
			_LyteComponent.appendChild = await _LC.appendChild;
			_LC.tDiv = await createElement("template");
			await (await _LC.tDiv).setAttribute("id", "dummy-templates-div");
			_LC.hDiv = await createElement("template");
			await (await _LC.hDiv).setAttribute("id", "keep-alive-div");
			_LC.h1Div = await createElement("template");
			await (await _LC.h1Div).setAttribute("id", "lyte-helper-div");
			(await Lyte.Compile).componentsDiv = _LC.lyteComponentsDiv = await createElement("div");
			await (await _LC.lyteComponentsDiv).setAttribute("id", "lyte-components-div");
			_LC.hiddenComponentsDiv = await createElement("template");
			await (await _LC.hiddenComponentsDiv).setAttribute("id", "hidden-component-div");
			_LC.hiddenYieldsDiv = await createElement("template");
			await (await _LC.hiddenYieldsDiv).setAttribute("id", "hidden-yields-div");
			(await $Lt._gc.Set.prototype).toArrayLyte = async function () {
				if (await (await this.constructor).name === "Set") {
					return await $Lt._gc.Array.from(this);
				} else {
					return await $Lt._gc.Array.from(await this._values);
				}
			};
			if (await $Lt._gc.document.readyState === "complete" || await $Lt._gc.document.readyState === "interactive") {
				await onDomContentForLyte();
			} else {
				await $Lt._gc.document.addEventListener("DOMContentLoaded", async function (e) {
					await onDomContentForLyte();
				}, true);
			}
			_LC.doCompile = doCompile;
			await _LC[registerHelperStr]("unbound", async function (value) {
				return value;
			});
			await _LC[registerHelperStr]("action", async function (parentNode, attrName, isCustom, actObj) {
				if (isCustom) {
					parentNode._actions = await parentNode._actions ? await parentNode._actions : {};
					if (!await (await parentNode._actions)[attrName]) {
						await this.createCustomEvent(attrName, parentNode, actObj);
						await parentNode.removeAttribute(attrName);
					}
				} else {
					await this.createEventListeners(parentNode, attrName, actObj);
				}
			});
			await _LC[registerHelperStr]("lbind", async function (name) {
				return await this.getData(name);
			});
			await _LC[registerHelperStr]("method", async function (parentComponent, attributeNode, functionName) {
				var parentComponent = await arguments[0];
				var attributeNode = await arguments[1];
				var functionName = await arguments[2];
				var self = await (await arguments[0]).component;
				var childComponent = attributeNode ? await attributeNode.ownerElement : null;
				var attributeName = await (await arguments[1]).nodeName;
				attributeNode = null;
				var args = await (await (await $Lt._gc.Array.prototype).slice).call(arguments, 2);
				var newFunc = async function () {
						let node = await this.$node;
						let contextSwitchArray = [];
						await _LC.adCx(node, contextSwitchArray);
						let processedArgs = await (await (await this.$node)._callee).processArgs(await (await this.$node)._callee, { "helperInfo": { "args": args } }, [], $Lt._gc.undefined, await this.$node);
						let functionName1 = await (await processedArgs.splice(0, 1))[0];
						await _LC.rmCx(node, contextSwitchArray);
						let customArgs = await $Lt._gc.Array.from(arguments);
						let mainArgs = await processedArgs.concat(customArgs);
						if (await (await (await self.$node)._methods)[functionName1]) {
							return await (await (await (await self.$node)._methods)[functionName1]).apply(self, mainArgs);
						}
						await _Lyte.error("LC009", functionName, await (await self.$node).tagName);
					};
				if (childComponent) {
					if (!await childComponent.set) {
						await childComponent.setMethods(await (await _LC.String).toCamelCase(attributeName), newFunc);
					} else {
						(await childComponent._methods)[await (await _LC.String).toCamelCase(attributeName)] = newFunc;
					}
				} else {
					return newFunc;
				}
			});
			await _LC[registerHelperStr]("stringifyHTML", async function () {
				return await (await (await (await (await Lyte.Component).registeredHelpers).unescape).apply(this, arguments)).innerHTML;
			});
			await _LC[registerHelperStr]("unescapeAttr", async function () {
				return await (await (await (await (await Lyte.Component).registeredHelpers).unescape).apply(this, arguments)).innerHTML;
			});
			await _LC[registerHelperStr]("unescape", async function (value, additionalObject, userInstance, options) {
				if (await _LC.ffr) {
					return value;
				}
				if (await window.isLyteWidget) {
					(await Lyte.Security).ignoreSanitizer = true;
				}
				if (await (await Lyte.Security).ignoreSanitizer && !(options && await options.force)) {
					let divEle = await $Lt._gc.document.createElement("div");
					divEle.innerHTML = value;
					return divEle;
				} else {
					if (additionalObject && await $Lt._gc.Object.keys(additionalObject) && await (await $Lt._gc.Object.keys(additionalObject)).length > 0) {
						if (await (await $Lt._gcFn.Object(await additionalObject.GLOBAL_TAGS)).length > 0) {
							var index = await (await additionalObject.GLOBAL_TAGS).indexOf("link-to");
							if (index != -1) {
								await (await additionalObject.GLOBAL_TAGS).splice(index, 1);
							}
						}
						if (additionalObject && await additionalObject.GLOBAL_ATTRIBUTES && await (await $Lt._gc.Object.keys(await additionalObject.GLOBAL_ATTRIBUTES)).length > 0) {
							var arr = [
									"is",
									"yield-name",
									"lt-prop-route",
									"lt-prop-dp",
									"lt-prop-fragment",
									"lt-prop-qp",
									"lt-prop",
									"lt-prop-class",
									"lt-prop-id",
									"lt-prop-rel",
									"lt-prop-title",
									"lt-prop-style",
									"lt-prop-target",
									"lt-prop-td",
									"lt-prop-custom",
									"lt-prop-target",
									"lt-prop-id",
									"lt-prop-class",
									"lt-prop-style",
									"lt-prop-rel",
									"lt-prop-title"
								];
							for (var i = 0; i < await arr.length; (i = i + 1) - 1) {
								var index = await (await additionalObject.GLOBAL_ATTRIBUTES).indexOf(await arr[i]);
								if (index != -1) {
									await (await additionalObject.GLOBAL_ATTRIBUTES).splice(index, 1);
								}
							}
						}
					}
					if (additionalObject && await additionalObject.GLOBAL_TAGS) {
						if (await additionalObject.GLOBAL_ATTRIBUTES == $Lt._gc.undefined) {
							additionalObject.GLOBAL_ATTRIBUTES = [];
						}
						var globalTagArr = await $Lt._gc.Array.from(await additionalObject.GLOBAL_TAGS);
						var attr = [];
						for (var a = 0; a < await globalTagArr.length; (a = a + 1) - 1) {
							if (await (await LyteComponent._registeredComponents)[await globalTagArr[a]]) {
								attr = await (await (await LyteComponent._registeredComponents)[await globalTagArr[a]]).observedAttributes;
							} else if (await (await Lyte.registeredCustomComponent)[await globalTagArr[a]]) {
								if (await (await (await Lyte.registeredCustomComponent)[await globalTagArr[a]]).observedAttributes) {
									attr = await (await (await Lyte.registeredCustomComponent)[await globalTagArr[a]]).observedAttributes;
								} else {
									attr = [];
								}
							}
							for (var i = 0; i < await attr.length; (i = i + 1) - 1) {
								if (await (await additionalObject.GLOBAL_ATTRIBUTES).indexOf(await attr[i]) == -1) {
									await (await additionalObject.GLOBAL_ATTRIBUTES).push(await attr[i]);
								}
							}
						}
					}
					var divEle = await $Lt._gc.document.createElement("div");
					if (userInstance && await (await $Lt._gc.Object.keys(userInstance)).length) {
						if (additionalObject && await (await $Lt._gc.Object.keys(additionalObject)).length) {
							await (await Lyte.Security).addGlobalObject(userInstance, additionalObject);
							var clean = await userInstance.sanitize(value);
							await (await Lyte.Security).removeGlobalObject(userInstance, additionalObject);
						} else {
							var clean = await userInstance.sanitize(value);
						}
					} else {
						if (additionalObject && await (await $Lt._gc.Object.keys(additionalObject)).length) {
							await (await Lyte.Security).addGlobalObject(await (await Lyte.Security)._ourSanitizerInstance_, additionalObject);
							var clean = await (await (await Lyte.Security)._ourSanitizerInstance_).sanitize(value);
							await (await Lyte.Security).removeGlobalObject(await (await Lyte.Security)._ourSanitizerInstance_, additionalObject);
						} else {
							var clean;
							if (await window.isLyteWidget) {
								clean = value;
							} else {
								clean = await (await (await Lyte.Security)._ourSanitizerInstance_).sanitize(value);
							}
						}
					}
					divEle.innerHTML = clean;
					return divEle;
				}
			});
			if (!await window.isLyteWidget) {
				await _LC[registerHelperStr]("escape", async function (value, type) {
					if (type == "url") {
						return await (await (await $Lt._gc.ZWAF["7_0_0"]).Encoder).encodeForHTMLAttribute(value);
					} else if (type == "js") {
						return await (await (await $Lt._gc.ZWAF["7_0_0"]).Encoder).encodeForJavaScript(value);
					} else if (type == "css") {
						return await (await (await $Lt._gc.ZWAF["7_0_0"]).Encoder).encodeForCSS(value);
					} else {
						return value;
					}
				});
			}
			await _LC[registerHelperStr]("debugger", async function () {
				debugger;
			});
			await _LC[registerHelperStr]("log", async function () {
				await (await $Lt._gc.console.log).apply(window, await $Lt._gc.Array.from(arguments));
			});
			await _LC[registerHelperStr]("ifEquals", async function (arg1, arg2) {
				if (arg1 === arg2) {
					return true;
				} else {
					return false;
				}
			});
			await _LC[registerHelperStr]("if", async function (value, trueValue, falseValue) {
				if (value) {
					return trueValue;
				} else {
					return falseValue;
				}
			});
			await _LC[registerHelperStr]("negate", async function (arg1) {
				return !arg1;
			});
			await _LC[registerHelperStr]("ifNotEquals", async function (arg1, arg2) {
				if (arg1 === arg2) {
					return false;
				} else {
					return true;
				}
			});
			await _LC[registerHelperStr]("concat", async function () {
				var resp = "";
				var argLength = await arguments.length;
				for (var i = 0; i < argLength; (i = i + 1) - 1) {
					if (await arguments[i] != $Lt._gc.undefined) {
						resp += await arguments[i];
					}
				}
				return resp;
			});
			await _LC[registerHelperStr]("toString", async function (obj) {
				if (obj === null || obj === $Lt._gc.undefined) {
					return "";
				} else if (typeof obj == "object") {
					return await $Lt._gc.JSON.stringify(obj);
				}
				return obj;
			});
			await $Lt._gcFn.defProp(await $Lt._gc.HTMLElement.prototype, "setData", {
				writable: true,
				configurable: true,
				enumerable: false,
				value: async function (arg0, arg1) {
					this._initProperties = await this._initProperties || {};
					if (typeof arg0 === "string") {
						if (await window.isLyteWidget && await this.tagName != "TEMPLATE") {
							await $Lt._gc.DataBindingLayer.updateInitProperties(this, arg0, arg1);
						}
						(await this._initProperties)[arg0] = arg1;
					} else if (typeof arg0 === "object") {
						for (let key in arg0) {
							if (await window.isLyteWidget && await this.tagName != "TEMPLATE") {
								await $Lt._gc.DataBindingLayer.updateInitProperties(this, key, await arg0[key]);
							}
							(await this._initProperties)[key] = await arg0[key];
						}
					}
				}
			});
			await $Lt._gcFn.defProp(await $Lt._gc.HTMLElement.prototype, "setMethods", {
				configurable: true,
				writable: true,
				enumerable: false,
				value: async function (arg0, arg1) {
					this._initMethods = await this._initMethods || {};
					if (typeof arg0 === "string") {
						(await this._initMethods)[arg0] = arg1;
					} else if (typeof arg0 === "object") {
						for (let key in arg0) {
							(await this._initMethods)[key] = await arg0[key];
						}
					}
				}
			});
			if (!await window.isLyteWidget) {
				await _LC[registerHelperStr]("encAttr", async function (val) {
					return await (await (await $Lt._gc.ZWAF["7_0_0"]).Encoder).encodeForHTMLAttribute(await $Lt._gcFn.encodeURIComponent(val));
				});
			}
			await _LC[registerHelperStr]("expHandlers", async function (leftOperand, operator, rightOperand, nextOperand) {
				var argLen = await arguments.length;
				if (operator == "++") {
					if (rightOperand == "postfix") {
						return (leftOperand = leftOperand + 1) - 1;
					} else if (rightOperand == "prefix") {
						return leftOperand = leftOperand + 1;
					}
				} else if (operator == "--") {
					if (rightOperand == "postfix") {
						return (leftOperand = leftOperand - 1) + 1;
					} else if (rightOperand == "prefix") {
						return leftOperand = leftOperand - 1;
					}
				} else if (operator == "==") {
					return leftOperand == rightOperand;
				} else if (operator == "===") {
					return leftOperand === rightOperand;
				} else if (operator == "!=") {
					return leftOperand != rightOperand;
				} else if (operator == "!==") {
					return leftOperand !== rightOperand;
				} else if (operator == "&&") {
					return leftOperand && rightOperand;
				} else if (operator == "||") {
					return leftOperand || rightOperand;
				} else if (operator == "+") {
					if (argLen > 2) {
						return leftOperand + rightOperand;
					}
					return leftOperand;
				} else if (operator == "-") {
					if (argLen > 2) {
						return leftOperand - rightOperand;
					}
					return -leftOperand;
				} else if (operator == "*") {
					return leftOperand * rightOperand;
				} else if (operator == "/") {
					return leftOperand / rightOperand;
				} else if (operator == "%") {
					return leftOperand % rightOperand;
				} else if (operator == "<") {
					return leftOperand < rightOperand;
				} else if (operator == ">") {
					return leftOperand > rightOperand;
				} else if (operator == "<=") {
					return leftOperand <= rightOperand;
				} else if (operator == ">=") {
					return leftOperand >= rightOperand;
				} else if (operator == "|") {
					return leftOperand | rightOperand;
				} else if (operator == "&") {
					return leftOperand & rightOperand;
				} else if (operator == "!") {
					return !leftOperand;
				} else if (operator == "=") {
					leftOperand = rightOperand;
					return leftOperand;
				} else if (operator == "+=") {
					return leftOperand += rightOperand;
				} else if (operator == "-=") {
					return leftOperand -= rightOperand;
				} else if (operator == "*=") {
					return leftOperand *= rightOperand;
				} else if (operator == "/=") {
					return leftOperand /= rightOperand;
				} else if (operator == "?:") {
					return leftOperand ? rightOperand : nextOperand;
				}
			});
			await _LyteComponent.register("lyte-event-listener", {
				_template: "<template tag-name=\"lyte-event-listener\"></template>",
				_dynamicNodes: [],
				_observedAttributes: ["eventName"],
				init: async function () {
					let self = this;
					let regId = await _Lyte.addEventListener(await this.get("eventName"), async function () {
							let args = await (await (await $Lt._gc.Array.prototype).slice).call(arguments);
							await args.splice(0, 0, "on-fire");
							await (await self.throwEvent).apply(self, args);
						});
					this.regId = regId;
				},
				data: async function () {
					return { "eventName": await _Lyte.attr("string") };
				},
				didDestroy: async function () {
					await _Lyte.removeEventListener(await this.regId);
				}
			});
			await _LyteComponent.registerCustomPropHandler("ltProp");
			_LyteComponent.shouldIgnoreDisconnect = async function () {
				return await _LC.ignoreDisconnect || await ltCf.ignoreDisconnect;
			};
			_LyteComponent._setIgnoreDisconnect = async function (val) {
				_LC.ignoreDisconnect = ltCf.ignoreDisconnect = val;
			};
			_LyteComponent.addLyteEventListener = async function (element, eventName, func, context) {
				element._lyteEvents = await element._lyteEvents || {};
				(await element._lyteEvents)[eventName] = await (await element._lyteEvents)[eventName] || [];
				var ind = await (await (await element._lyteEvents)[eventName]).push({
						"func": func,
						"fromEventListener": true,
						"context": context
					});
				return eventName + "-" + ind;
			};
			_LyteComponent.removeLyteEventListener = async function (element, listenerId) {
				if (!listenerId) {
					await _Lyte.error("No listenerId provided");
					return;
				}
				var split = await listenerId.split("-");
				var eventName = await split[0];
				var index = await $Lt._gcFn.parseInt(await split[1]);
				if (!await element._lyteEvents || !await (await element._lyteEvents)[await split[0]] || await $Lt._gcFn.isNaN(index)) {
					await _Lyte.error("Invalid listenerId / listener is not available");
					return;
				}
				(await (await element._lyteEvents)[await split[0]])[await split[1] - 1] = {};
			};
			_LyteComponent.throwEvent = await _LC.throwEvent;
			_LC.hasLyteEvents = async function (element, eventName) {
				if (await element._lyteEvents && await (await element._lyteEvents)[eventName]) {
					return true;
				} else {
					return false;
				}
			};
			_LC.handleLyteEvents = async function (element, event) {
				var funcs = await (await element._lyteEvents)[await event.type];
				var ret;
				var eventStopped;
				for (var i = 0; i < await funcs.length; (i = i + 1) - 1) {
					if (await (await funcs[i]).func) {
						ret = await (await (await funcs[i]).func).call(await (await funcs[i]).context ? await (await funcs[i]).context : window, event);
						if (ret === false || await event.cancelBubble) {
							eventStopped = true;
							break;
						}
					}
				}
				if (eventStopped) {
					await event.stopPropagation();
				}
				return eventStopped;
			};
			if (!await window.LyteComponent) {
				await $Lt._gc.Object.defineProperty(window, "LyteComponent", { get: async function () {
						await _Lyte.warn("Usage of LyteComponent is deprecated. Use Lyte.Component instead");
						return LyteComponent;
					} });
			}
			await _LyteComponent.chromeBugFix();
			_LC.booleanAttrList = [
				"async",
				"autocomplete",
				"autofocus",
				"autoplay",
				"border",
				"challenge",
				"checked1",
				"compact",
				"contenteditable",
				"controls",
				"default",
				"defer",
				"disabled",
				"formNoValidate",
				"frameborder",
				"hidden",
				"indeterminate",
				"ismap",
				"loop",
				"multiple",
				"muted",
				"nohref",
				"noresize",
				"noshade",
				"novalidate",
				"nowrap",
				"open",
				"readonly",
				"required",
				"reversed",
				"scoped",
				"scrolling",
				"seamless",
				"selected",
				"sortable",
				"spellcheck",
				"translate"
			];
			(await (await Lyte.$).requiredMixins).component = async function (mix, compDetails) {
				var mixinsToBeUsed = [];
				var actionsFromMixin = {};
				var methodsFromMixin = {};
				var newDefinition = {};
				await mixinsToBeUsed.push(mix);
				await $Lt._fE(compDetails, async ele => {
					var componentName = ele;
					var customCrmComponent = await (await LyteComponent._registeredComponents)[componentName];
					if (await mixinsToBeUsed.length) {
						await LyteComponent.dataFromMixin(mixinsToBeUsed, actionsFromMixin, methodsFromMixin, newDefinition);
					}
					customCrmComponent._actions = await $Lt._gc.Object.assign(await customCrmComponent._actions, actionsFromMixin);
					(await customCrmComponent.component)._actions = await $Lt._gc.Object.assign(await customCrmComponent._actions, actionsFromMixin);
					var methods = await $Lt._gc.Object.assign(await customCrmComponent._methods, methodsFromMixin);
					delete newDefinition.methods;
					await LyteComponent.updateCustomCrmComponent(newDefinition, customCrmComponent);
					customCrmComponent._methods = methods;
					(await customCrmComponent.component)._methods = methods;
					(await LyteComponent._registeredComponents)[componentName] = customCrmComponent;
				});
			};
			(await (await Lyte.$).injectServices).component = async function (key, name, type, ins, compClass, data) {
				if (compClass) {
					var obj = {};
					obj[await compClass.compName] = compClass;
				}
				var registeredComponents = compClass ? obj : await _LC._registeredComponents;
				if (registeredComponents) {
					var arr = await $Lt._gc.Object.keys(registeredComponents);
					await $Lt._fE(arr, async function (comp) {
						var component = await registeredComponents[comp];
						if (ins && await (await Lyte.__gS)[key]) {
							(await (await component.component).prototype)[key] = ins;
						} else {
							await (await Lyte.$).requiredServices(key, name, async function (serviceData, serviceKey) {
								(await (await component.component).prototype)[serviceKey] = serviceData;
							}, $Lt._gc.undefined, $Lt._gc.undefined, true, data);
						}
					});
				}
			};
			(await Lyte.Security).addGlobalObject = async function (instanceObj, additionalObj) {
				for (var property in additionalObj) {
					if (await $Lt._gc.Array.isArray(await additionalObj[property])) {
						await $Lt._fE(await additionalObj[property], async function (item) {
							if (await (await instanceObj["_" + property]).indexOf(item) == -1) {
								await (await instanceObj["_" + property]).push(item);
							}
						});
					}
				}
			};
			(await Lyte.Security).removeGlobalObject = async function (instanceObj, additionalObj) {
				for (var property in additionalObj) {
					if (await $Lt._gc.Array.isArray(await additionalObj[property])) {
						await $Lt._fE(await additionalObj[property], async function (item) {
							var index = await (await instanceObj["_" + property]).indexOf(item);
							if (index != -1) {
								await (await instanceObj["_" + property]).splice(index, 1);
							}
						});
					}
				}
				;
			};
			(await Lyte.Compile).getTrimmedContent = async function (content, position, node) {
				let dummyContent = content;
				if (node) {
					position = [];
					let parentNode = await node.parentNode;
					while (true) {
						await position.unshift(await this.getArrayIndex(await parentNode.childNodes, node));
						parentNode = await parentNode.parentNode;
						node = await node.parentNode;
						if (!parentNode) {
							break;
						}
					}
				}
				for (let i = 0; i < await position.length; (i = i + 1) - 1) {
					for (let j = await (await content.childNodes).length - 1; j > await position[i]; (j = j - 1) + 1) {
						await (await (await content.childNodes)[j]).remove();
					}
					content = await (await content.childNodes)[await position[i]];
				}
				return dummyContent;
			};
			(await Lyte.Compile).getArrayIndex = async function (array, value) {
				for (let i = 0; i < await array.length; (i = i + 1) - 1) {
					if (await array[i] === value) {
						return i;
					}
					;
				}
			};
			(await Lyte.Compile).splitMixedText = async function (str) {
				var stack = [], start = 0, helper = {
						name: "concat",
						args: []
					}, strStack = [], lastAdded, helperStarted;
				for (var i = 0; i < await str.length; (i = i + 1) - 1) {
					var j = i;
					if (helperStarted && await str[i] === "'") {
						if (lastAdded === "'" && await str[i - 1] !== "\\") {
							await strStack.pop();
							lastAdded = $Lt._gc.undefined;
						} else if (!await strStack.length) {
							lastAdded = await str[i];
							await strStack.push(lastAdded);
						}
					} else if (helperStarted && await str[i] === "\"") {
						if (lastAdded === "\"" && await str[i - 1] !== "\\") {
							await strStack.pop();
							lastAdded = $Lt._gc.undefined;
						} else if (!await strStack.length) {
							lastAdded = await str[i];
							await strStack.push(lastAdded);
						}
					} else if ((helperStarted && !await strStack.length || !helperStarted) && await str[i - 1] !== "\\" && await str[i] === "{" && await str[i = i + 1] === "{") {
						await stack.push("{{");
						await (await helper.args).push("'" + await str.substr(start, j - start) + "'");
						start = i + 1;
						helperStarted = true;
					} else if ((helperStarted && !await strStack.length || !helperStarted) && await str[i] === "}" && await str[i = i + 1] === "}" && await stack.length) {
						await stack.pop(start);
						helperStarted = false;
						var toPush = await str.substr(start, j - start);
						var actObj = await this.getHelper(toPush);
						if (actObj) {
							toPush = actObj;
							await (await helper.args).push({
								type: "helper",
								value: toPush
							});
						} else {
							await (await helper.args).push(toPush);
						}
						start = i + 1;
					}
				}
				if (start < await str.length) {
					await (await helper.args).push("'" + await str.substr(start, await str.length - start) + "'");
				}
				return helper;
			};
			(await Lyte.Compile).getHelper = async function (dynamicValue, newCompile) {
				let helperValue = await (/\((?:[^)]*|(?:(?:"(?:[^"\\]|\\.)*?")|(?:'([^'\\]|\\.)*?')|[\w\s!@#$%^&*)([\]+=.,_-]*?)*?)\)$/).exec(dynamicValue);
				if (helperValue) {
					return await this.getHelperInfo(dynamicValue, helperValue, newCompile);
				}
				return $Lt._gc.undefined;
			};
			(await Lyte.Compile).getHelperInfo = async function (dynamicValue, helperValue, newCompile) {
				let helperFunc = {};
				helperFunc.name = await (await dynamicValue.substr(0, await helperValue.index)).replace((/\s/g), "");
				helperValue = helperValue ? await (await helperValue[0]).trim() : helperValue;
				if (await helperFunc.name == "lyteViewPort" && helperValue == "()") {
					helperFunc.args = [];
					return helperFunc;
				}
				let args = await this.getHelperArgs(await helperValue.substr(1, await helperValue.length - 2), newCompile);
				if (args === false) {
					return false;
				}
				helperFunc.args = args;
				return helperFunc;
			};
			(await Lyte.Compile).getHelperArgs = async function (str, newCompile) {
				let stack = [], args = [], from = 0;
				let lastPushed;
				for (let i = 0; i < await str.length; (i = i + 1) - 1) {
					if (!await stack.length && await str.charAt(i) === ",") {
						let toPush = await str.substr(from, i - from);
						toPush = await toPush.trim();
						if (toPush && await toPush.startsWith("\"") && await toPush.endsWith("\"")) {
							toPush = await toPush.slice(1, -1);
							toPush = "'" + toPush + "'";
						}
						toPush = await this.getHelperArgValue(toPush, newCompile);
						await args.push(toPush);
						from = i + 1;
					} else if (await str.charAt(i) === "(") {
						if (await stack[await stack.length - 1] != "'" && await stack[await stack.length - 1] != "\"") {
							await stack.push(await str.charAt(i));
							lastPushed = await str.charAt(i);
						}
					} else if (await str.charAt(i) === ")") {
						if (await stack[await stack.length - 1] === "(") {
							await stack.pop();
						}
					} else if (await str.charAt(i) === "'" && await str.charAt(i - 1) !== "\\") {
						if (await stack[await stack.length - 1] === "'") {
							await stack.pop();
						} else if (await stack[await stack.length - 1] !== "\"") {
							await stack.push(await str.charAt(i));
							lastPushed = await str.charAt(i);
						}
					} else if (await str.charAt(i) === "\"" && await str.charAt(i - 1) !== "\\") {
						if (await stack[await stack.length - 1] === "\"") {
							await stack.pop();
						} else if (await stack[await stack.length - 1] !== "'") {
							await stack.push(await str.charAt(i));
							lastPushed = await str.charAt(i);
						}
					}
				}
				if (await stack.length) {
					return false;
				}
				var toPush = await str.substr(from, await str.length - from);
				toPush = await toPush.trim();
				if (toPush && await toPush.startsWith("\"") && await toPush.endsWith("\"")) {
					toPush = await toPush.slice(1, -1);
					toPush = "'" + toPush + "'";
				}
				try {
					toPush = await this.getHelperArgValue(toPush, newCompile);
				} catch (err) {
					return false;
				}
				await args.push(toPush);
				if (newCompile) {
					var newArgs = [];
					await $Lt._fE(args, async function (item) {
						if (typeof item === "string" && await item[0] !== "'" && item !== "event" && item !== "this") {
							await newArgs.push(await _LC.getDV(item));
						} else {
							await newArgs.push(item);
						}
					});
					args = newArgs;
				}
				return args;
			};
			(await Lyte.Compile).getHelperArgValue = async function (argValue, newCompile) {
				switch (argValue) {
				case "undefined":
					return $Lt._gc.undefined;
				case "true":
					return true;
				case "false":
					return false;
				case "null":
					return null;
				case "":
					return $Lt._gc.undefined;
				default:
					if (argValue && await argValue.startsWith("'") && await argValue.endsWith("'")) {
						argValue = await argValue.replace((/\\\'/g), "'");
						argValue = await argValue.replace((/\\\"/g), "\"");
						return argValue;
					} else if (await (/\([\w\s,')(]*/).test(argValue)) {
						return {
							"type": "helper",
							"value": await this.getHelper(argValue, newCompile)
						};
					} else if (!await $Lt._gcFn.isNaN(argValue)) {
						return await $Lt._gcFn.parseInt(argValue);
					} else {
						return argValue;
					}
				}
			};
			(await Lyte.Compile).getMustache = async function (value) {
				value = value && typeof value === "string" ? await value.trim() : value;
				if (await (/^{{(?=[\s]*[\w-_\(\$)]+)/).test(value)) {
					let arr = await value.match((/{{[a-zA-Z0-9_.[\]()]*(?![\\])}}/g));
					if (arr && await arr.length > 1) {
						return $Lt._gc.undefined;
					}
					if (!await this.syntaxCheck(value) || !await (/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}$/).test(value)) {
						return $Lt._gc.undefined;
					}
					let dynamic = await value.match((/[\w!@#$%^&*)(+=.,_-]+[\s]*[(]{0,1}(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#$%^&*)([\]+=.,_-]*?)*?[)]{0,1}[\s]*(?=}})/g));
					if (dynamic && await dynamic.length > 1) {
						return $Lt._gc.undefined;
					} else {
						dynamic = dynamic ? await (await dynamic[0]).trim() : dynamic;
					}
					return dynamic;
				}
				return $Lt._gc.undefined;
			};
			(await Lyte.Compile).syntaxCheck = async function (value) {
				var stack = [], lastAdded;
				for (var i = 0; i < await value.length; (i = i + 1) - 1) {
					if (await value[i] === "'") {
						if (lastAdded === "'" && await value[i - 1] !== "\\") {
							await stack.pop();
							lastAdded = $Lt._gc.undefined;
						} else if (!await stack.length) {
							lastAdded = await value[i];
							await stack.push(lastAdded);
						}
					} else if (await value[i] === "\"") {
						if (lastAdded === "\"" && await value[i - 1] !== "\\") {
							await stack.pop();
							lastAdded = $Lt._gc.undefined;
						} else if (!await stack.length) {
							lastAdded = await value[i];
							await stack.push(lastAdded);
						}
					}
				}
				if (await stack.length) {
					return false;
				}
				return true;
			};
			LyteComponent.replaceWithOrigTemplate = async function (node) {
				(await node._origTemplate)._fakeTemp = node;
				return await node._origTemplate;
			};
			LyteComponent.pendingViewPortElements = [];
			LyteComponent.isInViewPort = async function (el, lazy) {
				if (lazy) {
					return true;
				}
				var rect = await el.getBoundingClientRect();
				if (await rect.width == 0 && await rect.height == 0 && await rect.top == 0 && await rect.bottom == 0 && await el.localName != "dummy-port-element") {
					return false;
				}
				let innerHeight = await window.innerHeight || await (await $Lt._gc.document.documentElement).clientHeight;
				let innerWidth = await window.innerWidth || await (await $Lt._gc.document.documentElement).clientWidth;
				return (await rect.top >= 0 && await rect.top <= innerHeight || await rect.bottom >= 0 && await rect.bottom <= innerHeight || await rect.top <= 0 && await rect.bottom >= 0) && (await rect.left >= 0 && await rect.left <= innerWidth || await rect.right >= 0 && await rect.right <= innerWidth || await rect.left <= 0 && await rect.right >= 0);
			};
			_LC._doneRaf = {};
			await (await Lyte.Component).registerHelper("lyteViewPort", async function (node, config) {
				let compName = await this.localName;
				let self = this;
				let actNode = await _LC.getActViewPortTemplate(node);
				if (await actNode._viewPortRendered) {
					return false;
				}
				let disableViewPort = config;
				let pve = await _LC.pendingViewPortElements;
				let promise;
				actNode._disable = {};
				if (config && typeof config == "object") {
					actNode._lazy = node._lazy = await config.lazy;
					actNode._custom = true;
					disableViewPort = await config.disableViewPort;
					if (await config.viewIn || await config.viewOut) {
						promise = true;
						actNode._viewIn = await config.viewIn ? await $Lt._gc.Object.assign(await config.viewIn) : $Lt._gc.undefined;
						actNode._viewOut = await config.viewOut ? await $Lt._gc.Object.assign(await config.viewOut) : $Lt._gc.undefined;
						let _res, _rej;
						actNode._renderPromise = await $Lt._cO($Lt._gc.Promise, async function (res, rej) {
							_res = res;
							_rej = rej;
						});
						actNode._promiseObject = {
							resolvedByLyte: false,
							spouse: await actNode._viewIn,
							resolve: async function () {
								if (!await (await actNode._viewOut)._afterAppendCalled && await (await actNode._viewOut).beforeRemove && await actNode._renderPromise && !await (await actNode._viewOut)._beforeRemoveCalled) {
									await (await (await actNode._viewOut).beforeRemove).apply(await actNode._viewOut, [await node._promiseObject]);
									(await actNode._viewOut)._beforeRemoveCalled = true;
								}
								if (await actNode._renderPromise) {
									await _res();
								}
							},
							reject: async function () {
								(await actNode._renderPromise)._reject = true;
								await _rej();
							}
						};
						await (await actNode._renderPromise).then(async function () {
							if (!await (await actNode._callee).component) {
								return;
							}
							let waitInd = await (await _LC.waitingForResolve).indexOf(await node._renderPromise);
							if (waitInd != -1) {
								await (await _LC.waitingForResolve).splice(waitInd, 1);
							}
							(await actNode._renderPromise)._resolved = true;
							let ind = await pve.indexOf(actNode);
							if (ind != -1) {
								await pve.splice(ind, 1);
							}
							let viewInIns = await actNode._viewIn;
							if (viewInIns && await viewInIns.beforeAppend) {
								await (await viewInIns.beforeAppend).apply(viewInIns);
							}
							await _LC._executeIfTemplates(actNode);
							if (viewInIns && await viewInIns.afterAppend) {
								await (await viewInIns.afterAppend).apply(viewInIns);
							}
							actNode._renderPromise = null;
						}, async function () {
							await Lyte.error("Promise rejected - Viewport cannot be toggled.");
						});
					}
				}
				if (!disableViewPort) {
					if (!await (await _LC._doneRaf)[compName]) {
						await $Lt._gcFn.requestAnimationFrame(async function () {
							await $Lt._gcFn.setTimeout(async function () {
								let inViewTemplates = [];
								var arr = await $Lt._gc.Array.from(pve);
								let beforeRemoveHook = [];
								for (var i = await arr.length - 1; i >= 0; (i = i - 1) + 1) {
									let temp = await arr[i];
									var actTemp = await _LC.getActViewPortTemplate(temp);
									let viewOutIns = await actTemp._viewOut;
									if (viewOutIns && await viewOutIns.afterAppend) {
										await (await viewOutIns.afterAppend).apply(viewOutIns, [await actTemp._promiseObject]);
										viewOutIns._afterAppendCalled = true;
									}
								}
								for (var i = await arr.length - 1; i >= 0; (i = i - 1) + 1) {
									let temp = await arr[i];
									var actTemp = await _LC.getActViewPortTemplate(temp);
									if (await _LC.isViewPortTemplate(temp) && !await (await temp._callee)._destroyed) {
										let obj = {};
										if (await _LC._isInViewPort(actTemp, await actTemp._callee, beforeRemoveHook, $Lt._gc.undefined, obj)) {
											let nd = await (await pve.splice(i, 1))[0];
											temp._inPve = false;
											temp._viewPortRendered = true;
											!await obj.beforeRemoveHook && await inViewTemplates.push(nd);
										}
										actTemp._inPve = await temp._inPve;
										actTemp._viewPortRendered = await temp._viewPortRendered;
									}
								}
								for (let i = 0; i < await beforeRemoveHook.length; (i = i + 1) - 1) {
									await (await (await (await beforeRemoveHook[i]).viewOutIns).beforeRemove).apply(await (await beforeRemoveHook[i]).viewOutIns, await (await beforeRemoveHook[i]).arg);
									await (await _LC.waitingForResolve).push(await (await (await beforeRemoveHook[i]).node)._renderPromise);
								}
								for (let i = 0; i < await inViewTemplates.length; (i = i + 1) - 1) {
									await _LC._executeIfTemplates(await inViewTemplates[i]);
								}
								(await _LC._doneRaf)[compName] = false;
								if (await inViewTemplates.length) {
									await $Lt._gcFn.requestAnimationFrame(async function () {
										await $Lt._gcFn.setTimeout(async function () {
											await _LC.executePendingViewPort();
										}, 1);
									});
								}
								!await window.isLyteWidget && await _LC.resolveLazy();
							}, 1);
						});
						(await _LC._doneRaf)[compName] = true;
					}
					if (await pve.indexOf(await _LC.getFakeTemplate(node)) == -1) {
						node._inPve = true;
						await pve.push(node);
					}
					return true;
				} else if (await pve.length) {
					let fakeTemp = await _LC.getFakeTemplate(node);
					let ind = await pve.indexOf(fakeTemp);
					node._inpve = fakeTemp._inPve = false;
					node._viewPortRendered = fakeTemp._viewPortRendered = true;
					if (ind != -1) {
						await pve.splice(ind, 1);
					}
				}
			});
			LyteComponent.waitingForResolve = [];
			LyteComponent._isInViewPort = async function (node, comp, beforeRemoveHook, lazyForce, obj) {
				var fchild = await (await node._caseContent)[0];
				if (fchild && await _LC.isInViewPort(fchild, lazyForce)) {
					node._isInView = true;
					if (await node._custom) {
						let viewOutIns = await node._viewOut;
						if (viewOutIns && !await (await node._renderPromise)._resolved && await viewOutIns.beforeRemove && !await viewOutIns._beforeRemoveCalled) {
							(await node._promiseObject).resolvedByLyte = true;
							viewOutIns._beforeRemoveCalled = true;
							await beforeRemoveHook.push({
								viewOutIns: viewOutIns,
								arg: [await node._promiseObject],
								node: node
							});
							if (obj) {
								obj.beforeRemoveHook = true;
								return true;
							}
						} else if (!await (await node._renderPromise)._reject) {
							if (obj) {
								obj.beforeRemoveHook = true;
							}
							return true;
						}
					} else {
						return true;
					}
				}
			};
			LyteComponent.__preLazyRender = false;
			LyteComponent.resolveLazy = async function () {
				if (await LyteComponent.pendingViewPortElements) {
					await $Lt._gcFn.requestAnimationFrame(async function () {
						await $Lt._gcFn.setTimeout(async function () {
							let waitingForViewportProcess = false;
							for (let key in await _LC._doneRaf) {
								if (await (await _LC._doneRaf)[key]) {
									waitingForViewportProcess = true;
								}
							}
							if (await (await _LC.waitingForResolve).length) {
								await (await $Lt._gc.Promise.all(await _LC.waitingForResolve)).then(async function () {
									await LyteComponent.resolveLazy();
								}, async function () {
									await Lyte.error("Promise rejected - Viewport cannot be toggled.");
								});
							} else if (waitingForViewportProcess) {
								await LyteComponent.resolveLazy();
							} else {
								!await _LC.__preLazyRender && await Lyte.triggerEvent("preLazyRender");
								_LC.__preLazyRender = true;
								await _LC.executePendingViewPort({ lazy: true });
							}
						}, 1);
					});
				}
			};
			LyteComponent._executeIfTemplates = async function (node) {
				let actNode = await _LC.getActViewPortTemplate(node);
				(await actNode._attributes).value = false;
				var isYieldContext, contextSwitchInfo;
				if (await actNode._cx || await actNode.nodeType === 2 && await (await actNode.ownerElement)._cx) {
					contextSwitchInfo = await actNode._cx || await (await actNode.ownerElement)._cx;
					var contextSwitchArray = [];
					await _LC.changeContext(await contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo);
				} else if (await actNode.tagName === "LYTE-YIELD" && await (await actNode._callee)._cx) {
					isYieldContext = true;
					contextSwitchInfo = await (await actNode._callee)._cx;
					var contextSwitchArray = [];
					await _LC.changeContext(await contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, true);
				}
				await (await actNode._callee).updateSwitchHelper("if", actNode, await actNode._cx, true, true);
				if (contextSwitchInfo) {
					await _LC.removeContext(await contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, isYieldContext);
				}
			};
			LyteComponent.isViewPortTemplate = async function (node) {
				if ((await node.tagName == "TEMPLATE" || await node._origTemplate) && await node.getAttribute("is") == "if") {
					return true;
				}
			};
			LyteComponent.getActViewPortTemplate = async function (node) {
				return await node._origTemplate ? await node._origTemplate : node;
			};
			LyteComponent.getFakeTemplate = async function (node) {
				return await node._fakeTemp ? await node._fakeTemp : node;
			};
			LyteComponent.executePendingViewPort = async function (options) {
				var pve = await _LC.pendingViewPortElements;
				if (!await pve.length) {
					return;
				}
				var arr = await $Lt._gc.Array.from(pve);
				var inViewPortElements = [];
				let beforeRemoveHook = [];
				let lazyForce = options && await options.lazy ? true : $Lt._gc.undefined;
				let settings = await (await _Lyte.Component).viewPortSettings;
				let lazyToggleCount = await (await settings.lazy).count;
				let lazyToggleByElements = await (await settings.lazy).toggleBy == "elements" ? true : false;
				let lazyToggleByScreen = await (await settings.lazy).toggleBy == "screen" ? true : false;
				if (options && await options.lazy && await (await options.lazy).toggleBy) {
					lazyToggleCount = await (await options.lazy).count;
					lazyToggleByElements = await (await options.lazy).toggleBy == "elements" ? true : false;
					lazyToggleByScreen = await (await options.lazy).toggleBy == "screen" ? true : false;
					if (lazyToggleByElements) {
						_LC._toggleElementsCount = lazyToggleCount;
					} else if (lazyToggleByScreen == "screen") {
						_LC._toggleScreenCount = lazyToggleCount;
					}
				}
				let sliceCount = 0;
				_LC.autoRender = await _LC.autoRender || options && await options.force == "autoRender";
				if ((!options || !await options.force) && !await _LC.autoRender) {
					for (var i = await arr.length - 1; i >= 0; (i = i - 1) + 1) {
						let ele = await arr[i];
						if (await _LC.isViewPortTemplate(ele)) {
							let actTemp = await _LC.getActViewPortTemplate(ele);
							lazyForce = await actTemp._lazy && lazyForce ? lazyForce : false;
							if (lazyForce && lazyToggleByElements) {
								if (lazyToggleCount == 0) {
									await $Lt._gcFn.requestAnimationFrame(async function () {
										await $Lt._gcFn.setTimeout(async function () {
											await _LC.executePendingViewPort({ lazy: true });
										});
									});
									break;
								}
								(lazyToggleCount = lazyToggleCount - 1) + 1;
							}
							if (await _LC._isInViewPort(actTemp, await actTemp._callee, beforeRemoveHook, lazyForce)) {
								await inViewPortElements.push(await (await pve.splice(i, 1))[0]);
								(sliceCount = sliceCount + 1) - 1;
								ele._inPve = false;
								ele._viewPortRendered = true;
							}
							actTemp._inPve = await ele._inPve;
							actTemp._viewPortRendered = await ele._viewPortRendered;
						} else if (await _LC.isInViewPort(await ele._dummyViewPortF) || await _LC.isInViewPort(await ele._dummyViewPortL)) {
							ele._dummyViewPortF = ele._dummyViewPortL = $Lt._gc.undefined;
							await inViewPortElements.push(await (await pve.splice(i, 1))[0]);
							(sliceCount = sliceCount + 1) - 1;
						}
					}
					for (let i = 0; i < await beforeRemoveHook.length; (i = i + 1) - 1) {
						await (await (await (await beforeRemoveHook[i]).viewOutIns).beforeRemove).apply(await (await beforeRemoveHook[i]).viewOutIns, await (await beforeRemoveHook[i]).arg);
					}
				} else {
					inViewPortElements = arr;
				}
				let pveLn = await arr.length;
				for (var j = 0; j < await inViewPortElements.length; (j = j + 1) - 1) {
					let ele = await inViewPortElements[j];
					if (await _LC.isViewPortTemplate(ele)) {
						await _LC._executeIfTemplates(ele);
					} else {
						await ele.setData("lyteViewPort", false);
						var index = await pve.indexOf(ele);
						if (index != -1) {
							await pve.splice(index, 1);
							(sliceCount = sliceCount + 1) - 1;
						}
					}
				}
				_LC.isViewPortPending = false;
				if (await inViewPortElements.length && !await window.isLyteWidget) {
					await $Lt._gcFn.requestAnimationFrame(async function () {
						await $Lt._gcFn.requestAnimationFrame(async function () {
							await _LC.executePendingViewPort();
						});
					});
				} else if (pveLn == await (await _LC.pendingViewPortElements).length + sliceCount && (!options || !await options.lazy)) {
					await Lyte.triggerEvent("viewportRendered");
				}
			};
			await window.addEventListener("resize", async function () {
				await $Lt._gcFn.requestAnimationFrame(async function () {
					await $Lt._gcFn.requestAnimationFrame(async function () {
						await _LC.executePendingViewPort();
					});
				});
			});
			await $Lt._gc.document.addEventListener("scroll", async function () {
				if (await window.isLyteWidget) {
					(await _LyteComponent.viewPortSettings).debounce = 100;
				}
				var debounceTime = await (await _LyteComponent.viewPortSettings).debounce;
				if (debounceTime) {
					if (await _LC.viewPortScrollDebounce) {
						await $Lt._gcFn.clearTimeout(await _LC.viewPortScrollDebounce);
					}
					_LC.viewPortScrollDebounce = await $Lt._gcFn.setTimeout(async function () {
						await $Lt._gcFn.requestAnimationFrame(async function () {
							await $Lt._gcFn.requestAnimationFrame(async function () {
								await _LC.executePendingViewPort();
							});
						});
						_LC.viewPortScrollDebound = $Lt._gc.undefined;
					}, debounceTime);
				} else {
					await $Lt._gcFn.requestAnimationFrame(async function () {
						await $Lt._gcFn.requestAnimationFrame(async function () {
							await _LC.executePendingViewPort();
						});
					});
				}
			}, true);
			LyteComponent.core = {};
			(await LyteComponent.core)._constructor = customElementPrototype;
			(await LyteComponent.core)._registerComponent = await customElementPrototype._registerComponent;
			(await LyteComponent.core).registerComponent = await _LC.registerComponent;
			(await LyteComponent.core).executeBlockHelpers = await (await customElementPrototype.prototype).executeBlockHelpers;
			(await LyteComponent.core).updateForHelper = await (await customElementPrototype.prototype).updateForHelper;
			(await LyteComponent.core).updateForInHelper = await (await customElementPrototype.prototype).updateForInHelper;
			(await LyteComponent.core).updateSwitchHelper = await (await customElementPrototype.prototype).updateSwitchHelper;
			_LyteComponent.viewPortSettings = {
				debounce: 0,
				lazy: {
					toggleBy: "elements",
					count: 100
				},
				executePendingViewPortElements: async function (options) {
					await LyteComponent.executePendingViewPort(options);
				},
				resetLazy: async function () {
					LyteComponent.__preLazyRender = false;
				}
			};
			LyteComponent.insertBeforeNative = async function (parent, newNode, refNode) {
				await parent.insertBefore(newNode, refNode);
			};
		}($Lt._gc.window);
		$Lt._cV("widgetScopeMap", await $Lt._cO($Lt._gc.Map), "var"), $Lt._cV("widgetStyles", await $Lt._cO($Lt._gc.Map), "var"), $Lt._cV("widgetCompStyles", await $Lt._cO($Lt._gc.Map), "var"), $Lt._cV("widgetShadows", await $Lt._cO($Lt._gc.Map), "var"), $Lt._cV("widgetMap", await $Lt._cO($Lt._gc.Map), "var"), $Lt._cV("prxWkMap", await $Lt._cO($Lt._gc.WeakMap), "var");
		$Lt._gc.window.widgetScopeMap = $Lt._gc.widgetScopeMap;
		$Lt._gc.window.widgetMap = $Lt._gc.widgetMap;
		$Lt._cV("isWidget", await $Lt._gc.window.isLyteWidget, "var"), $Lt._cV("widgetConfig", {}, "var"), $Lt._cV("oldProtoSet", undefined, "var");
		$Lt._cV("windowEventListeners", [], "var");
		$Lt._cV("oldDocumentEventListener", await $Lt._gc.document.addEventListener, "var");
		if (isWidget) {
			document.addEventListener = function () {
				if (arguments.length > 1) {
					var args = arguments;
					windowEventListeners.push(arguments);
					widgetShadows.forEach(function (value, key) {
						value.forEach(function (item) {
							item.addEventListener.apply(item, args);
						});
					});
					return oldDocumentEventListener.apply(this instanceof HTMLElement ? this : document, Array.from(arguments));
				} else {
					return function () {
						var args = arguments;
						windowEventListeners.push(arguments);
						widgetShadows.forEach(function (value, key) {
							value.forEach(function (item) {
								item.addEventListener.apply(item, args);
							});
						});
						return oldDocumentEventListener.apply(this instanceof HTMLElement ? this : document, Array.from(arguments));
					};
				}
			};
			var originalBodyAppendChild = document.body.appendChild;
			var originalBodyRemoveChild = document.body.removeChild;
			var bodyDiv = document.createElement("div");
			bodyDiv.setAttribute("lyte-info", "baseBodyDiv");
			var bodyShadow = window.bodyShadow = bodyDiv.attachShadow({ "mode": "open" });
			bodyShadow._isBodyShadow = true;
			document.body.appendChild(bodyDiv);
			document.body.appendChild = function (node, bypass) {
				if (bypass) {
					return originalBodyAppendChild.call(document.body, node);
				}
				if (node instanceof Node && node.getRootNode() != document) {
					var rootNode = node.getRootNode();
					if (!rootNode._bodyShadow) {
						var div = document.createElement("div");
						rootNode._bodyShadow = div.attachShadow({ "mode": "open" });
						rootNode._bodyShadow._isBodyShadow = true;
						var bodyWidgetObj = {
								"shadow": rootNode._bodyShadow,
								"mappings": {},
								"count": 2
							};
						bodyWidgetObj._id = (window.bodyShadowCount = window.bodyShadowCount + 1) - 1;
						rootNode._bodyShadow._id = bodyWidgetObj._id;
						rootNode._bodyShadow._m = 1;
						rootNode._bodyShadow._mX = rootNode._id;
						window.initializeMutations(bodyWidgetObj, true);
						document._addShadowForGlobalRegistry(rootNode._bodyShadow);
						window.childBodyWidgetMappings[bodyWidgetObj._id] = bodyWidgetObj;
						var styles = rootNode.querySelectorAll("link,style");
						styles.forEach(function (item) {
							rootNode._bodyShadow.appendChild(item.cloneNode(true));
						});
						originalBodyAppendChild.call(document.body, div);
					}
					return rootNode._bodyShadow.appendChild(node);
				} else if (node instanceof Node) {
					return bodyShadow.appendChild(node);
				}
			};
			if (window.isLyteWidget) {
				window.getDetailsCount = 0;
				window.getDetailsPromiseObj = {};
				window.getDetailsFromParent = async function (element, property, isProp, parameters) {
					var shadow;
					var isAnyElement = false;
					var element_m;
					if (element instanceof Window) {
						element_m = "window";
					} else if (element == document.documentElement) {
						element_m = "documentElement";
					} else {
						isAnyElement = true;
						element_m = element._m;
						shadow = element.getRootNode();
					}
					var promiseObj = {};
					var promise = new Promise(function (resolve, reject) {
							promiseObj.resolve = resolve;
							promiseObj.reject = reject;
						});
					if (parameters) {
						for (let i = 0; i < parameters.length; (i = i + 1) - 1) {
							let item = parameters[i];
							if (item instanceof Node) {
								if (!item._m) {
									return $Lt._aR(element.__origFuncs ? element.__origFuncs[property].apply(element, parameters) : undefined);
								}
								parameters[i] = {
									"__type": "node",
									"_m": item._m
								};
								let shadow = item.getRootNode();
								if (shadow._isBodyShadow) {
									parameters[i].x1 = shadow._id;
								} else {
									parameters[i].x = shadow._id;
								}
							}
						}
					}
					window.getDetailsPromiseObj[window.getDetailsCount] = promiseObj;
					var obj = {
							"c": "getDetails",
							"prop": property,
							"isProp": isProp,
							"count": (window.getDetailsCount = window.getDetailsCount + 1) - 1,
							"params": parameters,
							"_m": element_m
						};
					if (isAnyElement) {
						if (shadow._isBodyShadow) {
							obj.x1 = shadow._id;
						} else {
							obj.x = shadow._id;
						}
					}
					window.parent.postMessage(obj, "*");
					return $Lt._aR(promise);
				};
				HTMLElement.prototype["getBoundingClientRect"] = async function () {
					return $Lt._aR($Lt._aW(await window.getDetailsFromParent(this, "getBoundingClientRect", false, [])));
				};
				Object.defineProperty(window, "print", { "get": async function () {
						return $Lt._aR($Lt._aW(await window.getDetailsFromParent(window, "print", false, [])));
					} });
				var windowFuncsFromParent = ["getComputedStyle"];
				window.__origFuncs = {};
				windowFuncsFromParent.forEach(function (item) {
					window.__origFuncs[item] = window[item];
					window[item] = async function () {
						return $Lt._aR($Lt._aW(await window.getDetailsFromParent(window, item, false, Array.from(arguments))));
					};
				});
				var windowPropsFromParent = [
						"pageXOffset",
						"pageYOffset",
						"innerHeight",
						"innerWidth"
					];
				windowPropsFromParent.forEach(function (item) {
					Object.defineProperty(window, item, { "get": async function () {
							return $Lt._aR($Lt._aW(await window.getDetailsFromParent(window, item, true, [])));
						} });
				});
				var documentElementProps = [
						"scrollTop",
						"scrollLeft",
						"clientWidth",
						"clientHeight"
					];
				documentElementProps.forEach(function (item) {
					Object.defineProperty(document.documentElement, item, { "get": async function () {
							return $Lt._aR($Lt._aW(await window.getDetailsFromParent(document.documentElement, item, true, [])));
						} });
				});
				let oldDocumentEventListenerRemove = document.removeEventListener;
				document.removeEventListener = function () {
					var arr = Array.from(arguments);
					arr[0] = arr[0]._OldF;
					oldDocumentEventListenerRemove.apply(this, arr);
				};
			}
			document.body.removeChild = function (node, bypass) {
				if (node instanceof Node) {
					if (node.getRootNode() != document) {
						node.getRootNode().removeChild(node);
					} else {
						originalBodyRemoveChild.call(document.body, node);
					}
				}
			};
		}
		$Lt._gc.window.DataBindingLayer = {
			"updateInitProperties": async function (node, key, value) {
					if (await node.__elmCntW) {
						var elementCounter = await this.getElementCounter(await node.__elmCntW);
						await this.addIdsNew(value, elementCounter);
						await (await $Lt._gc.window.parent).postMessage({
							"c": "dCInit",
							"e": await node.__elmCntW,
							"f": key,
							"g": value
						}, "*");
						await this.removeIdsNew(value);
					}
				},
			"elmCnt": 1,
			"valueSet": function (object, property, value) {
				var setInfo = this.weakMap.get(object);
				var self = this;
				if (setInfo) {
					setInfo.forEach(function (item) {
						let elmCnt = item.split("-")[0];
						self.addIdsNew(value, self.elementCounterMap[elmCnt]);
						window.parent.postMessage({
							"c": "dC",
							"e": item,
							"f": property,
							"g": value
						}, "*");
						self.removeIdsNew(value);
					});
				}
			},
			"elementCounterMap": {},
			"getElementCounter": function (elementCnt) {
				if (elementCnt) {
					return this.elementCounterMap[elementCnt];
				}
				var elmCounterObj = {
						elmCnt: (DataBindingLayer.elmCnt = DataBindingLayer.elmCnt + 1) - 1,
						dataCnt: 1
					};
				this.elementCounterMap[elmCounterObj.elmCnt] = elmCounterObj;
				return elmCounterObj;
			},
			"getDataCounter": function (elementCounter) {
				return elementCounter.elmCnt + "-" + elementCounter.dataCnt++;
			},
			"weakMap": await $Lt._cO($Lt._gc.WeakMap),
			"childMap": {},
			"sendDc": async function (id, property, value) {
				await (await $Lt._gc.window.parent).postMessage({
					"c": "dC",
					"e": id,
					"f": property,
					"g": value
				}, "*");
			},
			"addIdsNew": function (data, elementCounter) {
				var self = this;
				if (data && typeof data == "object" && !data.__id) {
					let setVal = this.weakMap.get(data);
					if (!setVal) {
						setVal = new Set();
						this.weakMap.set(data, setVal);
					}
					let __id = DataBindingLayer.getDataCounter(elementCounter);
					setVal.add(__id);
					data.__id = __id;
					if (Array.isArray(data)) {
						data.forEach(function (item) {
							if (typeof item == "object") {
								self.addIdsNew(item, elementCounter);
							}
						});
					} else {
						for (var key in data) {
							if (typeof data[key] == "object") {
								this.addIdsNew(data[key], elementCounter);
							}
						}
					}
				}
			},
			"removeIdsNew": function (data) {
				var self = this;
				if (data && typeof data == "object") {
					if (data.__id) {
						delete data.__id;
					}
					if (Array.isArray(data)) {
						data.forEach(function (item) {
							if (typeof item == "object") {
								self.removeIdsNew(item);
							}
						});
					} else {
						for (var key in data) {
							if (typeof data[key] == "object") {
								this.removeIdsNew(data[key]);
							}
						}
					}
				}
			}
		};
		await async function (Lyte) {
			async function errorFunction(errorEvent) {
				await (await $Lt._gc.window.parent).postMessage({
					"c": "7",
					"x": await _LyteComponent.currentWidgetId,
					"y": await errorEvent.type == "error" ? errorEvent : await errorEvent.reason
				}, "*");
			}
			async function eventHandlerChild(event) {
				var data = await event.data;
				var widgetObj;
				if (await data.p) {
					if (!await $Lt._gc.document._lyteResetAdded) {
					}
					if (await data.x) {
						_LyteComponent.currentWidgetId = await data.x;
						widgetObj = await (await $Lt._gc.window.childWidgetMappings)[await data.x];
					}
					if (await data.x1) {
						widgetObj = await (await $Lt._gc.window.childBodyWidgetMappings)[await data.x1];
					}
					var param1 = await data[1];
					var param2 = await data[2];
					var param3 = await data[3];
					var param4 = await data[4];
					switch (await data.p) {
					case "0": {
							if (await data.src && !await loadedWidgets[await data.w]) {
								await $Lt._aW(await loadWidget(await data.w, await data.src));
								loadedWidgets[await data.w] = true;
							}
						}
						break;
					case "1": {
							var widgetObj = (await $Lt._gc.window.childWidgetMappings)[param1] = {};
							var div = await $Lt._gc.document.createElement("div");
							await div.setAttribute("id", param1);
							await (await $Lt._gc.document.body).appendChild(div, true);
							var shadow = widgetObj.shadow = await div.attachShadow({ "mode": "open" });
							var wShadows = await $Lt._gc.widgetShadows.get(await data.w);
							if (!wShadows) {
								await $Lt._gc.widgetShadows.set(await data.w, wShadows = []);
							}
							await wShadows.push(shadow);
							await $Lt._gc.document._addShadowForGlobalRegistry(shadow);
							shadow._id = param1;
							shadow._eL = [];
							widgetObj.mappings = {};
							(await widgetObj.mappings)[1] = shadow;
							shadow._m = 1;
							widgetObj.count = 2;
							if (await data.src && !await loadedWidgets[await data.w]) {
								await $Lt._aW(await loadWidget(await data.w, await data.src));
								loadedWidgets[await data.w] = true;
							}
							await initializeMutations(widgetObj);
							await initStylesToWidget(shadow, await data.w);
						}
						break;
					case "1a": {
							await $Lt._aW(await loadWidget(await data.w, await data.src, await data.c));
							await (await $Lt._gc.window.parent).postMessage({
								"c": "1ar",
								"re": param1,
								"done": true
							}, "*");
						}
						break;
					case "2": {
							if (await data.w) {
								_LyteComponent.currentWidget = await data.w;
							}
							var component = await $Lt._gc.document.createElementLyte(param1);
							await component.addEventListener("onReady", async function () {
								await (await $Lt._gc.window.parent).postMessage({
									"c": "9",
									"x": await data.x
								}, "*");
							});
							await component.setData(param2);
							await (await widgetObj.shadow).appendChild(component);
							if (await data.w) {
								delete _LyteComponent.currentWidget;
							}
						}
						break;
					case "3": {
							var target = await (await widgetObj.mappings)[param1];
							switch (param2) {
							case "click": {
									var clickEvent = await $Lt._cO($Lt._gc.Event, param2, {
											"bubbles": true,
											"cancelable": true
										});
									clickEvent.button = await param4.button;
									clickEvent.__lyteCreated = true;
									if (!target) {
										return $Lt._aR(undefined);
									}
									await target.dispatchEvent(clickEvent);
									var typeName = await target.getAttribute("type");
									if (!await clickEvent.defaultPrevented) {
										if (typeName == "submit" || typeName == "image" || await target.tagName == "BUTTON" && typeName != "button" && typeName != "reset" && typeName) {
											if (await target.form) {
												var submitEvent = await $Lt._cO($Lt._gc.Event, "submit", {
														"bubble": true,
														"cancelable": true
													});
												submitEvent.__lyteCreated = true;
												await (await target.form).dispatchEvent(submitEvent);
												if (!await submitEvent.defaultPrevented) {
													await (await target.form).submit();
												}
											}
										}
										if (typeName == "reset") {
											var resetEvent;
											if (!await (await target.form).__lyteResetAdded) {
												await (await target.form).addEventListener("lyteReset", async function (event) {
													await (await $Lt._gc.window.parent).postMessage({
														"c": "2",
														"x": await (await widgetObj.shadow)._id,
														"y": await (await event.target)._m
													}, "*");
												}, true);
												(await target.form).__lyteResetAdded = true;
											}
											await (await target.form).reset();
										}
									}
								}
								break;
							case "input":
							case "change": {
									var type;
									if (!target) {
										return $Lt._aR(undefined);
									}
									if (await target.tagName == "INPUT") {
										type = await target.getAttribute("type") || "text";
										switch (type) {
										case "radio":
										case "checkbox": {
												target.checked = param3;
											}
											break;
										case "file": {
												target.files = param3;
											}
											break;
										default: {
												$Lt._gc.window.___ignoreVal = true;
												target.value = param3;
											}
										}
									} else {
										target.value = param3;
									}
								}
							case "mouseleave":
							case "mouseover":
							case "keypress":
							case "keydown":
							case "keyup":
							case "mouseout":
							default: {
									if (param2 == "drop") {
										await $Lt._gc.console.log("Drop event called in child");
									}
									var customEvent = await $Lt._cO($Lt._gc.Event, param2, {
											"bubbles": true,
											"cancelable": true
										});
									customEvent.__lyteCreated = true;
									if (param4) {
										delete param4["isTrusted"];
										for (var key in param4) {
											customEvent[key] = await param4[key];
										}
									}
									if (target) {
										await target.dispatchEvent(customEvent);
									}
								}
							}
						}
						break;
					case "8": {
							await (await (await widgetObj.shadow).querySelector("[lyte-rendered]")).setData(param1);
						}
						break;
					case "9": {
							var widgetObj = await (await $Lt._gc.window.childWidgetMappings)[param1];
							await (await widgetObj.observer).disconnect();
							await $Lt._fE(await (await widgetObj.shadow).querySelectorAll("[comp-in-parent]"), async function (item) {
								delete (await $Lt._gc.DataBindingLayer.childMap)[await item.__elmCntW];
							});
							await (await (await widgetObj.shadow).host).remove();
							delete (await $Lt._gc.window.childWidgetMappings)[param1];
						}
						break;
					case "10": {
							await (await Lyte.Component).set(await (await (await (await widgetObj.shadow).querySelector("[lyte-rendered]")).component).data, param1, param2);
						}
					case "11": {
							await (await Lyte.Widget).destroy(param1);
							break;
						}
					case "12": {
							await Lyte.injectResources(param1, async function (event) {
							}, async function (successFiles, failureFiles) {
								var success = false;
								if (await failureFiles.length == 0) {
									success = true;
								}
								await (await $Lt._gc.window.parent).postMessage({
									"c": "8",
									"done": success
								}, "*");
							});
						}
						break;
					case "13": {
							let retVal = await (await Lyte.Widget).destroy(param1, true);
							await retVal.then(async function () {
								await (await $Lt._gc.window.parent).postMessage({
									"c": "13r",
									"r1": param2
								}, "*");
							}, async function () {
								await (await $Lt._gc.window.parent).postMessage({
									"c": "13r",
									"r1": param2,
									"s": 0
								}, "*");
							});
							delete loadedWidgets[param1];
						}
						break;
					case "14": {
							var target = await (await widgetObj.mappings)[param1];
							let meth;
							if (target && await target._initMethods && (meth = await (await target._initMethods)[param2])) {
								let retValue = await meth.apply({ "$node": target }, param3);
								await (await $Lt._gc.window.parent).postMessage({
									"c": "14r",
									"r1": param4,
									"r": retValue
								}, "*");
							} else {
								await (await $Lt._gc.window.parent).postMessage({
									"c": "14r",
									"r1": param4,
									"s": 0
								}, "*");
							}
						}
						break;
					case "15": {
							var target = await (await widgetObj.mappings)[param1];
							if (await target.$data) {
								for (let key1 in param2) {
									await (await Lyte.Component).set(await target.$data, key1, await param2[key1]);
								}
							} else {
								await target.setData(param2, param3);
							}
						}
						break;
					case "getDetails": {
							var count = await data.count;
							var promiseObj = await (await $Lt._gc.window.getDetailsPromiseObj)[count];
							delete (await $Lt._gc.window.getDetailsPromiseObj)[count];
							await promiseObj.resolve(await data.value);
						}
						break;
					case "documentListener": {
							var type = await data.type;
							var eventObj = await data.eventObj;
							var event = await $Lt._cO($Lt._gc.Event, type);
							for (var key in eventObj) {
								event[key] = await eventObj[key];
							}
							if (type != "keydown") {
								await (await $Lt._gc.document.body).dispatchEvent(event);
							} else {
								await $Lt._gc.document.dispatchEvent(event);
							}
						}
						break;
					case "lbindUpdate": {
							let element = await (await $Lt._gc.DataBindingLayer.childMap)[param1];
							let contextSwitchArray;
							let callee = await element._callee;
							if (element) {
								contextSwitchArray = [];
								await _LC.adCx(element, contextSwitchArray);
							}
							let dynamicValue = await (await (await element._attributeDetails)[param2]).dynamicValue;
							let obj = await _LC.getNew(await (await callee.component).data, dynamicValue);
							if (await obj.context) {
								let lastKeyIndex = +await obj.lastKey;
								if (await $Lt._gc.Array.isArray(await obj.context) && typeof lastKeyIndex == "number") {
									await _LC.aF(await obj.context, lastKeyIndex < await (await obj.context).length ? "replaceAt" : "insertAt", lastKeyIndex, $Lt._gc.value);
								} else {
									await _LC.set(await obj.context, await obj.lastKey, param3);
								}
							}
							if (contextSwitchArray) {
								await _LC.rmCx(element, contextSwitchArray);
							}
						}
						break;
					case "parentComps": {
							$Lt._gc.window.parentWrapperComps = param1;
						}
						break;
					case "16": {
							let eventName = param1;
							let eventData = param2;
							let widgetName = param3;
							let options = param4;
							await (await $Lt._gc.window.LyteWidgetClass).triggerEvent(eventName, eventData, options, widgetName);
						}
						break;
					}
					_LyteComponent.currentWidgetId = $Lt._gc.undefined;
				}
			}
			function handleInitProperties(node, dataManipulation) {
				let initProperties = {};
				let elementCount = DataBindingLayer.getElementCounter();
				if (node.tagName.startsWith("LYTE-")) {
					if (node._initProperties) {
						for (var key in node._initProperties) {
							let val = node._initProperties[key];
							DataBindingLayer.addIdsNew(val, elementCount);
							dataManipulation.push(val);
							initProperties[key] = val;
						}
					}
					for (let key in node.$data) {
						if (key != "__lyteDirective") {
							initProperties[key] = node.$data[key];
						}
					}
				}
				node.__elmCntW = elementCount.elmCnt;
				DataBindingLayer.childMap[elementCount.elmCnt] = node;
				node.setAttribute("comp-in-parent", "");
				let initMethods;
				if (node._initMethods && (initMethods = Object.keys(node._initMethods))) {
					for (let k = 0; k < initMethods.length; (k = k + 1) - 1) {
						initMethods[k] = _LC.String.dasherize(initMethods[k]);
					}
				}
				return {
					"iP": initProperties,
					"eC": elementCount.elmCnt,
					"iM": initMethods
				};
			}
			async function loadWidget(name, src, componentName) {
				let styleArr;
				if (componentName) {
					if (!await $Lt._gc.widgetCompStyles.get(name)) {
						await $Lt._gc.widgetCompStyles.set(name, {});
					}
					let compStyles = await $Lt._gc.widgetCompStyles.get(name);
					styleArr = compStyles[componentName] = [];
				}
				await $Lt._gc.widgetStyles.set(name, []);
				var prmArr = [];
				return await $Lt._gcFn._lyteWidgetInit(name, src, styleArr);
			}
			async function initStylesToWidget(shadow, widgetName, componentName) {
				let compStyles;
				compStyles = componentName && (compStyles = await $Lt._gc.widgetCompStyles.get(widgetName)) ? await compStyles[componentName] : [];
				var styles = await $Lt._gc.widgetStyles.get(widgetName) || [];
				await (await styles.push).apply(styles, compStyles);
				var docFrag = await $Lt._gc.document.createDocumentFragment();
				for (var i = 0; i < await styles.length; (i = i + 1) - 1) {
					if (await (await styles[i]).styleTag) {
						var styleTag = await $Lt._gc.document.createElement("style");
						styleTag.innerHTML = await (await styles[i]).string;
						await styleTag.setAttribute("filename", await (await styles[i]).name);
						await docFrag.appendChild(styleTag);
					} else {
						let linkTag = await $Lt._gc.document.createElement("link");
						await linkTag.setAttribute("href", await styles[i]);
						await linkTag.setAttribute("rel", "stylesheet");
						await docFrag.appendChild(linkTag);
					}
				}
				await shadow.appendChild(docFrag);
			}
			function initializeMutations(widgetObj, isWidgetBody) {
				function postToBody() {
					clearTimeout(timeoutValue);
					var newList = list;
					list = [];
				}
				function iterateNodesDelete(node, widgetObj) {
					node.childNodes.forEach(function (item) {
						if (item.nodeType == 1) {
							iterateNodesDelete(item, widgetObj);
						}
					});
				}
				function handleAttrs(node) {
					let attrs = {};
					if (node._initMethods) {
						for (var key in node._initMethods) {
							attrs[_LC.String.dasherize(key)] = "";
						}
					}
					for (var attr of node.attributes) {
						attrs[attr.nodeName] = attr.nodeValue;
						let attrDetail;
						if (node._attributeDetails) {
							if (attrDetail = node._attributeDetails[attr.nodeName]) {
								if (attrDetail.isLbind) {
									attrs[attr.nodeName] = {
										"isLbind": true,
										"value": attr.nodeValue
									};
								}
							}
						}
					}
					return attrs;
				}
				function iterateNodes(node, targetNode, widgetObj, dataManipulation) {
					var childNodes = [];
					node.childNodes.forEach(function (item) {
						var obj = {};
						item._m = (widgetObj.count = widgetObj.count + 1) - 1;
						mappings[item._m] = item;
						if (item.nodeType == 1) {
							obj.type = "element";
							obj.tagName = item.tagName;
							var attrs = handleAttrs(item);
							obj.attrs = attrs;
							if (window.parentWrapperComps && window.parentWrapperComps.indexOf(item.tagName) != -1 && !item.children.length) {
								let initPropReturn = handleInitProperties(item, dataManipulation);
								obj.initProperties = initPropReturn.iP;
								obj.elementCnt = initPropReturn.eC;
								obj.initMethods = initPropReturn.iM;
							}
							obj.childNodes = iterateNodes(item, targetNode, widgetObj, dataManipulation);
						} else {
							obj.type = "node";
							obj.value = item.nodeValue;
							item._m = item._m || (widgetObj.count = widgetObj.count + 1) - 1;
						}
						childNodes.push(obj);
					});
					return childNodes;
				}
				var targetNode = widgetObj.shadow;
				var mappings = widgetObj.mappings;
				const config = {
						attributes: true,
						childList: true,
						subtree: true,
						characterData: true
					};
				var list = [];
				const callback = function (mutationsList, observer) {
						let refAttrObj = {};
						let dataManipulation = [];
						for (let mutation of mutationsList) {
							var shouldAdd = true;
							var obj = {};
							var target = mutation.target;
							target._m = target._m || widgetObj.count++;
							obj.target = target._m;
							obj.type = mutation.type;
							if (mutation.type === "childList") {
								obj.addNodes = [];
								obj.removedNodes = [];
								mutation.addedNodes.forEach(function (node) {
									if (!node._m) {
										if (node.nodeType == 1) {
											node._m = widgetObj.count++;
											mappings[node._m] = node;
											var attrs = handleAttrs(node);
											let initPropReturn = {};
											if (window.parentWrapperComps && window.parentWrapperComps.indexOf(node.tagName) != -1 && !node.children.length) {
												initPropReturn = handleInitProperties(node, dataManipulation);
											}
											let childNodeProcessed = iterateNodes(node, targetNode, widgetObj, dataManipulation);
											obj.addNodes.push({
												"type": "element",
												"tagName": node.tagName,
												"_m": node._m,
												"childNodes": childNodeProcessed,
												"prev": node.previousSibling ? node.previousSibling._m : undefined,
												"attrs": attrs,
												"initProperties": initPropReturn.iP,
												"initMethods": initPropReturn.iM,
												"elementCnt": initPropReturn.eC
											});
										} else {
											node._m = widgetObj.count++;
											mappings[node._m] = node;
											obj.addNodes.push({
												"type": "node",
												"value": node.nodeValue,
												"prev": node.previousSibling ? node.previousSibling._m : undefined
											});
										}
									} else {
										obj.addNodes.push({
											"type": "append",
											"_m": node._m
										});
									}
								});
								mutation.removedNodes.forEach(function (item) {
									iterateNodesDelete(item, widgetObj);
									obj.removedNodes.push({ "node": item._m });
									delete item._m;
								});
							} else if (mutation.type == "attributes") {
								var attr = target.attributes[mutation.attributeName];
								var tagObj = refAttrObj[target._m] = refAttrObj[target._m] || {};
								var attrObj = tagObj[mutation.attributeName];
								if (!attrObj && attr) {
									tagObj[mutation.attributeName] = true;
									obj.attributeName = mutation.attributeName;
									obj.attributeValue = target.attributes[mutation.attributeName].nodeValue;
								} else if (!attr) {
									obj.attributeName = mutation.attributeName;
									obj.remove = true;
									shouldAdd = true;
								}
							} else if (mutation.type == "characterData") {
								obj.value = target.nodeValue;
							}
							if (shouldAdd) {
								list.push(obj);
							}
						}
						if (!isWidgetBody) {
							window.parent.postMessage({
								"c": "1",
								"x": targetNode._id,
								"data": list,
								"timeStamp": +new Date()
							}, "*");
						} else {
							window.parent.postMessage({
								"c": "1",
								"x1": targetNode._id,
								"x2": targetNode._mX,
								"data": list,
								"timeStamp": +new Date()
							}, "*");
						}
						list = [];
						dataManipulation.forEach(function (item) {
							DataBindingLayer.removeIdsNew(item);
						});
					};
				var timeoutValue;
				const observer = new MutationObserver(callback);
				observer.observe(targetNode, config);
				widgetObj.observer = observer;
			}
			let _LyteComponent = await Lyte.Component;
			let _LC = await Lyte.__lc;
			;
			var __stack = [];
			var __stackStatus = 0;
			$Lt._gc.window.execStack1 = async function () {
				let currentStack = await __stack.shift();
				try {
					if (!(await currentStack.data && await (await currentStack.data).p == "2")) {
						__stackStatus = 1;
					}
					await eventHandlerChild(currentStack);
				} catch (e) {
					await $Lt._gc.console.error(e);
				}
				__stackStatus = 0;
				if (await __stack.length) {
					await $Lt._gc.window.execStack1();
				}
			};
			await $Lt._gc.window.addEventListener("error", errorFunction);
			await $Lt._gc.window.addEventListener("unhandledrejection", errorFunction);
			await $Lt._gc.window.addEventListener("message", async function (event) {
				await __stack.push(event);
				if (!__stackStatus) {
					await $Lt._gc.window.execStack1();
				}
			});
			$Lt._gc.window.childWidgetMappings = {};
			$Lt._gc.window.childBodyWidgetMappings = {};
			var bodyWidgetDiv = $Lt._gc.window.bodyWidgetDiv = await $Lt._gc.document.createElement("div");
			await $Lt._gc.document.addEventListener("DOMContentLoaded", async function () {
				await (await $Lt._gc.document.body).appendChild(bodyWidgetDiv);
			});
			window.makeChangesForChildWidget = function () {
				var protoGet = HTMLElement.prototype.getAttribute;
				HTMLElement.prototype.getAttribute = function (attrKey, attrValue) {
					if (!window._ignoreSetAttribute) {
						if (attrKey == "src" || attrKey == "href") {
							attrKey = "lyte-" + attrKey;
						}
					}
					return protoGet.call(this, attrKey);
				};
				var protoSet = HTMLElement.prototype.setAttribute;
				if (!oldProtoSet) {
					oldProtoSet = protoSet;
				}
				HTMLElement.prototype.setAttribute = function (attrKey, attrValue) {
					if (!window._ignoreSetAttribute) {
						if (attrKey == "src" || attrKey == "href") {
							attrKey = "lyte-" + attrKey;
						}
					}
					protoSet.apply(this, [
						attrKey,
						attrValue
					]);
				};
			};
			await $Lt._gc.window.makeChangesForChildWidget();
			var loadedWidgets = {};
			if (await $Lt._gc.window.isLyteWidget) {
				var bodyWidgetObj = {
						"shadow": await $Lt._gc.window.bodyShadow,
						"mappings": {},
						"count": 2
					};
				$Lt._gc.window.bodyShadowCount = 1;
				bodyWidgetObj._id = ((await (await $Lt._gc.$Lt._gc).window).bodyShadowCount = await (await (await $Lt._gc.$Lt._gc).window).bodyShadowCount + 1) - 1;
				(await $Lt._gc.window.childBodyWidgetMappings)[await bodyWidgetObj._id] = bodyWidgetObj;
				(await $Lt._gc.window.bodyShadow)._id = await bodyWidgetObj._id;
				(await $Lt._gc.window.bodyShadow)._m = 1;
				await $Lt._gcFn.setTimeout(async function () {
					await (await $Lt._gc.window.bodyShadow).appendChild(await $Lt._gc.document.createElement("div"));
				}, 3000);
				await initializeMutations(bodyWidgetObj, true);
				await $Lt._gc.document._addShadowForGlobalRegistry(await $Lt._gc.window.bodyShadow);
				$Lt._gc.window.initializeMutations = initializeMutations;
				await $Lt._gcFn.setTimeout(async function () {
					await (await $Lt._gc.window.parent).postMessage({ "c": "3" }, "*");
				}, 200);
			}
		}(Lyte);
		$Lt._cV("_LyteComponent", await Lyte.__lc, "let");
		$Lt._cV("oldQuerySelector", await $Lt._gc.document.querySelector, "var");
		$Lt._gc.document.querySelector = async function () {
			return await $Lt._gc.oldQuerySelector.apply(this, arguments);
		};
		$Lt._cV("oldDocumentEventListenerAdd", await $Lt._gc.document.addEventListener, "var");
		$Lt._cV("oldShadowEventListener", await (await $Lt._gc.ShadowRoot.prototype).addEventListener, "var");
		$Lt._cV("oldElementEventListenerAdd", await (await $Lt._gc.HTMLElement.prototype).addEventListener, "var");
		(await $Lt._gc.ShadowRoot.prototype).addEventListener = (await $Lt._gc.HTMLElement.prototype).addEventListener = $Lt._gc.document.addEventListener = async function () {
			var arr = await $Lt._gc.Array.from(arguments);
			var oldFunction = await arr[1];
			arr[1] = async function (event) {
				var eventObj = {};
				eventObj.target = event.target;
				eventObj.currentTarget = event.currentTarget;
				let proxyObj = $Lt._gc.$Lt ? await $Lt._gc.$Lt.oldProxy : $Lt._gc.Proxy;
				var eventProxy = await $Lt._cO(proxyObj, event, { "get": function (target, prop) {
							if (prop == "target" || prop == "currentTarget") {
								return eventObj[prop];
							} else if (typeof target[prop] == "function") {
								return function () {
									return target[prop].apply(target, arguments);
								};
							} else {
								return target[prop];
							}
						} });
				await oldFunction.apply(this, [eventProxy]);
			};
			(await arr[1])._oldF = oldFunction;
			oldFunction._newF = await arr[1];
			if (await $Lt._iO(this, $Lt._gc.ShadowRoot)) {
				return await $Lt._gc.oldShadowEventListener.apply(this, arr);
			} else {
				if (await arr[0] == "mouseenter") {
					return;
				}
				if (await $Lt._iO(this, $Lt._gc.HTMLElement)) {
					return await $Lt._gc.oldElementEventListenerAdd.apply(this, arr);
				} else {
					return await $Lt._gc.oldDocumentEventListenerAdd.apply(this, arr);
				}
			}
		};
		$Lt._cV("oldDocumentEventListenerRemove", await $Lt._gc.document.removeEventListener, "let");
		$Lt._cV("oldShadowEventListenerRemove", await (await $Lt._gc.ShadowRoot.prototype).removeEventListener, "let");
		$Lt._cV("oldElementEventListenerRemove", await (await $Lt._gc.HTMLElement.prototype).removeEventListener, "let");
		(await $Lt._gc.ShadowRoot.prototype).removeEventListener = (await $Lt._gc.HTMLElement.prototype).removeEventListener = $Lt._gc.document.removeEventListener = async function () {
			var arr = await $Lt._gc.Array.from(arguments);
			if (!await arr[0] || !await arr[1]) {
				await $Lt._gc.console.error("Remove Event Listener params not working");
				return;
			}
			arr[1] = await (await arr[1])._newF;
			if (await $Lt._iO(this, $Lt._gc.ShadowRoot)) {
				return await $Lt._gc.oldShadowEventListenerRemove.apply(this, arr);
			} else if (await $Lt._iO(this, $Lt._gc.HTMLElement)) {
				return await $Lt._gc.oldElementEventListenerRemove.apply(this, arr);
			} else {
				return await $Lt._gc.oldDocumentEventListenerRemove.apply(this, arr);
			}
		};
		$Lt._cV("wrapper", await (await Lyte.$).widgetWrapper, "let");
		await (await $Lt._gc.document.body).appendChild($Lt._gc.wrapper);
		if (await $Lt._gc.window.docEventListenerHandler) {
			await (await $Lt._gc.window.docEventListenerHandler).attachShadow(await $Lt._gc.wrapper.shadowRoot);
		}
		await (await (await $Lt._gc._LyteComponent.shadow).shadowList).push(await $Lt._gc.wrapper.shadowRoot);
		(await $Lt._gc.wrapper.shadowRoot)._shadowChild = [];
		(await $Lt._gc.wrapper.shadowRoot)._lyteShadow = true;
		(await $Lt._gc.wrapper.shadowRoot)._compList = [];
		(await $Lt._gc.wrapper.shadowRoot)._duplicateStyle = [];
		(await $Lt._gc.wrapper.shadowRoot)._linkRef = [];
		$Lt._gc.wrapper.instantiated = true;
		await (await $Lt._gc._LyteComponent.shadow).attachEvents(await $Lt._gc.wrapper.shadowRoot);
		await $Lt._gcFn.defProp(await $Lt._gc.HTMLElement.prototype, "getData", {
			configurable: true,
			writable: true,
			value: async function (arg0) {
				if (await this.$data) {
					if (arg0) {
						return await (await this.$data)[arg0];
					} else {
						return await this.$data;
					}
				}
				if (await this._initProperties) {
					if (arg0) {
						return await (await this._initProperties)[arg0];
					} else {
						return await this._initProperties;
					}
				}
			}
		});
		(async function () {
			if (!window.isLyteWidget) {
				return;
			}
			var getPrototypeOf = Object.getPrototypeOf;
			function replaceFuncCons(func) {
				var proto = getPrototypeOf(func);
				if (proto) {
					proto.constructor = function () {
						return function () {
						};
					};
				}
			}
			replaceFuncCons(function a() {
			});
			replaceFuncCons(function* b() {
			});
			replaceFuncCons(async function c() {
			});
			replaceFuncCons(async function* d() {
			});
			var __window = window;
			const builtInObjs = [
					"AggregateError",
					"Array",
					"ArrayBuffer",
					"BigInt",
					"BigInt64Array",
					"BigUint64Array",
					"Boolean",
					"DataView",
					"Date",
					"Error",
					"EvalError",
					"FinalizationRegistry",
					"Float32Array",
					"Float64Array",
					"Function",
					"Int16Array",
					"Int32Array",
					"Int8Array",
					"Map",
					"Number",
					"Object",
					"Promise",
					"Proxy",
					"RangeError",
					"ReferenceError",
					"Reflect",
					"RegExp",
					"Set",
					"SharedArrayBuffer",
					"String",
					"Symbol",
					"SyntaxError",
					"TypedArray",
					"TypeError",
					"Uint16Array",
					"Uint32Array",
					"Uint8Array",
					"Uint8ClampedArray",
					"URIError",
					"WeakMap",
					"WeakRef",
					"WeakSet",
					"WebAssembly"
				];
			const cloneOpts = {
					"Selection": {
							"type": "Selection",
							"readProps": [
								"anchorOffset",
								"baseOffset",
								"extentOffset",
								"focusOffset",
								"isCollapsed",
								"rangeCount",
								"type"
							],
							"writeProps": [],
							"cloneProps": [
								"anchorNode",
								"basNode",
								"extentNode",
								"focusNode"
							],
							"functions": [],
							"copyClone": true
						},
					"Component": {
						"type": "Component",
						"readProps": [
							"data",
							"$"
						],
						"writeProps": [],
						"cloneProps": ["$node"],
						"functions": [
							"getData",
							"getMethods",
							"setData",
							"setMethods",
							"executeMethod",
							"throwEvent"
						],
						"copyClone": true
					},
					"Window": {
						"type": "Window",
						"class": window,
						"targetProps": [
							"setTimeout",
							"setInterval"
						],
						"readProps": [
							"Component",
							"JSON",
							"Promise",
							"Lyte",
							"closed",
							"console",
							"document",
							"devicePixel",
							"innerHeight",
							"innerWidth",
							"length",
							"name",
							"outerHeight",
							"outerWidth",
							"Math"
						],
						"writeProps": [
							"$Lt",
							"__LCObj",
							"__lyteWidget",
							"__getClone__",
							"__winproxy"
						],
						"cloneProps": [
							"location",
							"navigator",
							"console",
							"event",
							"Node"
						],
						"functions": [
							"fetch",
							"addEventListener",
							"getSelection",
							"unescape",
							"clearInterval",
							"clearTimeout",
							"alert",
							"prompt",
							"confirm",
							"print",
							"prop",
							"getComputedStyle"
						],
						"copyClone": false
					},
					"Document": {
						"type": "Document",
						"class": document,
						"isNode": true,
						"readProps": [
							"__window",
							"characterSet",
							"compatMode",
							"contentType",
							"doctype",
							"designMode",
							"documentElement",
							"visibilityState",
							"designMode",
							"head",
							"title",
							"readyState",
							"lastModified",
							"visibilityState",
							"hidden",
							"screenX",
							"screenY",
							"screenLeft",
							"screenTop",
							"scrollX",
							"scrollY",
							"status",
							"btoa",
							"atob",
							"screen",
							"nodeType"
						],
						"readLocalProps": [""],
						"readLocalFunctions": [
							"querySelector",
							"querySelectorAll",
							"getElementById",
							"getElementsByTagName",
							"getElementsByClassName",
							"getElementsByName"
						],
						"writeProps": [
							"__window",
							"__getClone__"
						],
						"cloneProps": [
							"body",
							"implementation",
							"location",
							"head"
						],
						"functions": [
							"addEventListener",
							"createAttribute",
							"createCDATASection",
							"createComment",
							"createDocumentFragment",
							"createElement",
							"createEvent",
							"createNodeIterator",
							"createTextNode",
							"createTreeWalker",
							"getElementById",
							"getElementsByClassName",
							"getElementsByTagNameNS",
							"getElementsByName",
							"getElementsByTagName",
							"hasFocus",
							"querySelector",
							"querySelectorAll",
							"removeEventListener"
						],
						"copyClone": false
					},
					"Node": {
						"type": "Node",
						"class": Node,
						"isNode": true,
						"readProps": [
							"align",
							"title",
							"lang",
							"translate",
							"dir",
							"dataset",
							"hidden",
							"tabIndex",
							"accessKey",
							"draggable",
							"spellcheck",
							"autocapitalize",
							"contentEditable",
							"isContentEditable",
							"inputMode",
							"offsetParent",
							"offsetTop",
							"offsetLeft",
							"offsetWidth",
							"offsetHeight",
							"style",
							"innerText",
							"outerText",
							"nonce",
							"namespaceURI",
							"innerHTML",
							"outerHTML",
							"prefix",
							"nodeValue",
							"textContent",
							"localName",
							"tagName",
							"id",
							"className",
							"classList",
							"scrollTop",
							"scrollLeft",
							"scrollWidth",
							"scrollHeight",
							"clientTop",
							"clientLeft",
							"clientWidth",
							"clientHeight",
							"lookupPrefix",
							"lookupNamespaceURI",
							"isDefaultNamespace",
							"isConnected",
							"baseURI",
							"nodeType",
							"nodeName"
						],
						"writeProps": [],
						"cloneProps": [
							"component",
							"children",
							"firstChild",
							"firstElementChild",
							"lastChild",
							"parentNode",
							"previousSibling",
							"nextSibling",
							"lastElementChild",
							"childNodes"
						],
						"functions": [
							"setData",
							"cloneNode",
							"appendChild",
							"addEventListener",
							"setMethods",
							"scrollIntoViewIfNeeded",
							"scrollIntoView",
							"webkitMatchesSelector",
							"matches",
							"getClientRects",
							"getBoundingClientRect",
							"hasAttributes",
							"getAttributeNames",
							"getAttribute",
							"getAttributeNS",
							"hasAttribute",
							"hasAttributeNS",
							"setAttribute",
							"setAttributeNS",
							"removeAttribute",
							"removeAttributeNS",
							"toggleAttribute",
							"querySelector",
							"querySelectorAll",
							"getElementById",
							"getElementsByName",
							"getElementsByClassName",
							"getElementsByTagName"
						],
						"copyClone": true,
						"instance": { "property": { nodeName: {
									equals: [
											"BODY",
											"HEAD",
											"HTML"
										],
									allowedMethods: [
										"appendChild",
										"removeChild",
										"addEventListener",
										"removeEventListener",
										"dispatchEvent"
									],
									allowSet: false,
									allowGet: true
								} } }
					},
					"NodeTop": {
						"type": "Node",
						"readProps": [
							"align",
							"title",
							"lang",
							"translate",
							"dir",
							"dataset",
							"hidden",
							"tabIndex",
							"accessKey",
							"draggable",
							"spellcheck",
							"autocapitalize",
							"contentEditable",
							"isContentEditable",
							"inputMode",
							"offsetParent",
							"offsetTop",
							"offsetLeft",
							"offsetWidth",
							"offsetHeight",
							"style",
							"innerText",
							"outerText",
							"nonce",
							"namespaceURI",
							"innerHTML",
							"outerHTML",
							"prefix",
							"nodeValue",
							"textContent",
							"localName",
							"tagName",
							"id",
							"className",
							"classList",
							"scrollTop",
							"scrollLeft",
							"scrollWidth",
							"scrollHeight",
							"clientTop",
							"clientLeft",
							"clientWidth",
							"clientHeight",
							"lookupPrefix",
							"lookupNamespaceURI",
							"isDefaultNamespace",
							"isConnected",
							"baseURI",
							"nodeType",
							"nodeName"
						],
						"functions": [
							"appendChild",
							"removeChild",
							"addEventListener",
							"removeEventListener",
							"dispatchEvent"
						],
						"writeProps": [],
						"cloneProps": [
							"component",
							"children",
							"firstChild",
							"firstElementChild",
							"lastChild",
							"parentNode",
							"previousSibling",
							"nextSibling",
							"lastElementChild",
							"childNodes"
						]
					},
					"Event": {
						"type": "Event",
						"readProps": [
							"cancelBubble",
							"returnValue",
							"composed",
							"timeStamp",
							"defaultPrevented",
							"cancelable",
							"bubbles",
							"eventPhase",
							"type",
							"NONE",
							"CAPTURING_PHASE",
							"AT_TARGET",
							"BUBBLING_PHASE",
							"which",
							"sourceCapabilities",
							"isTrusted",
							"screenX",
							"screenY",
							"clientX",
							"clientY",
							"ctrlKey",
							"shiftKey",
							"altKey",
							"metaKey",
							"button",
							"buttons",
							"pageX",
							"pageY",
							"x",
							"y",
							"offsetX",
							"offsetY",
							"movementX",
							"movementY",
							"layerX",
							"layerY",
							"view",
							"detail"
						],
						"writeProps": ["cancelBubble"],
						"cloneProps": [
							"relatedTarget",
							"fromElement",
							"toElement",
							"srcElement",
							"currentTarget",
							"target"
						],
						"functions": [
							"getModifierState",
							"initMouseEvent",
							"toLocaleString",
							"propertyIsEnumerable",
							"preventDefault",
							"initEvent",
							"stopPropagation",
							"stopImmediatePropagation",
							"initUIEvent"
						],
						"copyClone": true
					},
					"Location": {
						"type": "Location",
						"readProps": [
							"href",
							"host",
							"hostname"
						],
						"writeProps": [],
						"cloneProps": [],
						"functions": [],
						"copyClone": true
					},
					"Navigator": {
						"type": "Navigator",
						"readProps": ["userAgent"],
						"writeProps": [],
						"cloneProps": ["connection"],
						"functions": [],
						"copyClone": true
					},
					"Connection": {
						"type": "Connection",
						"readProps": ["effectiveType"],
						"writeProps": [],
						"cloneProps": [],
						"functions": [],
						"copyClone": true
					},
					"Console": {
						"type": "Console",
						"readProps": [
							"log",
							"error",
							"time",
							"timeEnd",
							"warn"
						],
						"writeProps": [],
						"cloneProps": [],
						"functions": [],
						"copyClone": true
					},
					"Implementation": {
						"type": "Implementation",
						"readProps": [],
						"writeProps": [],
						"cloneProps": [],
						"functions": [
							"createDocument",
							"createDocumentType",
							"createHTMLDocument",
							"hasFeature"
						],
						"copyClone": true
					}
				};
			builtInObjs.forEach(function (itm) {
				if (!cloneOpts.hasOwnProperty(itm)) {
					cloneOpts[itm] = {
						type: itm,
						class: window[itm],
						readProps: "*",
						writeProps: [],
						cloneProps: [],
						functions: []
					};
				}
			});
			cloneOpts.Window.cloneProps = cloneOpts.Window.cloneProps.concat(builtInObjs);
			const mapOpts = {
					checkIfWidgetNode: { Document: { methods: [
									"querySelector",
									"querySelectorAll",
									"getElementById",
									"getElementsByTagName",
									"getElementsByClassName",
									"getElementsByTagNameNS",
									"getElementsByName"
								] } },
					saveInWidgets: { Node: { methods: [""] } },
					getCloneFromMap: { Node: { methods: [""] } },
					Document: {
						querySelector: { checkIfWidgetNode: true },
						querySelectorAll: { checkIfWidgetNode: true },
						getElementById: { checkIfWidgetNode: true },
						getElementsByTagName: { checkIfWidgetNode: true },
						getElementsByClassName: { checkIfWidgetNode: true },
						getElementsByTagNameNS: { checkIfWidgetNode: true },
						getElementsByName: { checkIfWidgetNode: true }
					},
					Node: {
						append: { saveInWidgets: true },
						appendChild: { getFromCloneMap: { arguments: [0] } },
						createDocumentFragment: { saveInWidgets: true },
						createElementNS: { saveInWidgets: true },
						createComment: { saveInWidgets: true },
						createCDATASection: { saveInWidgets: true },
						createAttribute: { saveInWidgets: true },
						cloneNode: { saveInWidgets: true },
						removeChild: { getFromCloneMap: { arguments: [0] } },
						replaceChild: { getFromCloneMap: { arguments: [
									0,
									1
								] } },
						isSameNode: { getFromCloneMap: { arguments: [0] } },
						isEqualNode: { getFromCloneMap: { arguments: [0] } },
						insertBefore: { getFromCloneMap: { arguments: [
									0,
									1
								] } },
						compareDocumentPosition: { getFromCloneMap: { arguments: [0] } },
						contains: { getFromCloneMap: { arguments: [0] } },
						insertAdjacentElement: { getFromCloneMap: { arguments: [1] } },
						dispatchEvent: { getFromCloneMap: { arguments: [0] } }
					}
				};
			const addEv = Node.prototype.addEventListener;
			const proxyObj = window.Proxy;
			Object.defineProperty(cloneOpts, "__cloneReturn", { value: false });
			function defProp(obj, key, val) {
				Object.defineProperty(obj, key, { value: val });
			}
			const handler = { get: function (obj, prop) {
						return (prop in obj) ? obj[prop] : undefined;
					} };
			var widgetUtils = {
					"querySingle": async function (self, prop, arg1) {
							let shadows = widgetShadows.get(self.widgetName) || [];
							for (let i = 0; i < shadows.length; i++) {
								let retVal = shadows[i][prop](arg1);
								if (retVal) {
									return retVal;
								}
							}
							let additionalComps = await self.additionalComps.toArrayLyte();
							for (let i = 0; i < additionalComps.length; i++) {
								let retVal;
								if (prop == "getElementById") {
									retVal = additionalComps[i].querySelectorAll("#" + arg1)[0];
								} else {
									retVal = additionalComps[i][prop](arg1);
								}
								if (retVal) {
									return retVal;
								}
							}
						},
					"queryMultiple": async function (self, prop, arg1) {
						let retVal = [];
						let shadows = widgetShadows.get(self.widgetName) || [];
						for (let i = 0; i < shadows.length; i++) {
							retVal.push.apply(retVal, Array.from(shadows[i][prop](arg1)));
						}
						let additionalComps = await self.additionalComps.toArrayLyte();
						for (let i = 0; i < additionalComps.length; i++) {
							retVal.push.apply(retVal, Array.from(additionalComps[i][prop](arg1)));
						}
						return retVal;
					}
				};
			class Widget {
				static addEventListener(eventName, func, options, widgetName, listenerId) {
					let listenerArr = this._globalEventHandler.listeners[eventName] = this._globalEventHandler.listeners[eventName] || [];
					listenerArr.push({
						"func": func,
						"options": options,
						"widget": widgetName,
						"id": listenerId
					});
					return listenerId;
				}
				static triggerEvent(eventName, data, options, widgetName) {
					let listenerArr = this._globalEventHandler.listeners[eventName];
					if (!listenerArr) {
						return;
					}
					let triggerNamespaces = options.target;
					let triggerComponentsMap = options.components || {};
					if (!triggerNamespaces.length) {
						console.log("There are no namespaces provided.");
						return;
					}
					let triggerAllListeners = triggerNamespaces == "*" ? true : false;
					listenerArr.forEach(function (listener) {
						try {
							let execute = false;
							let listenerComponent = listener.options.componentName;
							let listenerNamespaces = listener.options.origin;
							if (triggerAllListeners) {
								if (listenerNamespaces.indexOf("*") != -1 || listenerNamespaces.indexOf(widgetName) != -1) {
									execute = true;
								}
							} else {
								if (triggerNamespaces.indexOf(listener.widget) != -1) {
									if (listenerNamespaces == "*" || listenerNamespaces.indexOf(widgetName) != -1) {
										execute = true;
									}
								}
							}
							if (execute) {
								if (triggerComponentsMap.hasOwnProperty(listener.widget)) {
									if (triggerComponentsMap[listener.widget].indexOf(listenerComponent) != -1) {
										listener.func.call(Widget._widgetInstances[listener.widget].win_prox, data);
									}
								} else {
									listener.func.call(Widget._widgetInstances[listener.widget].win_prox, data);
								}
							}
						} catch (e) {
						}
					});
				}
				static removeEventListener(listenerId, widgetName) {
					let listenerIdSplits = listenerId.split("-");
					let listenerWidgetName = listenerIdSplits[0];
					let listenerEventName = listenerIdSplits[2];
					if (listenerWidgetName && listenerWidgetName === widgetName) {
						let listenerArr = this._globalEventHandler.listeners[listenerEventName];
						for (let i = listenerArr.length - 1; i >= 0; i--) {
							let item = listenerArr[i];
							if (item.id == listenerId) {
								listenerArr.splice(i, 1);
								return true;
							}
						}
					}
					console.log("Listener ID provided is not available");
					return false;
				}
				constructor(widgetName, widIns, compName) {
					this.eventCounter = 1;
					this.additionalComps = new Set();
					this.windowProps = new Map();
					this.widgetName = widgetName;
					this.doc_prox = this.getClone(widIns ? widIns.doc_prox : document, undefined, true, undefined, widIns ? "Document" : undefined);
					this.doc_prox.widgetInstances = [];
					this.win_prox = this.getClone(widIns ? widIns.win_prox : window, this.doc_prox, true, undefined, widIns ? "Window" : undefined, widgetName, compName);
					this.nodes = new WeakMap();
					this.components = new Map();
					Widget._widgetInstances[widgetName] = this;
				}
				destroy(fromRemove) {
					this.components.forEach(function (value, comp) {
						comp.remove();
					});
					if (fromRemove) {
						return this.destroyInstance();
					}
				}
				destroyInstance() {
					let promObj = {};
					var promise = new Promise(function (resolve, reject) {
							promObj.resolve = resolve;
							promObj.reject = reject;
						});
					widgetMap.delete(this.widgetName);
					widgetScopeMap.delete(this.widgetName);
					widgetShadows.delete(this.widgetName);
					var widgetComps = window.widgetComps ? window.widgetComps[this.widgetName] : [];
					setTimeout(function () {
						let arr = [];
						for (var i = 0; i < widgetComps.length; i++) {
							arr.push(Lyte.Component.unregisterComponent(widgetComps[i], { "__forceRemove": true }));
						}
						Promise.resolve(arr).then(function () {
							promObj.resolve();
						});
					}, 100);
					this.windowProps = this.widgetName = this.doc_prox = this.win_prox = this.nodes = this.components = $Lt._gc.undefined;
					if (!widgetMap.size) {
						var config = widgetConfig;
						var keepAlive = widgetConfig && widgetConfig[this.widgetName] && widgetConfig[this.widgetName].hasOwnProperty("keepAlive") ? widgetConfig[this.widgetName].keepAlive : true;
						!keepAlive ? window.parent.postMessage({ "c": "6" }) : undefined;
					}
					return promise;
				}
				removeComponent(ins) {
					this.components.delete(ins);
					if (!this.components.size) {
						var config = widgetConfig ? widgetConfig[this.widgetName] : undefined;
					}
				}
				static getCloneType(item) {
					var cloneType;
					if (item === window.$L) {
						cloneType = "LyteDom";
					} else if (item && item.__isComponent__) {
						cloneType = "Component";
					} else if (item instanceof Event) {
						cloneType = "Event";
					} else if (item instanceof Document) {
						cloneType = "Document";
					} else if (item instanceof Navigator) {
						cloneType = "Navigator";
					} else if (item instanceof Location) {
						cloneType = "Location";
					} else if (item == console) {
						cloneType = "Console";
					} else if (item instanceof DOMImplementation) {
						cloneType = "Implementation";
					} else if (item instanceof Selection) {
						cloneType = "Selection";
					} else if (item instanceof Element || item instanceof Text || item instanceof DocumentFragment) {
						if ((/^(HTML|HEAD|BODY)$/).test(item.nodeName)) {
							cloneType = "NodeTop";
						} else {
							cloneType = "Node";
						}
					} else if (item instanceof Window || item.__winproxy) {
						cloneType = "Window";
					} else if (item instanceof NodeList || item instanceof HTMLCollection || item instanceof HTMLAllCollection) {
						cloneType = "NodeArr";
					} else {
						var len = builtInObjs.length;
						for (var i = 0; i < len; i++) {
							var itm = builtInObjs[i];
							if (item instanceof window[itm]) {
								return itm;
							}
						}
					}
					return cloneType;
				}
				deepCopyObject(obj) {
					var targetVal = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
					var current, copies = [{
								source: obj,
								target: targetVal
							}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];
					var cloneObject = copies[0].target, targetReferences = [cloneObject];
					while (current = copies.shift()) {
						keys = Object.keys(current.source);
						for (propertyIndex = 0; propertyIndex < keys.length; propertyIndex++) {
							descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
							if (!descriptor) {
								continue;
							}
							if (!descriptor.value || typeof descriptor.value != "object") {
								Object.defineProperty(current.target, keys[propertyIndex], descriptor);
								continue;
							}
							nextSource = descriptor.value;
							descriptor.value = Array.isArray(nextSource) ? [] : nextSource instanceof Set ? new Set() : Object.create(Object.getPrototypeOf(nextSource));
							indexOf = sourceReferences.indexOf(nextSource);
							if (indexOf != -1) {
								descriptor.value = targetReferences[indexOf];
								Object.defineProperty(current.target, keys[propertyIndex], descriptor);
								continue;
							}
							sourceReferences.push(nextSource);
							targetReferences.push(descriptor.value);
							Object.defineProperty(current.target, keys[propertyIndex], descriptor);
							copies.push({
								source: nextSource,
								target: descriptor.value
							});
						}
					}
					return cloneObject;
				}
				getProxy(obj, def) {
					if (proxyObj) {
						return new Lyte.oldProxy(obj, def);
					} else {
						var newObj = Object.create(null);
						var keys = getAllProps(obj);
						keys.forEach(function (key, index) {
							var confObj = {};
							if (def.get) {
								confObj.get = function () {
									return def.get(obj, key, newObj);
								};
							}
							if (def.set) {
								confObj.set = function () {
									return def.set(obj, key, newObj);
								};
							}
							Object.defineProperty(newObj, key, confObj);
						});
						return newObj;
					}
				}
				static getAllProps(obj) {
					var keys = [];
					while (obj) {
						obj = Object.getOwnPropertyNames(obj);
						for (var i = 0; i < obj.length; i++) {
							if (keys.indexOf(i) === -1) {
								keys.push(i);
							}
						}
						obj = Object.getPrototypeOf(obj);
					}
					return keys;
				}
				setNodes(nodes) {
					var len = nodes.length;
					for (var i = 0; i < len; i++) {
						this.nodes.set(nodes[i], true);
						this.setNodes(nodes[i].childNodes);
					}
				}
				filterWidgetNodes(data) {
					if (data instanceof NodeList || data instanceof HTMLCollection) {
						var arr = [];
						for (var itm of data) {
							if (this.isWidgetNode(itm)) {
								arr.push[itm];
							}
						}
						return arr;
					} else if (data) {
						if (this.isWidgetNode(data)) {
							return data;
						}
					}
				}
				isWidgetNode(node) {
					return (/^(HTML|HEAD|BODY)$/).test(node.nodeName) || this.nodes.has(node) || this.isComponentNode(node);
				}
				isComponentNode(node) {
					var components = this.components;
					for (var val of components) {
						var cmp = val[0];
						if (!cmp.compareDocumentPosition(node) % 2) {
							return true;
						}
					}
					return false;
				}
				getClone(item, doc, forceClone, scope, type, widgetName, compName) {
					if (!item) {
						return;
					}
					var cloneType = type || Widget.getCloneType(item), commonScp;
					if (!cloneType) {
						return item;
					}
					if (item.__clone__ && !forceClone) {
						return item.__clone__;
					}
					if (cloneType == "NodeArr") {
						if (item instanceof NodeList || item instanceof HTMLAllCollection || item instanceof HTMLCollection) {
							var newRet = [];
							for (var i = 0; i < item.length; i++) {
								let clnType = Widget.getCloneType(item[i]);
								newRet[i] = clnType ? this.getClone(item[i]) : item[i];
							}
							return newRet;
						} else if (item instanceof Object) {
							let clnType = Widget.getCloneType(item);
							return clnType ? this.getClone(item) : item;
						}
						return item;
					}
					var obj = {};
					if (cloneType == "Window") {
						var itemDetails = cloneOpts[cloneType];
						for (var key in itemDetails) {
							var props = itemDetails[key];
							if (Array.isArray(props)) {
								props.forEach(function (itm, idx) {
									obj[itm] = item[itm];
								});
							}
						}
						obj.document = doc;
						var globalEvents = Lyte.__lyteRegisteredEventsGlobal;
						this.__frameLyte = this.Lyte = this.deepCopyObject(Lyte);
						let widgetConfig = Lyte.getConfig("widget") || {};
						let windowProps = widgetConfig.windowProps || {};
						var selfVal = this;
						Object.keys(windowProps).forEach(function (item) {
							Object.defineProperty(selfVal, item, {
								"get": function () {
										return windowProps[item].get(widgetName, compName);
									},
								"set": function () {
									return windowProps[item].set(widgetName, compName);
								}
							}, true);
						});
						this.Lyte.__lyteRegisteredEventsGlobal = globalEvents;
						Object.defineProperty(this.Lyte.$, "__Lyte__", { value: this.Lyte });
						this.Lyte.__widget = this.widgetName;
						this.Lyte.registeredMixins = {};
						this.Lyte.registeredServices = {};
						this.Lyte.requiredServices = {};
						this.Lyte.toBeInjectedServices = {};
						this.Lyte.requiredMixins = {};
						this.Lyte.getWidgetScope = undefined;
						var self = this;
						this.Lyte.injectServices = function (data) {
							var toInjectService = function (name, key) {
									var registeredComponents = self.components;
									for (var comp of registeredComponents) {
										var component = comp[0];
										component.component.prototype[key] = self.Lyte.registeredServices[name];
									}
								};
							data.forEach(function (itm) {
								if (itm && typeof itm == "object") {
									for (var key in itm) {
										self.Lyte.toBeInjectedServices[key] = itm[key];
										toInjectService(itm[key], key);
									}
								} else if (itm) {
									self.Lyte.toBeInjectedServices[itm] = itm;
									toInjectService(itm, itm);
								}
							});
						};
						Object.defineProperty(this.Lyte.Service, "__Lyte__", { value: this.Lyte });
						Object.defineProperty(this.Lyte.Mixin, "__Lyte__", { value: this.Lyte });
						obj.Lyte = this.Lyte;
						obj.$Lt = this.$Lt = {
							oldProxy: $Lt.oldProxy,
							"__defaultProps": $Lt.__defaultProps
						};
						obj.$Lt._iO = function (instance, constr) {
							var instance = prxWkMap.get(instance) || instance;
							if (constr.constructor.name == "AsyncFunction") {
								if (constr._lyteNF) {
									return instance instanceof constr._lyteNF;
								} else {
									return false;
								}
							} else {
								return instance instanceof constr;
							}
						};
						obj.document = this.doc_prox;
						obj.document.__window = obj.window;
						obj.__lyteWidget = this.widgetName;
						obj.eval = function (obj) {
							function safeEval(args) {
								const sbox = sandbox(obj);
								return sbox(args);
							}
							return safeEval;
						}(obj);
						obj.Function = function (obj) {
							function safeFunction(...args) {
								const fDef = args.pop();
								const fArgs = args.join(",");
								try {
									new Function(...args, fDef);
								} catch (exp) {
									console.error(exp);
								}
								const f = "(function(" + fArgs + "){" + fDef + "})";
								const evFn = obj.window.eval;
								return evFn(f);
							}
							return safeFunction;
						}(obj);
						obj.setTimeout = function (cBack, time) {
							var args = Array.prototype.slice.call(arguments, 0);
							return setTimeout.apply(window, [
								function () {
									typeof cBack == "function" ? cBack.apply(obj.window, args) : undefined;
								},
								time
							]);
						};
						obj.setInterval = function (cBack, time) {
							var args = Array.prototype.slice.call(arguments, 0);
							return setInterval.apply(window, [
								function () {
									typeof cBack == "function" ? cBack.apply(obj.window, args) : undefined;
								},
								time
							]);
						};
						var tar = prxWkMap.get(item);
						commonScp = tar && tar.__lyteWidget == "__common__" ? item : undefined;
						this.win = item = obj;
					}
					var ret = this.ItemClone(item, cloneType, scope, commonScp);
					if (cloneType == "Window") {
						obj.document._window = ret;
						obj.self = obj.window = ret;
						obj.document.__getClone__ = obj.window.__getClone__ = this.getClone;
					}
					cloneType == "Window" ? ret.__winproxy = true : undefined;
					return ret;
				}
				ItemClone(item, type, scope, commonScp) {
					let dummyObj = Object.create(null), _cloneOpts = scope || cloneOpts, itemDetails = _cloneOpts[type], isWindow = type == "Window";
					let self = this, isNode = itemDetails.isNode;
					let handlers = {
							"get": function (target, prop, receiver) {
									var selfVal = this;
									var mapObj = mapOpts[itemDetails.type], clnMap, result;
									if (mapObj && mapObj.hasOwnProperty(prop)) {
										clnMap = mapObj[prop];
									}
									if (type == "Window") {
										let widgetConfig = Lyte.getConfig("widget");
										let windowPropsFromConfig;
										if (widgetConfig && (windowPropsFromConfig = widgetConfig.windowProps)) {
											windowPropsFromConfig = Object.keys(windowPropsFromConfig);
										}
										if (windowPropsFromConfig && windowPropsFromConfig.indexOf(prop) != -1) {
											return self[prop];
										}
									}
									if (type == "Window" && (prop == "__frameLyte" || prop == "$Lt" || prop == "Lyte") && self[prop]) {
										if (prop == "__frameLyte") {
											return self["Lyte"];
										} else if (prop == "Lyte") {
											return undefined;
										}
										return self[prop];
									} else if (type == "Window" && (itemDetails.targetProps.indexOf(prop) != -1 || (prop == "self" || prop == "window"))) {
										return target[prop];
									} else if (itemDetails.cloneProps.indexOf(prop) != -1) {
										result = self.getClone(target[prop]);
									} else if ((Array.isArray(itemDetails.readProps) ? itemDetails.readProps.indexOf(prop) != -1 : itemDetails.readProps == "*") || itemDetails.writeProps.indexOf(prop) != -1) {
										result = (type == "Window" || target.__winproxy) && prop != "document" ? window[prop] : type == "Document" ? document[prop] : target[prop];
									} else if (isWindow && (Array.isArray(itemDetails.readProps) ? itemDetails.readProps.indexOf(prop) == -1 : itemDetails.readProps != "*") && itemDetails.cloneProps.indexOf(prop) == -1 && itemDetails.functions.indexOf(prop) == -1 && self.windowProps.get(prop)) {
										result = target[prop];
									} else if (itemDetails.functions.indexOf(prop) != -1) {
										if ((/^(Window|Document|Node)$/).test(itemDetails.type) && prop == "addEventListener") {
											return function (type, callback, options) {
												if (typeof callback != "function" && typeof callback != "object") {
													throw new SyntaxError("Failed to execute 'addEventListener' on 'EventTarget': parameter 2 is not of type 'Object'");
												}
												var context1 = itemDetails.type == "Window" ? __window : itemDetails.type == "Document" ? document : target;
												addEv.call(context1, type, function (ev) {
													var context2 = itemDetails.class == "Window" ? target.__clone__ : self.getClone(this);
													callback.call(context2, self.getClone(ev));
												}, options);
											};
										} else {
											return async function (arg1) {
												if (type == "Document" && itemDetails.readLocalFunctions.indexOf(prop) != -1) {
													switch (prop) {
													case "getElementById":
													case "querySelector": {
															return widgetUtils.querySingle(self, prop, arg1);
														}
													case "querySelectorAll": {
															return widgetUtils.queryMultiple(self, prop, arg1);
														}
													case "getElementsByTagName":
													case "getElementsByClassName":
													case "getElementsByName":
														console.log(prop + " is not supported in Widget");
														return;
													}
												}
												var args = arguments;
												if (clnMap && clnMap.getFromCloneMap) {
													var arr = clnMap.getFromCloneMap.arguments;
													if (arr) {
														arr.forEach(function (itm) {
															var targ = args[itm];
															args[itm] = prxWkMap.get(targ);
														});
													}
												}
												if (type == "Document" && prop == "createElement") {
													_LyteComponent.currentWidget = self.widgetName;
												}
												let retVal = type == "Window" ? await window[prop].apply(window, args) : type == "Document" ? await document[prop].apply(document, args) : await target[prop].apply(target, args);
												if (type == "Document" && prop == "createElement") {
													delete _LyteComponent.currentWidget;
												}
												if (isNode && clnMap && clnMap.saveInWidgets) {
													self.setNodes(retVal);
												}
												if (clnMap && clnMap.checkIfWidgetNode) {
													retVal = self.filterWidgetNodes(retVal);
												}
												if (type == "Component" && prop == "getData") {
													return retVal;
												}
												if (typeof retVal == "object" && !(retVal instanceof Promise) || typeof retVal == "function") {
													retVal = self.getClone(retVal);
												}
												return retVal;
											};
										}
									} else if (type == "Window" && window.$Lt && window.$Lt.isVarDeclarationVariable(prop)) {
										result = window[prop] || result;
									} else if (type == "Window" && window.$Lt && window.$Lt.isConstDeclarationVariable(prop)) {
										result = window.$Lt._gc[prop];
									} else if (itemDetails && itemDetails.type == "Component" && (target.constructor.prototype[prop] || target[prop])) {
										return target[prop];
									}
									return result;
								}.bind({
									window: window,
									document: document
								}),
							"set": function (target, key, value) {
								if (type == "Window" && key == "$Lt") {
									target[key] = value;
									this[key] = value;
								} else if (isWindow && (Array.isArray(itemDetails.readProps) ? itemDetails.readProps.indexOf(key) == -1 : itemDetails.readProps != "*") && itemDetails.writeProps.indexOf(key) == -1 && itemDetails.cloneProps.indexOf(key) == -1 && itemDetails.functions.indexOf(key) == -1) {
									target[key] = value;
									self.windowProps.set(key, true);
								} else if (itemDetails.writeProps.indexOf(key) != -1 || Array.isArray(target)) {
									target[key] = value;
								} else if (itemDetails.type == "Node" && (/^(innerHTML|innerText|outerText|outerHTML)$/).test(key) && !(/^(HTML|BODY|HEAD)$/).test(target.nodeName)) {
									_LyteComponent.currentWidget = self.widgetName;
									target[key] = value;
									delete _LyteComponent.currentWidget;
									self.setNodes(target.childNodes);
								} else if (type == "Document" && key == "widgetInstances") {
									this[key] = value;
								} else {
									dummyObj[key] = value;
								}
								return true;
							}.bind({
								window: window,
								document: document
							}),
							defineProperty: function (target, key, value) {
								if (isWindow && (Array.isArray(itemDetails.readProps) ? itemDetails.readProps.indexOf(key) == -1 : itemDetails.readProps != "*") && itemDetails.writeProps.indexOf(key) == -1 && itemDetails.cloneProps.indexOf(key) == -1 && itemDetails.functions.indexOf(key) == -1) {
									target.scope[key] = value;
								}
								return value;
							}.bind({
								window: window,
								document: document
							})
						};
					var proxy = self.getProxy(item, handlers);
					if (type == "Window") {
						item.window = item.self = proxy;
					}
					if (itemDetails.copyClone && !item.__clone__) {
						defProp(item, "__clone__", proxy);
					}
					prxWkMap.set(proxy, item);
					return proxy;
				}
			}
			Widget._globalEventHandler = { "listeners": {} };
			Widget._widgetInstances = {};
			window.LyteWidgetClass = Widget;
			function createClonedScope(widgetName) {
				var doc_prox = getClone(document, undefined, true);
				var win_prox = getClone(window, doc_prox, true);
				var obj = {};
				var windowOpts = cloneOpts.Window;
				for (var key in windowOpts) {
					var arr = windowOpts[key];
					var len = arr.length;
					for (var i = 0; i < len; i++) {
						var prop = arr[i];
						obj[prop] = win_prox[prop];
					}
				}
				obj.window = win_prox;
				obj.document = doc_prox;
				obj.document.__window = obj.window;
				obj.window.__lyteWidget = this.widgetName;
				obj.document.__getClone__ = obj.window.__getClone__ = getClone;
				obj.window.eval = function (obj) {
					function safeEval(args) {
						const sbox = sandbox(obj);
						return sbox(args);
					}
					Object.defineProperty(obj, "eval", { value: safeEval });
					return safeEval;
				}(obj);
				obj.window.Function = function (obj) {
					function safeFunction(...args) {
						const fDef = args.pop();
						const fArgs = args.join(",");
						try {
							new Function(...args, fDef);
						} catch (exp) {
							console.error(exp);
						}
						const f = "(function(" + fArgs + "){" + fDef + "})";
						const evFn = obj.window.eval;
						return evFn(f);
					}
					Object.defineProperty(obj, "Function", { value: safeFunction });
					return safeFunction;
				}(obj);
				obj.window.setTimeout = function (cBack, time) {
					var args = Array.prototype.slice.call(arguments, 0);
					return setTimeout.apply(window, [
						function () {
							typeof cBack == "function" ? cBack.apply(obj.window, args) : undefined;
						},
						time
					]);
				};
				Object.defineProperty(obj, "setTimeout", { value: obj.window.setTimeout });
				obj.window.setInterval = function (cBack, time) {
					var args = Array.prototype.slice.call(arguments, 0);
					return setInterval.apply(window, [
						function () {
							typeof cBack == "function" ? cBack.apply(obj.window, args) : undefined;
						},
						time
					]);
				};
				Object.defineProperty(obj, "setInterval", { value: obj.window.setInterval });
				win_prox.scope = obj;
				return new Proxy(obj, handler);
			}
			Lyte.getWidgetScope = function (name) {
				return widgetScopeMap.get(name);
			};
			function sandbox(scope) {
				var unsafeWindow = window;
				with (scope) {
					const {eval} = unsafeWindow;
					const evFn = eval;
					return function () {
						"use strict";
						return evFn(arguments[0]);
					};
				}
			}
			var commonWidget;
			function addToWidget(fStr, widgetName, fileName, type, styleArr) {
				if (type == "style") {
					if (!styleArr) {
						styleArr = widgetStyles.get(widgetName);
					}
					styleArr.push({
						"name": fileName,
						"string": fStr,
						"styleTag": true
					});
					return;
				}
				var prx = widgetScopeMap.get(widgetName);
				if (!prx) {
					var widget = new Widget(widgetName, commonWidget);
					prx = widget.win_prox;
					widgetMap.set(widgetName, widget);
					widgetScopeMap.set(widgetName, prx);
					var sBoxP = sandbox(prx);
					sBoxP(overridewidget);
				}
				var sBox = sandbox(prx);
				sBox("(async function(){" + fStr + "})()");
				return prx;
			}
			var globalWidgetObj = Lyte.Widget = {};
			globalWidgetObj.configureGlobals = function (conf) {
				var widgetConfig = Lyte.getConfig("widget");
				widgetConfig.globalConfig = conf;
			};
			Lyte.Widget.add = function (arg1, arg2) {
				if (typeof arg1 == "string") {
					widgetAdd(arg1, arg2);
				} else if (arg1 && typeof arg1 == "object") {
					for (var key in arg1) {
						widgetAdd(key, arg1[key]);
					}
				}
			};
			Lyte.Widget.addComponent = function (widgetName, resources) {
				var fObj = {
						"p": "1a",
						"w": widgetName,
						"src": resources
					};
				window.lyteWidgetFrame.contentWindow.postMessage(fObj, "*");
			};
			Lyte.Widget.remove = function (arg1) {
				if (window.isLyteWidget) {
					return Lyte.Widget.destroy(arg1, true);
				} else {
					if (!arg1) {
						console.error("No widget name is specified");
						return;
					}
					var widgetConfigGlobal = Lyte.getConfig("widget");
					if (widgetConfigGlobal.resources[arg1]) {
						Lyte.Widget.destroy(arg1, true);
						delete widgetConfigGlobal.resources[arg1];
					} else {
						console.error("Widget config not found");
					}
					window.lyteWidgetFrame.contentWindow.postMessage({
						"p": "13",
						"1": arg1
					}, "*");
				}
			};
			function widgetAdd(name, config) {
				if (widgetConfig.hasOwnProperty(name)) {
					Lyte.warn("Widget already registered");
					return;
				}
				var widgetConfigGlobal = Lyte.getConfig("widget");
				var resources = widgetConfigGlobal.resources;
				resources[name] = config.resources;
			}
			function getFiles(arr) {
				var prm = [];
				arr.forEach(function (itm) {
					prm.push(getFile(itm));
				});
				return Promise.all(prm);
			}
			function getFile(url) {
				return new Promise(function (resolve, reject) {
					var xhttp = new XMLHttpRequest();
					xhttp.open("GET", url, true);
					xhttp.send();
					xhttp.onreadystatechange = function () {
						if (this.readyState == 4) {
							if (this.status == 200) {
								resolve(xhttp.responseText);
							} else {
								reject();
							}
						}
					};
				});
			}
			_lyteWidgetInit = function (name, arr, styleArr) {
				return new Promise(function (resolve, reject) {
					var len = arr.length, count = 0;
					arr.forEach(function (itm) {
						let type;
						let itmObj = itm;
						if (typeof itm == "object") {
							type = itm.type;
							itm = itm.url;
						} else if (itm.endsWith(".css")) {
							type = "style";
						} else {
							type = "script";
						}
						if (type == "style") {
							if (itmObj.styleTag) {
								var prm = getFile(itm);
								prm.then(function (res) {
									count++;
									addToWidget(res, name, itm, type, styleArr);
									if (len == count) {
										resolve();
									}
								});
							} else {
								count++;
								var widgetStylesArr;
								if (styleArr) {
									widgetStylesArr = styleArr;
								} else {
									widgetStylesArr = widgetStyles.get(name);
								}
								widgetStylesArr.push(itm);
								if (len == count) {
									resolve();
								}
							}
						} else {
							var scrpt = document.createElement("script");
							oldProtoSet.apply(scrpt, [
								"src",
								itm
							]);
							scrpt.addEventListener("load", function () {
								count++;
								if (len == count) {
									resolve();
								}
							});
							document.head.appendChild(scrpt);
						}
					});
					if (arr.length == 0) {
						resolve();
					}
				});
			};
			Lyte.Widget.destroy = function (data, fromRemove) {
				var arr = [];
				if (typeof data == "string") {
					let retVal = widgetDestroy(data, fromRemove);
					if (retVal) {
						arr.push(retVal);
					}
				} else if (Array.isArray(data)) {
					data.forEach(function (itm) {
						let retVal = widgetDestroy(itm, fromRemove);
						if (retVal) {
							arr.push(retVal);
						}
					});
				} else if (data == undefined) {
					console.error("Specify the widget to remove");
				}
				return Promise.all(arr);
			};
			function widgetDestroy(name, fromRemove) {
				if (window.isLyteWidget) {
					if (name) {
						var widg = widgetMap.get(name);
						if (widg) {
							return widg.destroy(fromRemove);
						}
					} else {
						widgetMap.forEach(function (wIns, key) {
							wIns.destroy();
						});
					}
				} else {
					function removeMappings() {
						var mappings = window.parentWidgetMappings;
						for (let key in mappings) {
							if (mappings[key].widgetName == name) {
								var mapObj = mappings[key];
								if (mapObj.element) {
									mapObj.element.remove();
								}
								delete mappings[key];
							}
						}
					}
					if (!fromRemove) {
						window.lyteWidgetFrame.contentWindow.postMessage({
							"p": "11",
							"1": name
						}, "*");
						setTimeout(removeMappings, 100);
					} else {
						removeMappings();
					}
				}
			}
			var overridewidget = `var originalBind=Function.prototype.bind;if(Function.prototype.bind=function(){let t=Array.from(arguments);var e=originalBind.apply(this,t);return e.__notNative=!0,e},"undefined"!=typeof window){document.listenerIndex=0;var oldEventListener=HTMLElement.prototype.addEventListener,oldShadowEventListener=ShadowRoot.prototype.addEventListener;document.addEventListener=HTMLElement.prototype.addEventListener=function(t,e){if(this._m){var n=this.getRootNode(),r=n._id;n._eL=n._eL||[];var o=n._eL.push(e);e.__refCode=o;let i={c:"4",y:t,z:this._m,w:o};n._isBodyShadow?i.x1=r:i.x=r,window.top.postMessage(i,"*")}else for(var i in e.__liIn=document.listenerIndex++,window.top.postMessage({c:"4a",y:t,z:e.__liIn},"*"),window.childWidgetMappings)oldShadowEventListener.apply(window.childWidgetMappings[i].shadow,Array.from(arguments));oldEventListener.apply(this,Array.from(arguments))};var oldGetElementById=document.getElementById;document.getElementById=function(t){if(!Object.keys(window.childWidgetMappings).length)return oldGetElementById.apply(document,Array.from(arguments));for(let n in window.childWidgetMappings){if(e=window.childWidgetMappings[n].shadow.querySelector("[id='"+t+"'"))return e}if(window.childBodyWidgetMappings)for(let n in window.childBodyWidgetMappings){var e;if(e=window.childBodyWidgetMappings[n].shadow.querySelector("[id='"+t+"'"))return e}};var funcsToBeOverrided=[{v:"getElementsByTagName",a:!0,r:"querySelectorAll"},{v:"querySelector"},{v:"contains"},{v:"querySelectorAll",a:!0}],oldFunctions={};funcsToBeOverrided.forEach(function(t){let e=t.v,n=t.r||t.v;oldFunctions[e]=document[e],document[e]=function(r){let o=t.a?[]:null;if(Object.keys(window.childWidgetMappings).length){for(let e in window.childWidgetMappings){if(i=window.childWidgetMappings[e].shadow[n](r)){if(!t.a)return i;for(let t=0;t<i.length;t++)o.push(i[t])}}if(window.childBodyWidgetMappings)for(let e in window.childBodyWidgetMappings){var i;if(i=window.childBodyWidgetMappings[e].shadow[n](r)){if(!t.a)return i;for(let t=0;t<i.length;t++)o.push(i[t])}}return o}return oldFunctions[e].apply(document,Array.from(arguments))}});var oldRemoveEventListener=HTMLElement.prototype.removeEventListener,oldShadowRemoveEventListener=ShadowRoot.prototype.removeEventListener;document.removeEventListener=HTMLElement.prototype.removeEventListener=function(t,e){if(e){if(this._m&&e.__refCode){var n=this.getRootNode();let r=n._id,o=n._eL||[],i=e.__refCode;delete o[i-1];let a={c:"5",y:t,z:this._m,w:i};n._isBodyShadow?a.x1=r:a.x=r,setTimeout(function(){window.top.postMessage(a,"*")},2)}else{let n=e.__liIn;for(var r in window.top.postMessage({c:"5a",y:t,z:n},"*"),window.childWidgetMappings)oldShadowRemoveEventListener.apply(window.childWidgetMappings[r].shadow,Array.from(arguments))}oldRemoveEventListener.apply(this,Array.from(arguments))}};var oldCustomElementsDefine=customElements.define;customElements.define=function(t,e){var n=e.prototype.connectedCallback,r=e.prototype.attributeChangedCallback;e.prototype.connectedCallback=function(){var t={};this.__ccCBPromise=new Promise(function(e,n){t.resolve=e,t.reject=n}),this.__ccCBPromise.__node=this,window.liveCcCBArray.push(this.__ccCBPromise);var e=this,o=Array.from(arguments);e._pendingAttrs=e._pendingAttrs||[],this.__cp=this.__cp||[],Promise.all(this.__cp).then(async function(){if(n){for(var i=0;i<e._pendingAttrs.length;i++)$Lt._aW(await r.apply(e,e._pendingAttrs[i]));n.apply(e,o).finally(function(){e.__ccCB=!0,t.resolve()})}else t.resolve(),e.__ccCB=!0})},e.prototype.attributeChangedCallback=function(){this._pendingAttrs=this._pendingAttrs||[];var t=Array.from(arguments);this.__ccCB?r.apply(this,t):this._pendingAttrs.push(t)},oldCustomElementsDefine.apply(this,Array.from(arguments))};var oldDispatchEvent=Element.prototype.dispatchEvent;Element.prototype.dispatchEvent=async function(t){if(!t.__lyteCreated)return oldDispatchEvent.apply(this,Array.from(arguments));var e={},n=new Promise(function(t,n){e.resolve=t});arguments[0]._handledResolve=e.resolve,oldDispatchEvent.apply(this,Array.from(arguments)),setTimeout(function(){e.resolve()},2),await $Lt._aW(n)};var oldAppendChild=Element.prototype.appendChild;window.liveCcCBArray=[],DocumentFragment.prototype.appendChild=Element.prototype.appendChild=async function(t){var e=window.liveCcCBArray,n=window.liveCcCBArray=[],r=oldAppendChild.apply(this,Array.from(arguments));return n.length&&await $Lt._aW(Promise.all(n)),window.liveCcCBArray=e,t.__ccCBPromise&&(await $Lt._aW(t.__ccCBPromise),t.__ccCBPromise=null),r};var oldInsertBefore=Element.prototype.insertBefore,oldInsertBeforeDoc=DocumentFragment.prototype.insertBefore;DocumentFragment.prototype.insertBefore=Element.prototype.insertBefore=async function(){var t=window.liveCcCBArray,e=window.liveCcCBArray=[],n=Array.from(arguments),r=arguments[0];r instanceof DocumentFragment&&(r=r.children[0]);var o=(this instanceof DocumentFragment?oldInsertBeforeDoc:oldInsertBefore).apply(this,n);return e.length&&await $Lt._aW(Promise.all(e)),window.liveCcCBArray=t,r&&r.__ccCBPromise&&(await $Lt._aW(r.__ccCBPromise),r.__ccCBPromise=null),o}}async function sample(){}Object.defineProperty(sample.constructor.prototype,"prototype",{get:function(){return this._lyteProto||(this._lyteProto={})}}),function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e():"function"==typeof define&&define.amd?define(e):e()}(0,function(){var t=fetch;self.fetch=async function(){var e=Array.from(arguments);return new i(function(n,r){t.apply(self,e).then(n,r)})};var e=function(t){return function(){var e=this;return new i(function(n,r){t.apply(e,Array.from(arguments)).then(n,r)})}};self.Response.prototype.text=e(Response.prototype.text),self.Response.prototype.json=e(Response.prototype.json);var n=setTimeout;function r(t){return Boolean(t&&void 0!==t.length)}function o(){}function i(t){if(!(this instanceof i))throw new TypeError("Promises must be constructed via new");if("function"!=typeof t)throw new TypeError("not a function");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],l(t,this)}function a(t,e){for(;3===t._state;)t=t._value;0!==t._state?(t._handled=!0,i._immediateFn(function(){var n=1===t._state?e.onFulfilled:e.onRejected;if(null!==n){var r;try{r=n(t._value)}catch(t){return void s(e.promise,t)}c(e.promise,r)}else(1===t._state?c:s)(e.promise,t._value)})):t._deferreds.push(e)}function c(t,e){try{if(e===t)throw new TypeError("A promise cannot be resolved with itself.");if(e&&("object"==typeof e||"function"==typeof e)){var n=e.then;if(e instanceof i)return t._state=3,t._value=e,void f(t);if("function"==typeof n)return void l((r=n,o=e,function(){r.apply(o,arguments)}),t)}t._state=1,t._value=e,f(t)}catch(e){s(t,e)}var r,o}function s(t,e){t._state=2,t._value=e,f(t)}function f(t){2===t._state&&0===t._deferreds.length&&i._immediateFn(function(){t._handled||i._unhandledRejectionFn(t._value)});for(var e=0,n=t._deferreds.length;e<n;e++)a(t,t._deferreds[e]);t._deferreds=null}function l(t,e){var n=!1;try{t(function(t){n||(n=!0,c(e,t))},function(t){n||(n=!0,s(e,t))})}catch(t){if(n)return;n=!0,s(e,t)}}i.prototype.catch=function(t){return this.then(null,t)};i.prototype.then=function(t,e){if((n=t)&&1==n.__notNative||!n||"function"!=(typeof n).toLowerCase()||n!==Function.prototype&&!/^\s*function\s*(\b[a-z$_][a-z0-9$_]*\b)*\s*\((|([a-z$_][a-z0-9$_]*)(\s*,[a-z$_][a-z0-9$_]*)*)\)\s*{\s*\[native code\]\s*}\s*$/i.test(String(n))||this.__actAwait)return delete this.__actAwait,function(t,e){var n=new this.constructor(o);return a(this,new function(t,e,n){this.onFulfilled="function"==typeof t?t:null,this.onRejected="function"==typeof e?e:null,this.promise=n}(t,e,n)),n}.call(this,t,e);var n,r=this.then;this.then=void 0,t(this),this.then=r},i.prototype.finally=function(t){var e=this.constructor;return this.then(function(n){return e.resolve(t()).then(function(){return n})},function(n){return e.resolve(t()).then(function(){return e.reject(n)})})},i.any=function(t){return new i(function(e,n){if(!r(t))return n(new TypeError("Promise.any accepts an array"));var o=Array.prototype.slice.call(t);if(0===o.length)return n(AggregateError([],"All promises were rejected"));for(var i=[],a=o.length,c=0;c<o.length;c++)if(o[c].then&&"function"==typeof o[c].then){let t=c;o[c].then(function(t){e(t)},function(e){i[t]=e,0==--a&&n(new AggregateError(i))})}else e(o[c])})},i.allSettled=function(t){return new i(function(e,n){if(!r(t))return n(new TypeError("Promise.any accepts an array"));var o=Array.prototype.slice.call(t);if(0===o.length)return e([]);for(var i=[],a=o.length,c=0;c<o.length;c++)if(o[c].then&&"function"==typeof o[c].then){let t=c;o[c].then(function(n){i[t]={status:"fulfilled",value:n},0==--a&&e(i)},function(n){i[t]={status:"rejected",reason:n},0==--a&&e(i)})}else i[c]={status:"fulfilled",value:o[c]},0==--a&&e(i)})},i.all=function(t){return new i(function(e,n){if(!r(t))return n(new TypeError("Promise.all accepts an array"));var o=Array.prototype.slice.call(t);if(0===o.length)return e([]);var i=o.length;function a(t,r){try{if(r&&("object"==typeof r||"function"==typeof r)){var c=r.then;if("function"==typeof c)return void c.call(r,function(e){a(t,e)},n)}o[t]=r,0==--i&&e(o)}catch(t){n(t)}}for(var c=0;c<o.length;c++)a(c,o[c])})},i.resolve=function(t){return t&&"object"==typeof t&&t.constructor===i?t:new i(function(e){e(t)})},i.reject=function(t){return new i(function(e,n){n(t)})},i.race=function(t){return new i(function(e,n){if(!r(t))return n(new TypeError("Promise.race accepts an array"));for(var o=0,a=t.length;o<a;o++)i.resolve(t[o]).then(e,n)})},i._immediateFn="function"==typeof setImmediate&&function(t){setImmediate(t)}||function(t){n(t,0)},i._unhandledRejectionFn=function(t){"undefined"!=typeof console&&console&&console.warn("Possible Unhandled Promise Rejection:",t)};var u=function(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")}();u.$Lt=u.$Lt||{},(u.$Lt.__defaultProps=u.$Lt.__defaultProps||{}).Object={defineProperty:Object.defineProperty},u.$Lt._oldPromise=u.Promise,u.Promise=i;var p=["Array","TypeArray","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"].length,y=["every","filter","find","findIndex","flatMap","map","reduce","reduceRight","some","sort"],d=Array.from(y);d.splice(4,1);for(var h={Array:y,TypeArray:d},_=2;_<p;_++){h[p[_]]=d}var w=async function(){}.constructor;let v=Array.prototype.slice;var m={filter:async function(t,e){var n=this.length,r=[];if("function"!=typeof t)throw new TypeError(t+" is not a function");for(var o=0;o<n;o++){if(o in this)await m.__callbackfn(t,e||this,[this[o],o,this])&&r.push(this[o])}return r},every:async function(t,e){var n=this.length;if("function"!=typeof t)throw new TypeError(t+" is not a function");for(var r=0;r<n;r++){if(r in this)if(!await m.__callbackfn(t,e||this,[this[r],r,this]))return!1}return!0},find:async function(t,e){var n=this.length;if("function"!=typeof t)throw new TypeError(t+" is not a function");for(var r=0;r<n;r++){if(await m.__callbackfn(t,e||this,[this[r],r,this]))return this[r]}},findIndex:async function(t,e){var n=this.length;if("function"!=typeof t)throw new TypeError(t+" is not a function");for(var r=0;r<n;r++){if(await m.__callbackfn(t,e||this,[this[r],r,this]))return r}return-1},some:async function(t,e){var n=this.length;if("function"!=typeof t)throw new TypeError(t+" is not a function");for(var r=0;r<n;r++){if(r in this)if(await m.__callbackfn(t,e||this,[this[r],r,this]))return!0}return!1},flatMap:async function(t,e){var n=this.length,r=[];if("function"!=typeof t)throw new TypeError(t+" is not a function");for(var o=0;o<n;o++)if(o in this){var i=await m.__callbackfn(t,e||this,[this[o],o,this]);Array.isArray(i)?r=r.concat(i):r.push(i)}return r},map:async function(t,e){var n=this.length,r="String"==this.constructor.name?new Array(n):new this.constructor(n);if("function"!=typeof t)throw new TypeError(t+" is not a function");for(var o=0;o<n;o++)if(o in this){var i=await m.__callbackfn(t,e||this,[this[o],o,this]);r[o]=i}return r},reduce:async function(t,e){if("function"!=typeof t)throw new TypeError(t+" is not a function");var n,r=this.length,o=0;if(void 0!=e)n=e;else{for(;o<r&&!(o in this);)o++;if(o>=r)throw new TypeError("Reduce of empty array with no initial value");n=this[o++]}for(var i=o;i<r;i++)i in this&&(n=await m.__callbackfn(t,this,[n,this[i],i,this]));return n},reduceRight:async function(t,e){if("function"!=typeof t)throw new TypeError(t+" is not a function");var n,r=this.length-1;if(void 0!=e)n=e;else{for(;r>=0&&!(r in this);)r--;if(r<0)throw new TypeError("Reduce of empty array with no initial value");n=this[r--]}for(var o=r;o>=0;o--)o in this&&(n=await m.__callbackfn(t,this,[n,this[o],o,this]));return n},sort:async function(t){return await m.__srt(this,t)},__srt:async function(t,e,n){var r=await m.__sort(t,e,n);return r.forEach(function(e,n){t[n]=e}),r},__sort:async function(t,e,n){n=n||t;if(1===t.length)return t;var r=Math.floor(t.length/2),o=v.call(t,0,r),i=v.call(t,r);return await m.__merge(await m.__sort(o,e,n),await m.__sort(i,e,n),n,e)},__merge:async function(t,e,n,r){for(var o=[],i=0,a=0;i<t.length&&a<e.length;){var c=t[i],s=e[a];(r?await m.__callbackfn(r,n,[c,s])<=0:c.toString()<=s.toString())?(o.push(t[i]),i++):(o.push(e[a]),a++)}return o.concat(v.call(t,i)).concat(v.call(e,a))},__callbackfn:async function(t,e,n){return t instanceof w?await t.apply(e,n):t.apply(e,n)}};for(var g in h){var A=h[g],b=u[g];b&&A.forEach(function(t){b.prototype[t]&&m[t]&&Object.defineProperty(u[g].prototype,t,{value:m[t],enumerable:!1})})}var E=String.prototype.replace;String.prototype.replace=async function(t,e){var n=this;if("function"==typeof e&&e instanceof w){var r=[];return E.call(this,t,async function(){r.push(e.apply(n,Array.from(arguments)))}),r.length?await $Lt._aW(i.all(r).then(function(e){return E.call(n,t,function(){return e.shift()})})):this.toString()}return E.apply(this,Array.from(arguments))};var P=JSON.stringify;"undefined"!=typeof window&&(JSON.stringify=async function(){var t=arguments;let e=t[0];var n=t[1],r=this;if(n&&"function"==typeof n&&n instanceof w){n.apply(r,["",e]);let o=async function(t){let e,o;if(Array.isArray(t)){e=[];for(let a=0,c=t.length;a<c;a++){let c=t[a];"object"==typeof c&&c.toJSON&&(c=await c.toJSON(a.toString())),(o=await i(await n.apply(r,[a,c])))&&e.push(o)}}else for(var a in e={},t)if("toJSON"!=a){let c=t[a];"object"==typeof c&&c.toJSON&&(c=await c.toJSON(a)),(o=await i(await n.apply(r,[a,c])))&&(e[a]=o)}return e},i=async function(t){let e=typeof t;return"number"==e||"string"==e||"boolean"==e||"null"==e?t:"function"!=e&&"symbol"!=e&&"undefined"!=e&&"object"==e?await o.apply(this,[t]):void 0},a=await o.apply(r,[e]);return await P.apply(r,Array.from([a,null,t[2]]))}return await P.apply(r,arguments)})}),function(){var t=function(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")}();var e=t.$Lt;let n={},r=[],o=[],i=!1,a=[];var c=t.importScripts,s=t.setTimeout;e.oldProxy||(e.oldProxy=Proxy),self.Proxy=function(t,n){var r=n.get;return r&&(n.get=function(t,n){return"then"==n?r.apply(this,[t,n]):e._get(arguments,r.bind(this))}),new e.oldProxy(t,n)};let f=e.__defaultProps.Object.defineProperty;if(self.Object.defineProperty=function(){var t=arguments,n=t[2].get;return!t[3]&&n&&(t[2].get=function(){return e._get(arguments,n.bind(t[0]))}),f.apply(this,[t[0],t[1],t[2]])},e.error=function(t){var e=t.message;if(e){var n={"$Lt._gc.":"\\$Lt\\._gc\\.","$Lt._gcFn.":"\\$Lt\\._gcFn\\."};for(var r in n)e.includes(r)&&(e=replaceOriginal.apply(e,[new RegExp(n[r],"g"),""]));t.message=e}return t},e.getCp=function(t){return t.__cp||(t.__cp=[]),t.__cp},e._sT=function(){return s.apply(t,Array.from(arguments))},e._dG=function(t){return t()},e._gc=new e.oldProxy(t,{get:function(e,r){return n.hasOwnProperty(r)?n[r]:t[r]},set:function(e,r,o){return n.hasOwnProperty(r)?n[r]=o:t[r]=o,!0}}),e._gcFn=new e.oldProxy({},{get:function(e,r){if(n.hasOwnProperty(r))return n[r];if("function"==typeof t[r]){let e=t[r];return function(){return e.apply(t,Array.from(arguments))}}return t[r]}}),e.isVarDeclarationVariable=function(t){return-1!=r.indexOf(t)},e.isConstDeclarationVariable=function(t){return-1!=o.indexOf(t)},e._cV=function(e,i,a){var c=!0;let s=i;if("var"==a){if(n[e])throw new Error("Identifier '"+e+"' has already been declared");t[e]=i,r.push(e)}else{if(r.includes(e)||"window"==e||n.hasOwnProperty(e))throw"Identifier '"+e+"' has already been declared";"const"==a&&o.push(e),f(n,e,{get:function(){return s},set:function(t){if(!c)throw"Assignment to constant variable";s=t,o.includes(e)&&(c=!1)}})}},e._executeStack=function(){let t=function(){a.shift(),i=!1,e._executeStack()};if(a.length&&!i){var n=a[0];i=!0;try{n().then(function(){t()}).catch(function(e){t()})}catch(e){t()}}},e._get=function(t,n){var r=async function(){var r=await e._gc.Array.from(arguments);r=await r.splice(0,await r.length);var o=await n.apply(this,t),i=await e._aW(await o);return i?await i.apply(this,r):void 0};return r.then=async function(r){return n?await r(await n.apply(this,t)):await r(n),e._aR(void 0)},r},e._execScript=async function(t){a.push(t),e._executeStack()},e._knownClasses=[Map,Array,Date,Set,Promise],"undefined"!=typeof document){var l=document.createElement;document.createElementLyte=async function(t){var n=l.call(document,t),r=n.__cp||[],o=new Promise(function(t,e){Promise.all(r).then(function(){t()})});return await e._aW(o),n}}e._cO=async function(){var t=Array.from(arguments),n=t.shift();if("AsyncFunction"!=n.constructor.name){if(-1!=e._knownClasses.indexOf(n))return Reflect.construct(n,t);var r=Reflect.construct(n,t),o=r.__cp||[],i=new Promise(function(t,e){Promise.all(o).then(function(){t()})});return await e._aW(i),r}var a,c=n._lyteNF;c||(c=function(){return this._lyteCP=n.apply(this,Array.from(arguments)),this},n._lyteProto=n._lyteProto||{},c.prototype=n._lyteProto,(a=n._lyteProto.constructor)&&1==a.__notNative||!a||"function"!=(typeof a).toLowerCase()||a!==Function.prototype&&!/^\s*function\s*(\b[a-z$_][a-z0-9$_]*\b)*\s*\((|([a-z$_][a-z0-9$_]*)(\s*,[a-z$_][a-z0-9$_]*)*)\)\s*{\s*\[native code\]\s*}\s*$/i.test(String(a))||(n._lyteProto.constructor=n,Object.defineProperty(n._lyteProto,"constructor",{enumerable:!1,value:n})),Object.defineProperty(n,"_lyteNF",{enumerable:!1,value:c}));var s=Reflect.construct(c,t),f=await s._lyteCP;return delete s._lyteCP,f||s},e._iO=function(t,e){return"AsyncFunction"==e.constructor.name?!!e._lyteNF&&t instanceof e._lyteNF:t instanceof e},e._forInR=function(t){return{_forInR:t}},e._aW=function(t){return t&&Object.isExtensible(t)&&Object.defineProperty(t,"__actAwait",{value:!0,enumerable:!1}),t},e._cI=async function(t,e,n){if(t instanceof Array)for(var r=0;r<t.length;r++){let o=await e.apply(n,[t[r]]);if(o._forInR)return o}else for(var o=await t[Symbol.iterator]();;){let t=await o.next();if(t.done)break;let r=await e.apply(n,[t.value]);if(r._forInR)return r}},e._fE=async function(e,n,r){var o=r||t;for(let t=0;t<e.length;t++)await n.call(o,e[t],t,e)},e._aR=function(t){return t instanceof Promise?t:Promise.resolve(t)},e._importScripts=function(){var t=Array.from(arguments);return new Promise(function(n,r){c.apply(self,t),0==a.length?n():e._execScript(n)})},Object.freeze(t.$Lt),t.$Lt!==e&&Object.defineProperty(t,"$Lt",{value:e,writable:!1,configurable:!1,enumerable:!1})}();`;
		}());
		if (await $Lt._gc.window.isLyteWidget) {
			$Lt._cV("inputProtoProps", ["value"], "var");
			await $Lt._fE($Lt._gc.inputProtoProps, async function (item) {
				var descriptor = await $Lt._gc.Object.getOwnPropertyDescriptor(await $Lt._gc.HTMLInputElement.prototype, item);
				await $Lt._gc.Object.defineProperty(await $Lt._gc.HTMLInputElement.prototype, item, { set: async function (val) {
						await (await descriptor.set).apply(this, arguments);
						if (await $Lt._gc.window.___ignoreVal) {
							$Lt._gc.window.___ignoreVal = false;
							return;
						}
						if (await this._m) {
							await (await $Lt._gc.window.parent).postMessage({
								"c": "changeVal",
								"x": await (await this.getRootNode())._id,
								"y": await this._m,
								"z": val,
								"v": item
							}, "*");
						}
					} });
			});
		}
	}(self);
});;setTimeout(function() {
                        var oldInjectResources = Lyte.injectResources;
                        Lyte.injectResources = async function(a,b,c) {
                                window._ignoreSetAttribute = true;
                                await $Lt._aW(await oldInjectResources.call(Lyte, a,b,c));
                                window._ignoreSetAttribute = false;
                        }
                        Lyte.injectResources.availableTags = [];
                        Lyte.injectResources.respObj = [];
                },0)