var idbObj = {}, qLen, qTemp, pK, module, currentIdbName;
self.onmessage = function(event){
    try{
        var q = event.data;
        if(q.tolyteidb){
            currentIdbName = q.name || "lyte";
            if(q.type != "open" && !(idbObj.hasOwnProperty(currentIdbName))){
                self.postMessage({lyteidb:true,pause:true,model:q.model,type:q.type});
            }
            else if(q.type == "push"){
                qLen = qTemp = 0;
                module = q.module;
                pK = undefined;
                var data = q.data;
                if(!Array.isArray(data)){
                    data = [data];                    
                }
                pK = q.pK;
                qLen = data.length;
                data.forEach(function(item, index){
                    qProcess(item,item.type);
                });
            }
            else{
                qProcess(q, q.type);
            }
        }
    }catch(error){
        self.postMessage({lyteidb:true,pause:true,model:q.model,type:q.type,scriptErr:{msg:error,ScriptError:true}})
    }
};
function processed(){
    var msg = arguments[0];
    if(msg && msg.ScriptError){
        self.postMessage({ScriptErr:{msg:msg.msg,ScriptError:true}});
    }
    if(++qTemp == qLen){
        getAll({model:module}).then(function(res){
            var pks = [];
            var data = res.data || [];
            var pKs = pK.split(',');
            data.forEach(function(item){
                var pkVal;
                if(pKs.length > 1){
                    pkVal = {};
                    pKs.forEach(function(itm, idx){
                        pkVal[itm] = item[itm];
                    });
                }
                else{
                    pkVal = item[pK];
                }
                pks.push(pkVal);
            });
            self.postMessage({lyteidb:true, qProcess:"completed4",data:pks});
        },function(msg){
            if(msg.ScriptError){
                self.postMessage({ScriptErr:{msg:msg.msg,ScriptError:true}});
            }
        });
    }
}
function qProcess(obj, type){
    if(obj.queryCache == true && obj.type === "getCachedData" && ( !obj.queryParams || (obj.queryParams && Object.keys(obj.queryParams).length == 0)) ){
        if(obj.req == "findAll"){
            obj.type = "getAll";
        }
        else if(obj.req == "findRecord"){
            obj.type = "get";
        }
    }
    switch(obj.type){
        case "getCachedData":
        {
            getCachedData(obj).then(function(res){
                self.postMessage({lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:200,data:res, req:obj.req, key:obj.key});
            },function(msg){
                var msgObj = {lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:400, req:obj.req, key:obj.key};
                if(msg && msg.ScriptError){
                    msgObj.ScriptErr = msg;
                }
                self.postMessage(msgObj);                
            });
            break;
        }
        case "pushPayload":{
            if(!obj.data[obj.model]){
                var data = obj.data;
                obj.data = {};
                obj.data[obj.model] = data;
            }
        }
        case "findAll":
        case "findRecord":
        case "push": {
            push(obj,obj.type).then(processed,processed);
            break;
        }
        case "open": {
            openIDB(obj);
            break;
        }   
        case "create": {
            addMultiple(obj).then(processed,processed);
            break;
        }
        case "createRecord": {
            addData(obj).then(processed,processed);
            break;
        }   
        case "delete": {
            deleteMultiple(obj).then(processed,processed);
            break;
        }
        case "destroyRecord":
        case "deleteRecord": {
            deleteData(obj).then(processed,processed);
            break;
        }   
        case "update":{
            updateMultiple(obj).then(processed,processed);
            break;
        }
        case "updateRecord":{
            updateData(obj).then(processed,processed);
            break;
        }
        case "get":{
            obj.processKey = true;
            getData(obj).then(function(res){
                getCachedMeta(obj).then(function(meta){
                    if(res.data == undefined){
                        self.postMessage({lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:400,req:obj.req, key:obj.key});                                    
                    }
                    else{
                        var resp = {};
                        resp[obj.model] = res.data;
                        if(meta){
                            resp.meta = meta
                        }
                        self.postMessage({lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:200,data:resp,req:obj.req,  key:obj.key});
                    }    
                }, function(msg){
                    var msgObj = {lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:400,req:obj.req, key:obj.key}
                    if(msg && msg.ScriptError){
                        msgObj.ScriptErr=ScriptError;
                        self.postMessage(msgObj);
                    }
                    if(res.data == undefined){
                        self.postMessage(msgObj);                                    
                    }
                    else{
                        var resp = {};
                        resp[obj.model] = res.data;
                        self.postMessage({lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:200,data:resp,req:obj.req,  key:obj.key});
                    }    
                });
            },function(msg){
                var msgObj = {lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:400,req:obj.req,  key:obj.key}
                if(msg && msg.ScriptError){
                    msgObj.ScriptErr=ScriptError;
                }
                self.postMessage(msgObj);                
            });
            break;
        }
        case "getAll":{
            getAll(obj).then(function(res){
                getCachedMeta(obj).then(function(meta){
                    if(Array.isArray(res.data) && !res.data.length){
                        self.postMessage({lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:400,req:obj.req});                                    
                    } else{
                        var resp = {};
                        resp[obj.model] = res.data;
                        if(meta){
                            resp.meta = meta
                        }
                        self.postMessage({lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:200,data:resp, req:obj.req});
                    }
                }, function(msg){
                    var msgObj = {lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:400,req:obj.req}
                    if(msg && msg.ScriptError){
                        msgObj.ScriptErr=msg
                        self.postMessage(msgObj);
                    }
                    if(Array.isArray(res.data) && !res.data.length){
                        self.postMessage({lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:400,req:obj.req});                                    
                    } else{
                        var resp = {};
                        resp[obj.model] = res.data;
                        self.postMessage({lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:200,data:resp, req:obj.req});
                    }
                });
            },function(msg){
                var msgObj = {lyteidb:true, model:obj.model,type:obj.type,queryParams:obj.queryParams,code:400, req:obj.req}
                if(msg && msg.ScriptError){
                    msgObj.ScriptErr = msg
                }
                self.postMessage(msgObj);                
            });
            break;
        }
        case "close":{
            idbObj[currentIdbName].close();
            break;
        }
        default:{
            self.postMessage({lyteidb:true, msg:"No such actions defined "+obj.type, data:obj.data})
            break;
        }
    }
}

function getCachedMeta(obj){
    return new Promise(function(resolve, reject){
        var module = obj.model;
        var qP = obj.queryParams;
        var type = obj.req;
        var key = obj.key;
        getData({model:"__meta",key:module}).then(function(res){
            try{
                if(res.data == undefined){
                    return reject();
                }
                var cachedQ = res.data.cache;
                cachedQ = cachedQ[type];
                var index = checkWithQp(cachedQ,obj,key), meta;
                if(index != -1){
                    var q = cachedQ[index];
                    if(type == "findRecord"){
                        if(q.key && key && q.key == key){
                            meta = q.meta;
                        }
                        else{
                            return reject();
                        }
                    }
                    else{
                        meta = q.data.meta;
                    }
                    return resolve(meta);
                }
                else{
                    return reject();
                }
            }catch(error){
                return reject({msg:error,ScriptError:true})
            }
        },function(msg){
            return reject(msg)
        });    
    });
}

function getCachedData(obj){
    return new Promise(function(resolve, reject){
        try{
            var module = obj.model;
            var qP = obj.queryParams;
            var type = obj.req;
            var key = obj.key;
            getData({model:"__meta",key:module}).then(function(res){
                try{
                    if(res.data == undefined){
                        return reject();
                    }
                    var cachedQ = res.data.cache;
                    cachedQ = cachedQ[type];
                    var index = checkWithQp(cachedQ,obj);
                    if(index != -1){
                        var q = cachedQ[index], vals;
                        if(type == "findRecord"){
                            if(q.key && key && q.key == key){
                                vals = [q.data];
                                // meta = q.meta;
                            }
                            else{
                                return reject();
                            }
                        }
                        else{
                            vals = q.data[module];
                        }
                        // if(type == "findRecord" && !Array.isArray(vals)){
                            //     vals = [vals];
                            // }
                        if(vals && vals.length){
                            var len = vals.length, i=0, result = [];
                            vals.forEach(function(itm,idx){
                                getData({model:module,key:itm,processKey:true}).then(function(msg){
                                    try{
                                        result[idx] = msg.data;
                                        if(++i == len){
                                            var retObj = {};
                                            if(type == "findRecord"){
                                                retObj[obj.model] = result[0];
                                                if(q.meta !== undefined){
                                                    retObj.meta = q.meta;
                                                }
                                            }
                                            else{
                                                retObj[obj.model] = result;
                                                if(q.data && q.data.meta){
                                                    retObj.meta = q.data.meta;
                                                }
                                            }
                                            return resolve(retObj);
                                        }
                                    }catch(error){
                                        return reject({msg:error,ScriptError:true})
                                    }
                                },function(msg){
                                    return reject(msg)
                                });
                            });
                        }
                        else{
                            var retObj = {};
                            if(type == "findRecord"){
                                retObj[obj.model] = {};
                                if(q.meta !== undefined){
                                    retObj.meta = q.meta;
                                }
                            }
                            else if(type == "findAll"){
                                retObj[obj.model] = [];
                                if(q.data && q.data.meta){
                                    retObj.meta = q.data.meta;
                                }
                            }
                            return resolve(retObj);
                        }
                    }
                    else{
                        return reject();
                    }
                }catch(error){
                    return reject({msg:error,ScriptError:true})
                }
            },function(msg){
                return reject(msg)
            }); 
        }catch(error){
            return reject({msg:error,ScriptError:true})
        }   
    });
}

function checkAndRemoveCachedData(obj, removeMetaAlone){
    return new Promise(function(resolve, reject){
        var module = obj.model;
        var qP = obj.queryParams;
        // var type = obj.req;
        var key = obj.key;
        getData({model:"__meta",key:module}).then(function(res){
            try{
                if(res.data == undefined){
                    return reject();
                }
                var cQ = res.data.cache, cachedQ, changed = false;
                for(var ckey in cQ){
                    cachedQ = cQ[ckey];
                    var type = ckey;
                    var cQlen = cachedQ.length;
                    for(var j=cQlen-1;j>=0;j--){
                            var q = cachedQ[j], vals;
                            if(type == "findRecord"){
                                if(q.key && key && q.key == key){
                                    cachedQ.splice(j, 1);
                                    changed = true;
                                }
                                else{
                                    return reject();
                                }
                            }
                            else if(type == "findAll"){
                                vals = q.data[module], valsLen = vals.length, keyLen = Object.keys(key).length;
                                for(var i=0;i<valsLen;i++){
                                    var k=0;
                                    for(var vkey in key){
                                        if(key[vkey] && vals[i][vkey] === key[vkey]){
                                            k++;
                                        }
                                    }    
                                    if(k === keyLen){
                                        cachedQ.splice(j, 1);
                                        changed = true;
                                        break;
                                    }
                                }
                            }
                    }
                }
                if(changed){
                    updateData({model:"__meta",data:res.data, key:module}).then(function(){
                        return resolve();                
                    },function(msg){
                        self.console.error("error adding ",msg.data);
                        return reject(msg);
                    });  
                }
                else{
                    return resolve();
                }
            }catch(error){
                return reject({msg:error,ScriptError:true})
            }
        },function(msg){
            return reject(msg)
        });    
    });
}

function postMsg(msg){
    self.postMessage(msg);
}

function getPk(pK, data){
    var pkArr = pK.split(",");
    var pKval;
    if(pkArr.length>1){
        pKval = {};
        pkArr.forEach(function(itm){
            pKval[itm] = data[itm];
        });
    }
    else if(pkArr.length == 1){
        pKval = {}
        pKval[pkArr[0]] = data[pkArr[0]];
    }
    return pKval;
}
function push(obj,type){
    return new Promise(function(resolve, reject){
        try{
            var data = obj.data, len = data.length, i = 0;
            var module = obj.model;
            console.log(obj.data)
            checkAndInsert(module,obj.data).then(function(res){
                try{
                    if(type == "pushPayload"){
                        return resolve();
                    }
                    else{
                        getData({model:"__meta",key:module}).then(function(msg){
                            try{
                                var rObj = {};
                                rObj.queryParams = obj.queryParams;
                                var rData = rObj.data = obj.data;
                                if(type == "findRecord"){
                                    rObj.key = obj.key;
                                    rObj.data = getPk(pK, rObj.data[module]);
                                    if(obj.meta){
                                        rObj.meta = obj.meta;
                                    }
                                }
                                else{
                                    var kLen = rData[module].length;
                                    for(var k=0;k<kLen;k++){
                                        rData[module][k] = getPk(pK, rData[module][k])
                                    }
                                }
                                if(msg.data == undefined){
                                    var result = {};
                                    result.module = module;  
                                    result.cache = {};  
                                    result.cache[type] = result.data || [];
                                    checkQpAndPush(result.cache[type], rObj, rObj.key);  
                                    addData({model:"__meta",data:result}).then(function(){
                                        return resolve();                
                                    },function(err){
                                        self.console.error("error adding ",result);
                                        return reject(err)
                                    });          
                                }
                                else{
                                    msg.data.cache[type] = msg.data.cache[type] || [];
                                    checkQpAndPush(msg.data.cache[type], rObj, rObj.key);
                                    // msg.data.cache[type].push(rObj);     
                                    updateData({model:"__meta",data:msg.data, key:module}).then(function(){
                                        return resolve();                
                                    },function(err){
                                        self.console.error("error adding ",msg.data);
                                        return reject(err)
                                    });                        
                                }
                            }catch(error){
                                return reject({msg:error,ScriptError:true})
                            }
                        }, function(msg){
                            resolve(msg);
                        });
                    }
                }catch(error){
                    return reject({msg:error,ScriptError:true})
                }
            },function(msg){
                reject(msg);
            });
        }catch(error){
            return reject({msg:error,ScriptError:true})
        }
    });
}
function checkQpAndPush(arr, data){
    if(data && !Array.isArray(data)){
        data = [data];
    }
    data.forEach(function(item, index){
        var res = checkWithQp(arr, item)
        if(res == -1){
            arr.push(item);
        }
        else{
            arr[res] = item;
        }
    });
}
function checkWithQp(arr, data, key){
    var ind = -1; 
    arr = arr || [];
    var len = arr.length;
    var qp2 = data.queryParams || {};
    for(var i=0; i< len; i++){
        if(key === undefined || (data.req == "findRecord" && key !== undefined && arr[i].key == key)){
            var qp1;
            qp1 = arr[i].queryParams || {};
            if(qp1 == qp2){
                ind = i;
                break;
            }
            var qp1L = Object.keys(qp1).length;
            var qp2L = Object.keys(qp2).length;
            if(qp1L != qp2L){
                continue;
            }        
            var j=0;
            for(var k in qp1){
                if(qp1[k] == qp2[k]){
                    j++;
                }
            }
            if(j == qp1L){
                ind = i;
                break;
            }
        }
    }
    return ind;
}
function checkAndInsert(module, arr){
    var res = [], failed = false;
    return new Promise(function(resolve, reject){
        try{
            arr = arr[module];
            arr = arr || [];
            if(!Array.isArray(arr)){
                arr = [arr];
            }
            var arrLen = arr.length, i=0;
            if(arr.length){
                open(idbObj[currentIdbName].name, idbObj[currentIdbName].version).then(function(){
                    try{
                        var obs = idbObj[currentIdbName].transaction([module],"readwrite").objectStore(module), key;
                        if(obs.indexNames.contains("pk")){
                            obs = obs.index("pk");
                        }
                        arr.forEach(function(item, index){
                            if(typeof obs.keyPath == "string"){
                                key = item[obs.keyPath];
                            }
                            else if(Array.isArray(obs.keyPath)){
                                var _arr = [];
                                obs.keyPath.forEach(function(itm){
                                    _arr.push(item[itm]);
                                });
                                key = _arr;
                            }
                            getData({model:module,key: key}).then(function(res){
                                try{
                                    var resData = res.data;
                                    if(resData == undefined){
                                        addData({model:module,data:item}).then(function(){
                                            try{
                                                i++;
                                                if(i == arrLen){
                                                    if(failed){
                                                        return reject();
                                                    }else{
                                                        return resolve(arr);
                                                    }
                                                }
                                            }catch(error){
                                                return reject({msg:error,ScriptError:true})
                                            }
                                        },function(){
                                            try{
                                                failed = true;
                                                i++;
                                                if(i == arrLen){
                                                    if(failed){
                                                        return reject();
                                                    }
                                                    else{
                                                        return resolve(arr);
                                                    }
                                                }
                                            }catch(error){
                                                return reject({msg:error,ScriptError:true})
                                            }
                                        });    
                                    }
                                    else{
                                        updateData({model:module,data:item}).then(function(){
                                            try{
                                                i++;
                                                if(i == arrLen){
                                                    if(failed){
                                                        return reject();
                                                    }else{
                                                        return resolve(arr);
                                                    }
                                                }
                                            }catch(error){
                                                return reject({msg:error,ScriptError:true})
                                            }
                                        },function(){
                                            try{
                                                failed = true;
                                                i++;
                                                if(i == arrLen){
                                                    if(failed){
                                                        return reject();
                                                    }
                                                    else{
                                                        return resolve(arr);
                                                    }
                                                }
                                            }catch(error){
                                                return reject({msg:error,ScriptError:true})
                                            }
                                        });    
                                    }
                                }catch(error){
                                    return reject({msg:error,ScriptError:true})
                                }
                            },function(msg){
                                return reject(msg)
                            });
                        });
                    }
                    catch(error){
                        return reject({msg:error,ScriptError:true})
                    }
                },function(msg){
                    return reject(msg)
                });
            }
        else{
            resolve();
        }
        }catch(error){
            return reject({msg:error,ScriptError:true})
        }
    });
}
function openIDB(obj){
    var dbName = obj.name || 'lyte', 
    version = obj.version, 
    models = obj.models,
    maintainOrder = obj.maintainOrder;
    open(dbName,version,models,maintainOrder).then(function(){
        idbObj[currentIdbName].close();
        self.postMessage({lyteidb:true, msg:'successfully upgraded db', type:"open"});
    }, function(){
        self.postMessage({lyteidb:true, msg:'error'});    
    });
}

function open(dbName, version, models, maintainOrder){
    return new Promise(function(resolve, reject){
        try{
            var req = indexedDB.open(dbName, version), objStore;
            req.onupgradeneeded = function (e) {
                try{
                    idbObj[currentIdbName] = e.target.result;
                    if(models){
                        models.forEach(function(item, index){
                            if(!idbObj[currentIdbName].objectStoreNames.contains(item.modelName)){
                                var order = item.hasOwnProperty("maintainOrder") ? item.maintainOrder : maintainOrder;
                                if(order === true){
                                    var objStore = idbObj[currentIdbName].createObjectStore(item.modelName,{autoIncrement:true});
                                    objStore.createIndex("pk", item.pK.split(","));    
                                }
                                else{
                                    var objStore = idbObj[currentIdbName].createObjectStore(item.modelName,{keyPath: item.pK.split(",")/*,autoIncrement:true*/});
                                }
                                // objStore.createIndex("pk", item.pK.split(","));
                            }
                        });
                    }
                    if(!idbObj[currentIdbName].objectStoreNames.contains("__meta")){
                        idbObj[currentIdbName].createObjectStore("__meta",{keyPath:"module"})
                    }
                    // self.postMessage({lyteidb:true, msg:'successfully upgraded db', type:"open"});
                    resolve({lyteidb:true, msg:'successfully upgraded db', type:"open"});
                }
                catch(error){
                    reject({msg:error,ScriptError:true})
                }
            };
            req.onblocked = function(e){
                reject({lyteidb:true, msg:'error'});
            }
            req.onsuccess = function (e) {
                idbObj[currentIdbName] = e.target.result;
                idbObj[currentIdbName].addEventListener("versionchange", function(){
                    console.log("version change", arguments);
                });
                // self.postMessage({lyteidb:true, msg:'successfully opened db', type:"open"});
                resolve({lyteidb:true, msg:'successfully opened db', type:"open"});
            };
            req.onerror = function(e) {
            //   self.postMessage({lyteidb:true, msg:'error'});    
            reject({lyteidb:true, msg:'error'});
            }
        }catch(error){
            return reject({msg:error,ScriptError:true})
        }
    });
}
function addMultiple(obj){
    return new Promise(function(resolve,reject){
        try{
            var len = obj.data.length,i=0;
            obj.data.forEach(function(item, index){
                addData({model:obj.model,data:item}, false).then(function(){
                    if(++i == len){
                        idbObj[currentIdbName].close();
                        return resolve();
                    }
                },function(){
                    if(++i == len){
                        idbObj[currentIdbName].close();
                        return resolve();
                    }
                });
            });
        }
        catch(error){
            return reject({msg:error,ScriptError:true})
        }
    });
}
function addData(obj, close){
    return new Promise(function(resolve,reject){
        var data = obj.data;
        var model = obj.model;
        open(idbObj[currentIdbName].name, idbObj[currentIdbName].version).then(function(){
            try{
                var obs = idbObj[currentIdbName].transaction([model],"readwrite").objectStore(model);
                var req = obs.add(data);
                req.onsuccess = function (e){
                    close !== false ? idbObj[currentIdbName].close() : undefined;
                    // if(obj.queryCache == false && /^(create|createRecord)$/.test(obj.type)){
                    //     checkAndRemoveCachedData(obj).then(function(){
                    //         return resolve({msg:"Successfully deleted data"});
                    //     }, function(){
                    //         return resolve({msg:"Successfully deleted data"});
                    //     });                    
                    // }
                    return resolve({msg:"Successfully added data"});
                    //self.postMessage({msg:"Successfully added data"});
                }
                req.onerror = function (e){
                    close !== false ? idbObj[currentIdbName].close() : undefined
                    return reject({msg:"Error while adding data"});
        //            self.postMessage({msg:"Error while adding data"});
                }
                req.oncomplete = function (e){
                    close !== false ? idbObj[currentIdbName].close() : undefined
                    return resolve({msg:"Successfully added data"});
        //          self.postMessage({msg:"Successfully added data"});
                } 
            }
            catch(error){
                return reject({msg:error,ScriptError:true})
            }   
        }, function(){
            return reject({msg:"Cannot open indexeddb"});
        })
    });
}
function deleteMultiple(obj){
    return new Promise(function(resolve, reject){
        try{
            var len = obj.data.length, i=0;
            obj.data.forEach(function(item,index){
                deleteData({model:obj.model,key:item}, false).then(function(){
                    if(++i == len){
                        idbObj[currentIdbName].close();
                        return resolve();
                    }
                },function(){
                    if(++i == len){
                        idbObj[currentIdbName].close();
                        return resolve();
                    }
                });
            });
        }catch(error){
            return reject({msg:error,ScriptError:true})
        }
    });
}
function deleteData(obj, close){
    return new Promise(function(resolve, reject){
        try{
            var model = obj.model;
            var key = obj.key;
            open(idbObj[currentIdbName].name, idbObj[currentIdbName].version).then(function(){
                try{
                    var obs = idbObj[currentIdbName].transaction([model],"readwrite").objectStore(model), iobs;
                    if(obs.indexNames.contains("pk")){
                        iobs = obs.index("pk");
                        if(typeof iobs.keyPath == "string"){
                            obj.key = key = obj.key[iobs.keyPath];
                        }
                        else if(Array.isArray(iobs.keyPath)){
                            var arr = [];
                            iobs.keyPath.forEach(function(itm){
                                arr.push(obj.key[itm]);
                            });
                            key = arr;
                        }
                        openCursorForKey(iobs, key).then(function(cobj){
                            try{
                                var pK = cobj.cursor.primaryKey
                                var req = obs.delete(pK);
                                req.onsuccess = function (e){
                                    close !== false ? idbObj[currentIdbName].close(): undefined;
                                    if(obj.queryCache == true){
                                        checkAndRemoveCachedData(obj).then(function(){
                                            return resolve({msg:"Successfully deleted data"});
                                        }, function(){
                                            return resolve({msg:"Successfully deleted data"});
                                        });
                                    }
                                    else{
                                        return resolve({msg:"Successfully deleted data"});
                                    }
                                    // self.postMessage({msg:"Successfully deleted data"});
                                }
                                req.onerror = function (e){
                                    close !== false ? idbObj[currentIdbName].close(): undefined;
                                    return reject({msg:"Error while deleting data"});
                                    // self.postMessage({msg:"Error while deleting data"});
                                }
                                req.oncomplete = function (e){
                                    close !== false ? idbObj[currentIdbName].close(): undefined;
                                    return resolve({msg:"Successfully deleted data"});
                                    // self.postMessage({msg:"Successfully deleted data"});
                                } 
                            }
                            catch(error){
                                reject({msg:error,ScriptError:true})
                            }
                        });
                    }
                    else{
                        if(typeof obs.keyPath == "string"){
                            obj.key = key = obj.key[obs.keyPath];
                        }
                        else if(Array.isArray(obs.keyPath)){
                            var arr = [];
                            obs.keyPath.forEach(function(itm){
                                arr.push(obj.key[itm]);
                            });
                            key = arr;
                        }
                        var req = obs.delete(key);
                        req.onsuccess = function (e){
                            close !== false ? idbObj[currentIdbName].close(): undefined;
                            if(obj.queryCache == true){
                                checkAndRemoveCachedData(obj).then(function(){
                                    return resolve({msg:"Successfully deleted data"});
                                }, function(){
                                    return resolve({msg:"Successfully deleted data"});
                                });
                            }
                            else{
                                return resolve({msg:"Successfully deleted data"});
                            }
                            // self.postMessage({msg:"Successfully deleted data"});
                        }
                        req.onerror = function (e){
                            close !== false ? idbObj[currentIdbName].close(): undefined;
                            return reject({msg:"Error while deleting data"});
                            // self.postMessage({msg:"Error while deleting data"});
                        }
                        req.oncomplete = function (e){
                            close !== false ? idbObj[currentIdbName].close(): undefined;
                            return resolve({msg:"Successfully deleted data"});
                            // self.postMessage({msg:"Successfully deleted data"});
                        }    
                    }
                }
                catch(error)
                {
                   return reject({msg:error,ScriptError:true})
                }
            }, function(){
                return reject({msg:"Cannot open indexeddb"});
            });
        }catch(error){
            return reject({msg:error,ScriptError:true})
        }
    });
}
function updateMultiple(obj){
    return new Promise(function(resolve, reject){
        try{
            var len = obj.data.length, i=0;
            obj.data.forEach(function(item, index){
                updateData({model:obj.model,data:obj.data}, false).then(function(){
                    if(++i == len){
                        idbObj[currentIdbName].close();
                        return resolve();
                    }
                },function(){
                    if(++i == len){
                        idbObj[currentIdbName].close();
                        return resolve();
                    }
                });
            });
        }catch(error){
            return reject({msg:error,ScriptError:true});
        }
    });
}
function updateData(obj, close){
    return new Promise(function(resolve,reject){
        var model = obj.model, 
        data = obj.data, 
        key = obj.key;
        getData(obj).then(function(res){
            try{
                var resData = res.data;
                if(res.data == undefined){
                    addData(obj).then(function(){
                        return resolve({msg: "Successfully added data"});
                    },function(){
                        return reject({msg:"Error while adding data"});
                    });
                }
                else{
                    for(var key in data){
                        resData[key] = data[key];
                    }
                    open(idbObj[currentIdbName].name, idbObj[currentIdbName].version).then(function(){
                        try{
                            var obs = idbObj[currentIdbName].transaction([model],"readwrite").objectStore(model), indexed, iobs;
                            if(obs.indexNames.contains("pk")){
                                iobs = obs.index("pk");
                                indexed = true;
                                if(typeof iobs.keyPath == "string"){
                                    obj.key = key = obj.data[iobs.keyPath];
                                }
                                else if(Array.isArray(iobs.keyPath)){
                                    var arr = [];
                                    iobs.keyPath.forEach(function(itm){
                                        arr.push(obj.data[itm]);
                                    });
                                    key = arr;
                                }
                                openCursorForKey(iobs, key).then(function(cobj){
                                    try{
                                        var pK = cobj.cursor.primaryKey
                                        if(pK !== undefined){
                                            openCursorForKey(obs, pK).then(function(cobj2){
                                                try{
                                                var _req = cobj2.cursor.update(obj.data);
                                                _req.onsuccess = function (e){
                                                    var ind = e.target.result;
                                                    close !== false ? idbObj[currentIdbName].close() : undefined;
                                                    return resolve({msg:"Successfully updated data"});
                                                }
                                                _req.onerror = function (e){
                                                    close !== false ? idbObj[currentIdbName].close() : undefined;
                                                    return reject({msg:"Error while updating data"});
                                                    // self.postMessage({msg:"Error while updating data"});
                                                }
                                                _req.oncomplete = function (e){
                                                    close !== false ? idbObj[currentIdbName].close() : undefined;
                                                    return resolve({msg:"Successfully updated data"});            
                                                    // self.postMessage({msg:"Successfully updated data"});
                                                }
                                                }catch(error){
                                                    return reject({msg:error,ScriptError:true});
                                                }
                                            });
                                        }
                                    }catch(error){
                                        reject({msg:error,ScriptError:true})
                                    }
                                });
                            }
                            else{
                                var req = obs.put(resData);
                                req.onsuccess = function (e){
                                    close !== false ? idbObj[currentIdbName].close() : undefined;
                                    return resolve({msg:"Successfully updated data"});
                                    // self.postMessage({msg:"Successfully updated data"});
                                }
                                req.onerror = function (e){
                                    close !== false ? idbObj[currentIdbName].close() : undefined;
                                    return reject({msg:"Error while updating data"});
                                    // self.postMessage({msg:"Error while updating data"});
                                }
                                req.oncomplete = function (e){
                                    close !== false ? idbObj[currentIdbName].close() : undefined;
                                    return resolve({msg:"Successfully updated data"});            
                                    // self.postMessage({msg:"Successfully updated data"});
                                }        
                            }
                        }catch(error){
                            return reject({msg:error,ScriptError:true})
                        }
                    }, function(){
                        return reject({msg:"Cannot open indexeddb"});
                    });
                }
            }catch(error){
                return reject({msg:error,ScriptError:true})
            }
        },function(){
            return reject({msg:"Error while updating data"});
        });
    });
}
function getData(obj){
    return new Promise(function(resolve,reject){
        var model = obj.model;
        var key = obj.key;
        if(idbObj[currentIdbName] && idbObj[currentIdbName].objectStoreNames.contains(model)){
            open(idbObj[currentIdbName].name, idbObj[currentIdbName].version).then(function(){
                try{
                    var obs = idbObj[currentIdbName].transaction([model],"readwrite").objectStore(model);
                    if(obs.indexNames.contains("pk")){
                        obs = obs.index("pk");
                    }
                    if(obj.processKey){
                        if(Array.isArray(obs.keyPath)){
                            var arr = [];
                            if(key && typeof key == "object"){
                                obs.keyPath.forEach(function(itm){
                                    arr.push(key[itm]);
                                });
                            }
                            else{
                                arr.push(key);
                            }
                            key = arr;
                        }
                    }
                    else if(!key && obj.data){
                        if(typeof obs.keyPath == "string"){
                            key = obj.data[obs.keyPath];
                        }
                        else if(Array.isArray(obs.keyPath)){
                            var arr = [];
                            obs.keyPath.forEach(function(itm){
                                arr.push(obj.data[itm]);
                            });
                            key = arr;
                        }
                    }
                    var req = obs.get(key);
                    req.onsuccess = function (e){
                        idbObj[currentIdbName].close();
                        return resolve({msg:"Successfully got data success", data:e.target.result});
                        // self.postMessage({msg:"Successfully got data", data:e.target.result});
                    }
                    req.onerror = function (e){
                        idbObj[currentIdbName].close();
                        return reject({msg:"Error while getting data"});
                        // self.postMessage({msg:"Error while getting data"});
                    }
                    req.oncomplete = function (e){
                        idbObj[currentIdbName].close();
                        return resolve({msg:"Successfully got data complete", data:e.target.result});
                        // self.postMessage({msg:"Successfully got data", data:e.target.result});
                    }
                }
                catch(error){
                    return reject({msg:error,ScriptError:true})
                }
            }, function(){
                return reject({msg:"Cannot open indexeddb"});
            });
        }
        else{
            return reject({msg:"Error while getting data"});
            // self.postMessage({pause:true, model:obj.model, type: obj.type});
            // return reject({msg:"No such model defined in IDB"});
        }
    });
}
function getAll(obj){
    return new Promise(function(resolve, reject){
        var model = obj.model;
        if(idbObj[currentIdbName] && idbObj[currentIdbName].objectStoreNames.contains(model)){
            open(idbObj[currentIdbName].name, idbObj[currentIdbName].version).then(function(){
                try{
                    var obs = idbObj[currentIdbName].transaction([model],"readwrite").objectStore(model);
                    var req = obs.getAll();
                    req.onsuccess = function (e){
                        idbObj[currentIdbName].close();
                        return resolve({msg:"Successfully got data", data:e.target.result});
                        // self.postMessage({msg:"Successfully got data", data:e.target.result});
                    }
                    req.onerror = function (e){
                        idbObj[currentIdbName].close();
                        return reject({msg:"Error while getting data"});
                        // self.postMessage({msg:"Error while getting data"});
                    }
                    req.oncomplete = function (e){
                        idbObj[currentIdbName].close();
                        return resolve({msg:"Successfully got data", data:e.target.result});
                        // self.postMessage({msg:"Successfully got data", data:e.target.result});
                    }   
                }catch(error){
                    return reject({msg : error , ScriptError : true})
                }
            }, function(){
                return reject({msg:"Cannot open indexeddb"});
            });
        }
        else{
            return reject({msg:"Error while getting data"})
            // self.postMessage({lyteidb:true, pause:true, model:obj.model, type: obj.type});
            // return reject({msg:"No such model defined in IDB"});
        }
    });
}
function openCursorForKey(obs, key){
    return new Promise(function(resolve, reject){
        var req = obs.openCursor(key);
        req.onsuccess = function(e){
            return resolve({cursor: e.target.result});
        }
        req.onerror = function(){
            return reject("Curson not established");
        }
    });
}
// function DataSerDesForIDB( obj ){
//     return new Promise(function( resolve , reject ){
//         var newItem = {};
//         var data = obj.data , type = obj.type , module = obj.module;
//         var IdbRec = data.data ,serData = IdbRec.serData;
//         if(obj.data && type == "IDBSerialize"){
//             if(typeof module.keyPath == "string"){
//                 newItem[module.keyPath] = data[module.keyPath];
//             }
//             else if(Array.isArray(module.keyPath)){
//                 module.keyPath.forEach(function(itm){
//                     newItem[itm] = IdbRec[itm]
//                 });
//             }
//             newItem.__data__ = serData ? serData : data;
//             resolve(newItem);
//         }
//         else if (obj.data && type == "IDBDserialize"){
//             debugger;
//         }
//         reject(data)
//     })
// }
self.postMessage({lyteidb:true, init: "done"});

