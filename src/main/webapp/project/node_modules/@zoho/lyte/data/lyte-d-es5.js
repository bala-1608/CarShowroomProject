/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) });

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
  defineProperty(
    GeneratorFunctionPrototype,
    "constructor",
    { value: GeneratorFunction, configurable: true }
  );
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    defineProperty(this, "_invoke", { value: enqueue });
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per GeneratorResume behavior specified since ES2015:
        // ES2015 spec, step 3: https://262.ecma-international.org/6.0/#sec-generatorresume
        // Latest spec, step 2: https://tc39.es/ecma262/#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method;
    var method = delegate.iterator[methodName];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method, or a missing .next method, always terminate the
      // yield* loop.
      context.delegate = null;

      // Note: ["return"] must be used for ES3 parsing compatibility.
      if (methodName === "throw" && delegate.iterator["return"]) {
        // If the delegate iterator has a return method, give it a
        // chance to clean up.
        context.method = "return";
        context.arg = undefined;
        maybeInvokeDelegate(delegate, context);

        if (context.method === "throw") {
          // If maybeInvokeDelegate(context) changed context.method from
          // "return" to "throw", let that override the TypeError below.
          return ContinueSentinel;
        }
      }
      if (methodName !== "return") {
        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a '" + methodName + "' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(val) {
    var object = Object(val);
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable != null) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    throw new TypeError(typeof iterable + " is not iterable");
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
;var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*Polyfills for functions not available in other browsers. */

/*Polyfill for Node.after
//Not supported out of the box in IE and Edge. 
//from: https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/after()/after().md */
(function (arr) {
	arr.forEach(function (item) {
		if (item.hasOwnProperty('after')) {
			return;
		}
		Object.defineProperty(item, 'after', {
			configurable: true,
			enumerable: true,
			writable: true,
			value: function after() {
				var argArr = Array.prototype.slice.call(arguments),
				    docFrag = document.createDocumentFragment();

				argArr.forEach(function (argItem) {
					var isNode = argItem instanceof Node;
					docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
				});

				this.parentNode.insertBefore(docFrag, this.nextSibling);
			}
		});
	});
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);

/*Polyfill for replaceWith. 
//Not supported out of the box for IE and Edge. */
function ReplaceWith(Ele) {
	var parent = this.parentNode,
	    i = arguments.length,
	    firstIsNode = +(parent && (typeof Ele === 'undefined' ? 'undefined' : _typeof(Ele)) === 'object');
	if (!parent) {
		return;
	}

	while (i-- > firstIsNode) {
		if (parent && _typeof(arguments[i]) !== 'object') {
			arguments[i] = document.createTextNode(arguments[i]);
		}if (!parent && arguments[i].parentNode) {
			arguments[i].parentNode.removeChild(arguments[i]);
			continue;
		}
		parent.insertBefore(this.previousSibling, arguments[i]);
	}
	if (firstIsNode) {
		parent.replaceChild(this, Ele);
	}
}
if (!Element.prototype.replaceWith) {
	Element.prototype.replaceWith = ReplaceWith;
}
if (!CharacterData.prototype.replaceWith) {
	CharacterData.prototype.replaceWith = ReplaceWith;
}
if (!DocumentType.prototype.replaceWith) {
	DocumentType.prototype.replaceWith = ReplaceWith;
}

/*Polyfill for startsWith
//Not supported out of the box for  IE */
if (!String.prototype.startsWith) {
	String.prototype.startsWith = function (searchString, position) {
		position = position || 0;
		return this.indexOf(searchString, position) === position;
	};
}

/*Polyfill for endsWith
//Not supported out of the box for  IE */
if (!String.prototype.endsWith) {
	String.prototype.endsWith = function (search, this_len) {
		if (this_len === undefined || this_len > this.length) {
			this_len = this.length;
		}
		return this.substring(this_len - search.length, this_len) === search;
	};
}

var _Lyte = {
	version: "3.7.0-BETA1",
	$: {
		consoleTime: []
	},
	registeredMixins: {},
	registeredServices: {},
	requiredServices: {},
	toBeInjectedServices: {},
	_registeredComponents: {},
	_keywords: {
		"component": ["init", "didConnect", "didDestroy", "constructor", "onError", "actions", "methods", "data"],
		"adapter": ["namespace", "actionNamespace", "host", "withCredentials", "buildURL", "methodForRequest", "headersForRequest", "reloadRecord", "reloadRecord", "reloadAll", "processRequest", "parseResponse", "parseRequest", "super"],
		"serializer": ["normalize", "normalizeResponse", "serialize", "serializeKey", "deserializeKey", "extractMeta", "payloadKey", "serializeRecord", "normalizeRecord", "super"],
		"route": ["getDependencies", "getResources", "beforeModel", "model", "afterModel", "redirect", "renderTemplate", "afterRender", "beforeExit", "didDestroy", "queryParams", "title", "routeName", "component", "parent", "currentModel", "forceFetch", "setTitle", "setQueryParams", "getQueryParams", "setDynamicParam", "getDynamicParam", "removeFromCache", "refresh", "transitionTo", "replaceWith", "actions"],
		"is": function is(key, scope) {
			var arr = ["component", "adapter", "serializer", "route"];
			if (scope) {
				arr = [scope];
			}
			var len = arr.length;
			for (var i = 0; i < len; i++) {
				var keyArr = this[arr[i]];
				if (keyArr) {
					var res = keyArr.indexOf(key);
					if (res != -1) {
						return true;
					}
				}
			}
			return false;
		}
	},
	Mixin: {},
	Service: {},
	debug: false,
	performance: false,
	toBeRegistered: [],
	browser: {},
	registeredCustomComponent: {},
	Globals: {}
};
if (window.isLyteWidgetParent) {
	_widgetLyte = _Lyte;
	_Lyte.isWidgetBuild = true;
	window.__lyteConfig.isWidgetBuild = true;
} else {
	Lyte = _Lyte;
}

var IdleTaskScheduler = function () {
	function IdleTaskScheduler(obj) {
		_classCallCheck(this, IdleTaskScheduler);

		this.idleCallback = this.idleCallback.bind(this);
		this.timeout = 50;
		this.chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
		this.tasks = new Map();
		this.idleCallbackRequested = false;
		this.delayInit = false;
		this.useRequestIdleCallback = true;
		this.priorityQueue = [];
		this.processTime = {};
		this.perf = false;
		if (obj != undefined) {
			if (obj.useRequestIdleCallback !== undefined) {
				this.useRequestIdleCallback = obj.useRequestIdleCallback;
			}
			if (obj.delayInit !== undefined) {
				this.delayInit = obj.delayInit;
			}
			if (obj.timeout !== undefined) {
				this.timeout = obj.timeout;
			}
			if (obj.priorityQueue !== undefined) {
				this.priorityQueue = obj.priorityQueue;
			}
			if (obj.perf !== undefined) {
				this.perf = obj.perf;
			}
		}
	}

	_createClass(IdleTaskScheduler, [{
		key: 'isGenerator',
		value: function isGenerator(obj) {
			return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === "object" && typeof obj.next === "function" && typeof obj[Symbol.iterator] === "function";
		}
	}, {
		key: 'init',
		value: function init(obj) {
			if (this.delayInit == true) {
				if (obj !== undefined) {
					if (obj.useRequestIdleCallback !== undefined) {
						this.useRequestIdleCallback = obj.useRequestIdleCallback;
					}
					if (obj.timeout !== undefined) {
						this.timeout = obj.timeout;
					}
					if (obj.perf !== undefined) {
						this.perf = obj.perf;
					}
				}
				this.delayInit = false;
				this.tasksScheduler();
			}
		}
	}, {
		key: 'getUniqueKey',
		value: function getUniqueKey(len) {
			var result;
			while (result == undefined || this.tasks.has(result)) {
				result = undefined;
				result = this.generateUniqueKey(len);
			}
			return result;
		}
	}, {
		key: 'generateUniqueKey',
		value: function generateUniqueKey(length) {
			var result = '',
			    clen = this.chars.length;
			for (var _i = 0; _i < length; _i++) {
				result += this.chars.charAt(Math.floor(Math.random() * clen));
			}
			return result;
		}
	}, {
		key: 'enqueueTask',
		value: function enqueueTask(handler, data, id) {
			if (!id) {
				id = this.getUniqueKey(6);
			}
			if (this.tasks.has(id)) {
				console.error("Task with id-" + id + " is alreaded queued for execution.");
				return;
			}
			this.tasks.set(id, { handler: handler, data: data });
			this.tasksScheduler();
			return id;
		}
	}, {
		key: 'deleteTask',
		value: function deleteTask(id) {
			if (id) {
				var val = this.tasks.get(id);
				this.tasks.delete(id);
				if (this.priorityQueue.length) {
					var ind = this.priorityQueue.indexOf(id);
					if (ind != -1) {
						this.priorityQueue.splice(ind, 1);
					}
				}
				return val;
			}
		}
	}, {
		key: 'getPriorityQObj',
		value: function getPriorityQObj() {
			var id,
			    i = 0,
			    pObj;
			if (this.priorityQueue.length) {
				var len = this.priorityQueue.length;
				while (i < len) {
					id = this.priorityQueue[i];
					if (this.tasks.has(id)) {
						pObj = this.tasks.get(id);
						break;
					}
					i++;
				}
				if (pObj) {
					return { id: id, obj: pObj, ind: i };
				}
			}
			return false;
		}
	}, {
		key: 'dequeueTask',
		value: function dequeueTask(id) {
			if (id) {
				var val = this.tasks.get(id);
				// console.log("dequeud-",id);
				this.tasks.delete(id);
				return val;
			} else if (this.tasks.size || this.priorityQueue.length) {
				var pqObj = this.getPriorityQObj(),
				    gnxt,
				    gval,
				    obj,
				    isPriority = false,
				    ind;
				if (pqObj !== false) {
					id = pqObj.id;
					obj = pqObj.obj;
					ind = pqObj.ind;
					isPriority = true;
				} else {
					if (!this.tasks.size) {
						return;
					}
					var val = this.tasks.entries().next().value;
					id = val[0];
					obj = val[1];
				}
				// console.log("dequeud-",id);
				this.currentTask = { id: id, handler: obj.handler };
				Lyte.extendEventListeners(this.currentTask);
				if (this.isGenerator(obj.handler)) {
					gnxt = obj.handler.next();
					if (gnxt.done == false) {
						gval = gnxt.value;
						if (typeof gval == "function") {
							return gval;
						}
					} else {
						this.currentTask.triggerEvent("done", id);
						if (isPriority) {
							this.priorityQueue.splice(ind, 1);
						}
						this.tasks.delete(id);
						return this.dequeueTask();
					}
				} else {
					this.currentTask.triggerEvent("done", id);
					if (isPriority) {
						this.priorityQueue.splice(ind, 1);
					}
					this.tasks.delete(id);
				}
				return obj;
			}
		}
	}, {
		key: 'tasksScheduler',
		value: function tasksScheduler() {
			if (this.delayInit == false) {
				if (this.tasks.size) {
					if (this.idleCallbackRequested == false) {
						if ('requestIdleCallback' in window && this.useRequestIdleCallback) {
							this.idleCallbackRequested = true;
							requestIdleCallback(this.idleCallback);
						} else {
							this.requestIdleCallback(this.idleCallback);
						}
					}
				} else {
					if ('cancelIdleCallback' in window && this.useRequestIdleCallback) {
						cancelIdleCallback(this.idleCallback);
					}
				}
			}
		}
	}, {
		key: 'idleCallback',
		value: function idleCallback(deadline) {
			var task,
			    i = 0,
			    remTime = deadline.timeRemaining();
			while (remTime > 0 && this.tasks.size) {
				task = this.dequeueTask();
				if (this.perf) {
					var p1 = performance.now();
				}
				if (typeof task == "function") {
					// setTimeout(function(){
					task();
					// },1);
				}
				if ((typeof task === 'undefined' ? 'undefined' : _typeof(task)) == "object") {
					// setTimeout(function(){
					var data = task.data || [];
					if (typeof task.handler == "function") {
						var _task;

						(_task = task).handler.apply(_task, _toConsumableArray(data));
					}
					// },1);
				}
				if (this.perf) {
					var p2 = performance.now();
					var id = this.currentTask.id;
					this.processTime[id] = (this.processTime.hasOwnProperty(id) ? this.processTime[id] : 0) + (p2 - p1);
				}
				remTime = deadline.timeRemaining();
			}
			this.idleCallbackRequested = false;
			this.tasksScheduler();
		}
	}, {
		key: 'requestIdleCallback',
		value: function requestIdleCallback(callback) {
			var self = this;
			setTimeout(function () {
				setTimeout(function () {
					var startTime = Date.now();
					callback({
						timeRemaining: function timeRemaining() {
							var diffTime = Date.now() - startTime;
							if (diffTime > self.timeout) {
								return 0;
							}
							return self.timeout - diffTime;
						}
					});
				}, 1);
			}, 50);
		}
	}]);

	return IdleTaskScheduler;
}();

(function (Lyte) {
	var userAgent = Lyte.$.userAgent = window.userAgent = navigator.userAgent;
	var singletonServices = new Map();
	//temporary fix for IE 11
	if (userAgent.match(/rv:11/)) {
		Lyte.browser.ie = true;
		window.action = function () {
			return;
		};
	}
	if (userAgent.match('Edge')) {
		var s = createElement("div");
		s.innerHTML = "<template><div>c</div></template>";
		if (s.querySelector("template").childNodes.length) {
			Lyte.browser.ie = true;
		} else {
			Lyte.browser.edge = true;
		}
		s.remove();
	}

	Lyte.Globals.set = function (scope, value) {
		Lyte.Component.set(Lyte.__gl, scope, value);
	};

	Lyte.Globals.get = function (scope) {
		return Lyte.Component._get(Lyte.__gl, scope);
	};

	Object.defineProperty(Lyte.Service, "__Lyte__", {
		value: Lyte
	});
	Object.defineProperty(Lyte.Mixin, "__Lyte__", {
		value: Lyte
	});
	Object.defineProperty(Lyte.$, "__Lyte__", {
		value: Lyte
	});
	Lyte.Mixin.__Lyte__.requiredMixins = {};
	Lyte.oldProxy = typeof $Lt != "undefined" && $Lt.oldProxy ? $Lt.oldProxy : undefined;

	Lyte.$.assetsDiv = document.createElement("div");
	Lyte.$.assetsDiv.setAttribute("id", "lyteAssetsDiv");
	Lyte.assetsDivContainer = document.head;

	Lyte.$.widgetWrapper = document.createElement("shadow-wrapper");
	Lyte.$.widgetWrapper.attachShadow({ "mode": "open" }); //af
	Lyte.$.widgetWrapper.setAttribute("id", "widgetWrapperDiv");

	Lyte.domContentLoaded = function (callback) {
		if (document.readyState === "complete" || document.readyState === "interactive") {
			callback();
		} else {
			window.addEventListener('DOMContentLoaded', function () {
				callback();
			});
		}
	};

	Lyte.createApplication = function (name, obj) {
		if (obj.init) {
			obj.init.apply(Lyte);
		}
	};

	Lyte.registerErrorCodes = function (obj) {
		Object.assign(Lyte.errorCodes, obj);
	};

	Lyte.establishObserverBindings = function (observers, fromStore, properties, model) {
		var scope = this;
		var watchProps = model && fromStore ? model._fldGrps.JsonPathWatch : scope.constructor._deepWatchProperties;
		if (fromStore) {
			scope = fromStore;
		}
		for (var i = 0; i < observers.length; i++) {
			var props = observers[i].properties;
			var obsAttr = {},
			    obsDuplicate = false;
			var Jpath = {};
			for (var j = 0; j < props.length; j++) {
				var actProp;
				var isArrayObserver = false;
				if (typeof props[j] == "string") {
					if (props[j].search(/^\$\./g) != -1) {

						var JsonPath = props[j];

						var CmpPropertyPath = JsonPath.match(/[^\$.][^\.]*/g)[0];
						if (CmpPropertyPath.search(/\[[0-9*]\]/g) != -1) {
							CmpPropertyPath = CmpPropertyPath.split(/\[[0-9*]\]/g)[0];
						}
						if (watchProps[CmpPropertyPath] == undefined) {
							watchProps[CmpPropertyPath] = [];
						}

						if (Jpath[CmpPropertyPath] == undefined) {
							Jpath[CmpPropertyPath] = [];
						}

						var JSONPATH;
						var reg = "^\\$\\." + CmpPropertyPath + "\\.?";
						reg = new RegExp(reg);
						JSONPATH = props[j].replace(reg, "$.");
						if (!watchProps[CmpPropertyPath].includes(JSONPATH)) {
							watchProps[CmpPropertyPath].push(JSONPATH);
						}

						if (!Jpath[CmpPropertyPath].includes(JSONPATH)) {
							Jpath[CmpPropertyPath].push(JSONPATH);
						}

						CmpPropertyPath = CmpPropertyPath + ".*";
						if (!obsAttr.hasOwnProperty(CmpPropertyPath)) {
							actProp = Lyte.getProperty.call(this, CmpPropertyPath, fromStore, properties);
							obsAttr[CmpPropertyPath] = true;
							obsDuplicate = false;
						} else {
							obsDuplicate = true;
						}
					} else if (props[j].indexOf('.[]') !== -1) {
						isArrayObserver = true;
						actProp = Lyte.getProperty.call(this, props[j].substring(0, props[j].indexOf('.[]')), fromStore, properties);
					} else {
						if (props[j].indexOf('.*') !== -1) {
							var prop = props[j].split(".")[0];
							var isDeepObs = !fromStore && this.component.__data[prop] && this.component.__data[prop].watch || fromStore && model && model.fieldList && model.fieldList[prop] && model.fieldList[prop].watch ? true : false;
							if (!isDeepObs) {
								continue;
							}
						}
						actProp = Lyte.getProperty.call(this, props[j], fromStore, properties);
					}
					if (!obsDuplicate) {
						if (!actProp._observers) {
							Object.defineProperty(actProp, '_observers', {
								value: new Set(),
								enumerable: false,
								writable: true,
								configurable: true
							});
						}
						actProp._observers.add({ callee: scope, observer: observers[i], isArrayObserver: isArrayObserver });
					}
				} else {
					Lyte.warn("ERR27", JSON.stringify(props[j]), observers[i].fnName, this.tagName);
				}
			}
			observers[i].Jpath = Jpath;
			obsAttr = {};
		}
	};

	Lyte.getProperty = function (key, fromStore, properties) {
		var arr = key.match(/([^[\].]+|\[\])/g);
		var property = this;
		if (fromStore) {
			property = properties;
			if (!properties[arr[0]]) {
				properties[arr[0]] = {};
			}
			property = properties[arr[0]];
		} else {
			if (!property._properties[arr[0]]) {
				property._properties[arr[0]] = {};
			}
			property = property._properties[arr[0]];
		}

		Object.defineProperty(property, '_path', { enumerable: false, value: arr[0] });
		for (var _i2 = 1; _i2 < arr.length; _i2++) {
			if (arr[_i2].startsWith("'") || arr[_i2].startsWith('"')) {
				arr[_i2] = arr[_i2].substring(1, arr[_i2].length - 1);
			}
			if (!property[arr[_i2]]) {
				property[arr[_i2]] = {};
				Object.defineProperty(property[arr[_i2]], '_path', { enumerable: false, value: property._path + "." + arr[_i2] });
			}
			property = property[arr[_i2]];
		}
		return property;
	};

	Lyte.getErrorMessage = function (code) {
		var args = Array.from(arguments).slice(1);
		if (Lyte.errorCodes[code]) {
			return Lyte.errorCodes[code].replace(/{(\d+)}/g, function (t, i) {
				return args[i];
			});
		} else {
			return code;
		}
	};

	Lyte.error = function () {
		var errorObj = arguments[0],
		    parse = errorObj.stack;
		errorObj = parse ? errorObj : Error(Lyte.getErrorMessage.apply(Lyte, arguments));
		if (Lyte.onerror) {
			Lyte.onerror.call(this, errorObj, arguments[1]);
		}
		Lyte.triggerEvent("error", errorObj, arguments[1]);
		var safari = errorObj.stack && errorObj.stack.indexOf(errorObj.message) == -1;
		if (parse && !safari) {
			errorObj = JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj)));
		}
		if (arguments[1]) {
			console.error(errorObj.stack ? safari ? errorObj : errorObj.stack : errorObj.message, arguments[1]);
		} else {
			console.error(errorObj.stack ? safari ? errorObj : errorObj.stack : errorObj.message);
		}
	};

	Lyte.warn = function () {
		var errorObj = arguments[0];
		errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : Error(Lyte.getErrorMessage.apply(Lyte, arguments));
		console.warn(errorObj.stack ? errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace("Error: ", "") : errorObj : errorObj.message);
	};

	var requiredMixins = {};
	var fnProto = Function.prototype;
	if (!fnProto.on) {
		fnProto.on = function () {
			Lyte.warn("'.on()' method with the argument '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "callBack", "value": this.type === "observer" ? this.value : this, "properties": arguments, "observes": this.type === "observer" ? this : undefined };
		};
	}
	if (!fnProto.observes) {
		fnProto.observes = function () {
			Lyte.warn("'.observes()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "observer", "value": this, "properties": arguments, "on": Lyte._onObj, "lyteOn": Lyte._onObj };
		};
	}
	if (!fnProto.computed) {
		fnProto.computed = function () {
			Lyte.warn("'.computed()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "computed", "value": this, "properties": arguments };
		};
	}
	Lyte._onObj = function () {
		return { "type": "callBack", "value": this.type === "observer" ? this.value : this, "properties": arguments, "observes": this.type === "observer" ? this : undefined };
	};
	Lyte._observesObj = function () {
		return { "type": "observer", "value": this, "properties": arguments, "on": Lyte._onObj, "lyteOn": Lyte._onObj };
	};
	Lyte._computedObj = function () {
		return { "type": "computed", "value": this, "properties": arguments };
	};
	Lyte._preRegister = function () {
		Lyte._actualFnProtoOn = Function.prototype.on;
		Lyte._actualFnProtoObserves = Function.prototype.observes;
		Lyte._actualFnProtoComputed = Function.prototype.computed;
		var fnProto = Function.prototype;
		fnProto.on = fnProto.lyteOn = Lyte._onObj;
		fnProto.observes = fnProto.lyteObserves = Lyte._observesObj;
		fnProto.computed = fnProto.lyteComputed = Lyte._computedObj;
	};
	Lyte._postRegister = function () {
		var fnProto = Function.prototype;
		fnProto.on = Lyte._actualFnProtoOn;
		fnProto.observes = Lyte._actualFnProtoObserves;
		fnProto.computed = Lyte._actualFnProtoComputed;
	};
	Object.defineProperty(Lyte.Mixin, "register", {
		get: function get() {
			Lyte._preRegister();
			return Lyte.registerMixinWrapper;
		},
		"enumerable": true });
	Lyte.registerMixinWrapper = function () {
		try {
			Lyte.registerMixin.apply(Lyte, arguments);
			Lyte._postRegister();
		} catch (e) {
			Lyte._postRegister();
		}
	};
	Lyte.registerMixin = function (name, mixin) {
		Lyte.registeredMixins[name] = mixin;
		var req;
		if (req = requiredMixins[name]) {
			for (var key in req) {
				Lyte.$.requiredMixins[key](mixin, req[key], key);
			}
		}
	};

	Lyte.Mixin.get = function (name) {
		return Lyte.registeredMixins[name];
	};

	Lyte.$.instantiateService = function (name, data) {
		var service = Lyte.registeredServices[name];
		if (service.singleton == true) {
			if (singletonServices.has(name)) {
				return singletonServices.get(name);
			} else {
				var ins = new service(data);
				singletonServices.set(name, ins);
				return ins;
			}
		} else {
			return new service(data);
		}
	};

	Lyte.Service.register = function (name, service, isSingleton) {
		if (Lyte.registeredServices.hasOwnProperty(name)) {
			Lyte.warn('Service -' + name + ' is already registered');
			return;
		}
		if (!Lyte._keywords.is(name)) {
			var data = service,
			    req;
			if (isSingleton) {
				data.singleton = isSingleton;
			}
			Lyte.registeredServices[name] = data;
			var serv = Lyte.requiredServices[name];
			if (serv && serv.size) {
				serv.forEach(function (obj) {
					var toSend = data;
					if (obj.isGlobal) {
						toSend = Lyte.__gS[obj.key] = Lyte.__gS[obj.key] || Lyte.$.instantiateService(name, obj.data);
					}
					obj.cB(toSend, obj.key, obj.name, name);
				});
			}
			return data;
		} else {
			Lyte.warn('Service name-' + name + ' should not be a keyword used in Lyte');
		}
	};

	Lyte.Service.getInjected = function (key) {
		if (Lyte.__gS.hasOwnProperty(key)) {
			return Lyte.__gS[key];
		}
	};

	// Lyte.Service.get = function(name) {
	//   return Lyte.registeredServices[name];
	// }

	Lyte.$.requiredServices = function (key, serviceName, cB, type, name, isGlobal, data) {
		var reqServ = Lyte.requiredServices[serviceName];
		var req = reqServ ? reqServ : Lyte.requiredServices[serviceName] = new Map();
		var id = Lyte.$.genMapId(req);
		req.set(id, { key: key, cB: cB, type: type, name: name, serviceName: serviceName, isGlobal: isGlobal, data: data });
		return serviceName + "-" + id;
	};

	Lyte.$.lazyRegisterService = function (service, obj) {
		var scope = obj.scope,
		    name = obj.name,
		    callback = scope[obj.type][name];
		if (callback) {
			callback[obj.key] = service;
		}
	};

	Lyte.$.injectServices = {};
	Object.defineProperty(Lyte, "__gS", {
		value: {}
	});
	Lyte.injectServices = function (data) {
		var serv = {};
		if (!Array.isArray(data)) {
			data = [data];
		}
		data.forEach(function (itm) {
			if (itm && (typeof itm === 'undefined' ? 'undefined' : _typeof(itm)) == 'object') {
				var key = itm.as,
				    service = itm.service,
				    args = itm.data;
				if (!Lyte._keywords.is(key)) {
					if (!Lyte.toBeInjectedServices.hasOwnProperty(key)) {
						Lyte.toBeInjectedServices[key] = service;
						serv[key] = { service: service, data: args };
						if (Lyte.registeredServices[service]) {
							Lyte.__gS[key] = Lyte.$.instantiateService(service, args);
						}
					} else {
						Lyte.warn("A service has already been injected in the key named, ", key);
					}
				} else {
					Lyte.warn("Service cannot be used in any keywords of Lyte.");
				}
			} else if (typeof itm == "string") {
				if (!Lyte.toBeInjectedServices.hasOwnProperty(itm)) {
					Lyte.toBeInjectedServices[itm] = itm;
					serv[itm] = { service: itm };
					if (Lyte.registeredServices[itm]) {
						Lyte.__gS[itm] = Lyte.$.instantiateService(itm);
					}
				} else {
					Lyte.warn("A service has already been injected in the key named, ", itm);
				}
			} else {
				Lyte.warn("Invalid data passed to injectServices", itm);
			}
		});
		var mdlObj = Lyte.$.injectServices;
		for (var mKey in mdlObj) {
			for (var key in serv) {
				mdlObj[mKey](key, serv[key].service, mKey, Lyte.__gS[key], undefined, serv[key].data);
			}
		}
	};

	Lyte.$.genMapId = function (map) {
		var id = Math.floor(Math.random() * 10000000000 + 1);
		while (map.get(id)) {
			id = Math.floor(Math.random() * 10000000000 + 1);
		}
		return id.toString();
	};

	Lyte.$.toRemoveFromRequiredServices = function (str) {
		var arr = str.split("-"),
		    id = arr[arr.length - 1],
		    idLen = id.length,
		    servName = str.substr(0, str.length - (idLen + 1));
		var reqArr = Lyte.requiredServices[servName];
		if (reqArr) {
			reqArr.delete(id);
		}
	};

	Lyte.toBeUsedServices = function (obj) {
		// var serviceToBeUsed = obj.callback ? Object.assign({}, Lyte.toBeInjectedServices) : {};
		var serviceToBeUsed = {};
		var arr = obj.services;
		if (arr) {
			arr.forEach(function (service) {
				if (typeof service == "string") {
					serviceToBeUsed[service] = service;
				} else if (service && (typeof service === 'undefined' ? 'undefined' : _typeof(service)) == "object") {
					var key = service.as,
					    serv = service.service;
					if (!Lyte._keywords.is(key, obj.type)) {
						serviceToBeUsed[key] = serv;
					} else {
						Lyte.warn("Service cannot be used in any keywords of Lyte.");
					}
				}
			});
		}
		return serviceToBeUsed;
	};

	Lyte.extendService = function (arg) {
		var servObj = Lyte.toBeUsedServices(arg),
		    name;
		for (var serv in servObj) {
			name = servObj[serv];
			// var scp = arg.isGlobal && Lyte.__gS.hasOwnProperty(serv) : Lyte.registeredServices; 
			if (arg.isGlobal && Lyte.__gS.hasOwnProperty(serv) || !arg.isGlobal && Lyte.registeredServices.hasOwnProperty(name)) {
				var ins = arg.ins,
				    service = arg.isGlobal ? Lyte.__gS[serv] : Lyte.$.instantiateService(name);
				if (!Array.isArray(ins)) {
					ins = [arg.ins];
				}
				ins.forEach(function (insObj) {
					insObj[serv] = arg.isGlobal ? Lyte.__gS[serv] : Lyte.$.instantiateService(name);
				});
			} else {
				Lyte.$.requiredServices(serv, name, arg.callback, arg.type, arg.name, arg.isGlobal, arg.data);
			}
		}
	};

	Lyte.$.requiredMixins = function (mixin, dir, type) {
		var req = requiredMixins[mixin] ? requiredMixins[mixin] : requiredMixins[mixin] = {};
		if (!req[type]) {
			req[type] = [dir];
		} else {
			req[type].push(dir);
		}
	};

	Lyte.Mixin.exists = function (name) {
		if (!Lyte.registeredMixins[name]) {
			// Lyte.error('Mixin used before being registered.');
			return false;
		}
		return true;
	};

	Lyte.log = function (text, src, color) {
		if (Lyte.debug) {
			if (color) {
				console.log("%c" + text, 'color:' + color);
			} else {
				console.log(text);
			}
		}
	};

	Lyte.time = function (fn) {
		if (Lyte.performance) {
			var index;
			if ((index = Lyte.$.consoleTime.indexOf(fn)) != -1) {
				Lyte.$.consoleTime.splice(index, 1);
				console.timeEnd(fn);
			} else {
				Lyte.$.consoleTime.push(fn);
				console.time(fn);
			}
		}
	};
	/* disable async function */
	Lyte.isRecord = function (object) {
		if (object && object.$ && object.$.hasOwnProperty("isModified")) {
			return true;
		}
		return false;
	};

	Lyte.isComponent = function (object) {
		if (object && object.$node && object.__data) {
			return true;
		}
		return false;
	};

	/* --------- lyte router v2 changes starts---- */
	Lyte.$.reqFiles = {};

	Lyte.injectResources = function (files, every, completed, options) {
		var successFiles = [],
		    errorFiles = [];
		every = every || function () {};
		completed = completed || function () {};
		return new Promise(function (resolve, reject) {
			processRequirements(files, function () {
				if (options && options.defer) {
					options.defer({
						injectJS: injectJS,
						files: files,
						errorFiles: errorFiles
					});
					resolve();
				} else {
					injectJS(files, function () {
						completed(successFiles, errorFiles);
						if (errorFiles.length) {
							reject(successFiles, errorFiles);
						} else {
							resolve(successFiles, errorFiles);
						}
					});
				}
			}.bind(this));
		});

		function injectJS(files, resolve, execFiles) {
			var len;
			execFiles = execFiles || [];
			if (!files) {
				resolve(successFiles, errorFiles);
			} else {
				if (!Array.isArray(files)) {
					files = [files];
				}
				if (!files.length) {
					resolve(successFiles, errorFiles);
				}
				len = -files.length;
				files.forEach(function (file) {
					if (typeof file == "string") {
						var type = getFileExtn(file);
						if (type && (type == ".js" || type == ".css") && execFiles.indexOf(file) == -1) {
							execFiles.push(file);
							createScript(file, function () {
								loaded();
							});
						} else {
							loaded();
						}
					} else if (Array.isArray(file)) {
						injectJS(file, function () {
							loaded();
						});
					} else {
						len--;
						injectJS(file.parent, function () {
							injectJS(file.child, function () {
								loaded();
							});
							loaded();
						});
					}
				});
			}

			function loaded() {
				len++;
				if (len == 0) {
					resolve(successFiles, errorFiles);
				}
			}
		}

		function createScript(file, resolve) {
			var ev = Lyte.injectResources.respObj[file];
			if (ev && (!Lyte.injectResources.availableTags[file] || Lyte.injectResources.availableTags[file].tag.getAttribute("rel") == "preload")) {
				var type = getFileExtn(file),
				    tag;
				if (type == ".js") {
					tag = document.createElement('script');
					tag.setAttribute('type', "text/javascript");
					tag.setAttribute('src', file);
				} else if (type == ".css") {
					tag = document.createElement('link');
					tag.setAttribute('type', "text/css");
					tag.setAttribute('rel', "stylesheet");
					tag.setAttribute('href', file);
				}
				ev.getAttributeNames().forEach(function (attr) {
					if (["href", "as", "rel"].indexOf(attr) == -1) {
						tag.setAttribute(attr, ev.getAttribute(attr));
					}
				});
				tag.onerror = tag.onload = function (event) {
					if (event.type == "error") {
						errorFiles.push(event);
					} else {
						successFiles.push(event);
					}
					delete Lyte.injectResources.respObj[file];
					Lyte.injectResources.availableTags[file].tag.remove();
					Lyte.injectResources.availableTags[file] = { tag: tag, event: event, type: event.type == "error" ? "error" : "load" };
					resolve();
					tag.onerror = tag.onload = undefined;
				};
				Lyte.$.assetsDiv.appendChild(tag);
			} else {
				var t = Lyte.injectResources.availableTags[file];
				if (t.type == "error") {
					errorFiles.push(t.event);
				} else {
					successFiles.push(t.event);
				}
				resolve();
			}
		}

		function processRequirements(files, resolve) {
			var len;
			if (!files) {
				resolve();
			} else {
				if (!Array.isArray(files)) {
					files = [files];
				}
				if (!files.length) {
					resolve();
				}
				len = -files.length;
				files.forEach(function (file) {
					if (typeof file == "string") {
						requestFile(file, Lyte.injectResources.availableTags[file], function () {
							loaded();
						});
					} else if (Array.isArray(file)) {
						new Promise(function (r) {
							processRequirements(file, r);
						}).then(function () {
							loaded();
						});
					} else {
						len--;
						new Promise(function (r) {
							processRequirements(file.parent, r);
						}).then(function () {
							loaded();
						});
						new Promise(function (r) {
							processRequirements(file.child, r);
						}).then(function () {
							loaded();
						});
					}
				});
			}

			function loaded() {
				len++;
				if (len == 0) {
					resolve();
				}
			}

			function requestFile(file, cached, resolve) {
				if (Lyte.$.reqFiles[file]) {
					Lyte.$.reqFiles[file].push(resolve);
				} else {
					Lyte.$.reqFiles[file] = [resolve];
					if (cached && cached.event.type != "error") {
						if (Lyte.removeFromCache.arr.indexOf(file) != -1) {
							Lyte.removeFromCache.arr.splice(Lyte.removeFromCache.arr.indexOf(file), 1);
						}
						fileLoaded.call(cached.tag, file, cached.event, true);
						resolve();
					} else {
						makeRequest(file, function (event) {
							Lyte.injectResources.respObj[file] = this;
							Lyte.$.reqFiles[file].forEach(function (resolve) {
								resolve();
							});
							// filesObj[file] = this;
							fileLoaded.call(this, file, event);
							every.call(this, event);
						});
					}
				}
			}

			function fileLoaded(file, event, cached) {
				delete Lyte.$.reqFiles[file];
				if (!cached) {
					if (Lyte.injectResources.availableTags[file]) {
						Lyte.injectResources.availableTags[file].tag.remove();
						delete Lyte.injectResources.respObj[file];
					}
					Lyte.injectResources.availableTags[file] = { tag: this, event: event, type: event.type };
				}
			}
		}

		function makeRequest(file, callBack) {
			var tag,
			    ev = every.internal || {},
			    type = getFileExtn(file);
			ev.file = file;
			if (type == null) {
				Lyte.error('Type of file is not specified in injectResources.');
				return;
			}
			tag = document.createElement('link');
			tag.setAttribute('href', file);
			ev.tag = tag;
			if (type == '.css') {
				tag.setAttribute('as', "style");
			} else {
				tag.setAttribute('as', "script");
			}
			tag.setAttribute('rel', "preload");
			tag.onerror = tag.onload = function (event) {
				callBack.call(this, event);
				this.onerror = this.onload = undefined;
			};
			Lyte.triggerEvent("onBeforeInject", ev);
			Lyte.$.assetsDiv.appendChild(tag);
		};
	};

	function getFileExtn(file) {
		return file.match(/\.[a-zA-Z]+(?=\?|$)/);
	}

	Lyte.injectResources.availableTags = [];
	Lyte.injectResources.respObj = [];

	function getFileExtn(file) {
		return file.match(/\.[a-zA-Z]+(?=\?|$)/);
	}

	Lyte.$.replaceOldInjectResource = function () {
		Lyte.injectResources = function (files, every, completed) {
			var successFiles = [],
			    errorFiles = [];
			every = every || function () {};
			completed = completed || function () {};
			return new Promise(function (resolve) {
				processRequirements(files, resolve);
			}).then(function () {
				completed(successFiles, errorFiles);
			});

			function processRequirements(files, resolve) {
				var len;
				if (!files) {
					resolve();
				} else {
					if (!Array.isArray(files)) {
						files = [files];
					}
					if (!files.length) {
						resolve();
					}
					len = -files.length;
					files.forEach(function (file) {
						if (typeof file == "string") {
							requestFile(file, Lyte.injectResources.availableTags[file], function () {
								loaded();
							});
						} else if (Array.isArray(file)) {
							new Promise(function (r) {
								processRequirements(file, r);
							}).then(function () {
								loaded();
							});
						} else {
							new Promise(function (r) {
								processRequirements(file.parent, r);
							}).then(function () {
								new Promise(function (r1) {
									processRequirements(file.child, r1);
								}).then(function () {
									loaded();
								});
							});
						}
					});
				}

				function loaded() {
					len++;
					if (len == 0) {
						resolve();
					}
				}

				function requestFile(file, cached, resolve) {
					if (Lyte.$.reqFiles[file]) {
						Lyte.$.reqFiles[file].push(resolve);
					} else {
						Lyte.$.reqFiles[file] = [resolve];
						if (cached && cached.event.type != "error") {
							if (Lyte.removeFromCache.arr.indexOf(file) != -1) {
								Lyte.removeFromCache.arr.splice(Lyte.removeFromCache.arr.indexOf(file), 1);
							}
							fileLoaded.call(cached.tag, cached.event, true);
							resolve();
						} else {
							makeRequest(file, function (event) {
								Lyte.$.reqFiles[file].forEach(function (resolve) {
									resolve();
								});
								fileLoaded.call(this, event);
								every.call(this, event);
							});
						}
					}
				}

				function fileLoaded(event, cached) {
					var file = this.getAttribute('src') || this.getAttribute('href');
					delete Lyte.$.reqFiles[file];
					if (!cached) {
						if (Lyte.injectResources.availableTags[file]) {
							Lyte.injectResources.availableTags[file].tag.remove();
						}
						this.onerror = this.onload = undefined;
						Lyte.injectResources.availableTags[file] = { tag: this, event: { type: event.type } };
					}
				}
			}

			function makeRequest(file, callBack) {
				var tags = { ".js": 'script', ".css": 'link' },
				    type = getFileExtn(file);
				tag = document.createElement(tags[type]);
				if (!type) {
					Lyte.error('Type of file is not specified in injectResources.');
					return;
				} else if (type == '.css') {
					tag.setAttribute('href', file);
					tag.setAttribute('type', "text/css");
					tag.setAttribute('rel', "stylesheet");
				} else {
					tag.setAttribute('src', file);
				}
				tag.onerror = tag.onload = function (event) {
					if (event.type == "error") {
						errorFiles.push(event);
					} else {
						successFiles.push(event);
					}
					if (callBack) {
						callBack.call(this, event);
					}
				};
				var ev = every.internal || {};
				ev.file = file;
				ev.tag = tag;
				Lyte.triggerEvent("onBeforeInject", ev);
				Lyte.$.assetsDiv.appendChild(tag);
			};
		};

		Lyte.injectResources.availableTags = [];
		Lyte.injectResources.respObj = [];
	};

	Lyte.removeFromCache = function (arr) {
		Lyte.removeFromCache.assign(arr);
		if (Lyte.removeFromCache.arr.length) {
			Lyte.removeFromCache.arr.forEach(function (file) {
				if (Lyte.injectResources.availableTags[file]) {
					Lyte.injectResources.availableTags[file].tag.remove();
					delete Lyte.injectResources.availableTags[file];
					delete Lyte.injectResources.respObj[file];
				}
			});
			Lyte.removeFromCache.arr = [];
		}
	};

	Lyte.removeFromCache.arr = [];

	Lyte.removeFromCache.assign = function (arr) {
		arr = arr == "*" ? Object.keys(Lyte.injectResources.availableTags) : Array.isArray(arr) ? arr : [arr];
		Lyte.removeFromCache.arr = Lyte.removeFromCache.arr.concat(arr);
		return;
	};

	Lyte.$.prefetchSupport = false;
	try {
		if (!Lyte.browser.ie) {
			var link = document.createElement('link');
			Lyte.$.prefetchSupport = link.relList.supports('prefetch') && link.relList.supports('preload');
		}
	} catch (e) {}
	if (!Lyte.$.prefetchSupport) {
		console.log("Prefetch is not supported. Falling back to old implementation");
		Lyte.$.replaceOldInjectResource();
	}

	/* --------- lyte router v2 changes ends ---- */

	Lyte.checkProperty = function (property, dataVal, key, fieldVal, field, record, type, name, init) {
		var exts = "extends";
		switch (property) {
			case "type":
				if (Lyte.Transform.hasOwnProperty(fieldVal) && dataVal !== undefined && dataVal !== null) {
					var _fld = Lyte.Transform[fieldVal],
					    _ret = true;
					if (Array.isArray(dataVal)) {
						if (Lyte.Transform[fieldVal][exts] != "array") {
							return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
						}
						if (_fld.hasOwnProperty("items")) {
							_ret = Lyte.checkProperty("items", dataVal, key, _fld.items);
						}
					} else if ((typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal)) === "object" && Lyte.Transform[fieldVal][exts] == "object" && _fld.hasOwnProperty("properties")) {
						_ret = Lyte.checkProperty("properties", dataVal, key, _fld.properties);
					} else if (Lyte.Transform[fieldVal][exts] != (typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal))) {
						return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
					}
					if (_ret !== true) {
						return _ret;
					}
				} else if (dataVal !== undefined && dataVal !== null) {
					if (Array.isArray(dataVal)) {
						if (fieldVal != "array") {
							return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
						}
					} else if (fieldVal != (typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal))) {
						return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
					}
				}
				break;
			case "mandatory":
				var validateFlag = fieldVal;
				if ((typeof fieldVal === 'undefined' ? 'undefined' : _typeof(fieldVal)) == "object") {
					if (init && fieldVal.skipValidationOnInit == true) {
						validateFlag = false;
					}
				}
				if (validateFlag && (dataVal == undefined || dataVal == null || dataVal === "")) {
					return { code: "ERR02", message: Lyte.errorCodes.ERR02 };
				}
				break;
			case "maximum":
				if (typeof dataVal == "number" && dataVal > fieldVal) {
					return { code: "ERR04", message: Lyte.errorCodes.ERR04, expected: fieldVal };
				}
				break;
			case "minimum":
				if (typeof dataVal == "number" && dataVal < fieldVal) {
					return { code: "ERR05", message: Lyte.errorCodes.ERR05, expected: fieldVal };
				}
				break;
			case "maxLength":
			case "maxItems":
				if (dataVal && dataVal.length > fieldVal) {
					return { code: "ERR06", message: Lyte.errorCodes.ERR06, expected: fieldVal };
				}
				break;
			case "minLength":
			case "minItems":
				if (dataVal && dataVal.length < fieldVal) {
					return { code: "ERR07", message: Lyte.errorCodes.ERR07, expected: fieldVal };
				}
				break;
			case "pattern":
				if (typeof dataVal == "string" && !new RegExp(fieldVal).test(dataVal)) {
					return { code: "ERR08", message: Lyte.errorCodes.ERR08, expected: fieldVal };
				}
				break;
			case "uniqueItems":
				{
					if (Array.isArray(dataVal) && fieldVal) {
						var newArr = [];
						for (var i = 0; i < dataVal.length; i++) {
							var val = dataVal[i];
							if (newArr.indexOf(val) != -1) {
								return { code: "ERR09", message: Lyte.errorCodes.ERR09 };
							}
							newArr.push(val);
						}
					}
					break;
				}
			case "constant":
				if (Array.isArray(dataVal)) {
					var resp = dataVal.length == fieldVal.length && dataVal.every(function (v, i) {
						return v === fieldVal[i];
					});
					if (!resp) {
						return { code: "ERR10", message: Lyte.errorCodes.ERR10, expected: fieldVal };
					}
				} else if ((typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal)) == "object") {
					var resp = store.adapter.$.compareObjects(dataVal, fieldVal);
					if (!resp) {
						return { code: "ERR10", message: Lyte.errorCodes.ERR10, expected: fieldVal };
					}
				} else if (dataVal && dataVal != fieldVal) {
					return { code: "ERR10", message: Lyte.errorCodes.ERR10, expected: fieldVal };
				}
				break;
			case "items":
				{
					if (Array.isArray(dataVal)) {
						for (var i = 0; i < dataVal.length; i++) {
							if (!(fieldVal.any && Array.isArray(fieldVal))) {
								fieldVal = [fieldVal];
							}
							var fldLen = fieldVal.length,
							    _ret = true;
							for (var j = 0; j < fldLen; j++) {
								var _fld = fieldVal[j];
								for (var property in _fld) {
									var resp = Lyte.checkProperty(property, dataVal[i], i, _fld[property], _fld);
									if (resp !== true) {
										if (_ret === true) {
											resp.path = resp.path ? i + "." + resp.path : resp.path;
											_ret = resp;
										}
										break;
									}
								}
							}
							if (_ret !== true) {
								return _ret;
							}
						}
					}
					break;
				}
			case "properties":
				if ((typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal)) == "object" && !Array.isArray(dataVal)) {
					for (var key in dataVal) {
						if (fieldVal.hasOwnProperty(key)) {
							var fld = fieldVal[key];
							if (!(fld.any && Array.isArray(fld))) {
								fld = [fld];
							}
							var fldLen = fld.length,
							    _ret = true;
							for (var i = 0; i < fldLen; i++) {
								var _fld = fld[i];
								for (var property in _fld) {
									var resp = Lyte.checkProperty(property, dataVal[key], key, _fld[property], _fld);
									if (resp != true) {
										if (_ret === true) {
											resp.path = resp.path ? key + "." + resp.path : key.toString();
											_ret = resp;
										}
										break;
									}
								}
							}
							if (_ret !== true) {
								return _ret;
							}
						}
						// else if(field.exact){
						// 	return { code : "ERR29", message: Lyte.errorCodes.ERR29, property: key };
						// }
					}
				}
				break;
			case "validation":
				{
					var resp = Lyte.customValidator[fieldVal].apply(record, [key, dataVal, name]);
					if (resp != true) {
						return resp;
					}
					break;
				}
			case "instanceof":
				{
					if ((typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal)) === "object" && !Array.isArray(dataVal) && !(dataVal instanceof fieldVal)) {
						return { code: "ERR30", message: Lyte.errorCodes.ERR30, property: key, instanceof: fieldVal };
					}
				}
		}
		return true;
	};

	Lyte.checkNestedProp = function (id, path, dtype, wobj, object, property, value, check, fromStore) {
		if (Lyte.Transform[dtype.type]) {
			dtype = Lyte.Transform[dtype.type];
			dtype.type = dtype.extends;
		}
		if (path.length != 0) {
			if (dtype.type == 'array') {
				if (dtype.items && !isNaN(path[0]) && _typeof(dtype.items) == 'object') {
					path = path.slice(1);
					Lyte.checkNestedProp(id, path, dtype.items, wobj, object, property, value, check, fromStore);
				}
			} else if (dtype.type == "object") {
				if (dtype.properties && dtype.properties.hasOwnProperty(path[0])) {
					var k = path[0];
					path = path.slice(1);
					Lyte.checkNestedProp(id, path, dtype.properties[k], wobj, object, property, value, check, fromStore);
				}
			}
		} else {
			var err;
			if (dtype && (dtype.properties || dtype.items) && !check.hasOwnProperty("warn")) {
				var component = {};component.__data = {};
				if (dtype.properties) {
					component.__data[property] = dtype.properties[property];
				} else if (dtype.items && wobj.index) {
					component.__data[wobj.index] = dtype;
				} else {
					component.__data[property] = dtype.items;
				}
				var cp = Lyte.validate(object, property, value, component);
				var errKey = wobj.attr ? wobj.attr : wobj.key,
				    _path = wobj.path.split(".");
				var PathWay = wobj.index == undefined && property ? wobj.path + (wobj.path != "" ? "." : "") + property : wobj.index != undefined ? wobj.path + (wobj.path != "" ? "." : "") + wobj.index : wobj.path;
				if (cp && (typeof cp === 'undefined' ? 'undefined' : typeof cp === 'undefined' ? 'undefined' : _typeof(cp)) == "object" && cp.code) {
					cp.value = value;
					cp.path = wobj.path != "" ? wobj.path : property;
					if (wobj.isRec && fromStore && wobj.key == undefined && wobj.path != "") {
						errKey = wobj.path.split(".")[0];
						_path.shift();
						_path = _path.length == 1 && _path[0] == property ? [] : _path;
					}
					// wobj.Error ? true : wobj.Error = {}
					wobj.Error && wobj.Error[errKey] ? wobj.Error[errKey].code && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : wobj.Error[errKey].nested = {} : wobj.Error[errKey] = { nested: {} };
					wobj.Error[errKey].code = "ERR34";
					wobj.Error[errKey].message = Lyte.errorCodes.ERR34;
					err = wobj.Error[errKey].nested;
					wobj._cmpErr[errKey] ? true : wobj._cmpErr[errKey] = {};
					wobj._cmpErr[errKey].code = "ERR34";
					wobj._cmpErr[errKey].message = Lyte.errorCodes.ERR34;
					var cmpErrPath = wobj._cmpErr[errKey].path ? wobj._cmpErr[errKey].path : [];
					if (wobj.path != "") {
						_path.forEach(function (k) {
							if (err && !err[k]) {
								err = err[k] = {};
							} else {
								err = err[k];
							}
						});
					}
					wobj.index != undefined ? err[wobj.index] = cp : err[property] = cp;
					if (!cmpErrPath.includes(PathWay)) {
						cmpErrPath.push(PathWay);
					}
					wobj._cmpErr[errKey].path = cmpErrPath;
				} else {
					if (wobj.isRec && fromStore && wobj.key == undefined) {
						errKey = wobj.path.split(".")[0];
						_path.shift();
						_path = _path.length == 1 && _path[0] == property ? [property] : _path;
					}
					err = wobj.Error[errKey] && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : undefined;
					var cmpErr = wobj._cmpErr[errKey] || undefined;
					if (cmpErr && cmpErr.path && cmpErr.path.includes(PathWay)) {
						var ind = cmpErr.path.indexOf(PathWay);
						cmpErr.path.splice(ind, 1);
					}
					//var p = object.$.error[property];
					if (err) {
						var key = wobj.index || property;
						var flag = true,
						    p = PathWay.split(".");
						p.forEach(function (r) {
							if (err[r] && err[r].code) {
								delete err[r];
								if (err && Object.keys(err).length == 0) {
									flag = true;
								} else {
									flag = false;
								}
							} else {
								err = err[r];
							}
						});
						if (flag == true && wobj.Error[errKey] && wobj._cmpErr[errKey]) {
							delete wobj.Error[errKey];
							delete wobj._cmpErr[errKey];
						}
					}
				}
				if (check.value && check.value.hasOwnProperty("code") && cp.code || !check.value) {
					check.value = cp;
				}
			}
		}
		wobj.index && delete wobj.index;
	};

	Lyte.types = ["string", "object", "number", "boolean", "array"];

	Lyte.attr = function (type, opts) {
		var obj = {};
		obj.type = type;
		if (opts == undefined) {
			opts = {};
		}
		if (Lyte.types.indexOf(type) == -1 && !Lyte.Transform.hasOwnProperty(type)) {
			throw new Error("Not a valid field type - " + type);
		}
		Object.assign(obj, opts);
		return obj;
	};

	window.prop = Lyte.attr;
	Lyte.defineRelation = function (name, type, opts) {
		var relation = { type: "relation", relType: type, relatedTo: name };
		if (opts) {
			relation.opts = opts;
		}
		return relation;
	};

	Lyte.belongsTo = function (name, opts) {
		return this.defineRelation(name, "belongsTo", opts);
	};

	Lyte.hasMany = function (name, opts) {
		return this.defineRelation(name, "hasMany", opts);
	};

	Lyte.Transform = {};

	Lyte.customValidator = {};

	Lyte.registerDataType = function (fieldTypeName, properties) {
		var exts = "extends";
		if (this.Transform.hasOwnProperty(fieldTypeName)) {
			Lyte.warn("Custom Field Type - " + fieldTypeName + " -  already exists.");
			return;
		}
		if (properties[exts] == undefined || Lyte.types.indexOf(properties[exts]) == -1) {
			Lyte.error("Not a valid field type - " + properties[exts]);
			return;
		}
		this.Transform[fieldTypeName] = properties;
	};

	Lyte.registerValidator = function (customValidatorName, func) {
		if (this.customValidator.hasOwnProperty(customValidatorName)) {
			Lyte.warn("Custom Validator with name - " + customValidatorName + " - already exists");
			return;
		}
		this.customValidator[customValidatorName] = func;
	};

	Lyte.patterns = {
		email: /^([A-Za-z0-9._%\-'+/]+@[A-Za-z0-9.-]+\.[a-zA-Z]{2,22})$/,
		url: /(^(ht|f)tp(s?):\/\/[0-9a-zA-Z][-.\w]*(:[0-9])*(\/?)([a-zA-Z0-9\-.?,:'/\\+=&amp;%$#_[\]@!()*;~]*)?$)/,
		ampm: /^(AM|PM|am|pm)$/,
		hour: /^(0?[0-9]|1[0-9]|2[0-4])$/,
		minute: /^(0?[0-9]|[1-5][0-9]|60)$/,
		boolean: /^(true|false|TRUE|FALSE)$/,
		alphaNumeric: /([a-zA-Z0-9])+/,
		alphabetsOnly: /([a-zA-Z])+/,
		numeric: /([0-9])+/,
		phoneNo: /^[0-9a-zA-Z+.()\-;\s]+$/
	};

	Lyte.validate = function (object, key, value, component, init) {
		var definition = component.__data[key];
		var isError = false;
		var type = definition ? definition.type : undefined;
		var _def = definition;
		if (_def) {
			if (!(_def.any && Array.isArray(_def))) {
				_def = [_def];
			}
			var defLen = _def.length,
			    _ret = true;
			for (var i = 0; i < defLen; i++) {
				var _d = _def[i];
				for (var defKey in _d) {
					isError = Lyte.checkProperty(defKey, value, key, _d[defKey], _d, object, type, undefined, init);
					if (isError !== true) {
						if (_ret === true) {
							_ret = isError;
						}
					}
				}
			}
			if (_ret !== true) {
				return _ret;
			}
		}
		return false;
	};

	Lyte.registerPattern = function (patternName, pattern) {
		this.patterns[patternName] = pattern;
	};

	Lyte.errorCodes = {
		ERR01: "Primary key cannot be modified", ERR02: "Mandatory field cannot be empty", ERR03: "Type of value does not match the specified data type", ERR04: "Value is greater than the maximum value allowed",
		ERR05: "Value is less than the minimum value allowed", ERR06: "Length of string/array is greater than the maximum limit allowed", ERR07: "Length of string/array is less than the minimum limit allowed",
		ERR08: "String does not match the specified pattern", ERR09: "Values in array are not unique", ERR10: "Value is not equal to the specified constant", ERR11: "Model of related field is not defined",
		ERR12: "Model of backward relation is not defined", ERR13: "Record not found", ERR14: "Model does not match the related field model", ERR15: "Error in creating a record as a relation",
		ERR16: "Record with primary key already exists", ERR17: "Value cannot be changed because record has been deleted", ERR18: "Action not defined", ERR19: "Model not defined",
		ERR20: "Key not specified", ERR21: "'belongsTo' relationship expects a single object/id", ERR22: "Type not specified for polymorphic relation", ERR23: "Primary Key value not present", ERR24: "Error while relating record", ERR25: "Backward relation not present", ERR26: "Primary key value cannot be undefined or null",
		ERR27: "Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'",
		ERR28: "Unloaded record cannot be saved",
		ERR29: "Property not defined in the object",
		ERR30: "Error in variables declaration for Query", ERR31: "Query not registered for the Model",
		ERR32: "Property not defined in the object",
		ERR33: "Property's value is not an instanceof the mentioned class",
		ERR34: "Type definition for nested properties / items does not match with the value",
		ERR35: "A datatype mismatch has occurred for custom DataType '{0}'"
	};

	Lyte.registeredGlobalEvents = Lyte.__lyteRegisteredEvents = {};
	Lyte.__lyteRegisteredEventsGlobal = {};
	Lyte.triggerEvent = function (obj) {
		var args;
		var actArgs;
		var eventObjectPath;
		if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == "object" && obj.global) {
			actArgs = obj.args;
			args = Array.prototype.slice.call(actArgs, 1);
			eventName = actArgs[0];
			eventObjectPath = "__lyteRegisteredEventsGlobal";
		} else {
			args = Array.prototype.slice.call(arguments, 1);
			eventName = arguments[0];
			eventObjectPath = "__lyteRegisteredEvents";
		}
		var stopEvent = false;
		var s = this[eventObjectPath][eventName];
		if (!s) {
			s = this[eventObjectPath][eventName] = { "listeners": [] };
		} else {
			for (var i = 0; i < s.listeners.length; i++) {
				var func = s.listeners[i];
				if (func) {
					var ret = func.apply(this, args);
					if (ret === false) {
						stopEvent = true;
						break;
					}
				}
			}
		}
		var customEvent = new CustomEvent(eventName, { "detail": args });
		if (!stopEvent) {
			document.dispatchEvent(customEvent);
		}
	};
	Lyte.triggerGlobalEvent = function () {
		return Lyte.triggerEvent({ "global": true, "args": Array.from(arguments) });
	};

	Lyte.addEventListener = function (eventName, func, options) {
		if (typeof func !== "function") {
			Lyte.error("Second parameter to Lyte.Component.addGlobalEventListener() must be a function");
			return;
		}
		var eventObjectPath = options && options.global ? "__lyteRegisteredEventsGlobal" : "__lyteRegisteredEvents";
		var s = this[eventObjectPath][eventName];
		if (!s) {
			s = this[eventObjectPath][eventName] = { "listeners": [] };
		}
		var d = s.listeners.push(func);
		return eventName + "-" + (d - 1);
	};

	Lyte.removeEventListener = function (id, options) {
		var lastIndex = void 0;
		if (!id || (lastIndex = id.lastIndexOf("-")) == -1) {
			Lyte.error("listener unique id not specified / invalid");
			return;
		}
		var globalId = id.split("-");
		if (options) {
			var globalId = id.split("-");
			var eventObjectPath = options && options.global ? "__lyteRegisteredEventsGlobal" : "__lyteRegisteredEvents";
			var s = this[eventObjectPath][globalId[0]];
			if (!s || !s.listeners[globalId[1]]) {
				Lyte.error("No such listener registered");
				return;
			}
			s.listeners[globalId[1]] = null;
		} else {
			var eventName = id.substring(0, lastIndex);
			var eventId = id.substring(lastIndex + 1);
			var s = this.__lyteRegisteredEvents[eventName];
			if (!s || !s.listeners[eventId]) {
				Lyte.error("No such listener registered");
				return;
			}
			s.listeners[eventId] = null;
		}
	};

	Lyte.extendEventListeners = function (scp) {
		if (scp && (typeof scp === 'undefined' ? 'undefined' : _typeof(scp)) == "object" && !scp.hasOwnProperty("__lyteRegisteredEvents")) {
			Object.defineProperties(scp, {
				__lyteRegisteredEvents: {
					value: {}
				},
				addEventListener: {
					value: Lyte.addEventListener
				},
				removeEventListener: {
					value: Lyte.removeEventListener
				},
				triggerEvent: {
					value: Lyte.triggerEvent
				}
			});
		}
	};

	Lyte.deepCopyObject = function (obj) {
		var targetVal = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
		var current,
		    copies = [{ source: obj, target: targetVal }],
		    keys,
		    propertyIndex,
		    descriptor,
		    nextSource,
		    indexOf,
		    sourceReferences = [obj];
		var cloneObject = copies[0].target,
		    targetReferences = [cloneObject];
		while (current = copies.shift()) {
			keys = Object.keys(current.source);
			for (propertyIndex = 0; propertyIndex < keys.length; propertyIndex++) {
				descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
				if (!descriptor) {
					continue;
				}
				if (!descriptor.value || _typeof(descriptor.value) != "object") {
					Object.defineProperty(current.target, keys[propertyIndex], descriptor);
					continue;
				}
				nextSource = descriptor.value;
				descriptor.value = Array.isArray(nextSource) ? [] : nextSource instanceof Set ? new Set() : Object.create(Object.getPrototypeOf(nextSource));
				indexOf = sourceReferences.indexOf(nextSource);
				if (indexOf != -1) {
					descriptor.value = targetReferences[indexOf];
					Object.defineProperty(current.target, keys[propertyIndex], descriptor);
					continue;
				}
				sourceReferences.push(nextSource);
				targetReferences.push(descriptor.value);
				Object.defineProperty(current.target, keys[propertyIndex], descriptor);
				copies.push({ source: nextSource, target: descriptor.value });
			}
			if (Lyte.isRecord(current.source)) {
				Object.defineProperty(current.target, "$", {
					value: {}
				});
				current.target.$.isNew = current.source.$.isNew;
				current.target.$.isModified = current.source.$.isModified;
				current.target.$.isDeleted = current.source.$.isDeleted;
				current.target.$.pK = current.source.$.pK;
				current.target.$._attributes = current.source.$._attributes;
				current.target.$.isCloned = true;
				current.target.$.model = { _name: current.source.$.model._name };
				if (current.source.$.hasOwnProperty("deepNest")) {
					current.target.$.deepNest = current.source.$.deepNest;
				}
				if (current.source.$.hasOwnProperty("partialType")) {
					current.target.$.partialType = current.source.$.partialType;
				}
			}
			if (Array.isArray(current.source)) {
				if (current.source.partial) {
					Object.defineProperty(current.target, "partial", {
						value: current.source.partial
					});
				}
			}
		}
		return cloneObject;
	};

	Lyte.nestScpId = 1;
	Lyte.nestScp = {};
	Lyte.__nestRef__ = {};
	// Lyte.__nestScp__ = {};
	Lyte.__nestScp__ = new Map();
	// Lyte.__nestScp1__ = new Map();
	Lyte.establishObjectBinding = function (data, attr, fromStore, update, storeRecord, watch) {
		var model, fld, nestObj;
		var checkAttrs = data.__component__ && data.__component__.component.__data ? data.__component__.component.__data[attr] : undefined;
		if (fromStore) {
			if (data && !data.$ && data._scp) {
				var keys = Array.from(data._scp.keys());
				keys.forEach(function (id) {
					var recObj = Lyte.nestScp[id];
					model = store.modelFor(recObj.model);
				});
			} else {
				model = data.$.model;
			}
			fld = model && model.fieldList && model.fieldList.hasOwnProperty(attr) ? model.fieldList[attr] : {};
			var _checkDtype = false;
			if (fld) {
				var _dtype = Lyte.Transform[fld.type];
				if (_dtype && (_dtype.hasOwnProperty("properties") || _dtype.hasOwnProperty("items"))) {
					_checkDtype = true;
				}
			}
			if (fld && fld.type !== "relation" && fld.watch || _checkDtype) {
				checkAttrs = fld;
			} else {
				if (data._scp) {
					var keys = Array.from(data._scp.keys());
					keys.forEach(function (id) {
						var _mpObj = data._scp.get(id),
						    mpObj = _mpObj.paths;
						var _dtype = Lyte.nestScp[id] || undefined;
						watch = _dtype && _dtype["watch"] ? _dtype["watch"] : watch;
						for (var key in mpObj) {
							var path = key ? key.split(".") : [];
							path.push(attr);
							Lyte.bindObj(data, attr, id, path, new Map(), undefined, checkAttrs, watch, true);
						}
					});
				}
				return;
			}
		}
		if (update && data._scp && data._scp.size) {
			var keys = Array.from(data._scp.keys());
			keys.forEach(function (id) {
				var _mpObj = data._scp.get(id),
				    mpObj = _mpObj.paths;
				var _dtype = Lyte.nestScp[id] || undefined;
				watch = _dtype && _dtype["watch"] ? _dtype["watch"] : watch;
				for (var key in mpObj) {
					var path = key ? key.split(".") : [];
					path.push(attr);
					Lyte.bindObj(data, attr, id, path, new Map(), undefined, checkAttrs, watch, true);
				}
			});
		}
		var customDtype = false;
		if (checkAttrs && Lyte.Transform[checkAttrs.type]) {
			var dtype = Lyte.Transform[checkAttrs.type];
			if (dtype.hasOwnProperty("properties") || dtype.hasOwnProperty("items")) {
				checkAttrs = Lyte.Transform[checkAttrs.type];
				customDtype = true;
			}
		}
		if ((!fromStore || fld.watch || fld.properties || fld.items || watch || customDtype) && data[attr]) {
			var _scpObj, kmpKey;
			if (data && data.__component__) {
				data.__component__.__scpObj || Object.defineProperty(data.__component__, "__scpObj", {
					value: {}
				});
				kmpKey = data.__component__;
				_scpObj = data.__component__.__scpObj;
			} else if (Lyte.isRecord(data)) {
				data.$.__scpObj || Object.defineProperty(data.$, "__scpObj", {
					value: {}
				});
				kmpKey = data;
				_scpObj = data.$.__scpObj;
			}
			var obj = _scpObj,
			    id;
			if (_scpObj) {
				var __nestScp1Set__ = false,
				    __nestScp2Set__ = false;
				if (fromStore) {
					if (data[attr] && !Lyte.__nestScp__.has(data[attr])) {
						nestObj = { model: model._name, attr: attr, pK: data.$.pK, Error: {} };
						__nestScp1Set__ = true;
					} else {
						// var kmp = Lyte.__nestScp__[kid] = Lyte.__nestScp__[kid] || new Map();
						// data ? kmp.set(data, true) : undefined;
						var __nId = Lyte.__nestScp__.get(data[attr]);
						var refMp = Lyte.__nestRef__[__nId] = Lyte.__nestRef__[__nId] || new Map();
						var refMpId = Lyte.$.genMapId(refMp);
						refMp.set(refMpId, true);
						Lyte.setRecBindMap(Lyte.nestScp[__nId], { model: model._name, attr: attr, pK: data.$.pK, Error: {} });
						obj[attr] = __nId + "_" + refMpId;
					}
				} else {
					if (data[attr] && !Lyte.__nestScp__.has(data[attr])) {
						var ErrMap = [],
						    cmpDataKeys = {};
						cmpDataKeys.key = attr;
						cmpDataKeys.dtype = data.__component__.component.__data[attr];
						cmpDataKeys._cmpErr = data.errors;
						cmpDataKeys.Error = {};
						ErrMap.push(cmpDataKeys);
						nestObj = { data: data[attr], PropsInfo: ErrMap };
						if (cmpDataKeys.dtype.watch) {
							nestObj.watch = true;
						}
						__nestScp2Set__ = true;
					} else {
						var __nId = Lyte.__nestScp__.get(data[attr]);
						var scope = Lyte.nestScp[__nId];
						if (scope) {
							if (!scope.PropsInfo) {
								scope.PropsInfo = [];
							}
							var errMp = scope.PropsInfo;
							var cmpDataKeys = {};
							cmpDataKeys.key = attr;
							cmpDataKeys.Error = {};
							cmpDataKeys._cmpErr = data.errors;
							cmpDataKeys.dtype = data.__component__.component.__data[attr];
							if (cmpDataKeys.dtype.watch) {
								scope.watch = true;
							}
							errMp.push(cmpDataKeys);
						}
						var refMp = Lyte.__nestRef__[__nId] = Lyte.__nestRef__[__nId] || new Map();
						var refMpId = Lyte.$.genMapId(refMp);
						refMp.set(refMpId, true);
						obj[attr] = __nId + "_" + refMpId;
					}
				}
				if (nestObj) {
					var nestScpId = Lyte.nestScpId++;
					var refMp = Lyte.__nestRef__[nestScpId] = Lyte.__nestRef__[nestScpId] || new Map();
					var refMpId = Lyte.$.genMapId(refMp);
					refMp.set(refMpId, true);
					// var kmp = Lyte.__nestScp__[nestScpId] = Lyte.__nestScp__[nestScpId] || new Map();
					// kmp.set(kmpKey, true);
					Lyte.__nestScp__.set(data[attr], nestScpId);
					if (__nestScp1Set__) {
						Lyte.nestScp[nestScpId] = {};
						Lyte.setRecBindMap(Lyte.nestScp[nestScpId], nestObj);
						Lyte.nestScp[nestScpId].Error = nestObj.Error;
						//     Lyte.setRecBindMap(model._name, attr, data.$.pK, nestScpId); 
					}
					if (__nestScp2Set__) {
						Lyte.nestScp[nestScpId] = nestObj;
						//     Lyte.__nestScp2__.set(data[attr], nestScpId);
					}
					Lyte.nestScp[nestScpId]._data = data[attr];
					obj[attr] = obj[attr] || nestScpId + "_" + refMpId;
					var path = [];
					// fromStore ? path.push(attr) : undefined;
					Lyte.bindObj(data, attr, nestScpId, path, new Map(), undefined, checkAttrs, watch);
				}
			}
		}
	};

	Lyte.removeNestScp2Bind = function (mp, mdlObj) {
		var mp = mp.model;
		if (mp.has(mdlObj.model)) {
			var mp1 = mp.get(mdlObj.model);
			if (mp1.has(mdlObj.pK)) {
				var mp2 = mp1.get(mdlObj.pK);
				if (mp2.has(mdlObj.attr)) {
					mp2.delete(mdlObj.attr);
				}
				!mp2.size ? mp1.delete(mdlObj.pK) : undefined;
			}
			!mp1.size ? mp.delete(mdlObj.model) : undefined;
		}
	};

	Lyte.setRecBindMap = function (obj, nestObj) {
		var mp = obj.model = obj.model || new Map(),
		    modelName = nestObj.model,
		    pK = nestObj.pK,
		    attr = nestObj.attr;
		if (modelName && !mp.has(modelName)) {
			mp.set(modelName, new Map());
		}
		mp = mp.get(modelName);
		if (pK && !mp.has(pK)) {
			mp.set(pK, new Map());
		}
		mp = mp.get(pK);
		if (attr && !mp.has(attr)) {
			mp.set(attr, true);
		}
	};

	Lyte.bindObj = function (data, key, id, path, mp, check, checkAttrs, watch, ignoreCyclicDelete) {
		mp = mp || new Map();
		var value = key != undefined ? data[key] : data;
		var cyclic = false;
		if (!ignoreCyclicDelete && !path.length && Lyte.__nestScp__.get(data) === id) {
			delete Lyte.nestScp[id].cyclic;
		}
		if (path.length > 1 && value && Lyte.nestScp[id] && Lyte.nestScp[id].hasOwnProperty("data") && Lyte.nestScp[id].data === value) {
			if (mp.get(value)) {
				cyclic = true;
			} else {
				try {
					JSON.stringify(value);
				} catch (exp) {
					cyclic = true;
				}
			}
			if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
				Lyte.estObjScp(value, id, path, cyclic);
			}
			return;
		}
		var attrs, nestedSCP;
		if (checkAttrs) {
			if (checkAttrs.hasOwnProperty("items") || checkAttrs.hasOwnProperty("properties")) {
				attrs = checkAttrs.items || checkAttrs.properties;
				nestedSCP = true;
			} else if (watch == undefined && checkAttrs.watch == true) {
				watch = checkAttrs.watch;
			}
		}
		attrs = watch ? undefined : attrs;
		if (Array.isArray(value)) {
			if (!mp.get(value)) {
				mp.set(value, true);
				value.forEach(function (val, idx) {
					path.push(idx);
					if (watch || checkAttrs && checkAttrs.hasOwnProperty("items") && _typeof(checkAttrs.items) == "object") {
						Lyte.bindObj(value, idx, id, path, mp, undefined, attrs, watch);
					}
					path.pop();
				});
			} else {
				cyclic = true;
			}
			if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
				var _establish;
				if (Array.isArray(watch)) {
					_establish = Lyte.checkEstablishingSCP(value, path, watch);
				}
				if (_establish || typeof watch == "boolean" && watch || nestedSCP) {
					Lyte.estObjScp(value, id, path, cyclic);
				}
			}
		} else if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == "object") {
			var cyclic = false;
			if (!mp.get(value)) {
				mp.set(value, true);
				for (var str in value) {
					path.push(str);
					if (watch || attrs && attrs.hasOwnProperty(str)) {
						Lyte.bindObj(value, str, id, path, mp, undefined, attrs ? attrs[str] : undefined, watch);
					}
					path.pop();
				}
			} else {
				cyclic = true;
			}
			if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
				var _establish;
				if (Array.isArray(watch)) {
					_establish = Lyte.checkEstablishingSCP(value, path, watch);
				}
				if (_establish || typeof watch == "boolean" && watch || nestedSCP) {
					Lyte.estObjScp(value, id, path, cyclic);
				}
			}
		}
	};

	Lyte.checkAndAddBind = function (value, id, path, cyclic) {
		if (!value._scp || !value._scp.size) {
			return true;
		}
		if (value._scp.size) {
			if (value._scp.has(id)) {
				var _obj = value._scp.get(id);
				var obj = _obj.paths;
				if (obj.hasOwnProperty(path.join("."))) {
					if (cyclic) {
						Lyte.nestScp[id].cyclic = true;
					}
					return false;
				}
			}
		}
		return true;
	};

	Lyte.estObjScp = function (value, id, path, cyclic) {
		if (!value._scp) {
			Object.defineProperty(value, "_scp", {
				value: new Map(),
				enumerable: false,
				configurable: true
			});
		}
		var mp = value._scp;
		if (!mp.has(id)) {
			mp.set(id, {});
		}
		var obj = mp.get(id),
		    path = path ? path.join(".") : path;
		var pathObj = obj.paths = obj.paths || {};
		pathObj[path] = true;
		var nestObj = Lyte.nestScp[id];
		if (!nestObj.cyclic && cyclic == true) {
			nestObj.cyclic = true;
		}
	};

	Lyte.cmpObjs = function (obj1, obj2) {
		if (Object.keys(obj1).length !== Object.keys(obj2).length) {
			return false;
		}
		for (var key in obj1) {
			if (!obj2.hasOwnProperty(key)) {
				return false;
			}
			var ret = Lyte.cmpData(obj1[key], obj2[key]);
			if (ret == false) {
				return false;
			}
		}
		return true;
	};

	Lyte.cmpData = function (data1, data2) {
		if (Array.isArray(data1)) {
			if (!Array.isArray(data2) || data1.length !== data2.length) {
				return false;
			}
			if (data1 === data2) {
				return true;
			}
			var len = data1.length,
			    ret;
			for (var i = 0; i < len; i++) {
				ret = Lyte.cmpData(data1[i], data2[i]);
				if (ret == false) {
					return false;
				}
			}
		} else if (data1 && data2 && (typeof data1 === 'undefined' ? 'undefined' : _typeof(data1)) == "object" && (typeof data2 === 'undefined' ? 'undefined' : _typeof(data2)) == "object") {
			if (data1 === data2) {
				return true;
			}
			return Lyte.cmpObjs(data1, data2);
		}
		// else if(Lyte && Lyte.isRecord(data1) && Lyte.isRecord(data2)){
		//   if( (data1.$.model._name !== data1.$.model._name) || (Lyte.getpKVal(data1) !== Lyte.getpKVal(data2)) ){
		//     return false;
		//   }
		// }
		else if (data1 !== data2) {
				return false;
			}
		return true;
	};

	Lyte.nestScpRmPath = function (obj, path) {
		if (obj && obj.paths) {
			obj = obj.paths;
			for (var key in obj) {
				if (key.startsWith(path + ".")) {
					delete obj[key];
				}
			}
		}
	};

	Lyte.nestScpRemove = function (data, id, path) {
		var mp = data._scp;
		if (mp && mp.size) {
			if (path) {
				Lyte.nestScpRmPath(mp.get(id), path);
				var _obj = mp.get(id);
				var obj = _obj ? _obj.paths : undefined;
				if (obj && !Object.keys(obj).length) {
					mp.delete(id);
				}
			} else {
				mp.delete(id);
			}
			if (!mp.size) {
				delete data._scp;
			}
		}
	};

	Lyte.rmNestScp = function (value, id, mp, data, path) {
		if (Array.isArray(value)) {
			if (!mp.get(value)) {
				mp.set(value, true);
				value.forEach(function (val, idx) {
					Lyte.rmNestScp(val, id, mp, undefined, path);
				});
			}
			Lyte.nestScpRemove(value, id, path);
		} else if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == "object") {
			if (!mp.get(value)) {
				mp.set(value, true);
				for (var str in value) {
					Lyte.rmNestScp(value[str], id, mp, undefined, path);
				}
			}
			Lyte.nestScpRemove(value, id, path);
		}
	};

	Lyte.removeNestScp = function (value, id, mpId, path, context, mp, data, recObj) {
		mp = mp || new Map();
		id = Number.parseInt(id);
		var obj = Lyte.nestScp[id],
		    kmp = Lyte.__nestRef__[id];
		if (recObj && obj.model) {
			Lyte.removeNestScp2Bind(obj, recObj);
		}
		if (context) {
			if (kmp && kmp.has(mpId)) {
				kmp.delete(mpId);
			}
			if (!kmp || kmp && !kmp.size) {
				delete Lyte.__nestRef__[id];
				if (Lyte.__nestScp__.has(value)) {
					Lyte.__nestScp__.delete(value);
				}
				Lyte.rmNestScp(value, id, mp, true, path);
				if (!data) {
					delete Lyte.nestScp[id];
				}
			}
		} else {
			Lyte.rmNestScp(value, id, mp, true, path);
		}
	};

	Lyte.resolvePromises = function (promises) {
		if (typeof promises == "string" || promises instanceof Promise) {
			return promises;
		} else {
			if (Array.isArray(promises)) {
				return promiseArray(promises);
			} else if ((typeof promises === 'undefined' ? 'undefined' : _typeof(promises)) == "object") {
				return promiseHash(promises);
			}
		}

		function promiseHash(promiseObj) {
			var actPromKeys = [],
			    promises = [],
			    promiseKeys = Object.keys(promiseObj);
			promiseKeys.forEach(function (key) {
				var value = promiseObj[key];
				if (value instanceof Promise || value && !Array.isArray(value) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == "object" && typeof value.then == "function") {
					actPromKeys.push(key);
					promises.push(value);
				}
			});
			if (!promises.length) {
				return Promise.resolve(promiseObj);
			} else {
				var obj = {},
				    promise = new Promise(function (resolve, reject) {
					Promise.all(promises).then(function (data) {
						promiseKeys.forEach(function (promiseKey) {
							if (actPromKeys.indexOf(promiseKey) != -1) {
								obj[promiseKey] = data[actPromKeys.indexOf(promiseKey)];
							} else {
								obj[promiseKey] = promiseObj[promiseKey];
							}
						});
						resolve(obj);
					}, function (err) {
						reject(err);
						Lyte.error('Error on resolve promises', err);
					});
				});
				return promise;
			}
		}

		function promiseArray(promiseArray) {
			var array = [],
			    hasPromise = false;
			promiseArray.every(function (item, i) {
				if (item instanceof Promise || item && !Array.isArray(item) && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) == "object" && typeof item.then == "function") {
					hasPromise = true;
					return false;
				}
				return true;
			});
			if (!hasPromise) {
				return Promise.resolve(promiseArray);
			}
			var promise = new Promise(function (resolve, reject) {
				Promise.all(promiseArray).then(function (data) {
					promiseArray.forEach(function (key, index) {
						array[index] = data[index];
					});
					resolve(array);
				}, function (err) {
					reject(err);
					Lyte.error('Error on resolve promises', err);
				});
			});
			return promise;
		}
	};
	function domContentLoaded1() {
		Lyte.assetsDivContainer.appendChild(Lyte.$.assetsDiv);
	}

	if (document.readyState === "complete" || document.readyState === "interactive") {
		domContentLoaded1();
	} else {
		document.addEventListener("DOMContentLoaded", function (e) {
			domContentLoaded1();
		}, true);
	};

	var XHRSend = XMLHttpRequest.prototype.send;
	XMLHttpRequest.prototype.send = function () {
		var event = window.event;
		var type,
		    target = event ? event.target : undefined;
		if (Lyte.getConfig("stateHandling")) {
			if (event) {
				type = event.type;
				/^(click|dblclick)$/.test(type) && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false" ? addStateToMap(type, target, this) : undefined;
			} else {
				var router = Lyte && Lyte.Router ? Lyte.Router.getRouteInstance() : undefined;
				if (router) {
					var currentAction = router.transition ? router.transition.ev : undefined;
					if (currentAction && currentAction.target && currentAction.target.getAttribute && currentAction.target.getAttribute("lyte-state-handling") != "false") {
						var mp = Lyte.__transXHRMap = Lyte.__transXHRMap || new Map();
						mp.set(router.transition, { currentAction: currentAction, XHR: this });
						addStateToMap(currentAction.type, currentAction.target, this);
					}
				}
			}
		}
		XHRSend.apply(this, arguments);
	};

	Lyte.addEventListener("transitionStart", function (obj) {
		var trans = obj.nextTrans;
		if (trans && obj.prevTrans) {
			if (window.event && /^(click|dblclick)$/.test(window.event.type)) {
				trans.ev = window.event;
				if (obj.prevTrans.ev) {
					delete obj.prevTrans.ev;
				}
			} else if ((obj.prevTrans.state == 409 || obj.prevTrans.state == 308) && obj.prevTrans.ev) {
				trans.ev = obj.prevTrans.ev;
				delete obj.prevTrans.ev;
			}
		}
	});

	Lyte.addEventListener("afterRouteTransition", function (obj) {
		if (obj && obj.trans) {
			var mp = Lyte.__transXHRMap,
			    removeEv = false;
			if (obj.trans.state == 409 || obj.trans.state == 308) {
				var ev1 = window.event,
				    ev2 = obj.trans.ev;
				if (!ev1 || ev1 && ev2 && ev1 != ev2 && ev1.target == ev2.target && ev1.type == ev2.type) {
					obj.trans.nested = true;
				} else {
					removeEv = true;
				}
				if (mp) {
					var mpObj = mp.get(obj.trans);
					if (mpObj) {
						removeStateFromMap(mpObj.XHR, mpObj.currentAction.type, mpObj.currentAction.target);
						mp.delete(obj.trans);
					}
				}
			} else if (obj.trans.state == 200) {
				mp ? mp.delete(obj.trans) : undefined;
				removeEv = true;
			}
			if (removeEv) {
				obj.trans.ev ? delete obj.trans.ev : undefined;
			}
		}
	});

	Lyte.addEventListener("beforeRouteTransition", function (obj) {
		if (obj && obj.prevTrans && obj.prevTrans.nested) {
			obj.trans.ev = obj.prevTrans.ev;
			delete obj.prevTrans.ev;
			obj.trans.fromPrevTrans = true; // temp check
		}
	});

	function addStateToMap(event, target, XHR, stateName) {
		var mp = Lyte.__nodeXHRMap = Lyte.__nodeXHRMap || new Map();
		var nodeMap = mp.get(target);
		if (!nodeMap) {
			mp.set(target, new Map());
		}
		nodeMap = mp.get(target);
		var sr = target.lyteState = target.lyteState || [],
		    type = stateName || XHR;
		if (sr.indexOf(type) == -1) {
			sr.push(type);
		}
		target.setAttribute("lyte-state", "");
		var evMap = nodeMap.get(event);
		if (!evMap) {
			nodeMap.set(event, []);
			evMap = nodeMap.get(event);
		}
		if (stateName) {
			evMap.push({ state: stateName });
			return { target: target, event: event };
		} else {
			evMap.push({ isXHR: true, xhr: XHR });
			var callback = function callback(arg) {
				if (XHR.readyState == 4) {
					removeStateFromMap(XHR, event, target);
					XHR.removeEventListener("readystatechange", callback);
				}
			};
			XHR.addEventListener("readystatechange", callback);
		}
	}
	function removeStateFromMap(type, event, target) {
		var mp = Lyte.__nodeXHRMap;
		var nodeMap = mp.get(target);
		if (!nodeMap) {
			return;
		}
		var evMap = nodeMap.get(event);
		if (!evMap) {
			return;
		}
		if (evMap) {
			var arr = evMap;
			var ind = -1;
			arr.every(function (itm, idx) {
				if (itm && itm.isXHR && itm.xhr == type || typeof type == "string" && itm.state == type) {
					ind = idx;
					return false;
				}
				return true;
			});
			if (ind != -1) {
				arr.splice(ind, 1);
				var sind = target.lyteState.indexOf(type);
				target.lyteState.splice(sind, 1);
				if (!arr.length) {
					nodeMap.delete(event);
					var tyInd = target && Array.isArray(target.lyteState) ? target.lyteState.indexOf(type) : -1;
					tyInd != -1 ? target.lyteState.splice(tyInd, 1) : undefined;
					if (target && target.lyteState && target.lyteState.length == 0) {
						target.lyteState = null;
						target.removeAttribute("lyte-state");
					}
				}
				if (!nodeMap.size) {
					mp.delete(target);
				}
			}
		}
	}

	Lyte.setState = function (str) {
		if (!str) {
			console.error("Please provide a state name");
		}
		var evnt = window.event;
		if (/^(click|dblclick)$/.test(evnt.type)) {
			var target = evnt.target;
			if (Lyte.getConfig("stateHandling") == true && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false") {
				var state = target.getAttribute("lyte-state");
				if (!state) {
					var mp = Lyte.__stateMap = Lyte.__stateMap || new Map();
					var mpobj = mp.get(str);
					if (!mpobj) {
						var obj = addStateToMap(evnt.type, target, undefined, str);
						mp.set(str, obj);
					} else {
						console.error("There is already a open state by the name", str);
					}
				}
			}
		}
	};

	Lyte.removeState = function (str) {
		if (!str) {
			console.error("Please provide a state name");
		}
		var mp = Lyte.__stateMap;
		if (mp) {
			var obj = mp.get(str);
			if (obj) {
				mp.delete(str);
				removeStateFromMap(str, obj.event, obj.target);
			}
		}
	};
	Lyte.setConfig = function (key, value, cons) {
		if (key == "mutable") {
			if (value == true) {
				Lyte.__gl = Lyte.mut(Lyte.__gl__);
			} else if (value == false) {
				Lyte.__gl = Lyte.__gl__;
			}
		}
		var configObj = Lyte.__config = Lyte.__config || {};
		if (cons) {
			Object.defineProperty(configObj, key, {
				value: value
			});
		} else {
			configObj[key] = value;
		}
	};
	/*disable async function*/
	Lyte.getConfig = function (key) {
		var configObj = Lyte.__config;
		if (configObj) {
			return configObj[key];
		}
	};
	Lyte.establishWatchScope = function (watchProps, model) {
		var scope = this,
		    object;
		for (var v in watchProps) {
			var property = v;
			var watch = watchProps[v];
			if (scope.component && scope.component.__data && scope.component.__data[property]) {
				object = scope.getData(property);
				watch = scope.component.__data[property].watch ? true : watch;
				if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) == "object") {
					Lyte.establishObjectBinding(scope.component.data, v, false, undefined, undefined, watch);
				}
				var dataDef = scope.component.__data;
				if (Lyte.nestScp[Lyte.__nestScp__.get(object)]) {
					// nestScp[__nestScp__.get(object)].dtype.watch = watch;
					dataDef[v].watch = watch;
				}
			} else {
				if (model) {
					var fieldList = model.fieldList;
					if (fieldList[v] && fieldList[v].watch == undefined) {
						fieldList[v].watch = watch;
						model._fldGrps.watch[v] = fieldList[v];
					}
				}
			}
		}
	};

	Lyte.checkEstablishingSCP = function (value, path, watch) {
		if (Array.isArray(watch)) {
			var _path = '';
			_path = path.join(".");
			if (Lyte.checkWatchPath(_path, watch, true) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) != "object") {
				return true;
			}
			var _key = Object.keys(value);
			for (var i_scp = 0; i_scp < _key.length; i_scp++) {
				var spiePath = _key[i_scp];
				var finalaUth = _path == "" ? spiePath : _path + "." + spiePath;
				if (Lyte.checkWatchPath(finalaUth, watch, true)) {
					return true;
				}
			}
		}
	};
	Lyte.checkWatchPath = function (actualPath, watchArr, establishBind) {
		if (typeof watchArr == "boolean" && watchArr === true) {
			return true;
		} else if (Array.isArray(watchArr)) {
			for (var i_watch = 0; i_watch < watchArr.length; i_watch++) {
				var path = watchArr[i_watch];
				path = path.replace(/ /g, "");
				path = path.replace(/\$\.\./g, "..");
				path = path.replace(/\$\./g, "");
				var weirdPath = path.search(/\.\./g) != -1 || path.search(/\[|\\]|\{|\}/g) != -1 ? true : false || path.includes("*");
				if (actualPath == path) {
					return true;
				} else if (weirdPath) {
					if (establishBind) {
						if (path.search(/\.\./) != -1) {
							path = path.replace(/\.\.\S+/g, "..*");
							if (path == "..*") {
								return true;
							}
						}
					}
					path = path.search(/\[/) == 0 ? path.replace("[", "") : path;
					path = path.search(/\.\.\[/) == 0 ? path.replace("..[", "..") : path;
					path = path.replace(/\.*\[/g, ".");
					path = path.replace(/\]/g, "");
					var _watchPath = Lyte.checkWeirdPath(path, actualPath);
					if (_watchPath) {
						return true;
					}
				}
			}
		}
	};
	Lyte.checkWeirdPath = function (watchPath, actualPath) {
		if (actualPath == watchPath) {
			return true;
		} else if (watchPath.includes("..") || watchPath.includes("*")) {
			var cmpPath = watchPath;
			cmpPath = cmpPath.replace(/\*/g, "$$");
			cmpPath = cmpPath.replace(/\.\./g, "::");
			// cmpPath = cmpPath.replace("[","\\[")
			cmpPath = cmpPath.replace(/\./g, "\\.");
			cmpPath = cmpPath.replace(/\:\:/g, "\\.?.*\\.?");
			cmpPath = cmpPath.replace(/\$/g, ".*");
			var _wildCard = watchPath.split(".");
			var _wClenght = _wildCard.length;
			if (_wildCard[_wClenght - 2] == "" && _wildCard[_wClenght - 1] != "*") {
				cmpPath = cmpPath + "$";
			}
			var regularExp = new RegExp(cmpPath);
			if (regularExp.test(actualPath)) {
				return true;
			}
			return false;
		}
	};

	var ignoreMut = false;
	Lyte.ignoreMut = function (method) {
		ignoreMut = true;
		method();
		ignoreMut = false;
	};

	/*disable async function*/
	var wkMap = new WeakMap();
	/*disable async function*/
	Lyte.mut = function mut(data) {
		if (data && data.__ltPrx__) {
			return data;
		}
		if (data && wkMap.has(data)) {
			return wkMap.get(data);
		}
		if (!data || data && data.constructor.name !== "Object" && data.constructor.name !== "Record" && !Array.isArray(data) && !data.__ltPrx__) {
			return data;
		}
		var prxVal = new Proxy(data, {
			set: function set(target, prop, value) {
				if (!Array.isArray(target)) {
					Lyte.Component.set(target, prop, value);
				} else {
					target[prop] = value;
				}
				return true;
			},
			get: function get(target, prop) {
				if (prop === "__ltPrx__") {
					return true;
				}
				if (prop === "__target__") {
					return target;
				}
				var value = target[prop];
				if (value && value.__ltPrx__) {
					return value;
				}
				if (value && wkMap.has(value)) {
					return wkMap.get(value);
				}
				var descriptor = Object.getOwnPropertyDescriptor(target, prop);
				if (value && (value.constructor.name === "Object" || Array.isArray(value) || value && value.$ && value.$.hasOwnProperty("isModified")) && !value.__ltPrx__ && descriptor && descriptor.configurable) {
					// path = path || [];
					// path.push(prop);
					// if(Array.isArray(value) && value.model && value.key){
					//     var hmPrx = value.record.$.__hmPrx = value.record.$.__hmPrx || {};
					//     var retVal;
					//     if(!hmPrx[value.key]){
					//         retVal = hmPrx[value.key] = Lyte.mut(value)
					//     }
					//     else{
					//         retVal = hmPrx[value.key]
					//     }
					//     return retVal;
					// }
					var _prxVal = Lyte.mut(value);
					wkMap.set(value, _prxVal);
					// Object.defineProperty(value, "__mcln__", { value: prxVal});
					return _prxVal;
				}
				return value;
			}
		});
		wkMap.set(data, prxVal);
		// Object.defineProperty(data, "__mcln__", { value: prxVal});
		return prxVal;
	};
	/*disable async function*/
	Lyte.immut = function immut(data, mp) {
		var mp = mp || new WeakMap(),
		    nData;
		if (data && Array.isArray(data)) {
			nData = Array.from(data);
		} else if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object") {
			nData = Object.assign({}, data);
		}
		mp.get(data, nData);
		return new Proxy(data, {
			get: function get(data, prop) {
				var _obj = mp.get(data),
				    val;
				val = _obj[prop];
				if (val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == "object" && !mp.has(val)) {
					return Lyte.immut(val, mp);
				}
				return val;
			},
			set: function set(data, prop, value) {
				var _obj = mp.get(obj);
				// _obj[prop] = value;

				Lyte.Component.set(_obj, prop, value);
				return true;
			}
		});
	};
	// Lyte.mut = function mut(data){
	//     if(data && data.__ltPrx__){
	//         return data;
	//     }
	//     if(data && data.__mcln__){
	//         return data.__mcln__;
	//     }
	//     if(!data || (data && !data.constructor.name === "Object" && !Array.isArray(data)) && !value.__ltPrx__){
	//         return data;
	//     }
	//     // parent = parent || data;
	//     let prxVal =  new Proxy(data, {
	//         set:function(target, prop, value){
	//             if(!Array.isArray(target)){
	//                 Lyte.Component.set(target, prop, value);
	//             }else{
	//                 target[prop] = value;
	//             }
	//             return true;
	//         },
	//         get: function(target, prop){
	//             if(prop === "__mcln__"){
	//                 debugger
	//                 return target[prop];
	//             }
	//             if(prop === "__ltPrx__"){
	//                 return true;
	//             }
	//             if(prop === "__target__"){
	//                 return target;
	//             }
	//             var value = target[prop];
	//             if(value && value.__mcln__){
	//                 return value.__mcln__;
	//             }
	//             var descriptor = Object.getOwnPropertyDescriptor(target, prop);
	//             if((value && value.$ && value.$.hasOwnProperty("isModified") && value.$.getProxy)){
	//                 let prxVal = value.$.getProxy();
	//                 return prxVal;
	//             }
	//             else if(value && (value.constructor.name === "Object" || Array.isArray(value)) && !value.__ltPrx__ && descriptor && descriptor.configurable){
	//                 // path = path || [];
	//                 // path.push(prop);
	//                 if(Array.isArray(value) && value.model && value.key){
	//                     var hmPrx = value.record.$.__hmPrx = value.record.$.__hmPrx || {};
	//                     var retVal;
	//                     if(!hmPrx[value.key]){
	//                         retVal = hmPrx[value.key] = Lyte.mut(value)
	//                     }
	//                     else{
	//                         retVal = hmPrx[value.key]
	//                     }
	//                     return retVal;
	//                 }
	//                 let prxVal = Lyte.mut(value);
	//                 Object.defineProperty(value, "__mcln__", { value: prxVal});
	//                 return prxVal;
	//             }
	//             return value;
	//         }
	//     });
	//     Object.defineProperty(data, "__mcln__", { value: prxVal});
	//     return prxVal;
	// }
	Object.defineProperty(Lyte, "__gl__", {
		value: {}
	});
	Lyte.__gl = Lyte.__gl__;
})(_Lyte);
Lyte.registerErrorCodes({
	LD01: "Primary key value might be missing in the response data that is received, {0}",
	LD02: "{0} - {1} is not registered",
	LD03: "Cannot set the error {0} for {1}",
	LD04: "No such record to merge, {0}",
	LD05: "Model( {0} ) of related property - {1} not found in model - {2}",
	LD06: "Backward relation not present in model( {0} ), for the property {1} of model( {2} )",
	LD07: "{0} type not handled in handleArrayOperations",
	LD08: "{0} {1} will be deprecated from next version {2}",
	LD09: "deserializeKey cannot be processed for payload with more than two keys. Please use payloadKey callback instead or try modifying the same in normalizeResponse callback",
	LD10: "Response data not in a format lyte data store expects",
	LD11: "Deprecation Warning! findRecord response payload will not accept an array. It will be deprecated from the next version",
	LD12: "Response ( {0} ) is not in a format, lyte data store expects",
	LD13: "Response processing failed in {0} for model-{1} {2}, since invalid data is received in {1}(modelName) key of the data",
	LD14: "Cannot register {0} - {1}, as it already exists.",
	LD15: "Primary key value might be missing in the response data that is received, {0}",
	LD16: "Record merge failed for the record in model - {0} with primaryKey value - {1}, since either the persisted(saved) primary key value for a newly created record is not received from server or not in the proper structure to merge",
	LD17: "Record with the primary key value already exists",
	LD18: "No { 0 } present",
	LD19: "Deprecation Warning! findAll will not accept response payload values other than an array or any empty value. Current implementation which allows this will be deprecated from the next version",
	LD20: "Record cannot be saved as a state, when it is not either a new or a modified record or in a error state.",
	LD21: "No such state ( {0} ) saved for the record.",
	LD22: "For create / createRecord, response with a primary key value should be received",
	LD23: "PrimaryKey field {1} in {0} cannot have default value",
	LD24: "Response couldn't be parsed, {0}",
	LD25: "Cannot create record for the data - {0}",
	LD26: "Only one baseKey is allowed for a model",
	LD27: "Record merge failed, since the data passed is invalid - {0}",
	LD28: "Record merge failed for the model - {0}, since a valid primary key value is not found in the data to be merged - {1}",
	LD29: "Unloaded record-{0} of the model-{1} is being saved",
	LD30: "Variable value in query is mandatory for {0}",
	LD31: "Datatype defined for {0} is mismatch with the value's datatype",
	LD32: "Query '{0}' was not registered for the model '{1}"
});
var $Record = function $Record() {
	Object.assign(this, { inIDB: false, isPersisted: true, isUnloaded: false, isModified: false, isNew: false, isDeleted: false, isError: false, events: [], validatedOnCreate: true, error: {} });
};
/* Record Constructor
Steps Done: 
* Assign data
* Assign $Record -> Maintaining Record state
* Assign ref of model,record to act independently
***
*/
var Record = function Record(modelName, data, opts, clone) {
	var model = store.modelFor(modelName),
	    delayPers = opts ? opts.delayPersistence : store.$.getFromCB("adapter", modelName, "delayPersistence");
	Object.assign(this, data);
	Object.defineProperties(this, {
		$: {
			writable: true,
			value: new $Record()
		}
	});
	var pkVal = store.$.getpKVal(this, model);
	if (clone) {
		Object.defineProperties(this.$, {
			isCloned: {
				value: true,
				writable: false
			},
			donor: {
				value: store.$.peekRecord(modelName, pkVal)
			}
		});
	}
	Object.defineProperties(this.$, {
		pK: {
			value: pkVal,
			writable: true
		},
		model: {
			value: model
		},
		_attributes: {
			value: {},
			writable: true
		},
		_relationships: {
			value: {},
			writable: true
		},
		isDirty: {
			value: function value() {
				var result = [];
				var record = this.record;
				if (record.$.isModified) {
					return true;
				}
				result = store.$.isDirty(record, this.model.relations);
				if (result.length) {
					return result;
				}
				return false;
			}
		},
		undoStack: {
			value: store.$.genUnRedoStack(),
			writable: true
		},
		redoStack: {
			value: store.$.genUnRedoStack(),
			writable: true
		},
		delayPersistence: {
			value: delayPers
		}
	});
	this.$.record = this;
	if (model.sort && !clone) {
		store.$.defProp(this.$, "created_Time", store.$.getCreatedTime(model.cT));
	}
	var parent = store.$.saveParent;
	if (parent && this !== parent) {
		store.$.defProp(this.$, "parent", parent);
	}
	var defF = model._fldGrps.default;
	var watchF = model._fldGrps.watch;
	var hasManyF = model._fldGrps.hasMany;
	var nested = model._fldGrps.nested_prop;
	for (var dKey in defF) {
		var dFld = defF[dKey];
		var fldVal = data[dKey];
		if (fldVal === undefined || fldVal === "") {
			this[dKey] = store.$.getDefaultVal(this, dFld.default);
		}
	}
	for (var wKey in watchF) {
		Lyte.establishObjectBinding(this, wKey, true, undefined, undefined, true);
	}
	for (var k in nested) {
		Lyte.establishObjectBinding(this, k, true, undefined, undefined, k && k.watch ? k.watch : undefined);
	}
	for (var hKey in hasManyF) {
		var hFld = hasManyF[hKey];
		if (this.hasOwnProperty(hKey)) {
			this[hKey] = Array.isArray(this[hKey]) ? Array.from(this[hKey]) : this[hKey];
		} else if (store.modelFor(hFld.relatedTo) && !clone) {
			var toInit = store.$.getFromCB("serializer", hFld.relatedTo, "initHasManyRelation");
			if (toInit) {
				this[hKey] = [];
			}
		}
	}
	var props = model._properties;
	if (Object.keys(props).length) {
		if (!this._bindings) {
			store.$.defProp(this, '_bindings', new Set(), false, true);
		}
		this._bindings.add(props);
		store.$.establishObserverBindings(this, props);
	}
	if (model.deprecate && model.deprecate.size && Lyte.__config && Lyte.__config.deprecateModelFields) {
		var prx = new Proxy(this, {
			get: function get(target, prop, receiver) {
				if (model.deprecate.has(prop)) {
					Lyte.warn("Property - '" + prop + "' of Model-'" + model._name + "' has been deprecated. ");
				}
				return target[prop];
			},
			set: function set(target, prop, value) {
				if (model.deprecate.has(prop)) {
					Lyte.warn("Property - " + prop + " of Model-" + model._name + " has been deprecated.");
				}
				return Reflect.set.apply(Reflect, arguments);
			}
		});
		this.$.record = prx;
		return prx;
	}
};
/* Assigning the following in $record.prototype 
So it will be available to all record.$
*/

Object.defineProperties($Record.prototype, {
	get: {
		value: function value(attr) {
			var data = this.record[attr];
			if (Lyte.Component && Lyte.Component._get) {
				data = Lyte.Component._get(this.record, attr);
			}
			if (Lyte.getConfig("mutable")) {
				if (Lyte.isRecord(data) || Array.isArray(data) && data.model) {
					return Lyte.mut(data);
				}
			}
			return data;
		}
	},
	set: {
		value: function value1(attr, value, opts) {
			if (this.isDeleted) {
				store.$.setRecErr(this, this.model._pK, "ERR17");
			} else {
				store.$.setData(this, attr, value, opts);
			}
			return this.record;
		}
	},
	getDirtyAttributes: {
		value: function value() {
			var ret = [];
			var attributes = this._attributes;
			if (Object.keys(attributes).length) {
				for (var key in attributes) {
					ret.push(key);
				}
			}
			return ret;
		}
	},
	// getProxy: {
	// 	value: function value(){
	// 		var model = this.model;
	// 		if(store.$ && !store.$.mutable){
	// 			// Lyte.warn("Mutable option not enabled in store");
	// 			return;
	// 		}
	// 		model.__prx = model.__prx || new Map();
	// 		if(!model.__prx.has(this.record)){
	// 			model.__prx.set(this.record, Lyte.mut(this.record));
	// 		}
	// 		return model.__prx.get(this.record);
	// 	}
	// },
	rollBackAttributes: {
		value: function value(attr, inherit) {
			if (!Array.isArray(attr)) {
				attr = [attr];
			}
			var record = this.record.$.record,
			    changed = [],
			    model = this.model,
			    _attrs = this._attributes;
			for (var i = 0; i < attr.length; i++) {
				var key = attr[i];
				if (_attrs.hasOwnProperty(key)) {
					var field = model.fieldList[key],
					    oldVal = _attrs[key];
					if (field.type == "relation") {
						store.$.rllBckRecArr(oldVal, record, model, field);
						var obj = record.$.dN && record.$.dN.hasOwnProperty(key) ? record.$.dN[key] : new Map();
						obj.forEach(function (item, mKey) {
							store.$.deleteDeepNest(record, key, mKey);
						});
					} else {
						store.$.cmpSet(record, key, oldVal, undefined, true);
					}
					changed.push(key);
					delete _attrs[key];
				}
				store.$.clrRecErr(this, key);
			}
			if (!Object.keys(this._attributes).length) {
				if ((!this.hasOwnProperty("dN") || this.dN && !Object.keys(this.dN).length) && !record.$.isNew) {
					store.$.removeParentNesting(record, "modified");
				}
				store.$.cmpSet(this, "isModified", false);
				store.$.changePersist(record, true);
				if (!this.isNew) {
					store.$.deleteFromArray(model.dirty, this.get(model._pK));
				}
			}
			if (changed.length > 0) {
				var arr = [record, changed];
				this.emit("change", arr);
				model.emit("change", arr);
				this.undoStack = store.$.genUnRedoStack();
				this.redoStack = store.$.genUnRedoStack();
			}
		}
	},
	rollBack: {
		value: function value(state, inherit) {
			var model = this.model,
			    pK = model._pK,
			    recmp = new Map();
			inherit = inherit === false ? false : model._fldGrps.inherit && Object.keys(model._fldGrps.inherit).length;
			if (state) {
				this.rollBackState(state, inherit);
				store.$.removeOnSave(this.model._name, this.record.$.pK);
			} else {
				if (inherit) {
					store.$.rBinherit(this, recmp, "");
				}
				store.$.rollBackRecord(this);
			}
		}
	},
	deleteRecord: {
		value: function value(delayPers) {
			var model = this.model,
			    record = this.record.$.record,
			    delayPers = delayPers !== undefined ? delayPers : record.$.delayPersistence ? record.$.delayPersistence.delete : undefined;
			store.$.removeFromStore(model, record.$.pK, undefined, undefined, delayPers);
		}
	},
	destroyRecord: {
		value: function value(customData, qP, delayPers, mutationName) {
			this.deleteRecord(delayPers);
			return this.save(customData, qP, "destroyRecord", undefined, mutationName);
		}
	},
	addEventListener: {
		value: function value(type, func) {
			return store.$.eventListeners.add(this, type, func);
		}
	},
	removeEventListener: {
		value: function value(id) {
			store.$.eventListeners.remove(this, id);
		}
	},
	emit: {
		value: function value(type, args) {
			store.$.eventListeners.emit(this, type, args);
		}
	},
	triggerAction: {
		value: function value(actionName, customData, qP, method, data) {
			var model = this.model,
			    actions = model.actions,
			    action = actions ? actions[actionName] : undefined;
			if (action) {
				return store.adapter.$.handleAction(actionName, model, this.record.$.record, customData, qP, method, data);
			}
			return Promise.reject({ code: "ERR18", message: Lyte.errorCodes.ERR18, data: actionName });
		}
	},
	save: {
		value: function value(customData, qP, options, destroy, mutationName) {
			var self = this;
			if (this.isCloned) {
				if (this.isUnloaded) {
					return Promise.resolve();
				} else {
					self = store.$.savingDonorRecord(this);
				}
			}
			var model = self.model,
			    record = self.record,
			    dirty = self.isDirty(),
			    validateOnSave = options && options.validateOnSave,
			    skipValidation = options && options.skipValidation,
			    clear,
			    fields = model.fieldList,
			    ret;
			if (self.isUnloaded !== true) {
				if (self.isDeleted) {
					if (!self.isNew) {
						return store.adapter.$.del(model._name, record, true, destroy, customData, qP, mutationName);
					}
					// store.adapter.$.handleResponse(record, record, undefined, undefined, model);
				} else if (self.isNew) {
					var err = self;
					if (!skipValidation && (!record.$.validatedOnCreate || validateOnSave)) {
						ret = store.$.validateRecord(self.record, fields);
					}
					if (!skipValidation && (ret == false || err && err.error && Object.keys(err.error).length > 0)) {
						return Promise.reject(err.error);
					}
					return store.adapter.$.create(model._name, record, true, customData, qP, mutationName);
				} else if (self.isModified || dirty && dirty.length) {
					var data = {};
					if (!skipValidation && options && validateOnSave) {
						ret = store.$.validateRecord(self.record, fields);
					}
					if (!skipValidation) {
						if (ret == false || record && record.$ && record.$.isError) {
							return Promise.reject(record.$.error);
						}
					}
					var data = store.$.updateJSON(self.record, model, dirty);
					return store.adapter.$.put(model._name, data, record, true, customData, qP, mutationName);
				}
			} else {
				Lyte.warn("LD29", _typeof(record.$.pK) == "object" ? JSON.stringify(record.$.pK) : record.$.pK, model._name);
				var rejectUnloadRecordSave = store.$.getFromCB("adapter", model._name, "rejectUnloadRecordSave");
				if (rejectUnloadRecordSave) {
					return Promise.reject({ code: "ERR28", message: Lyte.errorCodes.ERR28, data: record });
				}
			}
			return Promise.resolve();
		}
	},
	getInitialValues: {
		value: function value(attr) {
			var isAttrPassed = false;
			if (attr) {
				if (!Array.isArray(attr)) {
					attr = [attr];
				}
				isAttrPassed = true;
			} else {
				attr = this.getDirtyAttributes();
			}
			var ret = {},
			    rec = this.record.$.record,
			    _attrs = this._attributes;
			for (var i = 0; i < attr.length; i++) {
				if (rec[attr] == undefined || !rec[attr[i]].add) {
					ret[attr[i]] = _attrs[attr[i]];
				} else {
					ret[attr[i]] = rec[attr[i]].slice(0);
					var arr = _attrs[attr[i]],
					    pK = rec[attr[i]].model._pK;
					for (var j = arr.length - 1; j >= 0; j--) {
						if (arr[j]._type == "added") {
							for (var k = 0; k < arr[j].records.length; k++) {
								var index = store.$.getIndex(ret[attr[i]], pK, arr[j].records[k].$.pK);
								if (index == -1) {
									continue;
								}
								ret[attr[i]].splice(index, 1);
							}
						} else if (arr[j]._type == "removed") {
							for (var k = arr[j].records.length - 1; k >= 0; k--) {
								ret[attr[i]].splice(arr[j]._indices[k], 0, arr[j].records[k]);
							}
						} else if (arr[j]._type == "changed") {
							ret[attr[i]] = Array.isArray(arr[j].records) ? Array.from(arr[j].records) : arr[j].records;
						}
					}
				}
			}
			if (isAttrPassed) {
				return ret[attr[0]];
			}
			return ret;
		}
	},
	toJSON: {
		value: function value(type, addNotDefinedFields) {
			var inherit = true;
			addNotDefinedFields = addNotDefinedFields ? true : false;
			if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) == "object" && type.inherit == false) {
				inherit = type.inherit;
			}
			return Object.assign({}, store.$.toJSON(this.model._name, this.record.$.record, !type ? true : type, undefined, undefined, inherit, addNotDefinedFields));
		}
	},
	undo: {
		value: function value(attr, state) {
			var currentState = this.undoStack._order_.length;
			state = state || (currentState ? currentState - 1 : currentState);
			// state = state || 0;
			while (currentState-- > state) {
				store.$.unredoOp(1, this, attr);
			}
		}
	},
	getCurrentState: {
		value: function value() {
			return this.undoStack._order_.length;
		}
	},
	redo: {
		value: function value(attr) {
			store.$.unredoOp(2, this, attr);
		}
	},
	validate: {
		value: function value(field, validateCallBack) {
			var fields = {};
			var model = this.model;
			var fieldList = model.fieldList;
			if (Array.isArray(field)) {
				field.forEach(function (item, index) {
					if (fieldList[item]) {
						fields[item] = fieldList[item];
					}
				});
			} else if ((typeof field === 'undefined' ? 'undefined' : _typeof(field)) == "object") {
				fields = field;
			}
			if (Object.keys(fields).length == 0 || field == true) {
				fields = fieldList;
			}
			var record = this.record;
			var err = store.$.validateRecord(record, fields, validateCallBack);
			if (validateCallBack && err && (typeof err === 'undefined' ? 'undefined' : _typeof(err)) == "object") {
				return err;
			}
		}
	},
	saveState: {
		value: function value(state) {
			if (!this.isNew && !this.isModified) {
				Lyte.warn("LD20");
				return;
			}
			var savedState = this._savedState = this._savedState || {},
			    currentState = state,
			    randomState;
			while (!currentState) {
				randomState = Math.floor(Math.random() * 100000 + 1);
				currentState = !savedState.hasOwnProperty(randomState) ? randomState : currentState;
			}
			var obj = this.toJSON("state");
			store.$.defProp(obj, "$", {}, false, true);
			var pK = this.model._arrPk;
			pK.forEach(function (val) {
				delete obj[val];
			});
			var undoStack = this.undoStack;
			var redoStack = this.redoStack;
			var _attributes = this._attributes;
			var old_dN = this.dN;
			// var dN = this.record.$.dN;
			if (undoStack && Object.keys(undoStack).length) {
				var _order = undoStack._order_;
				undoStack = obj.$.undoStack = store.$.deepCopyStack(undoStack);
				store.$.defProp(undoStack, "_order_", Lyte.deepCopyObject(_order), false, true);
			}
			if (redoStack && Object.keys(redoStack).length) {
				var _order = redoStack._order_;
				redoStack = obj.$.redoStack = store.$.deepCopyStack(redoStack);
				store.$.defProp(redoStack, "_order_", Lyte.deepCopyObject(_order), false, true);
			}
			if (_attributes && Object.keys(_attributes).length) {
				obj.$._attributes = store.$.deepCopyAttrs(this.model, _attributes);
			}
			if (old_dN && Object.keys(old_dN).length) {
				obj.$.dN = store.$.deepCopyAttrs(this.model, old_dN);
			}
			this._savedState[currentState] = obj;
			return currentState;
		}
	},
	clearState: {
		value: function value(state) {
			if (!state) {
				this._savedState = {};
				return;
			}
			delete this._savedState[state];
		}
	},
	rollBackState: {
		value: function value(state, inherit) {
			var savedSt = this._savedState;
			var obj = savedSt ? savedSt[state] : undefined;
			if (!obj) {
				Lyte.warn("LD21", state);
				return;
			}
			this.dN ? this.dN = {} : undefined;
			store.$.setData(this, obj, undefined, undefined, {}, true, inherit, obj.$.dN);
			store.$.updateDn(this.record.$.record);
			this.undoStack = obj.$.undoStack || store.$.genUnRedoStack();
			this.redoStack = obj.$.redoStack || store.$.genUnRedoStack();
			this._attributes = obj.$._attributes || {};
			store.$.checkAttrs(this.record.$.record);
			delete this._savedState[state];
		}
	},
	hasSavedState: {
		value: function value(state) {
			return this._savedState && this._savedState.hasOwnProperty(state) ? true : false;
		}
	},
	persist: {
		value: function value(obj) {
			var mName = this.model._name,
			    rec = this.record.$.record,
			    partialObj = { obj: new Map() },
			    type,
			    dirty;
			if (this.isNew) {
				type = "create";
				store.$.toJSON(mName, rec, undefined, type, partialObj);
			} else if (dirty = this.isDirty()) {
				var data = store.$.updateJSON(rec, this.model, dirty);
				store.$.toJSON(mName, data, undefined, undefined, partialObj);
			}
			var pObj = partialObj.obj.get(this.pK);
			store.adapter.$.mergeResponse(rec, this.model, undefined, this.pK, pObj, true);
			store.adapter.$.updateIDB(mName, type ? type : rec.$.isDeleted || rec.$.isUnloaded ? "deleteRecord" : rec.$.isModified || dirty ? "updateRecord" : undefined, rec);
		}
	},
	clone: {
		value: function value() {
			var parent = this.record.$.record,
			    data = this.record.$.toJSON({ type: "isClone" });
			var clonedData = store.$.insertIntoStore(parent.$.model._name, data, undefined, undefined, undefined, undefined, undefined, { type: "isClone" });
			return clonedData;
		}
	}
});
/* Model Object Constructor 
*/
var Model = function Model(name, fields) {
	Object.assign(this, { _name: name, fieldList: { id: { type: "string", primaryKey: true, defined: false } }, relations: {}, _properties: {}, deprecate: {}, _fldGrps: { default: {}, hasMany: {}, watch: {}, inherit: {}, nested_prop: {}, inverse: {}, JsonPathWatch: {} }, data: [], dirty: [], _deleted: new Map(),
		events: {} });
	store.$.defProp(this.data, "_recMap", new Map());
	var obs = [];
	for (var key in fields) {
		store.$.registerField(this, key, fields[key], obs);
	}
	if (!this._pK) {
		this._pK = 'id';
	}
	this.isComp = false;
	var splt = this._pK.split(',');
	if (splt.length > 1) {
		this.isComp = true;
	}
	this._arrPk = splt;
	if (typeof Lyte != "undefined") {
		Lyte.establishObserverBindings(obs, true, this._properties, this);
		Lyte.establishWatchScope(this._fldGrps.JsonPathWatch, this);
	}
	store.$.defArrUtls(this.data);
	store.$.defUtls(this.data, this);
	store.$.defProp(this, "extends", store.$.extendModel);
};
Model.prototype.addEventListener = function (type, func) {
	return store.$.eventListeners.add(this, type, func);
};
Model.prototype.removeEventListener = function (id) {
	store.$.eventListeners.remove(this, id);
};
Model.prototype.emit = function (type, args) {
	store.$.eventListeners.emit(this, type, args);
};
Model.prototype.on = function (type, func) {
	return this.addEventListener(type, func);
};
Model.prototype.setGql = function value(type, key, Query) {
	store.$.setQuery(this, key, type, Query);
};
var store = {
	model: {},
	$: {
		idbOpen: true,
		request: {},
		toRelate: {},
		idbQueue: [],
		idbQ: {},
		idbQ2: {},
		nestScp: {},
		nestScpId: 1,
		getAdapter: function getAdapter(obj) {
			if (obj.name == "application") {
				return store.adapter[obj.name];
			}
			if (obj.model || obj.name) {
				var model = obj.model || store.model[obj.name];
				if (model && model.extend) {
					if (!store.adapter.hasOwnProperty(model._name)) {
						return store.adapter[model.extend];
					}
				}
				var name = model ? model._name : obj.name;
				return store.adapter[name];
			}
		},
		registerModel: function registerModel(name, fields, options) {
			if (store.model.hasOwnProperty(name)) {
				Lyte.warn("LD14", "Model", name);
				Lyte._postRegister();
				return { error: Lyte.getErrorMessage("LD14", "Model", name), extends: function _extends() {} };
			}
			try {
				var extend, actions, idb, gql, sort, deprecate;
				if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) == "object") {
					extend = options.extends || undefined;
					actions = options.actions || undefined;
					idb = options.idb || undefined;
					gql = options.gql || undefined;
					sort = options.sort || undefined;
					deprecate = options.deprecate || undefined;
				}
				if (extend) {
					var parentFields = Object.assign({}, store.model[extend].fieldList);
					for (var key in parentFields) {
						if (parentFields[key].type == "relation") {
							delete parentFields[key];
						}
					}
					fields = Object.assign(fields, parentFields);
				}
				var model = store.model[name] = new Model(name, fields);
				if (extend) {
					store.$.extendModel(extend, model);
				}
				if (actions) {
					model.actions = actions;
				}
				if (idb) {
					model.idb = idb;
				}
				if (gql) {
					model.gql = gql;
				}
				if (sort) {
					model.sort = sort;
					model.cT = new Map();
				}
				if (deprecate) {
					if (!Array.isArray(deprecate)) {
						deprecate = [deprecate];
					}
					var mp = new Map();
					deprecate.forEach(function (itm) {
						if (!mp.has(itm)) {
							mp.set(itm, 1);
						}
					});
					model.deprecate = mp;
				}
				Lyte._postRegister();
			} catch (e) {
				Lyte._postRegister();
			}
			return model;
		},
		changePersist: function changePersist(record, value) {
			if (!record.$.isUnloaded || record.$.isPeristed !== value) {
				switch (value) {
					case true:
						{
							if (!record.$.isNew && !record.$.isModified && !record.$.isDeleted) {
								store.$.cmpSet(record.$, "isPersisted", true);
							}
							break;
						}
					case false:
						{
							if (record.$.isNew || record.$.isModified || record.$.isDeleted || record.$.dN && Object.keys(record.$.dN) && Object.keys(record.$.dN).length) {
								store.$.cmpSet(record.$, "isPersisted", false);
							}
							break;
						}
				}
			}
		},
		getFromCB: function getFromCB(type, name, key) {
			var scp = store[type],
			    extend;
			if (/^(adapter|serializer)$/.test(type) && store.model.hasOwnProperty(name) && store.model[name].extend) {
				extend = store.model[name].extend;
			}
			var obj = scp && scp.hasOwnProperty(name) ? scp[name] : extend && scp.hasOwnProperty(extend) ? scp[extend] : undefined,
			    result = obj ? obj[key] : undefined;
			while (result === undefined) {
				if (obj && obj.$super) {
					obj = obj.$super;
					result = obj ? obj[key] : undefined;
				} else {
					if (!obj) {
						obj = scp.application;
					}
					if (obj && obj.hasOwnProperty(key)) {
						result = obj[key];
					} else {
						if (type == "adapter") {
							switch (key) {
								case "host":
									{
										result = window.location.origin ? window.location.origin : window.location.protocol + "//" + window.location.host;
										break;
									}
								case "namespace":
									{
										result = "";
										break;
									}
								case "actionNamespace":
									{
										result = "action";
										break;
									}
								case "batchNamespace":
									{
										result = "batch";
										break;
									}
								default:
									result = undefined;
							}
							break;
						} else {
							break;
						}
					}
					if (!obj && !result) {
						break;
					}
				}
			}
			return result;
		},
		newCB: function newCB(type, self, name, attrs, opts) {
			self.__extendedBy = [];
			for (var key in attrs) {
				self[key] = attrs[key];
			}
			store.$.extendOptions(opts, type, name, self, store);
			store.$.lazyExtend(type, self, name);
			store.$.defProp(self, "is", type);
			store.$.defProp(self, "__name", name);
		},
		extendOptions: function extendOptions(opts, type, name, self, scope) {
			if (opts && opts.mixins && opts.mixins.length) {
				opts.mixins.forEach(function (item) {
					if (Lyte.Mixin.exists(item)) {
						var mixin = Lyte.registeredMixins[item];
						for (var key in mixin) {
							self[key] = mixin[key];
						}
					} else {
						Lyte.$.requiredMixins(item, { "name": name, "scope": scope }, type);
					}
				});
			}
			var services = opts ? opts.services : [];
			store.$.extendService(services, type, name, self, scope);
			if (Lyte.toBeInjectedServices) {
				var tbServ = Lyte.toBeInjectedServices,
				    arr = [];
				for (var key in tbServ) {
					arr.push({ as: key, service: tbServ[key] });
				}
				store.$.extendService(arr, type, name, self, scope, true);
			}
		},
		extendService: function extendService(services, type, name, self, scope, isGlobal, data) {
			Lyte.extendService({ services: services, type: type, name: name, ins: self, isGlobal: isGlobal, data: data, callback: function callback(serv, key, name, sname) {
					Lyte.$.lazyRegisterService(isGlobal ? serv : Lyte.$.instantiateService(sname), { scope: scope, type: type, name: name, key: key });
				} });
		},
		lazyExtend: function lazyExtend(type, self, name) {
			var scope = store[type];
			if (scope.__toAddSuper && scope.__toAddSuper.hasOwnProperty(name)) {
				var addSuper = scope.__toAddSuper[name];
				for (var i = 0; i < addSuper.length; i++) {
					var child = scope[addSuper[i]];
					if (child && child.is == type) {
						child.$super = self;
						self.__extendedBy.push(addSuper[i]);
						var index;
						if (name != "application") {
							if (scope.__toAddSuper.application) {
								index = scope.__toAddSuper.application.indexOf(child.__name);
								if (index > -1) {
									scope.__toAddSuper.application.splice(index, 1);
								}
							}
							if (scope.application) {
								index = scope.application.__extendedBy.indexOf(child.__name);
								if (index > -1) {
									scope.application.__extendedBy.splice(index, 1);
								}
							}
						}
					}
				}
				delete scope.__toAddSuper[name];
			}
		},
		cbDef: function cbDef(cls, type) {
			Object.defineProperties(cls.prototype, {
				"super": {
					value: function value() {
						return store.$.super.call(this, arguments);
					}
				},
				"extends": {
					value: function value(name) {
						store.$.extendCallback.call(this, store, type, name);
					}
				}
			});
		},
		changeRelPkMaps: function changeRelPkMaps(data, oldPk, newPk, type, changedField) {
			var model = data.$.model;
			var relations = model.relations;
			for (var key in relations) {
				var rels = relations[key],
				    relsLen = rels.length;
				for (var i = 0; i < relsLen; i++) {
					var itm = rels[i];
					var attr = itm.relKey,
					    relType = itm.relType,
					    inv;
					if (data.hasOwnProperty(attr)) {
						var relRec = data[attr],
						    bMod = store.model[itm.relatedTo],
						    inv,
						    isSortDef;
						if (bMod) {
							inv = store.$.getBackwardRel(model, itm, bMod);
							if (inv && inv.relType == "hasMany") {
								isSortDef = inv.opts && inv.opts.sort && inv.opts.sort.sortFn && inv.opts.sort.observes;
								if (relType == "belongsTo" && Lyte.isRecord(relRec)) {
									switch (type) {
										case "sort":
										case "srtObsChk":
											{
												if (relRec && Array.isArray(relRec[inv.relKey])) {
													if (type == "sort") {
														if (isSortDef && inv.opts.sort.observes.indexOf(changedField) != -1) {
															store.$.handleArrOp(relRec[inv.relKey], "sort");
														}
													} else if (changedField !== inv.relKey) {
														return true;
													}
												}
												break;
											}
										default:
											{
												relRec[inv.relKey] && relRec[inv.relKey]._recMap && relRec[inv.relKey]._recMap.delete(oldPk) ? relRec[inv.relKey]._recMap.set(newPk, data) : undefined;
											}
									}
								} else if (relType == "hasMany" && Array.isArray(relRec)) {
									var relRecLen = relRec.length;
									for (var l = 0; l < relRecLen; l++) {
										var rec = relRec[l];
										switch (type) {
											case "sort":
											case "srtObsChk":
												{
													if (rec && Array.isArray(rec[inv.relKey])) {
														if (type == "sort") {
															if (isSortDef && inv.opts.sort.observes.indexOf(changedField) != -1) {
																store.$.handleArrOp(rec[inv.relKey], "sort");
															}
														} else if (changedField !== inv.relKey) {
															return true;
														}
													}
													break;
												}
											default:
												{
													Lyte.isRecord(rec) && rec[inv.relKey] && rec[inv.relKey]._recMap && rec[inv.relKey]._recMap.delete(oldPk) ? rec[inv.relKey]._recMap.set(newPk, data) : undefined;
												}
										}
									}
								}
							}
						}
					}
				}
			}
			var _rels = data.$._relationships;
			for (var md in _rels) {
				var mdObj = _rels[md];
				var mdlIns = store.modelFor(md);
				for (var attr in mdObj) {
					var arr = mdObj[attr];
					var fldObj = mdlIns.fieldList[attr];
					var isSortDef = fldObj.opts && fldObj.opts.sort && fldObj.opts.sort.sortFn && fldObj.opts.sort.observes;
					var arrLen = arr.length;
					for (var j = 0; j < arrLen; j++) {
						var rec = arr[j];
						var relData = rec[attr];
						if (Array.isArray(relData)) {
							switch (type) {
								case "sort":
								case "srtObsChk":
									{
										if (Array.isArray(relData)) {
											if (type == "sort") {
												if (isSortDef && fldObj.opts.sort.observes.indexOf(changedField) != -1) {
													store.$.handleArrOp(relData, "sort");
												}
											} else if (changedField !== fldObj.relKey) {
												return true;
											}
										}
										break;
									}
								default:
									{
										relData._recMap && relData._recMap.delete(oldPk) ? relData._recMap.set(newPk, data) : undefined;
									}
							}
						}
					}
				}
			}
		},
		updateNestScp: function updateNestScp(record, oldPk) {
			if (Lyte.isRecord(record)) {
				var scpObj = record.$.__scpObj || {};
				for (var key in scpObj) {
					var val = scpObj[key];
					val = val.split("_")[0];
					if (Lyte.nestScp && Lyte.nestScp.hasOwnProperty(val) && Lyte.nestScp[val].model) {
						var mp1 = Lyte.nestScp[val].model.get(record.$.model._name);
						if (mp1.has(oldPk)) {
							var val = mp1.get(oldPk);
							mp1.delete(oldPk);
							mp1.set(record.$.pK, val);
						}
						// Lyte.nestScp[val].pK = record.$.pK;
					}
				}
			}
		},
		getDefaultVal: function getDefaultVal(rec, defVal) {
			if (typeof defVal != "function") {
				return defVal;
			} else {
				return defVal.call(rec);
			}
		},
		deepValueChange: function deepValueChange(rec, attr, value, changeObj) {
			var toEmit = { emit: false, attr: [], oldRec: {} };
			store.$.estAttrs(rec, attr, value, toEmit, changeObj);
			store.$.checkAttrs(rec);
			store.$.changeCallbck(rec, toEmit);
		},
		updateDn: function updateDn(record) {
			var model = record.$.model;
			var relations = model.relations;
			for (var key in relations) {
				var rels = relations[key];
				rels.forEach(function (itm) {
					var options = itm.opts,
					    attr = itm.relKey,
					    relType = itm.relType;
					if (options && options.deepNest) {
						if (record.hasOwnProperty(attr)) {
							var relRec = record[attr];
							if (relType == "belongsTo" && (relRec.$.isModified || relRec.$.dN && Object.keys(relRec.$.dN).length)) {
								store.$.setDeepNest(record, attr, relRec.$.pK, "updated");
							} else if (relType == "hasMany" && Array.isArray(relRec)) {
								relRec.forEach(function (rec) {
									if (rec.$.isModified || rec.$.dN && Object.keys(rec.$.dN).length) {
										store.$.setDeepNest(record, attr, rec.$.pK, "updated");
									}
								});
							}
						}
					}
				});
			}
		},
		genUnRedoStack: function genUnRedoStack() {
			var obj = {};
			store.$.defProp(obj, "_order_", [], false);
			return obj;
		},
		deepCopyStack: function deepCopyStack(stack) {
			if (stack && (typeof stack === 'undefined' ? 'undefined' : _typeof(stack)) == "object") {
				stack = Object.assign({}, stack);
				for (var attr in stack) {
					if (Array.isArray(stack[attr])) {
						var arr = stack[attr] = Array.from(stack[attr]);
						arr.forEach(function (itm, idx) {
							arr[idx] = Object.assign(itm);
						});
					}
				}
			}
			return stack;
		},
		deepCopyAttrs: function deepCopyAttrs(model, obj) {
			var fields = model.fieldList;
			var obj = Object.assign({}, obj);
			for (var attr in obj) {
				var _attr = obj[attr];
				if (fields[attr] && fields[attr].type == "relation" && Array.isArray(_attr)) {
					_attr = obj[attr] = Array.from(_attr);
					_attr.forEach(function (itm, idx) {
						_attr[idx] = Object.assign({}, itm);
						itm.hasOwnProperty("records") && itm.records ? itm.records = Array.from(itm.records) : undefined;
						itm.hasOwnProperty("_indices") && itm._indices ? itm._indices = Array.from(itm._indices) : undefined;
					});
				}
			}
			return obj;
		},
		// 1 index -> delete [0,2,a,4,5,6,7,8,9,10] '1' -> 1 index            
		// 2 index -> delete [0,2,4,5,6,7,8,9,10]   'a' -> 2 index
		// a index -> delete [0,2,4,6,7,8,9,10]	  	'5' -> a index
		// 2 index -> delete [0,2,4,7,8,9,10]	   	'6' -> a index 
		// 1 index -> delete [0,4,7,8,9,10]		  	'2' -> 1 index
		// 5 index -> delete [0,4,7,8,9]         	'10' -> 5 index
		// insert -> 5 -> add [0,4,7,8,9,11]

		// algo 
		// 1) to find the current index -> check the later items for lesser index. Minus the current index when the below item's index is less than it
		// 2) after rollbacking, check the later items for the same or higher index and increment it

		// case 1) rollback number 5 -> it should go in position 2
		// a - 1 - 1 = 1 
		// [ 0,4,5,7,8,9,11 ] 
		// 1 -> 1 , a -> 2, 6 -> a + 1, 2 -> 1 , 10 -> 5 + 1

		// case 2) rollback number a -> it should go in position 1
		// 2 - 1 = 1   
		// [ 0,a,4,5,7,8,9,11 ]
		// 1 -> 1 , 6 - > 4 + 1 , 2 -> 1 , 10 -> 6 + 1

		// case a) rollback number 6 -> it should go in position 4
		// 5 - 1
		// [ 0,a,4,5,6,7,8,9,11 ]
		// 1 -> 1 , 2 -> 1, 10 -> 7 + 1

		// case 4) rollback 10 -> it should go in position 8 
		// 8 
		// [ 0,a,4,6,7,8,9,10,11 ]

		addTo_Del: function addTo_Del(model, data, ind) {
			var deleted = model._deleted = model._deleted || new Map();
			var obj = { index: ind, data: data };
			deleted.set(data.$.pK, obj);
		},
		scExtd: function scExtd(type, name, opts, parent) {
			var scope = type == "adapter" ? store.adapter : store.serializer;
			if (!name) {
				return;
			}
			if (scope.hasOwnProperty(name)) {
				Lyte.warn("LD14", type, name);
				return { error: Lyte.getErrorMessage("LD14", type, name), extends: function _extends() {} };
			}
			if (type == "adapter") {
				scope[name] = new Adapter(opts, parent, name);
			} else {
				scope[name] = new Serializer(opts, parent, name);
			}
			if (scope.application && name != "application") {
				scope[name].$super = scope.application;
				scope.application.__extendedBy.push(name);
			}
			if (!scope.application && name != "application") {
				scope.__toAddSuper = scope.__toAddSuper || {};
				if (!scope.__toAddSuper.hasOwnProperty("application")) {
					scope.__toAddSuper.application = [];
				}
				scope.__toAddSuper.application.push(name);
			}
			return scope[name];
		},
		initCB: function initCB(type, modelName, key, obj) {
			var scope = store.$.cbScp(modelName, key, type),
			    args = obj.args,
			    ret = {};
			if (scope) {
				ret.data = store.$.cB(scope, args);
				return ret;
			}
		},
		cB: function cB(callback, args) {
			return callback.func.apply(callback.scope, args.concat(callback.name));
		},
		cbScp: function cbScp(name, key, type) {
			var scope = store[type],
			    callback,
			    application = scope.application,
			    extend;
			if (/^(adapter|serializer)$/.test(type) && store.model.hasOwnProperty(name) && store.model[name].extend) {
				extend = store.model[name].extend;
			}
			var layer = scope && scope.hasOwnProperty(name) ? scope[name] : extend && scope.hasOwnProperty(extend) ? scope[extend] : undefined;
			while (callback == undefined) {
				if (layer && layer[key] && typeof layer[key] == "function") {
					return { scope: layer, func: layer[key], name: key };
				} else if (layer && layer.$super) {
					layer = layer.$super;
				} else if (application && application[key] && typeof application[key] == "function") {
					return { scope: application, func: application[key], name: key };
				} else {
					return undefined;
				}
			}
		},
		comparePk: function comparePk(rec, pkVal) {
			var pK = rec.$.pK;
			var pkType = typeof pK === 'undefined' ? 'undefined' : _typeof(pK);
			if (pkType == "string" || pkType == "number") {
				return pK === pkVal;
			} else if ((typeof pK === 'undefined' ? 'undefined' : _typeof(pK)) == "object") {
				var len = Object.keys(pK).length,
				    i = 0;
				for (var key in pK) {
					if (pK[key] === pkVal[key]) {
						i++;
					}
				}
				return len === i;
			}
		},
		getpKVal: function getpKVal(record, model) {
			var model = model ? model : record.$.model;
			var arr = model._arrPk;
			if (arr.length == 1) {
				return record[arr[0]];
			} else {
				var obj = {};
				arr.forEach(function (item) {
					obj[item] = record[item];
				});
			}
			return obj;
		},
		unredoOp: function unredoOp(type, rec, attr) {
			var stack, revStack;
			if (type == 1) {
				stack = rec.undoStack;
				revStack = rec.redoStack;
			} else {
				stack = rec.redoStack;
				revStack = rec.undoStack;
			}
			var attrs = [],
			    obj,
			    revObj = {};
			if (attr) {
				if (!Array.isArray(attr)) {
					attrs = [attr];
				} else {
					attrs = attr;
				}
				attrs.forEach(function (item) {
					if (stack[item].length) {
						var len = stack._order_.length;
						for (var index = len - 1; index >= 0; index--) {
							var order = stack._order_[index];
							var attrIndex = order.indexOf(item);
							if (attrIndex > -1) {
								order.splice(attrIndex, 1);
								if (!order.length) {
									stack._order_.splice(index, 1);
								}
								break;
							}
						}
					}
				});
			} else {
				attrs = stack._order_ && stack._order_.length ? stack._order_.pop() : attrs;
			}
			if (attrs.length) {
				for (var index = 0; index < attrs.length; index++) {
					var key = attrs[index],
					    obj = stack[key].pop();
					if (obj._type == "update") {
						if (obj.hasOwnProperty("val")) {
							store.$.setData(rec, key, obj.val, undefined, revObj);
							// redoObj[key] = undo;
						} else if (obj.hasOwnProperty("records")) {
							store.$.setData(rec, key, obj.records, undefined, revObj);
						}
					} else if (type == 1 && obj._type == "propAdd") {
						if (typeof Lyte != "undefined") {
							revObj[key] = { _type: "propDelete", val: rec.record[key] };
							if (obj.hasOwnProperty("val")) {
								store.$.setData(rec, key, obj.val, undefined, {});
								// redoObj[key] = undo;
							}
							if (Lyte.objectUtils) {
								Lyte.objectUtils(rec.record, "delete", key);
							} else {
								delete rec.record[key];
							}
						} else {
							delete rec.record[key];
						}
					} else if (type == 2 && obj._type == "propDelete") {
						revObj[key] = { _type: "propAdd" };
						store.$.setData(rec, key, obj.val, undefined, revObj);
					} else if (obj._type == "added") {
						rec.record.$.get(key).remove(obj.records, undefined, revObj);
					} else if (obj._type == "removed") {
						store.$.rllBckRecArr([obj], rec.record, rec.model, rec.model.fieldList[key]);
						obj._type = "added";
						revObj[key] = obj;
					}
				}
				var keys = Object.keys(revObj);
				for (var index = 0; index < keys.length; index++) {
					var key = keys[index];
					revStack[key] = revStack[key] || [];
					revStack[key].push(revObj[key]);
				}
				if (keys.length) {
					// rec.redoStack._order_ = rec.redoStack._order_ || [];
					revStack._order_.push(keys);
				}
			}
		},
		// undo: function(rec){
		// 	var obj = rec.undoStack.pop(),undo, redoObj = {};
		// 	if(obj){
		// 		for(var key in obj){
		// 			var undo = obj[key];
		// 			if(undo._type == "update"){
		// 				if(undo.hasOwnProperty("val")){
		// 					store.$.setData(rec,key,undo.val,redoObj)
		// 				}else if(undo.hasOwnProperty("records")){
		// 					store.$.setData(rec,key,undo.records,redoObj)	
		// 				}
		// 			}
		// 			else if(undo._type == "propAdd"){
		// 				if(typeof Lyte != "undefined"){
		// 					redoObj[key] = {type:"propDelete", val:rec.record[key]};
		// 					Lyte.objectUtils(rec.record, "delete", key);
		// 				}
		// 				else{
		// 					delete rec.record[key];
		// 				}
		// 			}
		// 			else if(undo._type == "added"){
		// 				rec.record.$.get(key).remove(undo.records,undefined,redoObj);
		// 			}
		// 			else if(undo._type == "removed"){
		// 				store.$.rllBckRecArr([undo], rec.record, rec.model, rec.model.fieldList[key])
		// 				undo._type = "added";
		// 				redoObj[key] = undo;
		// 			}
		// 		}
		// 		rec.redoStack.push(redoObj);				
		// 	}
		// },
		unregisterModel: function unregisterModel(name, inherit) {
			var model = store.modelFor(name);
			if (!model) {
				Lyte.warn("LD02", "Model ", name);
				return;
			}
			if (model.data.length) {
				store.unloadAll(name, undefined, inherit);
			}
			var extendedBy = model.extendedBy;
			if (extendedBy && Object.keys(extendedBy).length) {
				for (var ext in extendedBy) {
					store.unregisterModel(ext, inherit);
				}
			}
			var extend = model.extend;
			if (extend) {
				var extMod = store.modelFor(extend);
				delete extMod.extendedBy[name];
			}
			delete store.model[name];
			store.__mdlPrx ? delete store.__mdlPrx[name] : undefined;
		},
		getDsrzEmpData: function getDsrzEmpData(field, modelName) {
			if (field.hasOwnProperty("deserializeEmptyData")) {
				return field.deserializeEmptyData;
			} else {
				var desrz = store.$.getFromCB("serializer", modelName, "deserializeEmptyData");
				if (desrz !== undefined) {
					return desrz;
				}
			}
			return false;
		},
		updateFieldValidation: function updateFieldValidation(model, key, deserialize, ignoreValidation) {
			var records = model.data;
			var fields = model.fieldList;
			records.forEach(function (item) {
				var field = fields[key];
				if (deserialize) {
					var empD = store.$.getDsrzEmpData(field, model._name);
					var boolChk = !empD && item[key];
					if (item.hasOwnProperty(key) && (boolChk || empD) && Lyte.Transform.hasOwnProperty(field.type) && Lyte.Transform[field.type].hasOwnProperty("deserialize")) {
						item[key] = Lyte.Transform[field.type].deserialize(item[key], key, model._name, store.$.getpKVal(item, model));
					}
				}
				if (!ignoreValidation) {
					var isOldVal = item.$.error && item.$.error.hasOwnProperty(key) && item.$.error[key].hasOwnProperty("value") ? true : false;
					var oldVal = isOldVal ? item.$.error[key].value : undefined;
					store.$.clrRecErr(item.$, key);
					isOldVal ? store.$.validateField(item, key, field, undefined, { old: true, value: oldVal }) : store.$.validateField(item, key, field, undefined);
				}
				if (isOldVal && item.$.error && Object.keys(item.$.error) === 0) {
					item.$.set(key, oldVal);
				}
			});
		},
		validateRelatedRecord: function validateRelatedRecord(record, key, field) {
			var fields = store.model[field.relatedTo].fieldList;
			if (field && field.opts && record && record.hasOwnProperty(key)) {
				if (field.opts && field.opts.serialize == "record") {
					if (field.relType == "belongsTo" && Lyte.isRecord(record[key])) {
						return this.validateRecord(record[key], fields);
					} else if (field.relType == "hasMany") {
						if (Array.isArray(record[key])) {
							var ret = true,
							    result,
							    self = this;
							record[key].forEach(function (item, index) {
								if (Lyte.isRecord(item)) {
									result = self.validateRecord(item, fields);
									if (result === false) {
										ret = false;
									}
								}
							});
							return ret;
						}
					}
				}
			}
		},
		validateRecord: function validateRecord(record, fields, validateCallBack) {
			var result,
			    ret = true,
			    returnVal,
			    validationErrors = {};
			for (var field in fields) {
				returnVal = this.validateField(record, field, fields[field], result, undefined, validateCallBack, validationErrors);
				if (ret === true && returnVal === false) {
					ret = false;
				}
			}
			if (validateCallBack) {
				var res = validateCallBack.apply(record.$, [validationErrors]);
				if (res && (typeof res === 'undefined' ? 'undefined' : _typeof(res)) == "object") {
					for (var e in res) {
						store.$.setRecErr(record.$, e, res[e]);
					}
				} else if (res == true) {
					return true;
				}
			}
			if (ret === false || record.$.isError === true && record.$.error && Object.keys(record.$.error).length) {
				return false;
			}
			return true;
		},
		validateField: function validateField(record, key, field, result, obj, validateCallBack, validationErrors) {
			var val = obj && obj.old ? obj.value : record[key],
			    ret,
			    err = record.$,
			    clear,
			    opts;
			if (validateCallBack && err.error[key]) {
				val = obj = err.error[key].value;
				opts = {
					skipValidation: true
				};
			}
			if (field.type == "relation") {
				ret = this.validateRelatedRecord(record, key, field);
				if (ret === false) {
					result = false;
					return result;
				}
			} else if (field.mandatory && !record.$.error.hasOwnProperty(key) && (val === undefined || val === "" || Array.isArray(val) && val.length === 0)) {
				if (validateCallBack) {
					validationErrors[key] = { code: "ERR02", message: Lyte.errorCodes.ERR02, value: val };
				} else {
					store.$.setRecErr(err, key, { code: "ERR02", message: Lyte.errorCodes.ERR02, value: val });
				}
			} else {
				clear = true;
				if (obj || record.hasOwnProperty(key) && !record.$.error.hasOwnProperty(key)) {
					var _field = field;
					if (!(_field.any && Array.isArray(_field))) {
						_field = [_field];
					}
					var fldLen = _field.length,
					    _ret = true;
					for (var i = 0; i < fldLen; i++) {
						var _fld = _field[i];
						for (var property in _fld) {
							var resp = Lyte.checkProperty(property, val, key, _fld[property], _fld, record, undefined, Lyte.isRecord(record) ? record.$.model._name : undefined);
							if (resp !== true) {
								if (_ret === true) {
									if ((typeof resp === 'undefined' ? 'undefined' : _typeof(resp)) == "object") {
										resp.value = val;
									}
									_ret = resp;
									// store.$.setRecErr(err,key,resp);
									// clear = false;
								}
								//err[field] = resp;
								break;
							}
						}
					}
					if (_ret !== true) {
						if (validateCallBack) {
							validationErrors[key] = _ret;
						} else {
							store.$.setRecErr(err, key, _ret);
						}
						clear = false;
					}
					if (obj && clear) {
						store.$.setData(record.$, key, val, opts);
					}
					if (clear) {
						store.$.clrRecErr(err, key);
					}
				}
			}
		},
		partialData: function partialData(rec, key, pK, type, polymorphicType, partRemoveOnly) {
			var arr = rec[key];
			if (!arr || !Array.isArray(arr)) {
				return true;
			}
			if (!arr.partial) {
				store.$.defPar(arr);
			}
			var partial = arr.partial = arr.partial || new Map();
			if (!partial.get(pK)) {
				partial.set(pK, {});
			}
			var revert = false;
			var obj = partial.get(pK);
			var objType = obj.type;
			switch (objType) {
				case "added":
					{
						if (type == "removed") {
							partial.delete(pK);
							revert = true;
						}
						break;
					}
				case "removed":
					{
						if (type == "added") {
							if (rec[key]._recMap) {
								var relRec = rec[key]._recMap.get(pK);
							}
							if (!relRec || Lyte.isRecord(relRec) && !relRec.$.isDirty()) {
								partial.delete(pK);
								revert = true;
							} else {
								var obj = partial.get(pK);
								obj.type = "modified";
							}
						}
						break;
					}
				case "modified":
				case "updated":
					{
						if (type == "added") {
							//this case mostly won't come. if at all it comes, break
							break;
						}
					}
				default:
					{
						if (!partRemoveOnly) {
							var pObj = { type: type };
							polymorphicType ? pObj.polymorphicType = polymorphicType : undefined;
							partial.set(pK, pObj);
						} else {
							partial.delete(pK);
							revert = true;
						}
					}
			}
			if (revert && !partial.size) {
				if (!partial.size) {
					store.$.deleteDeepNest(rec, key, pK);
				}
				return true;
			}
		},
		removeParentNesting: function removeParentNesting(rec, type, ignorePartial) {
			var model = rec.$.model;
			var pkVal = rec.$.pK;
			var rels = model.relations;
			for (var key in rels) {
				var relations = rels[key];
				relations.forEach(function (item) {
					var inv, deep, part, invRecs;
					//store.$.getRelations(model, item.relKey, store.model[item.relatedTo], rel);
					var bMod = store.model[item.relatedTo];
					if (bMod) {
						inv = store.$.getBackwardRel(model, item, bMod);
						//inv = rel.backward;
						if (inv && inv.opts) {
							deep = inv.opts.deepNest;
							part = inv.opts.hasOwnProperty("serialize");
							if (!item.relKey || item == inv) {
								invRecs = store.$.getRelatedRecord(rec, item.relatedTo, item.dummy ? item.dummy : item.relKey);
							} else {
								invRecs = rec[item.relKey];
							}
						}
						// if(deep){
						// 	if(Array.isArray(invRecs)){
						// 		invRecs.forEach(function(item){
						// 			if(Lyte.isRecord(item)){
						// 				store.$.deleteDeepNest(item, inv.relKey, pkVal);
						// 			}
						// 		});
						// 	}
						// 	else if(Lyte.isRecord(invRecs)){
						// 		store.$.deleteDeepNest(invRecs, inv.relKey, pkVal);
						// 	}
						// }
						if (part && !ignorePartial) {
							if (invRecs && !Array.isArray(invRecs)) {
								invRecs = [invRecs];
							}
							if (Array.isArray(invRecs)) {
								invRecs.forEach(function (invItm) {
									if (inv.relKey) {
										if (inv.relType == "belongsTo" && invItm && invItm.$) {
											if (invItm.$.partial && invItm.$.partial[inv.relKey] && invItm.$.partial[inv.relKey].has(pkVal)) {
												invItm.$.partial[inv.relKey].delete(pkVal);
												if (!invItm.$.partial[inv.relKey].size) {
													delete invItm.$.partial[inv.relKey];
												}
											}
											deep ? store.$.deleteDeepNest(invItm, inv.relKey, pkVal) : undefined;
										} else if (inv.relType == "hasMany") {
											var invArr = invItm[inv.relKey];
											if (Array.isArray(invArr)) {
												if (invArr.partial && invArr.partial.has(pkVal)) {
													var _ptype = invArr.partial.get(pkVal).type;
													if (type == "modified") {
														if (/^(modified|updated)$/.test(_ptype)) {
															invArr.partial.delete(pkVal);
														}
													} else {
														invArr.partial.delete(pkVal);
													}
													// else{
													// 	if(!/^added$/.test(_ptype) && !invItm[inv.relKey]._recMap.get(pkVal)){
													// 		invArr.partial.delete(pkVal);
													// 	}
													// }
												}
												deep ? store.$.deleteDeepNest(invItm, inv.relKey, pkVal) : undefined;
											}
										}
									}
								});
							}

							// if(invRecs && !Array.isArray(invRecs)){
							// 	invRecs=[invRecs];
							// }
							// if(Array.isArray(invRecs)){
							// 	invRecs.forEach(function(item){
							// 		var partData = inv.relKey ? item[inv.relKey] : undefined; 
							// 		if(partData && partData.partial && partData.partial.get(pkVal)){
							// 			var _ptype = partData.partial.get(pkVal).type;
							// 			if(type == "modified"){
							// 				if(/^(modified|updated)$/.test(_ptype)){
							// 					partData.partial.delete(pkVal);
							// 				}
							// 			}
							// 			else{
							// 				partData.partial.delete(pkVal);
							// 			}
							// 		}
							// 	});
							// }	
						}
					}
				});
			}
		},
		deleteDeepNest: function deleteDeepNest(rec, key, pkVal) {
			var deepNest = rec.$.dN;
			if (deepNest) {
				if (deepNest[key] && pkVal === undefined) {
					delete deepNest[key];
				} else if (deepNest[key] && deepNest[key].get(pkVal)) {
					deepNest[key].delete(pkVal);
					if (!deepNest[key].size) {
						delete deepNest[key];
					}
				}
				if (!Object.keys(deepNest).length) {
					delete rec.$.dN;
					if (!rec.$.isModified && !rec.$.isNew) {
						store.$.removeParentNesting(rec);
					}
					store.$.changePersist(rec, true);
				}
			}
		},
		// createJSON:function(record, fields, err, validateOnSave){
		// 	for(var field in fields){
		// 		var val = record[field], fieldKeys = fields[field];
		// 		if(fieldKeys.type == "relation"){
		// 			continue;
		// 		}
		// 		if(!record.$.validatedOnCreate || validateOnSave){
		// 			if(fieldKeys.mandatory && !record.$.error.hasOwnProperty(field) && (val == null || val == undefined || val === "" || (Array.isArray(val) && val.length == 0) )){
		// 					store.$.setRecErr(err,field,{code : "ERR02", message : Lyte.errorCodes.ERR02});
		// 					//err[field] = {code : "ERR02", message : Lyte.errorCodes.ERR02};
		// 			}
		// 			else{
		// 				clear = true;
		// 				if(record.hasOwnProperty(field) && !record.$.error.hasOwnProperty(field)){
		// 					for(var property in fieldKeys){
		// 						var resp = Lyte.checkProperty(property, record[field], field, fieldKeys[property]);
		// 						if(resp != true){
		// 							store.$.setRecErr(err,field,resp);
		// 							clear = false;
		// 							//err[field] = resp;
		// 							break;
		// 						}
		// 					}
		// 					if(clear){
		// 						store.$.clrRecErr(err, field);
		// 					}		
		// 				}
		// 			}							
		// 		}
		// 	}
		// },
		updateJSON: function updateJSON(record, model, dirty) {
			var data = {};
			var arrPk = model._arrPk;
			var dirtyAttr = record.$._attributes;
			for (var field in dirtyAttr) {
				data[field] = record[field];
			}
			var attrs = dirty;
			if (dirty == true) {
				attrs = store.$.isDirty(record, model.relations) || [];
			}
			for (var i = 0; i < attrs.length; i++) {
				data[attrs[i]] = record[attrs[i]];
			}
			arrPk.forEach(function (item) {
				data[item] = record[item];
			});
			return data;
		},
		removeDeepNest: function removeDeepNest(record) {
			if (!Lyte.isRecord(record)) {
				return;
			}
			var bool1 = record.$.dN && Object.keys(record.$.dN).length;
			if (bool1) {
				record.$.dN = {};
				var model = record.$.model;
				var relations = model.relations;
				for (var key in relations) {
					var rels = relations[key];
					rels.forEach(function (item) {
						var opts = item.opts;
						if (opts && (opts.deepNest || opts.serialize == "partial")) {
							var data = record[item.relKey];
							if (Array.isArray(data)) {
								data.forEach(function (itm) {
									if (Lyte.isRecord(itm)) {
										store.$.removeDeepNest(itm);
										if (!itm.$.isNew && !itm.$.isModified && (!itm.$.dN || itm.$.dN && Object.keys(itm.$.dN).length == 0)) {
											store.$.removeParentNesting(itm);
										}
									}
								});
							} else if (Lyte.isRecord(data)) {
								store.$.removeDeepNest(data);
								if (!data.$.isNew && !data.$.isModified && (!data.$.dN || data.$.dN && Object.keys(data.$.dN).length == 0)) {
									store.$.removeParentNesting(data);
								}
							}
						}
					});
				}
			}
		},
		addDeepNest: function addDeepNest(record, extended, type, ignoreRel, mp, processOnlySrzPart) {
			var relatedRecord,
			    mp = mp || new Map(),
			    model = extended ? store.model[record.$.model.extend] : record.$.model,
			    pK = record.$.pK,
			    type = type || "updated",
			    relations = model.relations;
			for (var key in relations) {
				var rels = relations[key];
				rels.forEach(function (item) {
					var inv,
					    deep,
					    part,
					    serz,
					    bMod = store.model[item.relatedTo];
					if (bMod) {
						inv = store.$.getBackwardRel(model, item, bMod);
						if (!item.relKey || inv === item) {
							relatedRecord = store.$.getRelatedRecord(record, item.relatedTo, item.dummy ? item.dummy : item.relKey);
						} else {
							relatedRecord = record[item.relKey];
						}
						if (relatedRecord) {
							var mppass = false,
							    nmp,
							    ignoreDn;
							if (!mp.get(inv)) {
								var nmp = mp.set(inv, new Map());
								mppass = true;
							}
							nmp = mp.get(inv);
							if (mppass || !nmp.get(relatedRecord)) {
								nmp.set(relatedRecord, true);
								if (inv && inv.opts) {
									deep = inv.opts.deepNest;
									part = inv.opts.serialize == "partial" ? true : false;
									serz = inv.opts.serialize ? inv.opts.serialize : false;
								}
								if (type == "updated" && serz == "id") {
									ignoreDn = true;
								}
								if ((!processOnlySrzPart || processOnlySrzPart && part) && !ignoreDn) {
									if (deep) {
										//					if(deep || part){
										store.$.makeDirty("dirty", relatedRecord, type, inv, pK, mp);
									}
									if (serz && record && relatedRecord && (!ignoreRel || !(ignoreRel && ignoreRel.model === item.relatedTo && inv.relKey === ignoreRel.relKey))) {
										var data = relatedRecord;
										if (inv.relType == "hasMany") {
											if (Array.isArray(data)) {
												data.forEach(function (item) {
													store.$.partialData(item, inv.relKey, pK, /^(added|removed)$/.test(type) ? type : "modified");
												});
											} else if (Lyte.isRecord(data)) {
												store.$.partialData(data, inv.relKey, pK, /^(added|removed)$/.test(type) ? type : "modified");
											}
										} else {
											if (Array.isArray(data)) {
												data.forEach(function (item) {
													if (type == "added" && item && item.$ && item.$.partial && item.$.partial[inv.relKey] && item.$.partial[inv.relKey].has(pK)) {
														delete item.$.partial;
													}
												});
											} else if (Lyte.isRecord(data)) {
												if (type == "added" && data && data.$ && data.$.partial && data.$.partial[inv.relKey] && data.$.partial[inv.relKey].has(pK)) {
													delete data.$.partial;
												}
											}
										}
										//store.$.partialData(record[item.relKey], inv.relKey, pK , "modified");
									}
								}
							}
						}
					}
				});
			}
			if (model.extend) {
				this.addDeepNest(record, true);
			}
		},
		getRelatedRecord: function getRelatedRecord(record, modelName, key) {
			if (record) {
				var relationship = record.$._relationships;
				if (relationship[modelName] && relationship[modelName][key]) {
					return relationship[modelName][key];
				}
			}
		},
		makeDirty: function makeDirty(name, records, type, rel, pK, mp) {
			if (!(rel.opts.serialize == 'id' && type == "updated")) {
				var relKey = rel.relKey;
				if (Array.isArray(records)) {
					records.forEach(function (item) {
						store.$.setDeepNest(item, relKey, pK, type, mp);
					});
				} else if (Lyte.isRecord(records)) {
					store.$.setDeepNest(records, relKey, pK, type, mp);
				}
			}
		},
		setDeepNest: function setDeepNest(item, relKey, pK, type, mp) {
			var deepN = item.$.dN = item.$.dN || {};
			var deepRel = deepN[relKey] = deepN[relKey] || new Map();
			if (!deepRel.has(pK)) {
				deepRel.set(pK, {});
			}
			var obj = deepRel.get(pK);
			switch (obj.type) {
				case "added":
					{
						if (type == "removed") {
							store.$.deleteDeepNest(item, relKey, pK);
						}
						break;
					}
				case "removed":
					{
						if (type == "added") {
							store.$.deleteDeepNest(item, relKey, pK);
						}
						if (type == "modified") {
							obj.type = "updated";
						}
						break;
					}
				default:
					{
						obj.type = type;
						store.$.changePersist(item, false);
						store.$.addDeepNest(item, undefined, undefined, undefined, mp);
					}
			}
		},
		isDirty: function isDirty(record, relations, parent, fMod) {
			var result = [];
			for (var rel in relations) {
				var rel_model = relations[rel];
				for (var j = 0; j < rel_model.length; j++) {
					var rel = rel_model[j];
					if (rel.opts && rel.opts.serialize) {
						var key = rel.relKey,
						    type = rel.relType,
						    records = record[key],
						    bMod = store.model[rel.relatedTo];
						if (parent && bMod) {
							var child = store.$.getBackwardRel(fMod, rel, store.model[rel.relatedTo]);
							if (parent == child && fMod._name != rel.relatedTo) {
								continue;
							}
						}
						if (rel.opts.serialize == "record") {
							var res = store.$.isRelDirty(rel, records, rel);
							if (res) {
								result.push(key);
								continue;
							}
						} else if (rel.opts.serialize == "partial") {
							if (type == "hasMany") {
								if (records && records.partial && records.partial.size) {
									result.push(key);
									continue;
								}
							} else {
								if (Lyte.isRecord(records) && records.$.isModified || record && record.$ && record.$.partial && record.$.partial.hasOwnProperty(key)) {
									result.push(key);
									continue;
								}
							}
						}
						if (rel.opts.deepNest) {
							if (record.$.dN && record.$.dN[key]) {
								result.push(key);
							}
						}
					}
				}
			}
			return result;
		},
		isRelDirty: function isRelDirty(rel, records, parent) {
			var type = rel.relType;
			var fMod = store.model[rel.relatedTo];
			var relations = fMod.relations;
			if (!store.$.isEmpty(records)) {
				if (type == "hasMany" && Array.isArray(records) && records.length) {
					var len = records.length;
					for (var i = 0; i < len; i++) {
						if (records[i].$.isModified == true) {
							return true;
						}
					}
					for (var j = 0; j < len; j++) {
						var rec = records[j];
						var arr = this.isDirty(rec, relations, parent, fMod);
						if (arr.length) {
							return true;
						}
					}
				} else if (type == "belongsTo" && Lyte.isRecord(records)) {
					if (records.$.isModified == true) {
						return true;
					}
					var arr = this.isDirty(records, relations, parent, fMod);
					if (arr.length) {
						return true;
					}
				}
			}
			return false;
		},
		handleCachedResponse: function handleCachedResponse(batch, resp) {
			var cached = store.$.cachedBatch = store.$.cachedBatch || {};
			var arr = cached[batch] || [],
			    count = 0;
			arr.forEach(function (item, index) {
				resp.splice(item.ind + count++, 0, item.data);
			});
			delete cached[batch];
			return resp;
		},
		addToCachedBatch: function addToCachedBatch(data) {
			var curr = store.$.currentBatch;
			var cached = store.$.cachedBatch = store.$.cachedBatch || {};
			var cachedB = cached[curr] = cached[curr] || [];
			var arr = store.$.batch[curr] || [];
			var ind = arr.length;
			cachedB.push({ ind: ind, data: data });
		},
		establishToRelated: function establishToRelated(record, relArr) {
			var bModel = record.$.model,
			    rel = {};
			relArr.forEach(function (item) {
				var rec = store.$.peekRecord(item.model, item.pkVal);
				if (rec) {
					var fModel = rec.$.model;
					store.$.getRelations(fModel, item.key, bModel, rel);
					store.$.establishLink(rel.forward, rel.backward, rec, record, undefined, true);
				}
			});
		},
		checkObjAndAddToArr: function checkObjAndAddToArr(arr, obj, keys) {
			var len = Object.keys(keys).length,
			    res = -1,
			    arrLen = arr.length;
			for (var k = 0; k < arrLen; k++) {
				var item = arr[k];
				var i = 0;
				for (var key in keys) {
					if (item[key] == obj[key]) {
						i++;
					}
				}
				if (i == len) {
					res = k;
					arr.splice(k, 1, obj);
					return;
				}
			}
			if (res == -1) {
				arr.push(obj);
			}
			return res;
		},
		addToRelate: function addToRelate(modelName, data, rel, key) {
			var relMod = rel.forward.relatedTo;
			var toRelMod = store.$.toRelate[relMod] = store.$.toRelate[relMod] || new Map();
			if (!toRelMod.has(key)) {
				toRelMod.set(key, []);
			}
			var toRel = toRelMod.get(key);
			var pkVal = data.$.pK;
			var obj = { model: modelName, pkVal: pkVal, key: rel.forward.relKey };
			toRel.push(obj);
			// this.checkObjAndAddToArr(toRel, obj, ["record","key"]);
		},
		addOnSave: function addOnSave(modelName, record, attr, field, pK, relPk) {
			store.$.onSave = store.$.onSave || {};
			var saveMod = store.$.onSave[modelName] = store.$.onSave[modelName] || {};
			var saveQ = saveMod[record[pK]] = saveMod[record[pK]] || {};
			var recs = record[attr] || [];
			if (field.relType == "belongsTo") {
				recs = !Array.isArray(record[attr]) ? [record[attr]] : record[attr];
			}
			recs.forEach(function (item) {
				var q = saveQ[field.relKey] = saveQ[field.relKey] || [];
				store.$.checkAndAddToArray(q, item[relPk]);
			});
		},
		addToIDBonSave: function addToIDBonSave(modelName, rec) {
			var model = store.model[modelName];
			var fields = model.fieldList;
			var saveMod = store.$.onSave ? store.$.onSave[modelName] : undefined;
			if (saveMod) {
				var pK = store.model[modelName]._pK;
				var saveQ = rec && pK ? saveMod[rec[pK]] : undefined;
				if (saveQ) {
					for (var key in saveQ) {
						var ids = saveQ[key];
						var relMod = fields[key].relatedTo;
						ids.forEach(function (item) {
							var rec = store.$.peekRecord(relMod, item);
							if (rec) {
								var parent = rec.$.parent;
								if (Lyte.isRecord(parent)) {
									var mod = parent.$.model;
									var modName = mod._name;
									var modPk = mod._pK;
									store.$.checkAndAddToIDBQ(modName, "updateRecord", store.$.peekRecord(modName, parent[modPk]).$.toJSON(true));
								} else {
									store.$.checkAndAddToIDBQ(relMod, "updateRecord", store.$.peekRecord(relMod, item).$.toJSON(true));
								}
							}
						});
					}
					store.$.removeOnSave(modelName, rec[pK]);
				}
			}
		},
		removeOnSave: function removeOnSave(modelName, pkVal) {
			var saveMod = store.$.onSave ? store.$.onSave[modelName] : undefined;
			if (saveMod && saveMod[pkVal]) {
				delete saveMod[pkVal];
			}
		},
		checkAndAddToIDBQ: function checkAndAddToIDBQ(modelName, type, data) {
			var obj = { model: modelName, type: type, data: data };
			var q = store.$.idbQ2[modelName] = store.$.idbQ2[modelName] || [];
			q.push(obj);
		},
		checkAndRemoveKey: function checkAndRemoveKey(rawData, fields, deserializeKeys) {
			for (var key in rawData) {
				var field = fields[key];
				if (field && field.type == "relation") {
					if (deserializeKeys && !this.checkPresenceInArray(deserializeKeys, key)) {
						delete rawData[key];
					} else {
						this.removeNotNeededKeys(field.relatedTo, rawData[key]);
					}
				}
			}
		},
		removeNotNeededKeys: function removeNotNeededKeys(modelName, rawData, idbObj) {
			var model = store.model[modelName];
			var fields = model.fieldList;
			var deserializeKeys = idbObj ? idbObj.deserializeKeys : undefined;
			if (model) {
				var self = this;
				if (Array.isArray(rawData)) {
					rawData.forEach(function (item) {
						self.checkAndRemoveKey(item, fields, deserializeKeys);
					});
				} else {
					this.checkAndRemoveKey(rawData, fields, deserializeKeys);
				}
			}
			return rawData;
		},
		getIDBObj: function getIDBObj(model, queryParams, type, key, customData, modelName) {
			if (model && model.hasOwnProperty('idb')) {
				if (typeof model.idb == "function") {
					return model.idb.apply(model, [{ model: modelName ? modelName : model._name, type: type, queryParams: queryParams, key: key, customData: customData }]);
				}
				return model.idb;
			}
		},
		idbQ2Push: function idbQ2Push(modelName, rawData, queryParams, type, key, meta, customData) {
			try {
				var model = store.model[modelName],
				    idb = store.$.getIDBObj(model, queryParams, type, key, customData);
				if (idb) {
					// if(type !== "pushPayload"){
					// 	rawData = Lyte.deepCopyObject(rawData);
					// }
					var qObj = { model: modelName, type: type, customData: customData };
					qObj.queryCache = idb.queryCache;
					var pK = model._pK;
					var q = store.$.idbQ2[modelName] = store.$.idbQ2[modelName] || [];
					switch (type) {
						case "action":
							{
								delete q[type];
								return;
							}
						case "update":
						case "create":
							{
								qObj.data = [];
								rawData.forEach(function (item) {
									qObj.data.push(Lyte.isRecord(item) ? item.$.toJSON(undefined, true) : item);
								});
								break;
							}
						case "updateRecord":
						case "createRecord":
							{
								qObj.data = rawData;
								break;
							}
						case "delete":
							{
								qObj.data = rawData;
								break;
							}
						case "destroyRecord":
						case "deleteRecord":
							{
								qObj.id = rawData;
								break;
							}
						case "findRecord":
							qObj.key = key;
							var newRawData = rawData[0].$.toJSON("idb");
							var nObj = {};
							nObj[modelName] = newRawData;
							if (meta) {
								nObj.meta = meta;
							}
							if (idb.queryCache === true) {
								qObj.queryParams = queryParams;
							}
							qObj.data = nObj;
							break;
						case "findAll":
							{
								var newRawData = [];
								rawData.forEach(function (itm) {
									newRawData.push(itm.$.toJSON("idb"));
								});
								var nObj = {};
								nObj[modelName] = newRawData;
								if (meta) {
									nObj.meta = meta;
								}
								// rawData[modelName] = this.removeNotNeededKeys(modelName, rawData[modelName], idb);
								if (idb.queryCache === true) {
									qObj.queryParams = queryParams;
								}
								qObj.data = nObj;
								break;
							}
						case "pushPayload":
							{
								if (Lyte.isRecord(rawData)) {
									rawData = rawData.$.toJSON("idb");
								}
								// rawData = this.removeNotNeededKeys(modelName, rawData, idb);
								qObj.data = rawData;
								break;
							}
					}
					q.push(qObj);
				}
			} catch (err) {
				Lyte.error("Error while adding to IDBQueue ", err);
			}
		},
		isEmpty: function isEmpty(val) {
			if (val != undefined && val !== "" && val != null) {
				return false;
			}
			return true;
		},
		isEmptyObj: function isEmptyObj(obj) {
			if (obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == "object" && Object.keys(obj).length == 0) {
				return true;
			}
			return false;
		},
		isEmptyArray: function isEmptyArray(arr) {
			if (Array.isArray(arr) && arr.length == 0) {
				return true;
			}
			return false;
		},
		registerField: function registerField(model, key, field, obs) {
			var oldField = model.fieldList[key] ? Object.assign({}, model.fieldList[key]) : undefined;
			if (field.type == "observer") {
				obs.push(field);
			} else if (field.type == "callBack") {
				if (field.observes) {
					obs.push(field.observes);
				}
				var props = field.properties;
				for (var i = 0; i < props.length; i++) {
					if (props[i] === "didLoad" || props[i] === "init") {
						if (!model.didLoad) {
							model.didLoad = [];
						}
						model.didLoad.push(field.value);
					} else if (props[i] === "add" || props[i] === "change") {
						model.on(props[i], field.value);
					}
				}
				if (key == "didLoad") {
					if (!model.didLoad) {
						model.didLoad = [];
					}
					model.didLoad.push(field.value);
				}
			} else if (key == "didLoad") {
				if (!model.didLoad) {
					model.didLoad = [];
				}
				model.didLoad.push(field);
			} else if (Object.keys(field).length) {
				if (field.primaryKey) {
					if (model.fieldList.id && model.fieldList.id.defined == false) {
						delete model.fieldList.id;
					}
					if (field.hasOwnProperty("default")) {
						Lyte.warn("LD23", model._name, key);
						delete field.default;
					}
					if (model._pK != undefined) {
						model._pK = model._pK + "," + key;
						model.isComposite = true;
					} else {
						model._pK = key;
					}
					if (field.baseKey) {
						if (model.bK) {
							Lyte.warn("LD26");
							return;
						}
						model.bK = key;
					}
				}
				if (model.fieldList.hasOwnProperty(key)) {
					var alrPresent = true;
				}
				model.fieldList[key] = field;
				if (oldField && model._fldGrps) {
					if (oldField.hasOwnProperty("default")) {
						delete model._fldGrps.default[key];
					}
					if (oldField.hasOwnProperty("watch")) {
						delete model._fldGrps.watch[key];
					}
					if (oldField.opts && oldField.opts.hasOwnProperty("inherit")) {
						delete model._fldGrps.inherit[key];
					}
					// if(oldField.hasOwnProperty("deprecate")){
					// 	delete model._fldGrps.deprecate[key]
					// }
				}
				if (field.hasOwnProperty("default")) {
					model._fldGrps.default[key] = field;
				}
				if (field && field.opts && field.opts.hasOwnProperty("inherit")) {
					model._fldGrps.inherit[key] = field;
				}
				if (field.hasOwnProperty("watch") && (field.watch == true || Array.isArray(field.watch)) && /^(array|object)$/.test(field.type)) {
					model._fldGrps.watch[key] = field;
				}
				if (Lyte.Transform[field.type]) {
					var customDatatype = Lyte.Transform[field.type];
					if (/^(array|object)$/.test(customDatatype.extends) && customDatatype.hasOwnProperty("properties") || customDatatype.hasOwnProperty("items")) {
						model._fldGrps.nested_prop[key] = field;
					}
				}
				// if(field.hasOwnProperty("deprecate")){
				// 	model._fldGrps.deprecate[key] = field;
				// }	
			}
			if (field.type === "relation") {
				field.relKey = key;
				var relTo = field.relatedTo;
				var relObj = model.fieldList[key];
				if (!model.relations[relTo]) {
					model.relations[relTo] = [];
				}
				var chkObj = {};
				chkObj.relKey = relObj.relKey;
				store.$.checkObjAndAddToArr(model.relations[field.relatedTo], relObj, chkObj);
				if (field.relType == "hasMany") {
					model._fldGrps.hasMany[key] = field;
				}
				if (field.hasOwnProperty("opts") && field.opts.hasOwnProperty("inverse")) {
					model._fldGrps.inverse[relTo] = field;
				}
			}
		},
		setError: function setError(err, attr, codeObj) {
			if (err.$.hasOwnProperty("error")) {
				if (Array.isArray(attr)) {
					attr.forEach(function (itm) {
						store.$.cmpSet(err.$.error, itm, codeObj);
					});
				} else {
					store.$.cmpSet(err.$.error, attr, codeObj);
				}
			} else {
				Lyte.error("LD03", err, attr);
			}
		},
		unRegCb: function unRegCb(type, name) {
			var callback = store[type][name];
			if (!callback) {
				Lyte.error("LD02", type, name);
				return;
			}
			var extendedBy = callback.__extendedBy;
			if (extendedBy.length) {
				store[type].__toAddSuper = store[type].__toAddSuper || {};
				if (!store[type].__toAddSuper[name]) {
					store[type].__toAddSuper[name] = extendedBy.slice();
				} else {
					extendedBy.forEach(function (item) {
						store[type].__toAddSuper[name].push(item);
					});
				}
				extendedBy.forEach(function (item) {
					store[type][item].$super = undefined;
				});
				if (store[type].application && name != "application") {
					var application = store[type].application;
					extendedBy.forEach(function (item) {
						store[type][item].$super = application;
						store[type].application.__extendedBy.push(item);
					});
				}
				if (!store[type].application) {
					if (!store[type].__toAddSuper.application) {
						store[type].__toAddSuper.application = extendedBy.slice();
					} else {
						extendedBy.forEach(function (item) {
							store[type].__toAddSuper.application.push(item);
						});
					}
				}
			}
			if (callback.$super) {
				callback.$super.__extendedBy.splice(callback.$super.__extendedBy.indexOf(name), 1);
			}
			delete store[type][name];
		},
		eventListeners: {
			add: function add(scope, type, func) {
				scope.events = scope.events || {};
				scope.events[type] = scope.events[type] || [];
				scope.events[type].push({ f: func });
				return type + "-" + (scope.events[type].length - 1);
			},
			remove: function remove(scope, id) {
				var type;
				if (id) {
					if (/^(add|remove|change)$/.test(id)) {
						type = id;
						scope.events && scope.events[type] ? delete scope.events[type] : undefined;
					} else {
						var arr = id ? id.split("-") : undefined;
						if (arr) {
							var listeners = scope.events[arr[0]];
							if (listeners && arr[1]) {
								listeners[arr[1]] = null;
							}
						}
					}
				} else {
					var ev = scope.events;
					for (var evType in ev) {
						ev && ev[evType] ? delete ev[evType] : undefined;
					}
				}
			},
			emit: function emit(scope, type, args) {
				var listeners = scope.events && scope.events[type] ? scope.events[type] : [];
				for (var i = 0; i < listeners.length; i++) {
					listeners[i] ? listeners[i].f.apply(null, args) : undefined;
				}
			}
		},
		extendCallback: function extendCallback(scope, type, parent) {
			var callback = scope[type],
			    addsuper;
			var res;
			if (parent && typeof parent === "string") {
				res = callback[parent];
				if (!res) {
					callback.__toAddSuper = callback.__toAddSuper || {};
					if (!callback.__toAddSuper.hasOwnProperty(parent)) {
						callback.__toAddSuper[parent] = [];
					}
					callback.__toAddSuper[parent].push(this.__name);
				}
			}
			if (res && res.is == type && (!this.$super || this.$super.__name == "application")) {
				this.$super = res;
				res.__extendedBy.push(this.__name);
				if (callback.application) {
					var application_extarr = callback.application.__extendedBy;
					var index = application_extarr.indexOf(this.__name);
					if (index > -1) {
						callback.application.__extendedBy.splice(index, 1);
					}
				}
				addsuper = callback.__toAddSuper;
				if (addsuper) {
					if (addsuper.application) {
						var addsuper_arr = addsuper.application;
						var index1 = addsuper_arr.indexOf(this.__name);
						if (index1 > -1) {
							callback.__toAddSuper.application.splice(index1, 1);
						}
					}
				}
			}
			return this;
		},
		super: function _super() {
			// console.log(arguments);
			var scope = this,
			    parent = this.$super,
			    name = arguments[0][0][arguments[0][0].length - 1],
			    arr = [],
			    arg = arguments[0][0];
			var parent_type = parent[name];
			if (typeof parent_type == "function") {
				delete arg[arg.length - 1];
				for (var key in arg) {
					if (arg.hasOwnProperty(key)) {
						arr.push(arg[key]);
					}
				}
				return parent_type.apply(parent, arr);
			}
			if (parent_type) {
				return parent_type;
			}
		},
		extendModel: function extendModel(extend, mdl) {
			var scp = mdl || this;
			if (!extend || !store.model[extend]) {
				return;
			}
			var parentFields = Object.assign({}, store.model[extend].fieldList);
			for (var key in parentFields) {
				if (parentFields[key].type == "relation") {
					delete parentFields[key];
				}
			}
			var pkObj = {};
			var extendParentPks = scp._pK == "id" && scp.fieldList.id.defined == false ? true : false;
			for (var key in parentFields) {
				var fld = parentFields[key];
				var custPk = extendParentPks && fld.primaryKey && fld.defined != false;
				if (scp.fieldList.hasOwnProperty(key) && scp._fldGrps) {
					var oldField = scp.fieldList[key];
					if (oldField.hasOwnProperty("default")) {
						delete scp._fldGrps.default[key];
					}
					if (oldField.hasOwnProperty("watch")) {
						delete scp._fldGrps.watch[key];
					}
				}
				if (fld.hasOwnProperty("default")) {
					scp._fldGrps.default[key] = fld;
				}
				if (fld.hasOwnProperty("watch") && fld.watch == true && /^(array|object)$/.test(fld.type)) {
					scp._fldGrps.watch[key] = fld;
				}
				if (!fld.primaryKey) {
					scp.fieldList[key] = fld;
				} else {
					pkObj[key] = fld;
				}
			}
			var pkObjKeys = Object.keys(pkObj),
			    pkObjLen = pkObjKeys.length;
			if (extendParentPks && pkObjLen) {
				delete scp.fieldList.id;
				for (var key in pkObj) {
					scp.fieldList[key] = pkObj[key];
				}
				if (pkObjLen == 1) {
					scp._pK = pkObjKeys[0];
					scp._arrPk = Array.from(pkObjKeys);
				} else {
					scp.isComp = true;
					scp._arrPk = Array.from(pkObjKeys);
					scp._pK = scp._arrPk.toString();
				}
			}
			var name = scp._name;
			store.model[name].extend = extend;
			store.model[extend].extendedBy = store.model[extend].extendedBy || {};
			store.model[extend].extendedBy[name] = true;
			// if(!store.adapter[name] && store.adapter[extend]){
			// 	store.adapter[name] = store.adapter[extend];
			// }
			// if(!store.serializer[name] && store.serializer[extend]){
			// 	store.serializer[name] = store.serializer[extend];
			// }
			if (store.model[extend].actions) {
				var actions = scp.actions = scp.actions || {};
				for (var key in store.model[extend].actions) {
					if (!actions.hasOwnProperty(key)) {
						actions[key] = store.model[extend].actions[key];
					}
				}
			}
		},
		demoLishObserverBindings: function demoLishObserverBindings(obj, prop, record) {
			if (!record) {
				record = obj;
			}
			for (key in prop) {
				if (obj[key] instanceof Object) {
					if (record && obj[key]._setterScope) {
						var ind = obj[key]._setterScope.indexOf(record);
						ind != -1 ? obj[key]._setterScope.splice(ind, 1) : undefined;
					}
					if (Object.keys(prop[key]).length) {
						this.demoLishObserverBindings(obj[key], prop[key], obj);
					}
				}
				if (obj._setterScope && obj != record) {
					var inx = obj._setterScope.indexOf(record);
					inx != -1 ? obj._setterScope.splice(inx, 1) : undefined;
				}
			}
		},
		establishObserverBindings: function establishObserverBindings(obj, prop, record) {
			if (!record) {
				record = obj;
			}
			for (key in prop) {
				if (obj[key] instanceof Object) {
					if (!obj[key]._bindings) {
						store.$.defProp(obj[key], '_bindings', new Set(), false, true);
					}
					if (record && !obj[key]._setterScope) {
						store.$.defProp(obj[key], '_setterScope', []);
					}
					var ind = obj[key]._setterScope.indexOf(record);
					ind == -1 ? obj[key]._setterScope.push(record) : undefined;
					obj[key]._bindings.add(prop[key]);
					if (Object.keys(prop[key]).length) {
						this.establishObserverBindings(obj[key], prop[key], obj);
					}
				}
				if (!obj._setterScope) {
					store.$.defProp(obj, '_setterScope', []);
					obj._setterScope.push(obj);
				}
			}
		},
		setData: function setData(self, attr, value, opts, redoObj, ignoreChange, inherit, oldDN) {
			var toEmit = { emit: false, attr: [], oldRec: {} };
			var model = self.model,
			    _estObsBind = false,
			    record = self.record,
			    attrData;
			if (inherit && attr) {
				var mfl = self.model._fldGrps.inherit;
				for (var v in mfl) {
					if (self.record[mfl[v].relKey] && attr[mfl[v].relKey]) {
						if (mfl[v].relType == "belongsTo") {
							self.model._arrPk.forEach(function (_key) {
								delete attr[mfl[v].relKey][_key];
							});
							this.setData(self.record[mfl[v].relKey].$, attr[mfl[v].relKey], undefined, undefined, undefined, ignoreChange, true);
							attr[mfl[v].relKey] = self.record[mfl[v].relKey].$.pK;
						} else {
							var len = attr[mfl[v].relKey].length;
							for (var j = len - 1; j >= 0; j--) {
								self.model._arrPk.forEach(function (_key) {
									delete attr[mfl[v].relKey][j][_key];
								});
								this.setData(self.record[mfl[v].relKey][j].$, attr[mfl[v].relKey][j], undefined, undefined, undefined, ignoreChange, true);
								attr[mfl[v].relKey][j] = self.record[mfl[v].relKey][j].$.pK;
							}
						}
						//delete attr[mfl[v].relKey];
					}
				}
			}
			if (attr && (typeof attr === 'undefined' ? 'undefined' : _typeof(attr)) === "object") {
				attrData = [];
				opts = value;
				for (var key in attr) {
					attrData.push(key);
					this.setValue(self, key, attr[key], opts, toEmit, ignoreChange, undefined, oldDN);
					model && model._properties && model._properties.hasOwnProperty(key) ? _estObsBind = true : undefined;
				}
			} else {
				attrData = attr;
				this.setValue(self, attr, value, opts, toEmit, ignoreChange);
				model && model._properties && model._properties.hasOwnProperty(attr) ? _estObsBind = true : undefined;
			}
			self.emit("set", [self.record, attrData]);
			self.model.emit("set", [model._name, self.record, attrData]);
			store.emit("set", [model._name, self.record, attrData]);
			if (_estObsBind) {
				store.$.establishObserverBindings(record, model._properties);
			}
			if (!ignoreChange && toEmit.emit) {
				store.$.changeCallbck(record, toEmit, redoObj);
			}
			return record;
		},
		changeCallbck: function changeCallbck(record, toEmit, redoObj) {
			var arr = [record, toEmit.attr];
			var self = record.$;
			self.emit("change", arr);
			self.model.emit("change", arr);
			store.emit("change", [self.model._name, self.record, toEmit.attr]);
			if (redoObj) {
				for (var key in toEmit.oldRec) {
					redoObj[key] = toEmit.oldRec[key];
				}
			} else {
				for (var index = 0; index < toEmit.attr.length; index++) {
					var key = toEmit.attr[index];
					self.undoStack[key] = self.undoStack[key] || [];
					self.undoStack[key].push(toEmit.oldRec[key]);
				}
				// self.undoStack._order_ = self.undoStack._order_ || store.$.defProp(self.undoStack, "_order_", [], false, true);
				self.undoStack._order_.push(toEmit.attr);
			}
		},
		setValue: function setValue(self, attr, value, opts, toEmit, ignoreChange, deepChange, oldDN) {
			var model = self.model,
			    oldAttrVal,
			    hasAttr,
			    pK = model._pK,
			    record = self.record;
			if (attr != model._pK) {
				var field = model.fieldList[attr],
				    watch = field && field.opts ? field.opts.watch == true : undefined;
				var hasAttr = record.hasOwnProperty(attr),
				    oldAttrVal = record[attr];
				if (!field) {
					store.$.cmpSet(record, attr, value, undefined, true);
					return;
				} else if (field.mandatory && (value == undefined || value == null || value === "")) {
					store.$.setRecErr(self, attr, { code: "ERR02", message: Lyte.errorCodes.ERR02, value: value });
				} else if (field.relType) {
					var relType = field.relType;
					var rel = {},
					    relRec,
					    oldVal,
					    relMod = store.modelFor(field.relatedTo),
					    bModel = relMod,
					    bPk = bModel._pK,
					    relPk = relMod._pK,
					    isComp = relMod.isComp,
					    bPkType = isComp ? "object" : relMod.fieldList[bPk].type,
					    relRec;
					var isComp = relMod.isComp,
					    bPk = relMod._pK,
					    bPkType = isComp ? "object" : relMod.fieldList[bPk].type,
					    isPoly = field && field.opts ? field.opts.polymorphic : undefined;
					this.getRelations(model, field.relKey, relMod, rel);
					if (record[attr] && relType == "hasMany") {
						oldVal = [];
						record[attr].forEach(function (item) {
							oldVal.push(item.$.pK);
						});
						if (record[attr] === value) {
							return;
						}
						if (Array.isArray(value) && value.length === record[attr].length) {
							var valLen = value.length,
							    j = 0,
							    val;
							for (var i = 0; i < valLen; i++) {
								val = value[i];
								if (Lyte.isRecord(val)) {
									relRec = val;
								} else {
									if (val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == bPkType) {
										relRec = store.$.peekRecord(val._type ? val._type : field.relatedTo, val);
									} else if (val && (isComp || isPoly && val._type)) {
										relRec = store.$.peekRecord(val._type ? val._type : field.relatedTo, store.$.getpKVal(val, store.modelFor(val._type ? val._type : field.relatedTo)));
									}
								}
								if (Lyte.isRecord(relRec) && relRec.$.record === record[attr][i]) {
									j++;
								} else {
									break;
								}
							}
							if (j && j == valLen) {
								// if(oldDN && oldDN[attr]){
								// 	if(record.$.dN == undefined){
								// 		record.$.dN = {};
								// 	}
								// 	record.$.dN[attr]=oldDN[attr];
								// }
								return;
							}
						}
						// oldVal = record[attr].slice(0);
						// oldVal1 = record[attr].mapBy(relMod._pK);
						store.$.addOnSave(model._name, record, attr, field, pK, relPk);
						var relData = Array.from(record[attr]);
						relData.forEach(function (rec) {
							store.$.demolishLink(rec, relPk, record, rel.forward.relKey, undefined, undefined, undefined, true);
							if (rel.backward !== null) {
								store.$.demolishLink(record, model._pK, rec, rel.backward.relKey, rel.forward);
							}
						});
						// // record[attr].splice(0, record[attr].length);
						// if(Array.isArray(record[attr]) && record[attr].length){
						// 	this.handleArrOp(record[attr], "removeAt", undefined, 0, record[attr].length);
						// }
					} else if (record[attr] && Lyte.isRecord(record[attr]) && relType == "belongsTo") {
						oldVal = record[attr].$.pK;
						if (Lyte.isRecord(value)) {
							relRec = value;
						} else {
							if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == bPkType) {
								relRec = store.$.peekRecord(value._type ? value._type : field.relatedTo, value);
							} else if (value && (isComp || isPoly && value._type)) {
								relRec = store.$.peekRecord(value._type ? value._type : field.relatedTo, store.$.getpKVal(value, store.modelFor(value._type ? value._type : field.relatedTo)));
							}
						}
						if (Lyte.isRecord(relRec) && relRec.$.record === record[attr]) {
							// if(oldDN && oldDN[attr]){
							// 	if(record.$.dN == undefined){
							// 		record.$.dN = {};
							// 	}
							// 	record.$.dN[attr]=oldDN[attr];
							// }
							return;
						}
						// oldVal = this.createCopy(record[attr]);
						store.$.addOnSave(model._name, record, attr, field, pK, relPk);
						// oldVal1 = record[attr][relMod._pK];
						var relRef = record[attr];
						store.$.demolishLink(relRef, relPk, record, rel.forward.relKey, undefined, undefined, undefined, true);
						if (rel.backward !== null) {
							store.$.demolishLink(record, model._pK, relRef, rel.backward.relKey, rel.forward);
						}
						// record[attr] = undefined;
						store.$.cmpSet(record, attr, {}, opts, true);
					}
					if (relType == "hasMany" && store.$.isEmpty(value)) {
						var partial = record[attr] && record[attr].partial ? record[attr].partial : undefined;
						store.$.cmpSet(record, attr, [], opts, true);
						partial ? store.$.defProp(record[attr], "partial", partial) : undefined;
						store.$.establishObserverBindings(record, record.$.model._properties);
						store.$.defArrUtls(record[attr]);
						store.$.defPolyUtls(record[attr]);
						store.$.defUtls(record[attr], relMod, record, attr);
					}
					if (!Array.isArray(value)) {
						value = [value];
					} else if (relType == "belongsTo") {
						this.revertToOldVal(record, attr, oldVal, rel);
						store.$.setRecErr(self, attr, "ERR21", value);
						return;
					}
					var err = [];
					for (var i = 0; i < value.length; i++) {
						if (this.isEmpty(value[i]) || relType == "belongsTo" && this.isEmptyObj(value[i]) || relType == "hasMany" && this.isEmptyArray(value[i])) {
							continue;
						}
						var relRecord = value[i],
						    relMod1 = value[i] && value[i]._type ? value[i]._type : field.relatedTo;
						if (!isComp && value[i] && _typeof(value[i]) === bPkType) {
							relRecord = store.$.peekRecord(value[i]._type ? value[i]._type : field.relatedTo, value[i]);
							if (relRecord == undefined) {
								this.addToRelate(model._name, record, rel, value[i]);
							} else if (relRecord.$ && relRecord.$.isError) {
								err.push({ code: "ERR15", message: Lyte.errorCodes.ERR15, error: Object.assign({}, relRecord) });
								continue;
							}
						} else if (value[i] && _typeof(value[i]) == "object") {
							if (relRecord.$ && relRecord.$.isError) {
								err.push({ code: "ERR15", message: Lyte.errorCodes.ERR15, error: Object.assign({}, relRecord) });
								continue;
							} else if (!Lyte.isRecord(relRecord)) {
								if (isPoly && value[i] && value[i]._type) {
									relRecord = store.$.peekRecord(value[i]._type, store.$.getpKVal(value[i], store.modelFor(value[i]._type)));
								} else if (isComp) {
									relRecord = store.$.peekRecord(value[i]._type ? value[i]._type : field.relatedTo, value[i]);
									if (!relRecord) {
										relRecord = this.newRecord(relMod1, value[i], opts ? opts.skipValidation : undefined);
									}
								} else {
									relRecord = this.newRecord(relMod1, value[i], opts ? opts.skipValidation : undefined);
								}
								if (relRecord.$.isError) {
									err.push({ code: "ERR15", data: value[i], message: Lyte.errorCodes.ERR15, error: Object.assign({}, relRecord) });
									continue;
								}
							} else {
								relRecord = relRecord.$.record;
							}
						}
						var changed = this.establishLink(rel.forward, rel.backward, record, relRecord, undefined, ignoreChange ? true : undefined);
						if (changed != true) {
							err.push({ code: changed, data: value[i], message: Lyte.errorCodes[changed] });
						} else {
							store.$.addOnSave(model._name, record, attr, field, pK, relPk);
						}
					}
					if (err.length && err.length == value.length) {
						this.revertToOldVal(record, attr, oldVal, rel);
						if (field.relType == "belongsTo") {
							store.$.setRecErr(self, attr, err[0]);
						} else {
							store.$.setRecErr(self, attr, err);
						}
						return;
					} else {
						if (err.length > 1) {
							store.$.setRecErr(self, attr, err);
						} else {
							store.$.clrRecErr(self, attr);
						}
						if (!ignoreChange) {
							var _attrs = record.$._attributes;
							if (!_attrs.hasOwnProperty(attr)) {
								_attrs[attr] = [];
							}
							_attrs[attr].push({ _type: "changed", records: oldVal });
							toEmit.emit = true;
							toEmit.attr.push(attr);
							var obj = {};obj.records = oldVal;obj._type = "update";
							toEmit.oldRec[attr] = obj;
							var arr = record.$.getInitialValues(attr),
							    changed = true;
							if (arr && Array.isArray(record[attr]) && arr.length == record[attr].length) {
								changed = false;
								for (var i = 0; i < arr.length; i++) {
									if (!store.$.comparePk(record[attr][i], arr[i])) {
										changed = true;
										break;
									}
								}
							}
							if (!changed) {
								delete _attrs[attr];
							}
						}
					}
				} else {
					if (value !== record[attr]) {
						// if(field && field.type !== Lyte.getDataType(value) && (value !== undefined  || field.type === "boolean")) {
						// 	value = Lyte.typeCast(value, field.type);
						// }
						if (!opts || opts && opts.skipValidation !== true) {
							var _field = field;
							if (!(_field.any && Array.isArray(_field))) {
								_field = [_field];
							}
							var fldLen = _field.length,
							    _ret = true;
							for (var i = 0; i < fldLen; i++) {
								var _fld = _field[i];
								for (var property in _fld) {
									var resp = Lyte.checkProperty(property, value, attr, _fld[property], _fld, record, undefined, model._name);
									if (resp !== true) {
										if (_ret === true) {
											if ((typeof resp === 'undefined' ? 'undefined' : _typeof(resp)) == "object") {
												resp.value = value;
											}
											_ret = resp;
										}
									}
								}
							}
							if (_ret !== true) {
								store.$.setRecErr(self, attr, _ret);
								return;
							}
						}
						if (!ignoreChange) {
							store.$.estAttrs(record, attr, value, toEmit, deepChange, opts);
						} else {
							var customDtype = false;
							if (Lyte.Transform[field.type]) {
								var customDatatype = Lyte.Transform[field.type];
								if (customDatatype.hasOwnProperty("properties") || customDatatype.hasOwnProperty("items")) {
									customDtype = true;
								}
							}
							if (watch && /^(array|object)$/.test(field.type) || customDtype) {
								Lyte.establishObjectBinding(record, attr, true);
							}
							store.$.cmpSet(record, attr, value, opts, true);
						}
					} else if (value === record[attr] && record.$.isError && record.$.error[attr]) {
						var valid = true,
						    _field = field;
						if (!(_field.any && Array.isArray(_field))) {
							_field = [_field];
						}
						var fldLen = _field.length,
						    _ret = true;
						for (var i = 0; i < fldLen; i++) {
							var _fld = _field[i];
							for (var property in _fld) {
								var resp = Lyte.checkProperty(property, value, attr, _fld[property], _fld, record, undefined, model._name);
								if (resp !== true) {
									_ret = false;
								}
							}
						}
						if (_ret !== true) {
							valid = false;
						}
						if (valid) {
							store.$.clrRecErr(self, attr);
						}
					}
				}
				store.$.checkAttrs(record);
			} else {
				if (record[attr] !== value) {
					store.$.setRecErr(self, attr, "ERR01", value);
				}
			}
		},
		estAttrs: function estAttrs(record, attr, value, toEmit, deepChange, opts) {
			var _attrs = record.$._attributes;
			var model = record.$.model;
			var attribute = _attrs[attr];
			var isAttrPres = _attrs.hasOwnProperty(attr);
			if (!isAttrPres) {
				_attrs[attr] = deepChange ? deepChange.data : this.createCopy(record[attr]);
			} else if (deepChange && Lyte.cmpData(isAttrPres ? attribute : deepChange.data, record[attr]) || value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == "object" && !deepChange && store.adapter.$.compareObjects(attribute, value) || attribute == value) {
				delete _attrs[attr];
			}
			var hasAttr = record.hasOwnProperty(attr);
			var oldAttrVal = deepChange ? deepChange.data : record[attr];
			if (!deepChange) {
				var isPropPresent = model._properties && model._properties.hasOwnProperty(attr),
				    propObj = {};
				if (isPropPresent) {
					propObj[attr] = model._properties[attr];
					store.$.demoLishObserverBindings(record, propObj);
				}
				store.$.cmpSet(record, attr, value, opts, true);
			}
			store.$.clrRecErr(record.$, attr);
			if (record.$.srtObs) {
				store.$.changeRelPkMaps(record, undefined, undefined, "sort", attr);
			}
			var obj = {};
			obj._type = "update";
			obj.val = oldAttrVal;
			if (!hasAttr) {
				obj._type = "propAdd";
			}
			toEmit.emit = true;
			toEmit.attr.push(attr);
			toEmit.oldRec[attr] = obj;
		},
		checkAttrs: function checkAttrs(record) {
			var model = record.$.model;
			if (Object.keys(record.$._attributes).length) {
				store.$.cmpSet(record.$, "isModified", true);
				store.$.changePersist(record, false);
				store.$.addDeepNest(record);
				this.checkAndAddToArray(model.dirty, record.$.pK);
			} else {
				store.$.cmpSet(record.$, "isModified", false);
				store.$.changePersist(record, true);
				if (!record.$.isNew && (!record.$.hasOwnProperty("dN") || record.$.dN && !Object.keys(record.$.dN).length)) {
					store.$.removeParentNesting(record);
				}
				if (!record.$.isNew) {
					this.deleteFromArray(model.dirty, record.$.pK);
				}
			}
		},
		checkForCorrectRelation: function checkForCorrectRelation(rel, record) {
			var relatedTo = rel.relatedTo;
			if (!Lyte.isRecord(record)) {
				return false;
			}
			if (rel.opts && rel.opts.polymorphic) {
				return record.$.model.extend ? rel.relatedTo === record.$.model.extend : false;
			}
			return rel && record ? relatedTo === record.$.model._name : false;
		},
		removeKeys: function removeKeys(fieldList, record) {
			for (var key in record) {
				if (!fieldList.hasOwnProperty(key)) {
					delete record[key];
				} else {
					var field = fieldList[key];
					if (field.type === "belongsTo" || field.type === "hasMany" && record[key]) {
						this.removeNotDefinedKeys(field.relatedTo, record[key], field.opts && field.opts.polymorphic ? true : undefined);
					}
				}
			}
		},
		removeNotDefinedKeys: function removeNotDefinedKeys(model, records, polymorphic) {
			var fieldList = model.fieldList;
			if (Array.isArray(records)) {
				for (var i = 0; i < records.length; i++) {
					var record = records[i];
					this.removeKeys(polymorphic ? Lyte.isRecord(record) ? record.$.model.fieldList : fieldList : fieldList, record);
				}
			} else {
				this.removeKeys(polymorphic ? Lyte.isRecord(records) ? records.$.model.fieldList : fieldList : fieldList, records);
			}
		},
		add: function add(value, type, opts, redoObj) {
			var record = this.record.$.record,
			    model = record.$.model,
			    attr = this.key,
			    field = model.fieldList[attr],
			    rel = {};
			var oldArr;
			store.$.getRelations(model, field.relKey, store.modelFor(field.relatedTo), rel);
			if (!Array.isArray(value)) {
				value = [value];
			}
			var relMod = store.modelFor(rel.forward.relatedTo);
			var pK = relMod._pK,
			    err = [],
			    arr = [],
			    isComp = relMod.isComp;
			if (record.$._attributes.hasOwnProperty(attr) && record.$._attributes[attr].length) {
				oldArr = record.$.getInitialValues(attr);
			}
			for (var i = 0; i < value.length; i++) {
				var rec = value[i];
				if (isComp) {
					if ((typeof rec === 'undefined' ? 'undefined' : _typeof(rec)) == "object" && Object.keys(rec).length === relMod._arrPk.length) {
						if (this.polymorphic && !type) {
							err.push({ code: "ERR22", data: value[i], message: Lyte.errorCodes.ERR22 });
							continue;
						}
						rec = store.$.peekRecord(type ? type : rel.forward.relatedTo, rec);
					}
				}
				if (!isComp && relMod.fieldList[pK].type.toLowerCase() == (typeof rec === 'undefined' ? 'undefined' : _typeof(rec)) || isComp && (typeof rec === 'undefined' ? 'undefined' : _typeof(rec)) == "object" && Object.keys(rec).length === relMod._arrPk.length) {
					if (this.polymorphic && !type) {
						err.push({ code: "ERR22", data: value[i], message: Lyte.errorCodes.ERR22 });
						continue;
					}
					rec = store.$.peekRecord(type ? type : rel.forward.relatedTo, rec);
				} else if ((typeof rec === 'undefined' ? 'undefined' : _typeof(rec)) == "object" && !Lyte.isRecord(rec)) {
					rec = store.$.newRecord(rec._type ? rec._type : type ? type : field.relatedTo, rec, opts ? opts.skipValidation : undefined);
				}
				var polyType = this.polymorphic && type ? type : rec && rec._type ? rec._type : undefined;
				if (rec == undefined) {
					err.push({ code: "ERR13", data: value[i], message: Lyte.errorCodes.ERR13 });
				} else if (rec.$ && rec.$.isError) {
					err.push({ code: "ERR15", data: value[i], message: Lyte.errorCodes.ERR15, error: rec });
				} else if (Lyte.isRecord(rec) && !store.$.hasDuplicateRelation(rec, record[attr], pK, polyType, relMod)) {
					rec = rec.$.record;
					var resp = store.$.establishLink(rel.forward, rel.backward, record, rec);
					if (resp != true) {
						err.push({ code: resp, data: value[i], message: Lyte.errorCodes[resp] });
					} else {
						arr.push(rec);
					}
				}
			}
			if (arr.length) {
				var _attrs = record.$._attributes;
				if (!_attrs[attr]) {
					_attrs[attr] = [{ _type: "added", records: arr }];
					store.$.cmpSet(record.$, "isModified", true);
					store.$.changePersist(record, false);
					// record.$.isModified = true;
					store.$.checkAndAddToArray(model.dirty, record[model._pK]);
				} else if (store.$.hasRecordsArrayChanged(record, attr, oldArr)) {
					_attrs[attr].push({ _type: "added", records: arr });
				} else {
					delete record.$._attributes[attr];
					if (!Object.keys(record.$._attributes).length) {
						store.$.cmpSet(record.$, "isModified", false);
						store.$.changePersist(record, true);

						// record.$.isModified = false;
						delete _attrs[attr];
						if (!record.$.isNew) {
							store.$.deleteFromArray(model.dirty, record.$.pK);
							if (!record.$.dN || record.$.dN && !Object.keys(record.$.dN).length) {
								store.$.removeParentNesting(record);
							}
						}
					}
				}
				store.$.emit("change", record, [attr]);
				var obj = { _type: "added", records: arr };
				if (redoObj) {
					redoObj[attr] = obj;
				} else {
					var stackObj = {};
					stackObj[attr] = obj;
					record.$.undoStack[attr] = record.$.undoStack[attr] || [];
					record.$.undoStack[attr].push(obj);
					// record.$.undoStack._order_ = record.$.undoStack._order_ || [];
					record.$.undoStack._order_.push([attr]);
				}
			}
			if (err.length > 0) {
				store.$.setRecErr(record.$, attr, err);
			} else {
				store.$.clrRecErr(record.$, attr);
			}
			return record;
		},
		remove: function remove(key, type, redoObj) {
			var record = this.record.$.record,
			    model = record.$.model,
			    attr = this.key,
			    field = model.fieldList[attr],
			    rel = {};
			var oldArr;
			store.$.getRelations(model, field.relKey, store.modelFor(field.relatedTo), rel);
			if (!Array.isArray(key)) {
				key = [key];
			}
			var relMod = store.modelFor(rel.forward.relatedTo);
			var pK = relMod._pK,
			    isComp = relMod.isComp,
			    err = [],
			    relatedRecord,
			    arr = [],
			    indices = [];
			if (record.$._attributes.hasOwnProperty(attr) && record.$._attributes[attr].length) {
				oldArr = record.$.getInitialValues(attr);
			}
			for (var i = 0; i < key.length; i++) {
				var rec = key[i],
				    polyType;
				if (!isComp && relMod.fieldList[pK].type.toLowerCase() == _typeof(key[i]) || isComp && (typeof rec === 'undefined' ? 'undefined' : _typeof(rec)) == "object" && Object.keys(rec).length === relMod._arrPk.length) {
					if (this.polymorphic == true && !type) {
						err.push({ code: "ERR22", data: key[i], message: Lyte.errorCodes.ERR22 });
						continue;
					}
					relatedRecord = store.$.peekRecord(type ? type : rel.forward.relatedTo, key[i]);
					polyType = type;
				} else if (Lyte.isRecord(key[i])) {
					relatedRecord = key[i].$.record;
					polyType = type ? type : relatedRecord && relatedRecord._type ? relatedRecord._type : undefined;
				}
				if (relatedRecord) {
					var index = store.$.getIndex(record[attr], pK, relatedRecord.$.get(pK), polyType);
					store.$.demolishLink(relatedRecord, pK, store.$.peekRecord(model._name, record.$.pK), rel.forward.relKey, undefined, undefined, undefined, true);
					if (rel.backward != null) {
						store.$.demolishLink(record, model._pK, store.$.peekRecord(polyType ? polyType : rel.forward.relatedTo, relatedRecord.$.pK), rel.backward.relKey, rel.forward);
					}
					arr.push(relatedRecord);
					indices.push(index);
				}
			}
			if (arr.length) {
				var _attrs = record.$._attributes;
				if (!_attrs[attr]) {
					_attrs[attr] = [{ _type: "removed", records: arr, _indices: indices }];
					store.$.cmpSet(record.$, "isModified", true);
					store.$.changePersist(record, false);

					// record.$.isModified = true;
					store.$.checkAndAddToArray(model.dirty, record[model._pK]);
				} else if (store.$.hasRecordsArrayChanged(record, attr, oldArr)) {
					_attrs[attr].push({ _type: "removed", records: arr, _indices: indices });
				} else {
					delete record.$._attributes[attr];
					if (!Object.keys(record.$._attributes).length) {
						store.$.cmpSet(record.$, "isModified", false);
						store.$.changePersist(record, true);

						// record.$.isModified = false;
						delete _attrs[attr];
						if (!record.$.isNew) {
							store.$.deleteFromArray(model.dirty, record.$.pK);
							if (!record.$.dN || record.$.dN && !Object.keys(record.$.dN).length) {
								store.$.removeParentNesting(record);
							}
						}
					}
				}
				store.$.emit("change", record, [attr]);
				var obj = { _type: "removed", records: arr, _indices: indices };
				if (redoObj) {
					redoObj[attr] = obj;
				} else {
					var stackObj = {};
					stackObj[attr] = obj;
					// record.$.undoStack.push(stackObj);
					record.$.undoStack[attr] = record.$.undoStack[attr] || [];
					record.$.undoStack[attr].push(obj);
					// record.$.undoStack._order_ = record.$.undoStack._order_ || [];
					record.$.undoStack._order_.push([attr]);
				}
			}
			if (err.length > 0) {
				store.$.setRecErr(record.$, attr, err);
			} else {
				store.$.clrRecErr(record.$, attr);
			}
		},
		filter: function filter(record, filObj, len) {
			var j = 0;
			for (var key in filObj) {
				if (record[key] === filObj[key]) {
					j++;
				}
			}
			if (j === len) {
				return true;
			}
		},
		filterBy: function filterBy(obj) {
			var len = Object.keys(obj).length,
			    j = 0,
			    arr = [];
			for (var i = 0; i < this.length; i++) {
				if (store.$.filter(this[i], obj, len)) {
					arr.push(this[i]);
				}
			}
			if (!arr.filterBy) {
				store.$.defArrUtls(arr);
				store.$.defUtls(arr, this.model);
			}
			return arr;
		},
		idbSerialize: function idbSerialize(data, rel, model, bModel, pkVal, expose) {
			var relTo = rel.forward.relatedTo,
			    pK = model._pK,
			    bPk = bModel._pK;
			if (Array.isArray(data)) {
				data.forEach(function (item, index) {
					if (Lyte.isRecord(item) && item.$.inIDB) {
						data[index] = item[bPk];
					} else if (!store.$.checkPresenceInArray(store.$.recStack[relTo], item[bPk])) {
						store.$.removeBackwardRel(item, rel, pK, pkVal, true);
						store.$.removeSelfCircularReference(bModel._name, item, expose);
					} else {
						data[index] = item[bPk];
					}
				});
			} else if (data && Lyte.isRecord(data)) {
				if (Lyte.isRecord(data) && data.$.inIDB) {
					data[rel.relKey] = data[bPk];
				} else if (!this.checkPresenceInArray(store.$.recStack[relTo], data[bPk])) {
					this.removeBackwardRel(data, rel, pK, pkVal, true);
					this.removeSelfCircularReference(bModel._name, data, expose);
				} else {
					data[rel.relKey] = data[bPk];
				}
			}
		},
		idSerialize: function idSerialize(obj, rel, expose, partialObj, partialRef) {
			var polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined,
			    relKey = rel.forward.relKey,
			    relKey = rel.forward.relKey;
			var data = obj[relKey],
			    model = store.model[rel.backward.relatedTo],
			    bModel = store.model[rel.forward.relatedTo],
			    pkVal = store.$.getpKVal(obj, model),
			    modName;
			if (Array.isArray(data)) {
				if (polymorphic) {
					obj[relKey] = this.polymorphicToJSON(rel.forward, data);
				} else {
					var arr = [];
					if (partialObj) {
						var partial = partialObj[relKey] = partialObj[relKey] || [],
						    anyNew = false;
					}
					data.forEach(function (item) {
						if (item.$ && item.$.isNew && expose != true && expose != "state") {
							anyNew = true;
							store.$.rSerialize(item, rel, bModel, model._pK, pkVal, expose, partial, partialRef);
							arr.push(item);
						} else {
							if (partial) {
								var pObj = {},
								    pType = "related";
								if (item.$.isDeleted) {
									pType = "removed";
								}
								store.$.defProp(pObj, "$", {});
								var nPartial = pObj.$,
								    nModel = rel.forward.relatedTo;
								Object.defineProperties(nPartial, {
									pkVal: {
										value: item.$.pK
									},
									type: {
										value: pType
									},
									model: {
										value: nModel
									},
									record: {
										value: store.$.peekRecord(nModel, item.$.pK)
									}
								});
								if (item.$.isDeleted) {
									pObj.$.onlyDetach = true;
								}
								partial.push(pObj);
							}
							if (item.$ && !item.$.isDeleted) {
								arr.push(item.$.pK && _typeof(item.$.pK) == "object" ? Object.assign({}, item.$.pK) : item.$.pK);
							}
						}
					});
					obj[relKey] = arr;
				}
			} else if (data && Lyte.isRecord(data)) {
				if (data.$.isNew && expose != true && expose != "state") {
					if (partialObj) {
						var partial = partialObj[relKey] = partialObj[relKey] || {};
					}
					partial = store.$.rSerialize(data, rel, bModel, model._pK, pkVal, expose, partial, partialRef);
					partialObj[relKey] = partial;
				} else {
					if (polymorphic) {
						obj[relKey] = this.polymorphicToJSON(rel.forward, data);
					} else if (!data.$.isDeleted) {
						obj[relKey] = data.$.pK && _typeof(data.$.pK) == "object" ? Object.assign({}, data.$.pK) : data.$.pK;
					}
				}
			}
		},
		recordSerialize: function recordSerialize(obj, key, val, rel, model, bModel, pkVal, expose, partialObj, partialRef) {
			var pK = model._pK;
			if (Array.isArray(val)) {
				if (val.length == 0) {
					delete obj[key];
					return 0;
				}
				val = Array.from(val);
				var partial = partialObj[key] = partialObj[key] || [];
				if (val.length) {
					var toRem = [];
					for (var j = 0; j < val.length; j++) {
						if (val[j] && Lyte.isRecord(val[j])) {
							// if(val[j].$.isDeleted){
							// 	toRem.push(j);
							// }
							// else{
							this.rSerialize(val[j], rel, bModel, pK, pkVal, expose, partial, partialRef);
							// }
							if (val[j].$.isDeleted) {
								partial[j] && partial[j].$ ? partial[j].$.onlyDetach = true : undefined;
								val.splice(j, 1);
								j--;
							}
						}
					}
					if (toRem.length) {
						for (var k = 0; k < toRem.length; k++) {
							val.splice(k, 1);
						}
					}
				}
			} else if (val && Lyte.isRecord(val)) {
				var partial = partialObj[key] = partialObj[key] || {};
				partial = this.rSerialize(val, rel, bModel, pK, pkVal, expose, partial, partialRef);
				// if(val.$.isDeleted){
				// 	debugger
				// }
				partialObj[key] = partial;
			}
		},
		rSerialize: function rSerialize(data, rel, bModel, pK, pkVal, expose, partialObj, partialRef) {
			var relTo = rel.forward.relatedTo,
			    partial,
			    model = store.model[rel.backward.relatedTo];
			var polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined;
			this.removeBackwardRel(data, rel, pK, pkVal);
			if (partialObj) {
				var partial = {};
				var pType = data.$.isNew ? "added" : data.$.isModified ? "modified" : data.$.isDeleted ? "removed" : "related",
				    modName;
				if (polymorphic) {
					modName = data.$.model._name;
					data.$.polymorphicType = modName;
					bModel = store.model[modName];
				}
				store.$.defProp(partial, "$", {});
				var nPartial = partial.$;
				var nModel = polymorphic ? modName : relTo;
				Object.defineProperties(nPartial, {
					pkVal: {
						value: data.$.pK
					},
					type: {
						value: pType
					},
					model: {
						value: nModel
					},
					record: {
						value: store.$.peekRecord(nModel, data.$.pK)
					}
				});
				if (Array.isArray(partialObj)) {
					partialObj.push(partial);
				}
			}
			this.removeSelfCircularReference(bModel._name, data, expose, undefined, partial, partialRef);
			return partial;
		},
		partialSerialize: function partialSerialize(obj, key, val, rel, model, bModel, pkVal, expose, partialObj, partialRef) {
			var field = rel.forward,
			    pK = model._pK,
			    relTo = rel.forward.relatedTo;
			var polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined;
			if (field.relType == "hasMany") {
				if (val && val.partial) {
					var part = val.partial;
					var bpK = bModel._pK;
					if (partialObj) {
						partial = partialObj[key] = partialObj[key] || [];
						store.$.defProp(partial, "partial", true);
					}
					if (part) {
						var pObj,
						    pKey,
						    newPartial,
						    result = [],
						    self = this;
						part.forEach(function (value, partKey) {
							pObj = value, pKey = partKey, newPartial;
							if (/^(added|modified)$/.test(pObj.type)) {
								var pType = "related";
								var ind = store.$.getIndex(val, bpK, pKey, undefined, store.model[relTo]);
								if (ind != -1) {
									var rec = val[ind],
									    updVal,
									    rec$;
									if (rec && rec.$) {
										rec$ = Object.assign({}, rec.$);
										rec = Object.assign({}, rec);
										store.$.defProp(rec, '$', rec$);
									}
									updVal = rec;
									var polyType;
									if (polymorphic && rec) {
										polyType = rec._type ? rec._type : rec.$.model._name;
										bModel = store.model[polyType];
									}
									var record = store.$.peekRecord(bModel._name, pKey);
									self.removeBackwardRel(rec, rel, pK, pkVal);
									if (rec.$.isNew) {
										pType = "added";
									} else if (rec.$.isModified) {
										pType = "modified";
										var valDir = store.$.isDirty(record, bModel.relations);
										updVal = store.$.updateJSON(rec, bModel, valDir);
									} else {
										var valDir = store.$.isDirty(record, bModel.relations);
										updVal = store.$.updateJSON(rec, bModel, valDir);
									}
									if (partial) {
										var newPart = {};
										store.$.defProp(newPart, "$", {});
										var newPart$ = newPart.$;
										var newPartModel = polymorphic ? polyType : relTo;
										Object.defineProperties(newPart$, {
											pkVal: {
												value: pKey
											},
											type: {
												value: pType
											},
											model: {
												value: polymorphic ? polyType : relTo
											},
											record: {
												value: store.$.peekRecord(newPartModel, pKey)
											}
										});
										// if(partialRef){
										// 	var refId = "rec"+(++partialRef.size), refKey = partialRef.refKey;
										// 	updVal[refKey] = refId;
										// 	partialRef.set(refId, newPart);
										// }
										partial.push(newPart);
									}
									self.removeSelfCircularReference(bModel._name, updVal, expose, undefined, newPart, partialRef);
									// var resObj = {type: pObj.type, data: updVal};
									if (Lyte.isRecord(updVal)) {
										updVal.$.partialType = pObj.type;
									} else {
										store.$.defProp(updVal, "$", {});
										store.$.defProp(updVal.$, "partialType", pObj.type);
										if (!updVal.$.hasOwnProperty("pK")) {
											store.$.defProp(updVal.$, "pK", pKey);
										}
									}
									if (polymorphic) {
										updVal.$.polymorphicType = polyType;
									}
									result.push(updVal);
								}
							} else if (pObj.type == "removed") {
								var dObj = {};
								if (pKey && (typeof pKey === 'undefined' ? 'undefined' : _typeof(pKey)) == "object") {
									Object.assign(dObj, Object.assign({}, pKey));
								} else {
									dObj[bpK] = pKey;
								}
								var record = store.$.peekRecord(bModel._name, pKey) || store.$.peekRecord(bModel._name, pKey, true);
								if (partial) {
									var newPart = {};
									store.$.defProp(newPart, "$", {});
									var newPart$ = newPart.$;
									Object.defineProperties(newPart$, {
										pkVal: {
											value: pKey
										},
										type: {
											value: "removed"
										},
										model: {
											value: polymorphic && pObj.polymorphicType ? pObj.polymorphicType : relTo
										},
										record: {
											value: record
										}
									});
									if (partialRef) {
										var refId = "rec" + ++partialRef.size,
										    refKey = partialRef.refKey;
										dObj[refKey] = refId;
										partialRef.set(refId, newPart);
									}
									partial.push(newPart);
								}
								store.$.defProp(dObj, "$", {});
								dObj.$.partialType = "removed";
								if (polymorphic && pObj.polymorphicType) {
									dObj.$.polymorphicType = pObj.polymorphicType;
								}
								if (!dObj.$.hasOwnProperty('pK')) {
									dObj.$.pK = pKey;
								}
								// result.push({type:"removed", data: dObj})

								result.push(dObj);
							}
						});
						if (result.length) {
							val = obj[key] = result;
						} else {
							delete obj[key];
						}
					}
				} else {
					delete obj[key];
				}
			} else if (field.relType == "belongsTo" && val && Lyte.isRecord(val)) {
				var polyType;
				if (polymorphic && val) {
					polyType = val._type ? val._type : val.$.model._name;
					bModel = store.model[polyType];
				}
				this.removeBackwardRel(val, rel, pK, pkVal);
				var updVal = val,
				    valDir;
				if (val.$.isNew) {
					this.removeBackwardRel(val, rel, pK, pkVal);
				} else {
					valDir = store.$.isDirty(val, bModel.relations);
					updVal = store.$.updateJSON(val, bModel, valDir);
				}
				if (partialObj) {
					var partial = partialObj[key] = partialObj[key] || {};
					var pType = val.$.isNew ? "added" : val.$.isModified ? "modified" : "related";
					store.$.defProp(partial, "$", {});
					var partial$ = partial.$;
					var partMod = polymorphic ? polyType : relTo;
					Object.defineProperties(partial$, {
						pkVal: {
							value: val.$.pK
						},
						type: {
							value: pType
						},
						model: {
							value: partMod
						},
						record: {
							value: store.$.peekRecord(partMod, val.$.pK)
						}
					});
					// if(partialRef){
					// 	var refId = "rec"+(++partialRef.size), refKey = partialRef.refKey;
					// 	updVal[refKey] = refId;
					// 	partialRef.set(refId, partial);
					// }
				}
				if (polymorphic) {
					updVal.$ || store.$.defProp(updVal, "$", {});
					updVal.$.polymorphicType = polyType;
				}
				this.removeSelfCircularReference(bModel._name, updVal, expose, undefined, partial, partialRef);
				val = obj[key] = updVal;
			}
		},
		removeSelfCircularReference: function removeSelfCircularReference(modelName, obj, expose, type, partialObj, partialRef, inherit, addNotDefinedFields) {
			var model = store.model[modelName],
			    fieldList = model.fieldList,
			    extended = model.extend ? true : false,
			    pkVal = store.$.getpKVal(obj, model);
			store.$.recStack[modelName] = store.$.recStack[modelName] || [];
			var ret = store.$.checkAndAddToArray(store.$.recStack[modelName], pkVal),
			    record = store.$.peekRecord(modelName, pkVal),
			    partObj = Lyte.isRecord(record) ? record.$.partial : undefined,
			    polymorphicType = obj && obj.$ ? obj.$.polymorphicType : undefined,
			    recmp = new Map(),
			    refId;
			recmp.set(obj, pkVal);
			if (partialRef) {
				refId = "rec" + ++partialRef.size;
				var refObj = {};
				store.$.defProp(refObj, "$", { pkVal: record.$.pK, model: record.$.model._name });
				partialRef.set(refId, refObj);
			}
			var unlinkedKeys = store.$.getFromCB("serializer", modelName, "serializeEmptyRelation");
			for (var key in obj) {
				var field = fieldList[key],
				    extMod,
				    swap = false,
				    relTo,
				    bModel,
				    relType,
				    relSlave;
				var removePk = (type == "create" || Lyte.isRecord(obj) && obj.$.isNew) && model._pK == key ? true : false;
				if (removePk && expose != true) {
					delete obj[key];
					continue;
				}
				if (!field) {
					if (polymorphicType) {
						extMod = store.modelFor(polymorphicType);
						field = extMod.fieldList[key];
						swap = true;
					}
					if (!addNotDefinedFields) {
						delete obj[key];
					}
					continue;
				}
				if (field && field.type != "relation" && !expose && Lyte.Transform[field.type] && Lyte.Transform[field.type].serialize && obj.hasOwnProperty(key)) {
					obj[key] = Lyte.Transform[field.type].serialize(obj[key], key, record);
					continue;
				}
				if (partObj && partObj.hasOwnProperty(key)) {
					var partPload = {},
					    bPk = store.model[field.relatedTo]._pK,
					    doCont = false;
					partObj[key].forEach(function (item, partPk) {
						if ((unlinkedKeys === true || Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey)) && field.opts && /^(id|record)$/.test(field.opts.serialize)) {
							obj[key] = null;
							doCont = true;
						} else if (field.opts.serialize == "partial") {
							partPload[bPk] = partPk;
							store.$.defProp(partPload, "$", {});
							store.$.defProp(partPload.$, "partialType", "removed");
							store.$.defProp(partPload.$, "pK", partPk);
							obj[key] = partPload;
							doCont = true;
						}
						if (partialObj) {
							var partial = partialObj[key] = partialObj[key] || {};
							store.$.defProp(partial, "$", {});
							var partial$ = partial.$;
							Object.defineProperties(partial$, {
								pkVal: {
									value: partPk
								},
								type: {
									value: "removed"
								},
								model: {
									value: field.relatedTo
								},
								parent: {
									value: record
								},
								record: {
									value: store.$.peekRecord(field.relatedTo, partPk)
								}
							});
							if (field && field.opts && /^(id|record)$/.test(field.opts.serialize)) {
								Object.defineProperties(partial$, {
									onlyDetach: {
										value: true
									},
									relKey: {
										value: key
									}
								});
							}
						}
					});
					if (doCont) {
						continue;
					}
				}
				if ((expose == true || expose == "state") && obj[key] && _typeof(obj[key]) == "object" && field && field.type != "relation") {
					obj[key] = Lyte.deepCopyObject(obj[key]);
					continue;
				}
				if (expose && expose.type == "isClone") {
					if (obj[key] && field && field.type == "relation") {
						relSlave = field.opts && field.opts.inherit ? true : false;
						if (!relSlave) {
							delete obj[key];
						}
					}
				}
				if (obj[key] && field && field.type == "relation") {
					relTo = field.relatedTo;
					relType = field.relType;
					relSlave = field.opts && field.opts.inherit ? true : false;
					bModel = store.modelFor(relTo);
					if (bModel == undefined) {
						continue;
					}
					var relKey = field.relKey,
					    rel = {};
					if (swap) {
						this.getRelations(extMod, field.relKey, bModel, rel);
					} else {
						this.getRelations(model, relKey, bModel, rel);
					}
					var opts = field.opts;
					var serialize = opts ? opts.serialize : undefined,
					    val = obj[relKey];
					if (expose == "idb") {
						store.$.idbSerialize(val, rel, model, bModel, pkVal, expose);
					} else if (inherit && relSlave) {
						store.$.toChildJSON(relTo, relType, obj[key], key, modelName, recmp, addNotDefinedFields, expose);
						if (relType == "belongsTo") {
							obj[key] = Object.assign({}, obj[key]);
							if (obj[key][store.modelFor(relTo)._pK] == pkVal && relTo == modelName) {
								obj[key] = pkVal;
							}
						}
						//store.$.toChildJSON(relTo,relType,obj[key],key,modelName,recmp,modelName+"_"+pkVal);
					} else if (expose && !inherit || inherit && !relSlave || serialize == "id") {
						store.$.idSerialize(obj, rel, expose, partialObj, partialRef);
					} else if (serialize === "record") {
						var ret = store.$.recordSerialize(obj, key, val, rel, model, bModel, pkVal, expose, partialObj, partialRef);
						if (ret == 0) {
							if (relType === "hasMany" && (unlinkedKeys === true || Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey)) && Array.isArray(record[key]) && record[key].partial && record[key].partial.size) {
								var emptyArr = true;
								record[key].partial.forEach(function (pobj) {
									if (pobj.type !== "removed") {
										emptyArr = false;
									}
								});
								if (emptyArr) {
									obj[key] = [];
									continue;
								}
							}
						}
					} else if (serialize === "partial") {
						store.$.partialSerialize(obj, key, val, rel, model, bModel, pkVal, expose, partialObj, partialRef);
					} else {
						delete obj[relKey];
						continue;
					}
					val = obj ? obj[relKey] : undefined;
					if (val && relType == "hasMany" && Array.isArray(val) && val.length == 0 || relType == "belongsTo" && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == "object" && Object.keys(val).length == 0) {
						if ((unlinkedKeys === true || Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey)) && relType == "hasMany" && field.opts && /^(id|record)$/.test(field.opts.serialize)) {
							obj[relKey] = [];
						} else {
							delete obj[relKey];
						}
					}
				}
			}
			if (expose == "state") {
				var fields = record.$.model.fieldList;
				for (var key in fields) {
					if (!record.hasOwnProperty(key)) {
						if (fields[key].type == "relation") {
							if (fields[key].relType == "hasMany") {
								obj[key] = [];
							} else {
								obj[key] = undefined;
							}
						} else {
							obj[key] = undefined;
						}
					}
				}
			}
			if (partialRef) {
				var refKey = partialRef.refKey;
				obj[refKey] = refId;
			}
		},
		removeBackwardRel: function removeBackwardRel(val, rel, pK, pkVal, wholeRelKey) {
			if (wholeRelKey) {
				delete val[rel.backward.relKey];
				return;
			}
			if (rel.backward != null) {
				var rec = val[rel.backward.relKey];
				if (Array.isArray(rec)) {
					for (var i = 0; i < rec.length; i++) {
						if (this.comparePk(rec[i], pkVal)) {
							rec.splice(i, 1);
							if (rec.length == 0) {
								delete val[rel.backward.relKey];
							}
							return;
						}
					}
				} else if (rec && Lyte.isRecord(rec) && this.comparePk(rec, pkVal)) {
					delete val[rel.backward.relKey];
				}
			}
		},
		polymorphicToJSON: function polymorphicToJSON(rel, data) {
			var opts = rel.opts;
			if (opts && opts.polymorphic) {
				if (Array.isArray(data)) {
					var res = [];
					data.forEach(function (item) {
						res.push(store.$.polyToJSON(item));
					});
					return res;
				} else {
					return store.$.polyToJSON(data);
				}
			}
		},
		polyToJSON: function polyToJSON(data) {
			var polyMod = data.$.model;
			if (!polyMod.hasOwnProperty("fieldList") && polyMod._name) {
				polyMod = store.model[polyMod._name];
			}
			var pK = polyMod ? polyMod._pK : undefined,
			    poly = {},
			    pkVal = data.$.pK;
			if ((typeof pkVal === 'undefined' ? 'undefined' : _typeof(pkVal)) == "object") {
				poly = Object.assign({}, pkVal);
			} else {
				poly[pK] = pkVal;
			}
			poly._type = data._type ? data._type : data.$.model._name;
			return poly;
		},
		toChildJSON: function toChildJSON(model, reltype, record, relKey, parent, recmp, addNotDefinedFields, expose) {
			var mdl = store.modelFor(model),
			    mdlf = mdl.fieldList,
			    rel = {},
			    pk;
			if (!Array.isArray(record)) {
				record = [record];
			}
			for (var i = 0; i < record.length; i++) {
				if (!recmp.get(record[i])) {
					var pval = store.$.getpKVal(record[i], mdl);
					recmp.set(record[i], pval);
				}
				if (!addNotDefinedFields) {
					for (var fldKeys in record[i]) {
						if (!mdlf.hasOwnProperty(fldKeys)) {
							delete record[i][fldKeys];
						}
					}
				}
				for (var s in mdl.relations) {
					for (var j = 0; j < mdl.relations[s].length; j++) {
						var v = mdl.relations[s][j].relKey ? mdl.relations[s][j].relKey : undefined;
						if (v && mdlf[v] && mdlf[v].type == "relation" && record[i][mdlf[v].relKey]) {
							if (record[i][mdlf[v].relKey] && mdlf[v].opts && mdlf[v].opts.inherit) {
								if (mdlf[v].relType == "hasMany" && record[i][mdlf[v].relKey]) {
									for (var v1 = 0; v1 < record[i][mdlf[v].relKey].length; v1++) {
										pval = store.$.getpKVal(record[i][mdlf[v].relKey][v1], store.modelFor(mdlf[v].relatedTo));
										if (!recmp.get(record[i][mdlf[v].relKey][v1])) {
											recmp.set(record[i][mdlf[v].relKey][v1], pval);
											store.$.toChildJSON(mdlf[v].relatedTo, mdlf[v].relType, record[i][mdlf[v].relKey][v1], mdlf[v].relKey, mdlf[v].relatedTo, recmp, addNotDefinedFields);
											if (_typeof(record[i][mdlf[v].relKey][v1]) == "object") {
												record[i][mdlf[v].relKey][v1] = Object.assign({}, record[i][mdlf[v].relKey][v1]);
											}
											//store.$.toChildJSON(mdlf[v].relatedTo,mdlf[v].relType,record[i][mdlf[v].relKey][v1],mdlf[v].relKey,mdlf[v].relatedTo,recmp,str);
										} else if (Lyte.isRecord(record[i][mdlf[v].relKey][v1]) && recmp.get(record[i][mdlf[v].relKey][v1])) {
											if ((typeof pval === 'undefined' ? 'undefined' : _typeof(pval)) == "object") {
												record[i][mdlf[v].relKey][v1] = pval;
											} else {
												var robj = {};
												robj[store.modelFor(mdlf[v].relatedTo)._pK] = pval;
												record[i][mdlf[v].relKey][v1] = robj;
											}
											var newPk = {};
											newPk[store.modelFor(mdlf[v].relatedTo)._pK] = pval;
											record[i][mdlf[v].relKey][v1] = (typeof pval === 'undefined' ? 'undefined' : _typeof(pval)) == "object" ? pval : newPk;
										}
									}
								} else if (mdlf[v].relType == "belongsTo" && record[i][mdlf[v].relKey]) {
									pval = store.$.getpKVal(record[i][mdlf[v].relKey], store.modelFor(mdlf[v].relatedTo));
									if (!recmp.get(record[i][mdlf[v].relKey])) {
										recmp.set(record[i][mdlf[v].relKey], pval);
										store.$.toChildJSON(mdlf[v].relatedTo, mdlf[v].relType, record[i][mdlf[v].relKey], mdlf[v].relKey, mdlf[v].relatedTo, recmp, addNotDefinedFields);
										record[i][mdlf[v].relKey] = Object.assign({}, record[i][mdlf[v].relKey]);
									} else {
										var newPk = {};
										newPk[store.modelFor(mdlf[v].relatedTo)._pK] = pval;
										record[i][mdlf[v].relKey] = (typeof pval === 'undefined' ? 'undefined' : _typeof(pval)) == "object" ? pval : newPk;
									}
								}
								if (Object.keys(record[i][mdlf[v].relKey]).length == 0) {
									delete record[i][mdlf[v].relKey];
								}
							} else if (Lyte.isRecord(record[i][mdlf[v].relKey]) || mdlf[v].relType == "hasMany" && Lyte.isRecord(record[i][mdlf[v].relKey][0])) {
								if (!expose || expose && expose.type != "isClone") {
									this.getRelations(mdl, mdlf[v].relKey, store.modelFor(mdlf[v].relatedTo), rel);
									store.$.idSerialize(record[i], rel, true);
								} else {
									delete record[i][mdlf[v].relKey];
								}
							}
						}
					}
				}
				if (Lyte.isRecord(record[i])) {
					record[i] = Object.assign({}, record[i]);
				}
			}
		},
		toJSONObj: function toJSONObj(model, data, expose, type, partial, inherit, addNotDefinedFields) {
			var copyObj,
			    pkVal,
			    modelName = model._name,
			    pK = model._pK;
			var inhFldLen = model._fldGrps.inherit && Object.keys(model._fldGrps.inherit).length;
			if ((expose == true || expose == "state") && (!inherit || inherit && !inhFldLen)) {
				copyObj = Object.assign({}, data);
			} else {
				copyObj = Lyte.deepCopyObject(data);
			}
			if (Lyte.isRecord(copyObj)) {
				pkVal = copyObj.$.pK;
			} else {
				if (store.$.getpKVal(copyObj, model)) {
					if (store.$.peekRecord(modelName, store.$.getpKVal(copyObj, model))) {
						pkVal = store.$.peekRecord(modelName, store.$.getpKVal(copyObj, model)).$.pK;
					} else {
						return;
					}
				} else {
					return;
				}
			}
			var partialObj = partial ? partial.obj : undefined,
			    partialMp;
			if (partialObj && !partialObj.has(pkVal)) {
				partialObj.set(pkVal, {});
				partialMp = partialObj.get(pkVal);
			}
			this.removeSelfCircularReference(modelName, copyObj, expose, type, partialMp, partial && partial.ref ? partial.ref : undefined, inherit, addNotDefinedFields);
			if (expose == "idb") {
				this.removeNotNeededKeys(modelName, copyObj, model.idb);
			}
			return copyObj;
		},
		toJSON: function toJSON(modelName, obj, expose, type, partialObj, inherit, addNotDefinedFields) {
			var copyObj,
			    model = store.model[modelName];
			store.$.recStack = {};
			if (Array.isArray(obj)) {
				var arr = [];
				for (var i = 0; i < obj.length; i++) {
					copyObj = this.toJSONObj(model, obj[i], expose, type, partialObj, inherit, addNotDefinedFields);
					arr.push(copyObj);
				}
				return arr;
			} else if (obj && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === "object" || Lyte.isRecord(obj))) {
				copyObj = this.toJSONObj(model, obj, expose, type, partialObj, inherit, addNotDefinedFields);
			}
			store.$.recStack = {};
			return copyObj;
		},
		createCopy: function createCopy(data) {
			if (Array.isArray(data)) {
				if (data.save) {
					var arr = [];
					for (var i = 0; i < data.length; i++) {
						var rec = Lyte.deepCopyObject(data[i]);
						arr.push(rec);
					}
					return arr;
				}
			} else if (data && (Lyte.isRecord(data) || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object")) {
				return Lyte.deepCopyObject(data);
			}
			return data;
		},
		compareRecords: function compareRecords(a, b, pK, type, model) {
			var pK = model._arrPk;
			if (Lyte.isRecord(a) && Lyte.isRecord(b) && pK.length) {
				if (type && a._type && type !== a._type) {
					return false;
				}
				var pkLen = pK.length;
				for (var i = 0; i < pkLen; i++) {
					var itm = pK[i];
					if (a[itm] && b[itm] && a[itm] !== b[itm]) {
						return false;
					}
				}
				return true;
			}
			return false;
		},
		hasRecordInArray: function hasRecordInArray(array, record, pK, type, isComp) {
			if (Lyte.isRecord(record) && pK) {
				var len = array.length;
				for (var i = 0; i < len; i++) {
					var itm = array[i];
					if (type && itm._type !== type) {
						continue;
					}
					if (isComp) {
						if (this.compareRecords(itm, record, pK, undefined, record.$.model)) {
							return true;
						}
					} else {
						if (type && itm._type && type === record._type && itm[pK] === record[pK] || itm[pK] === record[pK]) {
							return true;
						}
					}
				}
			}
			return false;
		},
		hasDuplicateRelation: function hasDuplicateRelation(toRelate, relation, pK, type, model) {
			var isComp = model.isComp;
			if (Array.isArray(relation)) {
				if (!isComp && !relation.isPolymorphic && relation._recMap) {
					return relation._recMap.get(toRelate[pK]);
				} else {
					return this.hasRecordInArray(relation, toRelate, pK, type, isComp);
				}
			} else if (relation && Lyte.isRecord(relation)) {
				return this.compareRecords(toRelate, relation, pK, type, model);
			}
			return false;
		},
		checkPresenceInArray: function checkPresenceInArray(arr, value) {
			return arr && arr.some(function (val) {
				return val === value;
			});
		},
		checkAndAddToArray: function checkAndAddToArray(arr, value) {
			if (!this.checkPresenceInArray(arr, value)) {
				arr.push(value);
			} else {
				return -1;
			}
		},
		deleteFromArray: function deleteFromArray(arr, value) {
			var ind = arr.indexOf(value);
			if (ind != -1) {
				arr.splice(ind, 1);
			}
		},
		genPk: function genPk(pK, opts, fields) {
			var pkType;
			pK.forEach(function (item) {
				pkType = fields[item].type;
				var random = opts[item] = Math.floor(Math.random() * 100000 + 1);
				if (pkType == "string") {
					opts[item] = random.toString();
				}
			});
		},
		generateRandomPk: function generateRandomPk(model, opts, pK, fields) {
			this.genPk(pK, opts, fields);
			while (this.isDuplicateRecord(model, opts, pK.toString())) {
				this.genPk(pK, opts, fields);
			}
		},
		pkPresence: function pkPresence(opts, pK) {
			var result = true;
			pK.forEach(function (item) {
				if (!opts.hasOwnProperty(item) || !opts[item]) {
					result = false;
					return;
				}
			});
			return result;
		},
		newRecord: function newRecord(name, opts, withoutValidation) {
			var model = store.modelFor(name);
			if (model === undefined) {
				Lyte.warn("LD02", "Model", name);
				var err = new error1(undefined, undefined, Lyte.getErrorMessage("LD02", "Model", name));
				return err;
			}
			if (opts === undefined) {
				opts = {};
			}
			if (opts && (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== "object") {
				Lyte.warn("LD25", opts);
				var err = new error1(undefined, undefined, Lyte.getErrorMessage("LD25", opts));
				return err;
			}
			var fields = model.fieldList,
			    record = {},
			    errorObj = new error1();
			var pK = model._arrPk;
			if (!this.pkPresence(opts, pK)) {
				this.generateRandomPk(model, opts, pK, fields);
			} else if (this.isDuplicateRecord(model, opts, pK)) {
				store.$.setError(errorObj, pK, { code: "ERR16", message: Lyte.errorCodes.ERR16 });
			}
			for (var field in fields) {
				var fieldKeys = fields[field];
				if (fieldKeys.relType == "hasMany") {
					record[field] = [];
				}
				var val = opts[field];
				var fldType = fieldKeys.type;
				if (fldType != "relation") {
					if (val === undefined || val === "") {
						if (fieldKeys.hasOwnProperty("default")) {
							val = record[field] = store.$.getDefaultVal(record, fieldKeys.default);
						}
					}
					// if(fldType !== Lyte.getDataType(val) && (val !== undefined  || fldType === "boolean")) {
					// 	val = Lyte.typeCast(val, fldType);
					// }		
					if (!withoutValidation) {
						var _field = fieldKeys;
						if (!(_field.any && Array.isArray(_field))) {
							_field = [_field];
						}
						var fldLen = _field.length,
						    _ret = true;
						for (var i = 0; i < fldLen; i++) {
							var _fld = _field[i];
							for (var property in _fld) {
								var resp = Lyte.checkProperty(property, val, field, _fld[property], _fld, opts, record, name);
								if (resp != true) {
									if (_ret === true) {
										if ((typeof resp === 'undefined' ? 'undefined' : _typeof(resp)) == "object") {
											resp.value = val;
										}
										_ret = resp;
									}
									// store.$.setError(errorObj,field,resp);
									// break;
								}
							}
						}
						if (_ret !== true) {
							store.$.setError(errorObj, field, _ret);
						}
					}
				}
			}
			for (var opt_key in opts) {
				record[opt_key] = opts[opt_key];
			}
			record = new Record(name, record);
			store.$.cmpSet(record.$, "isNew", true);
			store.$.changePersist(record, false);
			// record.$.isNew = true;
			var relations = model.relations;
			for (var key in relations) {
				var relation = relations[key];
				for (var i = 0; i < relation.length; i++) {
					var relObj = relation[i];
					var relKey = relObj.relKey;
					var polymorphic = relObj.opts ? relObj.opts.polymorphic : undefined;
					if (record && record[relKey]) {
						var optsRelVal = opts[relKey];
						record[relKey] = undefined;
						// Reflect.set(record, relKey, undefined, false);
						var fieldKeys = relation[i],
						    rel = {},
						    resp = this.getRelations(model, fieldKeys.relKey, store.modelFor(fieldKeys.relatedTo), rel),
						    ingore = false;
						if (resp != true) {
							store.$.setError(errorObj, fieldKeys.relKey, { code: resp, data: relation, message: Lyte.errorCodes[resp] });
							continue;
						}
						var bModel = store.modelFor(fieldKeys.relatedTo),
						    bPk = bModel._pK,
						    isComp = bModel.isComp,
						    bPkType = !isComp ? bModel.fieldList[bModel._pK].type : undefined;
						if (!Array.isArray(optsRelVal)) {
							optsRelVal = [optsRelVal];
						} else if (relation[i].relType == "belongsTo") {
							store.$.setError(errorObj, fieldKeys.relKey, { code: "ERR21", data: optsRelVal, message: Lyte.errorCodes.ERR21 });
							continue;
						}
						errorObj[fieldKeys.relKey] = [];
						for (var j = 0; j < optsRelVal.length; j++) {
							var relRecord = undefined,
							    relMod = fieldKeys.relatedTo,
							    ind;
							if (optsRelVal[j] && Lyte.isRecord(optsRelVal[j])) {
								relRecord = optsRelVal[j].$.record;
							} else if (isComp && _typeof(optsRelVal[j]) == "object") {
								var ind = store.$.getIndex(bModel.data, bPk, store.$.getpKVal(optsRelVal[j], bModel));
								if (ind != -1) {
									relRecord = bModel.data[ind];
								} else {
									if (polymorphic) {
										if (optsRelVal[j] && optsRelVal[j].hasOwnProperty("_type")) {
											relMod = optsRelVal[j]._type;
										} else {
											store.$.setError(errorObj, fieldKeys.relKey, { code: "ERR22", data: optsRelVal[j], message: Lyte.errorCodes.ERR22 });
											continue;
										}
									}
									relRecord = this.newRecord(relMod, optsRelVal[j]);
								}
							} else if (optsRelVal[j] && _typeof(optsRelVal[j]) == bPkType.toLowerCase()) {
								relRecord = store.$.peekRecord(relMod, optsRelVal[j]);
							} else if (optsRelVal[j] && _typeof(optsRelVal[j]) == "object") {
								if (polymorphic) {
									if (optsRelVal[j] && optsRelVal[j].hasOwnProperty("_type")) {
										relMod = optsRelVal[j]._type;
									} else {
										store.$.setError(errorObj, fieldKeys.relKey, { code: "ERR22", data: optsRelVal[j], message: Lyte.errorCodes.ERR22 });
										continue;
									}
								}
								relRecord = this.newRecord(relMod, optsRelVal[j]);
								// ingore = true;
							}
							if (relRecord && relRecord.$ && relRecord.$.isError) {
								store.$.setError(errorObj, fieldKeys.relKey, { code: "ERR15", data: optsRelVal[j], message: Lyte.errorCodes.ERR15, error: Object.assign({}, relRecord) });
								continue;
							}
							if (relRecord && relRecord.$ && !relRecord.$.isError) {
								resp = this.establishLink(rel.forward, rel.backward, record, relRecord, undefined, ingore);
								if (resp != true) {
									store.$.setError(errorObj, fieldKeys.relKey, { code: resp, data: optsRelVal[j], message: Lyte.errorCodes[resp] });
								}
							}
						}
						if (errorObj[fieldKeys.relKey].length == 0) {
							delete errorObj[fieldKeys.relKey];
						}
						if (relation[i].relType == "hasMany") {
							var fieldkey = relKey;
							if (record[fieldkey] == undefined) {
								// Reflect.set(record, fieldkey, [], false);
								record[fieldkey] = [];
							}
							if (!record[fieldkey].add) {
								if (polymorphic) {
									store.$.defProp(record[fieldkey], "polymorphic", true);
								}
								store.$.defArrUtls(record[fieldkey]);
								store.$.defUtls(record[fieldkey], store.modelFor(relation[i].relatedTo), record, fieldkey);
								store.$.defPolyUtls(record[fieldkey]);
							}
						}
					}
				}
			}
			if (errorObj && errorObj.$ && Object.keys(errorObj.$.error).length > 0) {
				return errorObj;
			}
			var toRel = store.$.toRelate[model._name],
			    pkVal = record.$.pK;
			if (toRel && toRel.has(pkVal)) {
				store.$.establishToRelated(record, toRel.get(pkVal));
				toRel.delete(pkVal);
			}
			if (model.didLoad) {
				var callBack = model.didLoad;
				for (var i = 0; i < callBack.length; i++) {
					callBack[i].apply(record);
				}
			}
			this.handleArrOp(model.data, "push", record);
			this.checkAndAddToArray(model.dirty, record.$.pK);
			model.emit("add", [record]);
			store.emit("add", [model._name, record]);
			if (withoutValidation) {
				record.$.validatedOnCreate = false;
			}
			return record;
		},
		toInsertData: function toInsertData(modelName, payLoad, saveParent, ind) {
			var model = store.model[modelName];
			var data = this.insertIntoStore(modelName, payLoad[modelName], saveParent, true, undefined, undefined, undefined, undefined, ind);
			model ? delete model.rel : undefined;
			return data;
		},
		insertIntoStore: function insertIntoStore(modelName, data, saveParent, stack, partialObj, temp, checkRelData, clone, index, CustomDeserialize) {
			var ret;
			if (Array.isArray(data)) {
				ret = [];
				for (var i = 0; i < data.length; i++) {
					ret[i] = this.insertIntoStore(modelName, data[i], saveParent, stack, partialObj);
					if (ret[i] && ret[i].$ && ret[i].$.isError) {
						ret.$ = ret.$ || store.$.defProp(ret, "$", {});
						// ret.$.isError = true;y
						store.$.cmpSet(ret.$, "isError", true);
					}
				}
			} else if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object" && Object.keys(data).length) {
				var currentModel = store.modelFor(modelName);
				if (data._type && currentModel.extendedBy) {
					currentModel = currentModel.extendedBy[data._type] ? store.modelFor(data._type) : undefined;
				}
				if (currentModel) {
					if (Lyte.isRecord(data) && !clone) {
						return undefined;
					}
					if (checkRelData && data && currentModel) {
						var rels = currentModel.relations;
						for (var key in rels) {
							var relArr = rels[key];
							relArr.forEach(function (rel) {
								var key = rel.relKey;
								var type = rel.relType;
								if (type == "hasMany" && data.hasOwnProperty(key) && Array.isArray(data[key]) && data[key].length) {
									var arr = data[key],
									    newArr = [];
									arr.forEach(function (itm) {
										if (Lyte.isRecord(itm)) {
											newArr.push(itm.$.pK);
										} else {
											newArr.push(itm);
										}
									});
									data[key] = newArr;
								} else if (type == "belongsTo" && data.hasOwnProperty(key) && Lyte.isRecord(data[key])) {
									data[key] = data[key].$.pK;
								}
							});
						}
					}
					if (!clone) {
						if (!this.isDuplicateRecord(currentModel, data, currentModel._pK)) {
							var rec = new Record(currentModel._name, data);
							currentModel.data.push(rec);
							var toRel = store.$.toRelate[currentModel._name],
							    pkVal = rec.$.pK;
							if (saveParent) {
								store.$.saveParent = rec;
							}
							ret = this.validateAndPush(currentModel, rec, partialObj, undefined, CustomDeserialize);
							if (toRel && toRel.has(pkVal)) {
								store.$.establishToRelated(rec, toRel.get(pkVal));
								toRel.delete(pkVal);
							}
						} else {
							ret = this.validateAndMerge(currentModel, data, partialObj, undefined, CustomDeserialize);
							if (ret && ret.data) {
								ret = ret.data;
							} else if (ret && ret.type) {
								Lyte[ret.type].apply(Lyte, ret.args || []);
							}
						}
					} else {
						var rec = new Record(currentModel._name, data, currentModel._pK, clone);
						var ret = this.validateAndPush(currentModel, rec, undefined, clone);
					}
					if (saveParent) {
						store.$.saveParent = undefined;
					}
					if (stack) {
						store.$.recStack = {};
					}
				} else {
					var defobj = store.modelless,
					    def = defobj[modelName] = defobj[modelName] || {};
					if (index) {
						if (!(typeof index === 'undefined' ? 'undefined' : _typeof(index)) == "string") {
							Lyte.error("Index should be a string");
						}
						if (def._pK) {
							if (def._pK !== index) {
								Lyte.error("");
								return;
							}
						}
						def._pK = index;
						def._arrPk = [index];
					} else {
						def._pK = index = "id";
						def._arrPk = [index];
					}
					def.data = def.data || [];
					if (!def.data.modelless) {
						store.$.defProp(def.data, "modelless", true);
						store.$.defProp(def.data, "pK", def._pK);
					}
					var ind = store.$.getInd(def.data, index, data[index]);
					if (ind == -1) {
						store.$.handleArrOp(def.data, "push", data);
					} else {
						store.$.handleArrOp(def.data, "replaceAt", data, ind);
					}
					return data;
				}
			}
			return ret;
		},
		removeFromStore: function removeFromStore(model, keys, fromStore, ignorePartial, delayPer, onlyRem, partOnlyRem, idbPersist) {
			var data = model.data,
			    modelName = model._name;
			if (data.length == 0) {
				return;
			}
			if (!Array.isArray(keys)) {
				keys = [keys];
			}
			var pKey = model._pK;
			for (var i = 0; i < keys.length; i++) {
				var index = this.getIndex(data, pKey, keys[i]);
				if (index == -1) {
					continue;
				}
				var rec = data[index];
				var pK = rec.$.pK;
				var relations = model.relations;
				if (rec.$.isNew) {
					onlyRem = delayPer = undefined;
					fromStore = true;
				}
				if (Object.keys(relations).length) {
					this.toDemolishRelation(model, index, ignorePartial, onlyRem, delayPer, partOnlyRem);
				}
				var deleted;
				if (delayPer !== true && onlyRem !== false) {
					deleted = this.handleArrOp(data, "removeAt", undefined, index, 1);
					if (model._properties) {
						store.$.demoLishObserverBindings(rec, model._properties);
					}
				}
				if (fromStore === true) {
					store.$.cmpSet(rec.$, "isUnloaded", true);
					var scpObj = rec.$.__scpObj;
					for (var key in scpObj) {
						var sid = scpObj[key];
						var sidArr = sid.split("_");
						var nestObj = Lyte.nestScp[sidArr[0]];
						nestObj ? Lyte.removeNestScp(nestObj._data, sidArr[0], sidArr[1], undefined, rec, undefined, undefined, { model: modelName, pK: rec.$.pK, attr: key }) : undefined;
					}
					var cqueries = store.model.cachedQueries;
					if (cqueries) {
						var Nm = cqueries[modelName],
						    n = modelName;
						if (Nm && Nm.length) {
							for (var j = Nm.length - 1; j >= 0; j--) {
								var obj = Nm[j];
								if (obj.hasDeletedRecords) {
									if (obj.data) {
										var ind = obj.data[modelName].indexOf(rec);
										if (ind !== -1) {
											Nm.splice(j, 1);
										}
									}
								}
							}
						}
					}
					if (idbPersist && !rec.$.isNew) {
						rec.$.persist();
					}
				}
				if (onlyRem == true) {
					model.emit("remove", [deleted[0]]);
					store.emit("remove", [model._name, deleted[0]]);
					continue;
				}
				var remRec = deleted ? deleted[0] : rec;
				if (!fromStore) {
					store.$.cmpSet(remRec.$, "isDeleted", true);
					store.$.changePersist(remRec, true);
					// deleted[0].$.isDeleted = true;
					if (delayPer !== true && onlyRem !== false && (remRec.$.isNew || remRec.$.isModified)) {
						store.$.deleteFromArray(model.dirty, remRec.$.pK);
					}
					if (!remRec.$.isNew) {
						store.$.addTo_Del(model, remRec, index);
						// model._deleted.push(deleted[0]);
					}
					var cqueries = store.model.cachedQueries;
					if (cqueries) {
						var Nm = cqueries[modelName],
						    n = modelName;
						if (Nm && Nm.length) {
							for (var j = Nm.length - 1; j >= 0; j--) {
								var obj = Nm[j];
								if (obj && obj.data) {
									var ind = obj.data[modelName].indexOf(rec);
									if (ind != -1) {
										obj.hasDeletedRecords = true;
									}
								}
							}
						}
					}
				}
				var ind;
				if (Array.isArray(model.dirty) && (ind = model.dirty.indexOf(pK)) != -1) {
					model.dirty.splice(ind, 1);
				}
				if (delayPer !== true && onlyRem !== false) {
					model.emit("remove", [deleted[0]]);
					store.emit("remove", [model._name, deleted[0]]);
				}
			}
		},
		getIndex: function getIndex(data, pKey, pkVal, type, model) {
			var isComp = model ? model.isComp : pKey.split(',').length > 1 ? true : false;
			if (!isComp) {
				return this.getInd(data, pKey, pkVal, type);
			} else {
				return this.getCompInd(data, pkVal, type, model);
			}
		},
		getCompInd: function getCompInd(data, pkVal, type, model) {
			for (var i = 0; data && i < data.length; i++) {
				var rec = data[i];
				if (type && data[i]._type !== type) {
					continue;
				}
				if (store.adapter.$.compareObjects(store.$.getpKVal(rec, model), pkVal)) {
					return i;
				}
			}
			return -1;
		},
		getInd: function getInd(data, pKey, pkVal, type) {
			for (var i = 0; data && i < data.length; i++) {
				var rec = data[i];
				if (type && rec._type !== type) {
					continue;
				}
				if (rec[pKey] == pkVal) {
					return i;
				}
				if (pKey && typeof pKey == "string" && pKey.search(/[.]/g) != -1) {
					if (rec && rec.$ && rec.$.record && rec.$.get(pKey) == pkVal) {
						return i;
					}
				}
			}
			return -1;
		},
		isDuplicateRecord: function isDuplicateRecord(model, obj) {
			var data = model.data,
			    pK = model._pK,
			    isComp = model.isComposite;
			if (data.length) {
				if (!isComp && model.data._recMap) {
					var pkVal = obj[pK];
					if (pkVal !== undefined) {
						return model.data._recMap.get(pkVal.toString()) !== undefined;
					} else {
						return false;
					}
				} else {
					return data.some(function (record) {
						if (store.adapter.$.compareObjects(store.$.getpKVal(obj, model), store.$.getpKVal(record))) {
							return true;
						}
					});
				}
			}
			return false;
		},
		validateAndPush: function validateAndPush(model, data, partialObj, clone, CustomDeserialize) {
			if (!model.rel) {
				model.rel = {};
			}
			var pkVals = model._arrPk,
			    pkValsLen = pkVals.length,
			    index;
			for (var i = 0; i < pkValsLen; i++) {
				var item = pkVals[i];
				if (!data.hasOwnProperty(item)) {
					index = model.data.indexOf(data);
					model.data.splice(index, 1);
					return new error1(item, { code: "ERR23", data: data, message: Lyte.errorCodes.ERR23 });
				} else if (data[item] == undefined || data[item] == null) {
					index = model.data.indexOf(data);
					model.data.splice(index, 1);
					return new error1(item, { code: "ERR26", data: data, message: Lyte.errorCodes.ERR26 });
				}
			}
			if (clone) {
				data = this.validateJSON(model, data, undefined, undefined, undefined, clone);
				return data;
			}
			var mapPk = data.$.pK == undefined || _typeof(data.$.pK) == "object" ? data.$.pK : data.$.pK.toString();
			model.data._recMap.set(mapPk, data);
			data = this.validateJSON(model, data, undefined, undefined, partialObj, undefined, CustomDeserialize);
			var index = model.data.indexOf(data); //have to check if the removal of these lines, doesn't affect any
			model.data.splice(index, 1);
			this.handleArrOp(model.data, "push", data);
			if (model.didLoad) {
				var callBack = model.didLoad;
				for (var i = 0; i < callBack.length; i++) {
					callBack[i].apply(data);
				}
			}
			model.emit("add", [data]);
			store.emit("add", [model._name, data]);

			return data;
		},
		validateAndMerge: function validateAndMerge(model, data, partialObj, mergeError, CustomDeserialize) {
			if (!model.rel) {
				model.rel = {};
			}
			// if((data && typeof data !== "object") || Lyte.isRecord(data)){
			//     return { type:"warn", args:["LD27",Lyte.isRecord(data) ? data : JSON.stringify(data)]};
			// }
			var pkVal = store.$.getpKVal(data, model);
			if (pkVal === undefined) {
				return { type: "error", args: ["LD28", model._name, Lyte.isRecord(data) ? data : JSON.stringify(data)] };
			}
			var record = store.$.peekRecord(model._name, store.$.getpKVal(data, model));
			if (!record || !Lyte.isRecord(record)) {
				return { type: "error", args: ["LD04", Lyte.isRecord(data) ? data : JSON.stringify(data)] };
			}
			this.mergeData(record, data, partialObj, mergeError, CustomDeserialize);
			// record = this.validateJSON(model, record, Object.keys(data), toValidate, partialObj);
			if (model.didLoad) {
				var callBack = model.didLoad;
				for (var i = 0; i < callBack.length; i++) {
					callBack[i].apply(record);
				}
				//model.didLoad.apply(record);
			}
			return { data: record };
		},
		mergeData: function mergeData(record, data, partialObj, mergeError, CustomDeserialize) {
			if (!record || !data) {
				return;
			}
			var model = record.$.model,
			    field,
			    _estObsBind = false;
			var deserialize = CustomDeserialize == false ? CustomDeserialize : true;
			if (mergeError) {
				store.adapter.$.mergeError(model, record, data);
			}
			for (var key in data) {
				field = model.fieldList[key];
				if (field) {
					if (field.type != "relation") {
						var empD = store.$.getDsrzEmpData(field, model._name);
						var boolChk = !empD && data[key];
						if (data.hasOwnProperty(key) && (boolChk || empD) && Lyte.Transform.hasOwnProperty(field.type) && Lyte.Transform[field.type].hasOwnProperty("deserialize") && deserialize) {
							data[key] = Lyte.Transform[field.type].deserialize(data[key], key, model._name, store.$.getpKVal(data, model));
						}
						var isPropPresent = model._properties && model._properties.hasOwnProperty(key),
						    propObj = {};
						if (isPropPresent) {
							propObj[key] = model._properties[key];
							store.$.demoLishObserverBindings(record, propObj);
						}
						store.$.cmpSet(record, key, data[key], undefined, true);
						model._properties && model._properties.hasOwnProperty(key) ? _estObsBind = true : undefined;
					} else if (field && field.type == "relation") {
						var todo = {};
						var rel = {};
						store.$.getRelations(record.$.model, key, store.modelFor(field.relatedTo), rel);
						var bMod = store.model[rel.forward.relatedTo];
						// if new record created and replace (true) , then newly created record will be completely removed form store
						// response recived from the server replaced
						if (field.relType == "hasMany" && partialObj && partialObj[key] && partialObj[key].replace) {
							var rec_ar = record[key]._recMap,
							    arr_rec = [];
							rec_ar.forEach(function (rec, key_i) {
								arr_rec.push(key_i);
							});
							arr_rec.forEach(function (i) {
								if (store.$.peekRecord(field.relatedTo, i).$.isNew) {
									store.$.removeFromStore(store.modelFor(field.relatedTo), i, true);
								} else {
									store.$.demolishLink(store.$.peekRecord(field.relatedTo, i), store.$.peekRecord(field.relatedTo, i).$.model._pK, record, rel.forward.relKey, undefined, undefined, true, true);
									if (rel.backward != null) {
										store.$.demolishLink(record, model._pK, store.$.peekRecord(field.relatedTo, i), rel.backward.relKey, rel.forward, undefined, true, true);
									}
								}
							});
							delete partialObj[key];
						}
						var result = this.compareRelations(record, data, key, field, partialObj ? partialObj[key] : undefined, todo, mergeError);
						this.mergeRecords(todo, result, model, bMod, record, key, data, rel, partialObj, mergeError);
					}
				} else if (key != "$") {
					store.$.cmpSet(record, key, data[key], undefined, true);
				}
			}
			if (_estObsBind) {
				store.$.establishObserverBindings(record, model._properties);
			}
		},
		mergeRecords: function mergeRecords(todo, result, model, bMod, record, key, data, rel, partialObj, mergeError) {
			if (!rel) {
				var rel = {};
				store.$.getRelations(model, key, bMod, rel);
			}
			var pK = model._pK;
			if (rel.forward.relType == "hasMany" && store.$.isEmptyArray(data[key]) && Array.isArray(todo.remove) && record && record[key] && todo.remove.length != record[key].length || record && !record[key] && Array.isArray(data[key])) {
				store.$.cmpSet(record, key, [], undefined, true);
				store.$.establishObserverBindings(record, record.$.model._properties);
				store.$.defArrUtls(record[key]);
				store.$.defPolyUtls(record[key]);
				store.$.defUtls(record[key], bMod, record, key);
			}
			if (Array.isArray(todo.add)) {
				todo.add.forEach(function (item) {
					store.$.createAndRelate(model, bMod, record, key, item, rel, partialObj);
				});
			}
			if (Array.isArray(todo.remove)) {
				todo.remove.forEach(function (obj) {
					var pkVal = obj.pK,
					    model = obj.model;
					store.$.demolishLink(record, pK, store.$.peekRecord(model, pkVal), rel.backward.relKey, rel.forward, rel.backward, true);
					store.$.demolishLink(store.$.peekRecord(model, pkVal), store.modelFor(model)._pK, record, rel.forward.relKey, rel.backward, rel.forward, true);
				});
			}

			if (record && record.hasOwnProperty(key)) {
				store.$.deleteDeepNest(record, key);
				if (Array.isArray(record[key]) && record[key].hasOwnProperty("partial")) {
					var partObj = record[key].partial,
					    partKeys = [];
					partObj.forEach(function (value, partKey) {
						partKeys.push(partKey);
						record[key].partial.delete(partKey);
					});
				}
			}
			switch (result) {
				case 0:
					{
						if (Lyte.isRecord(record[key])) {
							store.$.demolishLink(record, pK, record[key], rel.backward.relKey, rel.forward, rel.backward, true);
							store.$.demolishLink(record[key], bMod._pK, record, rel.forward.relKey, rel.backward, rel.forward, true);
						}
						store.$.createAndRelate(model, bMod, record, key, data[key], rel, partialObj);
						break;
					}
				case 1:
					{
						break;
					}
				case 2:
					{
						this.mergeData(record[key], data[key], undefined, mergeError);
						break;
					}
				default:
					break;
			}
		},
		compareRelations: function compareRelations(record, data, key, field, partialObj, todo, mergeError) {
			//return 0 - not same, 1 -same, 2 - merge, 3 - partial add, 4 - delete and partial add
			var model = store.modelFor(field.relatedTo);
			var pK = model._pK,
			    result = [];
			if (field.relType == "belongsTo") {
				if (partialObj && partialObj.$.type === "removed" && (!data || data && store.$.comparePk(record, store.$.getpKVal(data, model)))) {
					return 1;
				}
				return this.compareRecordWithObj(record[key], data[key], pK, partialObj, mergeError);
			} else {
				var isPartial = false;
				if (partialObj && partialObj.partial) {
					isPartial = true;
				}
				if (!isPartial && (!record.hasOwnProperty(key) || record && record.hasOwnProperty(key) && (store.$.isEmpty(record[key]) || store.$.isEmptyArray(record[key])))) {
					if (todo) {
						var arr = data[key] || [];
						arr.forEach(function (item) {
							var add = todo.add = todo.add || [];
							add.push(item);
						});
						return;
					}
					return 0;
				}
				var len = data[key] ? data[key].length : 0,
				    old = 0,
				    status = 1,
				    oldPks = [];
				for (var i = 0; i < len; i++) {
					var obj = data[key][i];
					if (partialObj && partialObj[i] && partialObj[i].$.type == "removed") {
						continue;
					}
					var ind = this.getIndex(record[key], pK, (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == "object" ? store.$.getpKVal(obj, model) : obj);
					if (ind == -1) {
						if (todo) {
							var add = todo.add = todo.add || [];
							add.push(obj);
						}
						status = 0;
						continue;
					}
					oldPks.push(record[key][ind].$.pK);
					var res = this.compareRecordWithObj(record[key][ind], obj, pK, partialObj ? partialObj[i] : undefined, mergeError);
					if (res == 1) {
						old++;
					}
					if (res == 2) {
						this.mergeData(record[key][ind], obj, partialObj ? partialObj[i] : undefined, mergeError);
					} else if (res == 0) {
						status = 0;
					}
				}
				if (todo && !isPartial) {
					var arr = record[key] || [];
					arr.forEach(function (item) {
						var pkVal = item.$.pK;
						if (oldPks.indexOf(pkVal) == -1) {
							var remove = todo.remove = todo.remove || [];
							remove.push({ pK: pkVal, model: item.$.model._name });
						}
					});
				}
			}
		},
		compareRecordWithObj: function compareRecordWithObj(rec, obj, pK, partialObj, mergeError) {
			if (!rec || !Lyte.isRecord(rec)) {
				return 0;
			}
			var recModel = rec.$.model;
			var recPk = recModel._pK;
			var isComp = recModel.isComp;
			var recFields = recModel.fieldList;
			if (!isComp) {
				var field = recModel.fieldList[pK];
				if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == field.type) {
					if (rec[pK] == obj) {
						return 1;
					} else {
						return 0;
					}
				}
			}
			if (obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == "object") {
				if (!store.$.comparePk(rec, store.$.getpKVal(obj, recModel))) {
					return 0;
				}
				if (Lyte.isRecord(obj) && obj === rec) {
					return 1;
				}
				for (var data_key in obj) {
					var field = recFields[data_key];
					if (field) {
						if (field.type == "relation") {
							var todo = {};
							var res = this.compareRelations(rec, obj, data_key, field, partialObj ? partialObj[data_key] : undefined, todo, mergeError);
							this.mergeRecords(todo, res, recModel, store.modelFor(field.relatedTo), rec, data_key, obj, undefined, partialObj);
						} else if (rec[data_key] != obj[data_key]) {
							return 2;
						}
					} else {
						if (rec[data_key] != obj[data_key]) {
							return 2;
						}
					}
				}
				return 1;
			}
			return 0;
		},
		validateJSON: function validateJSON(model, data, keys, toValidate, partialObj, clone, CustomDeserialize) {
			var validate = toValidate ? toValidate.toValidate : undefined;
			var deserialize = CustomDeserialize == false ? CustomDeserialize : true;
			var fields = validate && Object.keys(validate).length ? validate : model.fieldList;
			var extended = model.extend ? true : false;
			for (var key in data) {
				if (keys && keys.indexOf(key) == -1) {
					continue;
				}
				var fld = fields[key];
				if (fld) {
					if (fld.type == "relation" && data[key]) {
						var partialAdd = toValidate && toValidate.toPartialAdd ? toValidate.toPartialAdd[key] : undefined;
						var resp = this.handleRelation(key, model, fld, data, partialAdd, partialObj, clone);
						if (resp != true) {
							return new error1(key, { code: resp, data: data, message: Lyte.errorCodes[resp] });
						}
						if (fld.relType == "hasMany" && !data[key].add) {
							store.$.defArrUtls(data[key]);
							store.$.defPolyUtls(data[key]);
							store.$.defUtls(data[key], store.model[fld.relatedTo], data, key);
						}
					} else if (fld.type) {
						var fieldKeys = fld;
						if (data[key] === undefined && fieldKeys.default) {
							data[key] = store.$.getDefaultVal(data, fieldKeys.default);
						}
						var empD = store.$.getDsrzEmpData(fld, model._name);
						var boolChk = !empD && data[key];
						if (data.hasOwnProperty(key) && (boolChk || empD) && Lyte.Transform.hasOwnProperty(fieldKeys.type) && Lyte.Transform[fieldKeys.type].hasOwnProperty("deserialize") && deserialize) {
							data[key] = Lyte.Transform[fieldKeys.type].deserialize(data[key], key, model._name, store.$.getpKVal(data, model));
						}
					}
				} else {
					if (extended) {
						var extMod = store.modelFor(model.extend);
						var extKey = extMod.fieldList[key];
						if (extKey && extKey.type == "relation") {
							var partialAdd = toValidate && toValidate.toPartialAdd ? toValidate.toPartialAdd[key] : undefined;
							var resp = this.handleRelation(key, extMod, extKey, data, partialAdd);
							if (resp != true) {
								return new error1(key, { code: resp, data: data, message: Lyte.errorCodes[resp] });
							}
							if (extKey.relType == "hasMany" && !data[key].add) {
								store.$.defArrUtls(data[key]);
								store.$.defPolyUtls(data[key]);
								store.$.defUtls(data[key], extMod, data, key);
							}
						}
					}
				}
			}
			return data;
		},
		handleRelation: function handleRelation(key, model, field, data, partialAdd, partialObj, clone) {
			var rel = {};
			if (!model.rel.hasOwnProperty(key)) {
				var relResp = this.getRelations(model, key, store.modelFor(field.relatedTo), rel);
				if (relResp !== true) {
					return relResp;
				}
				model.rel[key] = rel;
			} else {
				rel = model.rel[key];
			}
			return this.solveRelation(rel, model, store.modelFor(field.relatedTo), key, data, partialAdd, partialObj, clone);
		},
		getRelations: function getRelations(fModel, key, bModel, rel) {
			if (bModel == undefined) {
				Lyte.error("LD05", fModel.fieldList[key].relatedTo, key, fModel._name);
				return "ERR11";
			}
			rel.forward = fModel.fieldList[key];
			rel.backward = this.getBackwardRel(fModel, rel.forward, bModel);
			if (rel.backward === undefined) {
				// Lyte.warn("LD06",fModel._name,key,bModel._name);
				// return "ERR25";
				var temp_backward = { type: "relation", relatedTo: fModel._name, dummy: rel.forward.relKey, relKey: undefined };
				bModel.relations[fModel._name] = bModel.relations[fModel._name] || [];
				bModel.relations[fModel._name].push(temp_backward);
				rel.backward = temp_backward;
			}
			return true;
		},
		getBackwardRel: function getBackwardRel(fModel, rel, bModel) {
			var inverse, polymorphic;
			if (rel.opts) {
				inverse = rel.opts.inverse;
				polymorphic = rel.opts.polymorphic;
				if (inverse === null) {
					return undefined;
				}
				if (polymorphic) {
					var extendedModels = bModel.extendedBy;
					if (extendedModels) {
						for (var key in extendedModels) {
							var extModel = store.modelFor(key);
							if (extModel.relations[fModel._name]) {
								bModel = extModel;
								break;
							}
						}
					}
				}
			}
			var relatedTo;
			if (inverse && inverse != "") {
				relatedTo = inverse;
			} else {
				var bRel = bModel.relations[fModel._name];
				var extFmodel = store.modelFor(fModel.extend),
				    checkPoly;
				if (!bRel && extFmodel && bModel.relations[extFmodel._name]) {
					bRel = bModel.relations[extFmodel._name];
					checkPoly = true;
				}
				relatedTo = bRel && bRel.length == 1 && (bRel[0].opts && bRel[0].opts.inverse && bRel[0].opts.inverse !== rel.relKey ? false : true) && (!checkPoly || checkPoly && bRel[0].opts && bRel[0].opts.polymorphic) ? bRel[0].relKey : undefined;
			}
			if (!relatedTo) {
				var bRels = bModel.relations[fModel._name];
				var extFmodel_1 = store.modelFor(fModel.extend);
				if (!bRels && extFmodel_1 && bModel.relations[extFmodel_1._name] && bModel.relations[extFmodel_1._name].opts && bModel.relations[extFmodel_1._name].opts.polymorphic) {
					bRels = bModel.relations[extFmodel_1._name];
				}
				if (rel.dummy && bRels) {
					for (var i = 0; i < bRels.length; i++) {
						if (bRels[i] && bRels[i].relKey && bRels[i].relKey == rel.dummy) {
							relatedTo = bRels[i].relKey;
							break;
						}
					}
				} else if (bRels) {
					for (var i = 0; i < bRels.length; i++) {
						if (bRels[i] && bRels[i].opts && bRels[i].opts.inverse && bRels[i].opts.inverse === rel.relKey) {
							relatedTo = bRels[i].relKey;
							break;
						} else if (bRels[i] && bRels[i].dummy && bRels[i].dummy == rel.relKey) {
							relatedTo = bRels[i];
							break;
						}
					}
				}
			}
			if (relatedTo && relatedTo.dummy) {
				return relatedTo;
			}
			if (relatedTo && fModel._fldGrps.inverse.hasOwnProperty(rel.relatedTo) && !rel.dummy) {
				if (relatedTo && fModel.relations[rel.relatedTo] && fModel.relations[rel.relatedTo].length > 1 && !inverse) {
					if (!bModel.fieldList[relatedTo].opts || bModel.fieldList[relatedTo].opts && !bModel.fieldList[relatedTo].opts.inverse) {
						return undefined;
					}
				}
			}
			return relatedTo && bModel ? bModel.fieldList[relatedTo] : undefined;
		},
		solveRelation: function solveRelation(rel, fModel, bModel, key, data, partialAdd, partialObj, clone) {
			var backward = rel.backward,
			    forward = rel.forward,
			    partial = partialObj ? partialObj[key] : undefined,
			    partialRel = partial && partial.partial;
			var fPk = fModel._pK,
			    val = [];
			if (partialAdd) {
				val = partialAdd;
			} else if (!partialRel) {
				if (data[key] && (data[key].add || Lyte.isRecord(data[key]))) {
					return true;
				}
				if (!Array.isArray(data[key])) {
					// Reflect.set(data, key, [data[key]], false);
					data[key] = [data[key]];
				} else if (forward.relType == "belongsTo") {
					return "ERR21";
				}
				val = data[key].splice(0, data[key].length);
				if (forward.relType == "belongsTo") {
					// Reflect.set(data, key, undefined);		
					data[key] = undefined;
				}
			} else if (Array.isArray(data[key])) {
				var val = data[key].splice(0, data[key].length);
			}
			for (var i = 0; i < val.length; i++) {
				var ret;
				ret = this.createAndRelate(fModel, bModel, data, key, val[i], rel, partial, clone);
				if (ret != true) {
					return ret;
				}
			}
			return true;
		},
		createAndRelate: function createAndRelate(fModel, bModel, data, key, val, rel, partial, clone) {
			if (!rel.backward) {
				if (rel.forward.relatedTo === fModel._name) {
					rel.backward = rel.forward;
				}
				if (rel.backward === undefined) {
					return "ERR12";
				}
			}
			var pK = fModel._pK,
			    isComp = bModel.isComp,
			    isPoly = rel.forward && rel.forward.opts ? rel.forward.opts.polymorphic : undefined;
			var relatedRecord,
			    newPartial = partial && partial.hasOwnProperty(val[pK]) ? partial[val[pK]] : partial;
			if (!isComp && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == bModel.fieldList[bModel._pK].type && !clone) {
				relatedRecord = store.$.peekRecord(bModel._name, val);
			} else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == "object" && !Lyte.isRecord(val)) {
				relatedRecord = this.insertIntoStore(bModel._name, val, undefined, undefined, newPartial, undefined, undefined, clone);
			}
			if (relatedRecord && relatedRecord.$ && relatedRecord.$.isError) {
				store.$.cmpSet(data.$, "isError", true);
				// data.$.isError = true;
				var errObj = { code: "ERR24", message: Lyte.errorCodes.ERR24, data: data, error: relatedRecord.$.error };
				store.$.cmpSet(data.$.error, key, errObj);
			} else if (relatedRecord) {
				if (!this.hasDuplicateRelation(relatedRecord, data[key], bModel._pK, isPoly ? val._type : undefined, bModel)) {
					this.establishLink(rel.forward, rel.backward, data, relatedRecord, undefined, true, false);
				}
			} else {
				this.addToRelate(fModel._name, data, rel, val);
			}
			return true;
		},
		singleEstablishLink: function singleEstablishLink(forward, data, relatedRecord) {
			var relation = relatedRecord.$._relationships,
			    fModelName = data.$.model._name,
			    fRelKey = forward.relKey;
			relation[fModelName] = relation[fModelName] || {};
			relation[fModelName][fRelKey] = relation[fModelName][fRelKey] || [];
			if (!this.hasDuplicateRelation(data, relation[fModelName][fRelKey], data.$.model._pK, undefined, data.$.model)) {
				relation[fModelName][fRelKey].push(data);
			}
		},
		establishLink: function establishLink(forward, backward, data, relatedRecord, index, ignorePartial, isDuplicate, partRemoveOnly) {
			if (!relatedRecord) {
				return "ERR13";
			}
			if (!this.checkForCorrectRelation(forward, relatedRecord)) {
				return "ERR14";
			}
			var fRelKey = forward.relKey,
			    isPoly = forward.opts && forward.opts.polymorphic,
			    type = isPoly ? relatedRecord._type : undefined,
			    ignoreRel = {},
			    fSet = false;
			if (forward.relType == "belongsTo") {
				if (data[fRelKey] !== relatedRecord) {
					store.$.cmpSet(data, fRelKey, relatedRecord, undefined, true);
					if (data.$.partial && Object.keys(data.$.partial).length && data.$.partial[fRelKey]) {
						delete data.$.partial[fRelKey];
					}
					fSet = true;
				}
			} else if (forward.relType === "hasMany") {
				if (!data[fRelKey]) {
					store.$.cmpSet(data, fRelKey, [], undefined, true);
				}
				if (!data[fRelKey].model) {
					var relModel = relatedRecord.$.model;
					if (isPoly && type) {
						store.$.defProp(data[fRelKey], "polymorphic", true);
						relModel = store.modelFor(relModel.extend);
					}
					store.$.establishObserverBindings(data, data.$.model._properties);
					store.$.defArrUtls(data[fRelKey]);
					store.$.defPolyUtls(data[fRelKey]);
					store.$.defUtls(data[fRelKey], relModel, data, fRelKey);
				}
				var mdl = forward ? store.modelFor(forward.relatedTo) : undefined;
				if (isDuplicate == false || !this.hasDuplicateRelation(relatedRecord, data[fRelKey], forward ? mdl._pK : undefined, type, mdl)) {
					if (index != undefined) {
						this.handleArrOp(data[fRelKey], "insertAt", relatedRecord, index);
					} else {
						this.handleArrOp(data[fRelKey], "push", relatedRecord);
					}
					var ret;
					if ((!ignorePartial || partRemoveOnly) && forward.opts && forward.opts.serialize) {
						ret = store.$.partialData(data, fRelKey, relatedRecord.$.pK, "added", undefined, partRemoveOnly);
						ignoreRel.relKey = fRelKey;
						ignoreRel.model = data.$.model._name;
					}
					fSet = true;
				}
			}
			var fnest = false;
			if (!ignorePartial && fSet == true) {
				fnest = ret ? false : true;
			}
			if (backward === null) {
				if (relatedRecord.hasOwnProperty(bRelKey)) {
					delete relatedRecord[bRelKey];
				}
				return true;
			}
			if (backward.dummy || forward == backward) {
				this.singleEstablishLink(forward, data, relatedRecord);
			} else {
				var bRelKey = backward.relKey,
				    relRecMod = relatedRecord.$.model,
				    bSet = false;
				if (!this.checkForCorrectRelation(backward, data)) {
					return "ERR14";
				}
				if (backward.relType == "belongsTo") {
					if (relatedRecord[bRelKey] != undefined && relatedRecord[backward.relKey] !== data) {
						this.toDemolishLink(relRecMod, relatedRecord, backward, ignorePartial);
					}
					if (relatedRecord[bRelKey] !== data) {
						store.$.cmpSet(relatedRecord, bRelKey, data, undefined, true);
						if (relatedRecord.$.partial && Object.keys(relatedRecord.$.partial).length && relatedRecord.$.partial[bRelKey]) {
							delete relatedRecord.$.partial[bRelKey];
						}
						bSet = true;
					}
				} else if (backward.relType === "hasMany") {
					if (!relatedRecord[bRelKey]) {
						store.$.cmpSet(relatedRecord, bRelKey, [], undefined, true);
					}
					if (!relatedRecord[bRelKey].model) {
						store.$.defArrUtls(relatedRecord[bRelKey]);
						store.$.defPolyUtls(relatedRecord[bRelKey]);
						store.$.defUtls(relatedRecord[bRelKey], data.$.model, relatedRecord, bRelKey);
					}
					var bMdl = backward ? store.modelFor(backward.relatedTo) : undefined,
					    bret,
					    bnest;
					if (!this.hasDuplicateRelation(data, relatedRecord[bRelKey], backward ? bMdl._pK : undefined, type, bMdl)) {
						this.handleArrOp(relatedRecord[bRelKey], "push", data);
						if ((!ignorePartial || partRemoveOnly) && backward.opts && backward.opts.serialize) {
							bret = store.$.partialData(relatedRecord, bRelKey, data.$.pK, "added", undefined, partRemoveOnly);
						}
						if (!ignorePartial) {
							bnest = bret ? false : true;
						}
					}
				}
			}
			if (fnest) {
				if (forward.opts && forward.opts && forward.opts.deepNest) {
					var type = "added";
					if (data[forward.relKey].partial && data[forward.relKey].partial.get(relatedRecord.$.pK)) {
						type = data[forward.relKey].partial.get(relatedRecord.$.pK).type;
					}
					store.$.setDeepNest(data, forward.relKey, relatedRecord.$.pK, type);
					bnest = false;
				}
				// store.$.addDeepNest(relatedRecord, undefined, !ignorePartial ? "added" : undefined, ignoreRel);
				if (bnest) {
					if (backward && backward.opts && backward.opts.deepNest) {
						store.$.setDeepNest(relatedRecord, backward.relKey, data.$.pK, "added");
					}
				}
			}
			return true;
		},
		toDemolishRelation: function toDemolishRelation(model, index, ignorePartial, onlyRem, delayPers, partOnlyRem) {
			var record = model.data[index],
			    relations = model.relations,
			    storeUtils = this;
			for (var key in relations) {
				var rel = relations[key];
				for (var i = 0; i < rel.length; i++) {
					var relation = rel[i],
					    relatedModel = store.modelFor(relation.relatedTo);
					if (relatedModel) {
						var bRel = store.$.getBackwardRel(model, relation, relatedModel);
						// if(model._name == relatedModel._name){
						// 	var data = relatedModel.data,index1,index2;
						// 	for(index1=0 ; index1<data.length; index1++){
						// 		var item=data[index1];
						// 		if(Array.isArray(item[relkey])){
						// 			for(var index2=0;index2<item[relkey].length;index2++){
						// 				var value = item[relkey][index2];
						// 				if(value[relPriKey] == record[relPriKey] && onlyRem !== false && delayPers !== true)
						// 				{
						// 					storeUtils.handleArrOp(item[relkey],"removeAt",undefined,index2,1);
						// 				}
						// 			}
						// 		}
						// 		else if (Lyte.isRecord(item[relkey])){
						// 			if(item[relkey][relPriKey] == record[relPriKey] && onlyRem !== false && delayPers !== true)
						// 				{
						// 					item[relkey] = undefined ;
						// 				}
						// 		}
						// 	}
						// }
						if (!record[relation.relKey] && !relation.dummy && relation !== bRel) {
							continue;
						}
						this.toDemolishLink(model, record, relation, ignorePartial, onlyRem, delayPers, partOnlyRem);
					}
				}
			}
		},
		toDemolishLink: function toDemolishLink(model, record, relation, ignorePartial, onlyRem, delayPers, partOnlyRem) {
			var records = record[relation.relKey],
			    priKey = model._pK,
			    relatedModel = store.modelFor(relation.relatedTo);
			if (!relatedModel) {
				return;
			}
			var relPriKey = relatedModel._pK,
			    relatedModelName = relation.relatedTo,
			    bRelation = this.getBackwardRel(model, relation, relatedModel),
			    serialize = relation.opts ? relation.opts.serialize : undefined;
			if (relation.dummy || relation === bRelation) {
				records = this.getRelatedRecord(record, relation.relatedTo, relation.dummy ? relation.dummy : relation.relKey);
			}
			// if(bRelation.dummy){
			// 	bRelation.relKey = undefined;
			// }
			var pKs = [],
			    rec;
			if (bRelation) {
				if (Array.isArray(records)) {
					for (var i = 0; i < records.length; i++) {
						this.demolishLink(record, priKey, records[i], bRelation.relKey, relation, bRelation, ignorePartial, undefined, onlyRem, delayPers, partOnlyRem);
					}
				} else if (Lyte.isRecord(records)) {
					this.demolishLink(record, priKey, records, bRelation.relKey, relation, bRelation, ignorePartial, undefined, onlyRem, delayPers, partOnlyRem);
				}
			}
		},
		demolishSingleRelation: function demolishSingleRelation(record, fModelName, key, relatedRecord, priKey, onlyRem, delayPers) {
			var arr, index;
			if (Lyte.isRecord(record)) {
				arr = record.$._relationships;
				if (arr && arr[fModelName] && arr[fModelName][key] && onlyRem !== false && delayPers !== true) {
					arr = arr[fModelName][key];
					index = this.getIndex(arr, priKey, relatedRecord[priKey]);
					if (index > -1) {
						arr.splice(index, 1);
					}
				}
			}
		},
		demolishLink: function demolishLink(record, priKey, relatedRecord, bRelKey, relation, bRelation, ignorePartial, ignoreAttrCheck, onlyRem, delayPers, partOnlyRem) {
			var links = relatedRecord[bRelKey],
			    relMod = relatedRecord.$.model,
			    pKs = [];
			var pK = record.$.pK;
			var poly = links ? links.polymorphic : undefined,
			    polymorphicType;
			if (Array.isArray(links)) {
				var ind = this.getIndex(links, priKey, pK, poly ? record._type : undefined);
				var _attrs = relatedRecord.$._attributes;
				var initialVal = _attrs.hasOwnProperty(bRelKey) && _attrs[bRelKey] && _attrs[bRelKey].length ? relatedRecord.$.getInitialValues(bRelKey) : undefined;
				var toRem = links.partial && links.partial.has(pK) && links.partial.get(pK).type == "added" ? true : false;
				if (ind != -1 && (toRem || onlyRem !== false && delayPers !== true)) {
					poly ? polymorphicType = links[ind].$.model._name : undefined;
					this.handleArrOp(relatedRecord[bRelKey], "removeAt", undefined, ind, 1);
				}
				if (!ignoreAttrCheck && initialVal) {
					if (!store.$.hasRecordsArrayChanged(relatedRecord, bRelKey, initialVal)) {
						delete relatedRecord.$._attributes[bRelKey];
						if (!Object.keys(relatedRecord.$._attributes).length) {
							store.$.cmpSet(relatedRecord.$, "isModified", false);
							store.$.changePersist(relatedRecord, true);
							if (!relatedRecord.$.isNew) {
								store.$.deleteFromArray(relMod.dirty, relatedRecord[relMod._pK]);
								if (!relatedRecord.$.dN || relatedRecord.$.dN && !Object.keys(relatedRecord.$.dN).length) {
									store.$.removeParentNesting(relatedRecord);
								}
							}
						}
					}
				}
			} else if (links && ((typeof links === 'undefined' ? 'undefined' : _typeof(links)) == "object" || Lyte.isRecord(links)) && onlyRem !== false && delayPers !== true) {
				if (Lyte != undefined && Lyte.objectUtils != undefined) {
					Lyte.objectUtils(relatedRecord, "delete", bRelKey, undefined, undefined, true);
				} else {
					delete relatedRecord[bRelKey];
				}
			} else {
				this.demolishSingleRelation(relatedRecord, record.$.model._name, relation.relKey, record, priKey, onlyRem, delayPers);
			}
			if (!bRelation) {
				bRelation = relMod.fieldList[bRelKey];
			}
			if ((!ignorePartial || partOnlyRem) && onlyRem !== true) {
				var relType, isPartial, ret, nest, serz;
				if (bRelation) {
					if (bRelation.opts) {
						isPartial = bRelation.opts.serialize == "partial";
						serz = bRelation.opts.serialize ? true : false;
						nest = bRelation.opts.deepNest;
					}
					var relType = bRelation ? bRelation.relType : undefined;
				}
				// if(delayPers && bRelation && bRelation.opts && /^(id|record)$/.test(bRelation.opts.serialize)){
				// 	return;
				// }
				if (relType == "belongsTo" && serz && !record.$.isNew) {
					var partObj = relatedRecord.$.partial = relatedRecord.$.partial || {};
					if (partOnlyRem) {
						if (partObj && partObj.hasOwnProperty(bRelKey) && partObj[bRelKey].has(pK)) {
							partObj[bRelKey].delete(pK);
						}
						if (nest) {
							store.$.deleteDeepNest(relatedRecord, bRelKey, pK);
						}
						nest = false;
					} else {
						partObj = partObj[bRelKey] = partObj[bRelKey] || new Map();
						if (!partObj.has(pK)) {
							partObj.set(pK, {});
						}
						partObj = partObj.get(pK);
						partObj.type = "removed";
					}
				}
				if (bRelation && bRelation.opts && bRelation.opts.serialize) {
					ret = store.$.partialData(relatedRecord, bRelKey, pK, "removed", polymorphicType, partOnlyRem);
					nest = ret && relType == "hasMany" ? false : nest;
				}
				if (nest) {
					store.$.makeDirty("dirty", relatedRecord, "removed", bRelation, pK);
					store.$.addDeepNest(relatedRecord);
				}
			}
		},
		rllBckRecArr: function rllBckRecArr(oldVal, record, model, field) {
			var rel = {},
			    pK = model._pK,
			    relPK = store.modelFor(field.relatedTo)._pK;
			store.$.getRelations(model, field.relKey, store.modelFor(field.relatedTo), rel);
			for (var i = oldVal.length - 1; i >= 0; i--) {
				var records = oldVal[i].records;
				if (oldVal[i]._type == "added") {
					for (var j = 0; j < records.length; j++) {
						var relatedRecord = records[j];
						if (relatedRecord && relatedRecord.$ && relatedRecord.$.hasOwnProperty("pK")) {
							// temp check to know if record exist in store
							this.demolishLink(relatedRecord, relPK, record, rel.forward.relKey);
							if (rel.backward != null) {
								this.demolishLink(record, pK, relatedRecord, rel.backward.relKey, rel.forward);
							}
						}
					}
				} else if (oldVal[i]._type == "removed") {
					for (var j = records.length - 1; j >= 0; j--) {
						var relatedRecord = records[j];
						if (relatedRecord && relatedRecord.$ && relatedRecord.$.hasOwnProperty("pK")) {
							// temp check to know if record exist in store
							this.establishLink(rel.forward, rel.backward, record, relatedRecord, oldVal[i]._indices[j]);
						}
					}
				} else if (oldVal[i]._type == "changed") {
					var currentRecords = record[field.relKey];
					if (!Array.isArray(currentRecords)) {
						currentRecords = [currentRecords];
					}
					var self = this;
					var kLen = currentRecords.length;
					for (var k = 0; k < kLen; k++) {
						var relatedRecord = currentRecords[0];
						if (relatedRecord && relatedRecord.$ && relatedRecord.$.hasOwnProperty("pK")) {
							self.demolishLink(relatedRecord, relPK, record, rel.forward.relKey);
							if (rel.backward != null) {
								self.demolishLink(record, pK, relatedRecord, rel.backward.relKey, rel.forward);
							}
						}
					}
					if (!Array.isArray(records)) {
						records = [records];
					}
					for (var j = 0; j < records.length; j++) {
						var relatedRecord = records[j];
						if (typeof relatedRecord == "string") {
							relatedRecord = store.$.peekRecord(rel.forward.relatedTo, relatedRecord);
						}
						if (relatedRecord && relatedRecord.$ && relatedRecord.$.hasOwnProperty("pK")) {
							// temp check to know if record exist in store
							this.establishLink(rel.forward, rel.backward, record, relatedRecord, undefined);
						}
					}
				}
			}
		},
		sortBy: function sortBy(field, order) {
			var fieldArr = store.$.mapBy.call(this, field);
			var model = this.model;
			var fie = model.fieldList[field];
			if (fie && fie.type == "string") {
				fieldArr.sort();
				if (order == "desc") {
					fieldArr.reverse();
				}
			} else {
				fieldArr.sort(function (a, b) {
					return a - b;
				});
				if (order == "desc") {
					fieldArr.sort(function (a, b) {
						return b - a;
					});
				}
			}
			var oldArr = this.slice(0),
			    newArr = [];
			for (var i = 0; i < fieldArr.length; i++) {
				if (fieldArr[i] == undefined) {
					continue;
				}
				var index = store.$.getIndex(oldArr, field, fieldArr[i]);
				newArr.push(oldArr[index]);
				oldArr.splice(index, 1);
			}
			if (oldArr.length > 0) {
				if (order == "desc") {
					newArr = newArr.concat(oldArr);
				} else {
					newArr = oldArr.concat(newArr);
				}
			}
			store.$.defArrUtls(newArr);
			store.$.defUtls(newArr, this.model);
			return newArr;
		},
		mapBy: function mapBy(field) {
			return this.map(function (value) {
				return value.$.get(field);
			});
		},
		revertToOldVal: function revertToOldVal(record, attr, oldVal, rel) {
			if (oldVal == undefined || oldVal.length == 0) {
				return;
			} else {
				if (!Array.isArray(oldVal)) {
					oldVal = [oldVal];
				}
				for (var i = 0; i < oldVal.length; i++) {
					var fModel = rel.forward.relatedTo;
					var fRec = store.$.peekRecord(fModel, oldVal[i]);
					this.establishLink(rel.forward, rel.backward, record, fRec, undefined);
				}
			}
		},
		removePartial: function removePartial(record, key) {
			var parObj = record.$.partial;
			if (parObj && parObj[key]) {
				delete parObj[key];
			}
		},
		findCurrentInd: function findCurrentInd(model, pkVal) {
			var deleted = model._deleted;
			var handle = false,
			    currentInd,
			    finalInd;
			deleted.forEach(function (itm, idx) {
				if (handle) {
					if (itm.index < currentInd) {
						finalInd--;
					}
				}
				if (idx == pkVal) {
					handle = true;
					finalInd = currentInd = itm.index;
				}
			});
			return finalInd;
		},
		modifyDelInd: function modifyDelInd(model, pkVal) {
			var deleted = model._deleted;
			var handle = false,
			    currentInd;
			deleted.forEach(function (itm, idx) {
				if (handle) {
					if (itm.index >= currentInd) {
						itm.index = itm.index + 1;
					}
				}
				if (idx == pkVal) {
					handle = true;
					currentInd = itm.index;
				}
			});
		},
		rollBackDelete: function rollBackDelete(model, pkVal, index, inherit) {
			var arr = [],
			    modelName = model._name;
			if (!pkVal) {
				model._deleted.forEach(function (itm) {
					arr.push(itm);
				});
			} else {
				var deleted = model._deleted,
				    obj = deleted.get(pkVal),
				    pK = model._pK;
				arr = [obj];
			}
			var self = this,
			    len = arr.length;
			for (var i = len - 1; i >= 0; i--) {
				var obj = arr[i];
				var rec = obj.data;
				//var currentInd = store.$.findCurrentInd(model, pkVal);
				var isRecInModel = model.data._recMap ? model.data._recMap.get(rec.$.pK) : model.data.indexOf(rec) !== -1;
				if (Lyte.isRecord(rec)) {
					store.$.cmpSet(rec.$, "isDeleted", false);
					store.$.changePersist(rec, true);
					var isDuplicate = store.$.isDuplicateRecord(model, rec);
					if (!isRecInModel) {
						if (index) {
							self.handleArrOp(model.data, "insertAt", rec, obj.index);
							// store.$.modifyDelInd(model, pkVal);
						} else {
							self.handleArrOp(model.data, "push", rec);
						}
						model.emit("add", [rec]);
						store.emit("add", [model._name, rec]);
						var relArr = model.relations;
						if (relArr) {
							for (var key in relArr) {
								var rel = relArr[key] || [];
								rel.forEach(function (item) {
									var key = item.relKey,
									    bRel,
									    bMod,
									    data;
									// if(rec.hasOwnProperty(key)){
									bMod = store.modelFor(item.relatedTo);
									bRel = self.getBackwardRel(model, item, bMod);
									if (!item.relKey || item == bRel) {
										data = store.$.getRelatedRecord(rec, item.relatedTo, item.dummy ? item.dummy : item.relKey);
									} else {
										data = rec[item.relKey];
									}
									if (Array.isArray(data)) {
										data.forEach(function (itm, ind) {
											if (item == bRel) {
												self.establishLink(bRel, item, itm, rec, undefined, false);
											} else {
												self.establishLink(item, bRel, rec, itm, undefined, false);
											}
										});
									} else {
										if (item == bRel) {
											self.establishLink(bRel, item, data, rec, undefined, false);
										} else {
											self.establishLink(item, bRel, rec, data, undefined, false);
										}
									}
									// }
								});
							}
						}
					} else {
						store.$.addDeepNest(rec, undefined, "added");
					}
					// else if (isRecInModel){
					// 	var relArr = model.relations;
					// 	var _rel = isRecInModel.$._relationships;
					// 	for(var r in _rel){
					// 		var mdl_rec = _rel[r]
					// 		for(var _k in mdl_rec){
					// 			var records = mdl_rec[_k]
					// 			var mdl = store.modelFor(r);
					// 			var rel = mdl.fieldList[_k]
					// 			if(rel.opts && rel.opts.serialize && rel.opts.serialize == "partial"){
					// 				if(Array.isArray(records)){
					// 					records.forEach(function(rec){
					// 						var partData = rec[_k].partial;
					// 						partData.delete(pkVal);
					// 					})
					// 				}
					// 			}
					// 		}
					// 	}
					// }
					// else{
					// 	Lyte.error("Cannot rollback record of model, since another instance of same record exists in store");
					// }
					var cqueries = store.model.cachedQueries;
					if (cqueries) {
						var Nm = cqueries[modelName],
						    n = modelName;
						if (Nm && Nm.length) {
							for (var j = Nm.length - 1; j >= 0; j--) {
								var obj = Nm[j];
								if (obj && obj.hasDeletedRecords) {
									var ind = obj.data[modelName].indexOf(rec);
									if (ind != -1) {
										delete obj.hasDeletedRecords;
									}
								}
							}
						}
					}
					if (rec.$.isNew || rec.$.isModified) {
						this.checkAndAddToArray(model.dirty, rec[model._pK]);
					}
					store.$.clrRecErr(rec.$, pK, "ERR17");
					!isDuplicate ? model.data._recMap.set(_typeof(rec.$.pK) == "object" ? rec.$.pK : rec.$.pK.toString(), rec) : undefined; //old handling
					model._deleted.delete(rec.$.pK);
				}
			}
		},
		rollBackNew: function rollBackNew(model, record, pK, inherit) {
			store.$.removeFromStore(model, record.$.pK, true, inherit);
			// var pkVal = record.$.pK;
			// var index = this.getIndex(model.data, pK, pkVal);
			// store.$.toDemolishRelation(model, index);
			// this.handleArrOp(model.data,"removeAt",undefined,index,1);
			// // record.$.isNew = false;
			// store.$.cmpSet(record.$, "isNew", false);
			// store.$.cmpSet(record, "$",  {});
			// model.emit("remove", [record]);
			// store.emit("remove", [model._name,record]);
			// this.deleteFromArray(model.dirty, pkVal);
		},
		emit: function emit(type, record, attr, err) {
			record.$.emit(type, [record, attr, err]);
			record.$.model.emit(type, [record, attr, err]);
			store.emit(type, [record.$.model._name, record, attr, err]);
		},
		hasRecordsArrayChanged: function hasRecordsArrayChanged(record, attr, old) {
			var arr = old || record.$.getInitialValues(attr),
			    changed = true,
			    pK = record.$.model._pK;
			if (arr && arr.length == record[attr].length) {
				changed = false;
				for (var i = 0; i < arr.length; i++) {
					if (record[attr].indexOf(arr[i]) == -1) {
						return true;
					}
				}
			}
			return changed;
		},
		setRecErr: function setRecErr($record, field, code, value) {
			store.$.cmpSet($record, "isError", true);
			var errObj = code;
			if ((typeof errObj === 'undefined' ? 'undefined' : _typeof(errObj)) == "object") {
				store.$.cmpSet($record.error, field, errObj);
			} else {
				if (typeof code == "string") {
					var errMes = Lyte.errorCodes[code];
					if (errMes) {
						errObj = { code: code, message: Lyte.errorCodes[code] };
					} else {
						errObj = code;
					}
				}
				store.$.cmpSet($record.error, field, errObj);
				if (value) {
					store.$.cmpSet($record.error[field], "value", value);
				}
			}
			store.$.emit("error", $record.record, field, errObj);
		},
		clrRecErr: function clrRecErr($record, field, code) {
			var objUtl = Lyte.objectUtils;
			var $err = $record.error;
			if (code) {
				if ($record.error.code == code) {
					if (typeof objUtl != "undefined") {
						objUtl($err, "delete", field);
					} else {
						delete $err[field];
					}
				}
			} else if (field) {
				if (typeof objUtl != "undefined") {
					objUtl($err, "delete", field);
				} else {
					delete $err[field];
				}
			} else {
				if (typeof objUtl != "undefined") {
					for (var err in $err) {
						objUtl($err, "delete", err);
					}
				} else {
					$record.error = {};
				}
			}
			if (Object.keys($record.error).length == 0) {
				store.$.cmpSet($record, "isError", false);
			}
		},
		cacheQuery: function cacheQuery(modelName, _cacheQuery, data, status) {
			var cq = store.model.cachedQueries;
			cq = store.model.cachedQueries = cq || {};
			cq = cq[modelName] = cq[modelName] || [];
			cq.push({ cacheQuery: _cacheQuery, data: data, status: status });
		},
		cacheRecordQuery: function cacheRecordQuery(modelName, key, cacheQuery, data, status) {
			var crq = store.model.cachedRecordQueries;
			crq = store.model.cachedRecordQueries = crq || {};
			crq = crq[modelName] = crq[modelName] || {};
			crq = crq[key] = crq[key] || [];
			crq.push({ cacheQuery: cacheQuery, data: data, status: status });
		},
		isModelDataArray: function isModelDataArray(data) {
			if (Array.isArray(data) && (data.modelless || data.model && data.model instanceof Model && !data.polymorphic)) {
				return true;
			}
		},
		handleArrOp: function handleArrOp(data, type, obj, pos, len) {
			len = len != undefined ? len : 0;
			var toBind = typeof Lyte.arrayUtils != "undefined" ? true : false,
			    ret,
			    sort;
			if (data.key && data.record) {
				var fld = data.record.$.model.fieldList[data.key],
				    srtObs = false;
				if (fld && fld.opts && fld.opts.sort) {
					if (fld.opts.sort.sortFn) {
						sort = fld.opts.sort.sortFn;
						if (fld.opts.sort.observes) {
							srtObs = true;
						}
					} else {
						sort = { sortBy: fld.opts.sort.sortBy || "$.created_Time", sortOrder: fld.opts.sort.sortOrder };
					}
				}
			} else if (data.model && data.model.sort) {
				if (!data.model.sort.sortBy) {
					sort = { sortBy: "$.created_Time", sortOrder: data.model.sort.sortOrder, defaultSort: true };
				} else {
					sort = { sortBy: data.model.sort.sortBy, sortOrder: data.model.sort.sortOrder };
				}
			}
			switch (type) {
				case "push":
					{
						if (this.isModelDataArray(data)) {
							// !data.record ? data.model._pkMap.set(obj.$.pK, {pkVal : obj.$.pK}) : undefined; //for push in model data
							data._recMap == undefined ? store.$.defProp(data, "_recMap", new Map()) : undefined;
							if (!data.modelless) {
								data._recMap.set(_typeof(obj.$.pK) == "object" ? obj.$.pK : obj.$.pK.toString(), obj);
							} else {
								data._recMap.set(obj[data.pK], obj);
							}
						}
						if (!sort) {
							ret = toBind ? Lyte.arrayUtils(data, type, obj) : data.push(obj);
						} else {
							ret = toBind ? Lyte.arrayUtils(data, "sort", sort, [obj]) : data.push(obj);
						}
						if (srtObs && obj && obj.$) {
							!obj.$.hasOwnProperty("srtObs") ? store.$.defProp(obj.$, "srtObs", true, false, true) : undefined;
						}
						break;
					}
				case "removeAt":
					{
						if (this.isModelDataArray(data)) {
							var cpyLen = len;
							for (var i = 0; i < cpyLen; i++) {
								var mpKey = undefined;
								if (!data.modelless) {
									var pkVal = data[pos + i] ? data[pos + i].$.pK : undefined;
									pkVal = (typeof pkVal === 'undefined' ? 'undefined' : _typeof(pkVal)) == "object" ? pkVal : pkVal.toString();
									mpKey = pkVal;
								} else {
									mpKey = data[pos + i][data.pK];
								}
								mpKey !== undefined && data._recMap ? data._recMap.delete(mpKey) : undefined;
							}
						}
						var _rec = data[pos];
						if (srtObs && _rec && _rec.$ && !store.$.changeRelPkMaps(_rec, undefined, undefined, "srtObsChk", data.key)) {
							_rec.$.hasOwnProperty("srtObs") ? _rec.$.srtObs = false : undefined;
						}
						ret = toBind ? Lyte.arrayUtils(data, type, pos, len) : data.splice(pos, len);
						break;
					}
				case "insertAt":
					{
						if (this.isModelDataArray(data)) {
							data._recMap == undefined ? store.$.defProp(data, "_recMap", new Map()) : undefined;
							if (!data.modelless) {
								data._recMap.set(_typeof(obj.$.pK) == "object" ? obj.$.pK : obj.$.pK.toString(), obj);
							} else {
								data._recMap.set(obj[data.pK], obj);
							}
						}
						if (!sort) {
							ret = toBind ? Lyte.arrayUtils(data, type, pos, obj) : data.splice(pos, len, obj);
						} else {
							ret = toBind ? Lyte.arrayUtils(data, "sort", sort, [obj]) : data.splice(pos, len, obj);
						}
						if (srtObs && obj && obj.$) {
							!obj.$.hasOwnProperty("srtObs") ? store.$.defProp(obj.$, "srtObs", true, false, true) : undefined;
						}
						break;
					}
				case "replaceAt":
					{
						if (!sort) {
							ret = toBind ? Lyte.arrayUtils(data, type, pos, obj) : data.splice(pos, len, obj);
						} else {
							ret = toBind ? Lyte.arrayUtils(data, "sort", sort, [obj]) : data.splice(pos, len, obj);
						}
						if (srtObs && obj && obj.$) {
							!obj.$.hasOwnProperty("srtObs") ? store.$.defProp(obj.$, "srtObs", true, false, true) : undefined;
						}
						break;
					}
				case "sort":
					{
						ret = Lyte.arrayUtils(data, "sort", sort);
						break;
					}
				default:
					{
						Lyte.error("LD07", type);
						break;
					}
			}
			return ret;
		},
		defpayObjUtls: function defpayObjUtls(obj) {
			Object.defineProperties(obj, {
				set: {
					value: store.$.payloadSet
				},
				remove: {
					value: store.$.payloadRemove
				}
			});
		},
		defPayArrUtls: function defPayArrUtls(obj) {
			Object.defineProperties(obj, {
				add: {
					value: store.$.payloadAdd
				},
				remove: {
					value: store.$.payloadRemove
				}
			});
		},
		defArrUtls: function defArrUtls(obj) {
			Object.defineProperties(obj, {
				filterBy: {
					value: store.$.filterBy
				},
				sortBy: {
					value: store.$.sortBy
				},
				mapBy: {
					value: store.$.mapBy
				}
			});
		},
		defPolyUtls: function defPolyUtls(obj) {
			Object.defineProperties(obj, {
				add: {
					value: store.$.add
				},
				remove: {
					value: store.$.remove
				}
			});
		},
		defUtls: function defUtls(obj, model, record, key) {
			if (model) {
				store.$.defProp(obj, "model", model);
				// if(model._fldGrps && model._fldGrps.hasOwnProperty("srtObs")){
				// 	store.$.defProp(obj, "srtObs", true, false, true);
				// }
			}
			if (record) {
				store.$.defProp(obj, "record", record, false, true);
			}
			if (key) {
				store.$.defProp(obj, "key", key);
			}
		},
		defPar: function defPar(arr) {
			store.$.defProp(arr, "partial", new Map());
		},
		cmpSet: function cmpSet(obj, key, value, opts, fromStore) {
			if (typeof Lyte.Component != "undefined") {
				// obj = Lyte.isRecord(obj) && obj.$.delayPersistence ? obj.$._data : obj;
				Lyte.Component.set(obj, key, value, opts, fromStore);
			} else {
				obj[key] = value;
			}
		},
		defProp: function defProp(scp, key, val, enume, write) {
			enume = !enume ? false : true;
			write = !write ? false : true;
			Object.defineProperty(scp, key, {
				value: val,
				enumerable: enume,
				writable: write
			});
		},
		removeChildRecords: function removeChildRecords(scope, record, recMap, partOnlyRem) {
			if (!recMap.get(record) && scope) {
				recMap.set(record, true);
				var pkval = record ? record.$.pK : undefined,
				    arrPK = [];
				var r = scope._fldGrps.inherit;
				for (var v in r) {
					var fkey = r[v].relKey ? r[v].relKey : undefined;
					if (record && fkey) {
						if (scope.fieldList[fkey].relType == "belongsTo" && record[scope.fieldList[fkey].relKey]) {
							this.removeChildRecords(store.modelFor(scope.fieldList[fkey].relatedTo), record[scope.fieldList[fkey].relKey], recMap);
						} else if (scope.fieldList[fkey].relType == "hasMany" && record[scope.fieldList[fkey].relKey]) {
							var len = record[scope.fieldList[fkey].relKey].length;
							for (var v1 = len - 1; v1 >= 0; v1--) {
								this.removeChildRecords(store.modelFor(scope.fieldList[fkey].relatedTo), record[scope.fieldList[fkey].relKey][v1], recMap);
							}
						}
					}
				}
				arrPK.push(pkval);
				this.removeFromStore(scope, arrPK, true, true, undefined, undefined, partOnlyRem);
			}
		},
		rBinherit: function rBinherit(scope, recmp) {
			var record = scope.record,
			    rel = scope.model._fldGrps.inherit;
			for (var v in rel) {
				if (rel[v].opts && rel[v].opts.inherit && record[rel[v].relKey]) {
					if (rel[v].relType === "belongsTo") {
						var _record = record[rel[v].relKey];
						if (_record && !recmp.get(_record)) {
							recmp.set(_record, true);
							this.rollBackRecord(_record.$, { inherit: true });
							store.$.rBinherit(_record.$, recmp);
						}
					} else if (rel[v].relType === "hasMany") {
						var rel_len = record[rel[v].relKey].length;
						if (rel_len != 0) {
							for (var j = rel_len - 1; j >= 0; j--) {
								var _record = record[rel[v].relKey][j];
								if (_record && !recmp.get(_record)) {
									recmp.set(_record, true);
									this.rollBackRecord(_record.$, { inherit: true });
									store.$.rBinherit(_record.$, recmp);
								}
							}
						}
					}
				}
			}
		},
		rollBackRecord: function rollBackRecord(scope, inherit) {
			var model = scope.model,
			    pK = model._pK;
			if (scope.isModified) {
				scope.rollBackAttributes(scope.getDirtyAttributes(), inherit);
				delete scope._savedState;
			}
			if (scope.isDeleted) {
				store.$.rollBackDelete(model, scope.get(pK), undefined, inherit);
			} else if (scope.isNew) {
				store.$.rollBackNew(model, scope.record, pK, inherit);
			} else if (scope.isError) {
				store.$.clrRecErr(scope);
			}
			store.$.removeOnSave(scope.model._name, scope.record.$.pK);
		},
		buildVariables: function buildVariables(gqlvar, variables, key, type) {
			gqlvar = gqlvar ? gqlvar : {};
			for (var v in variables) {
				if (variables[v].search(/!/g) != -1) {
					if (!gqlvar[v] && !key) {
						return { LdEr: "LD30", LyteError: "ERR30", "key": v };
					}
				}
				if (variables[v].search(/!/g) != -1) {
					variables[v] = variables[v].replace(/!/g, "");
				}
				if (key && variables[v].search(/\./g) == -1) {
					if (variables[v] == "ID" || variables[v] == "ID!") {
						gqlvar[v] = key;
					}
				}
				var ErrObj = { LdEr: "LD31", LyteError: "ERR30", "key": v };
				if (gqlvar && gqlvar[v]) {
					switch (variables[v]) {
						case "Int":
							if (typeof gqlvar[v] != "number") {
								return ErrObj;
							}
							break;
						case "String":
							if (typeof gqlvar[v] != "string") {
								return ErrObj;
							}
							break;
						case "Float":
							if (typeof gqlvar[v] != "number") {
								return ErrObj;
							}
							break;
						case "Boolean":
							if (typeof gqlvar[v] != "boolean") {
								return ErrObj;
							}
							break;
						case "Object":
							if (_typeof(gqlvar[v]) != "object") {
								return ErrObj;
							}
							break;
					}
				}
			}
			for (var t in gqlvar) {
				if (typeof gqlvar[t] == "string" || _typeof(gqlvar[t]) == "object") {
					gqlvar[t] = store.$.LyteStringfy(gqlvar[t], "");
				}
			}
			return gqlvar;
		},
		buildQuery: function buildQuery(modelName, type, fieldArr, variables, parent, qname, sendvar, key, LocalAttrs, Pmodel) {
			var str = "",
			    ignore = false;
			for (var v in fieldArr) {
				if (_typeof(fieldArr[v]) == "object") {
					str += Object.keys(fieldArr)[0] + " ";
					if (sendvar) {
						str += "( ";
						//str+=(key?"id: "+key:'')+" ";
						for (var s in sendvar) {
							if (s.search(/[.]/g) == -1 && parent == '') {
								str += s + ":" + sendvar[s] + " ";
							} else if (parent != '' && s.search(/[.]/g) != -1) {
								//var pcheck=s.replace(".","_");
								if (parent == s.match(/.*(?=\..*$)/g)[0]) {
									var split = s.split('.');
									str += split[split.length - 1] + ":" + sendvar[s] + " ";
								}
							}
						}
						str += ") ";
						str = str.replace(/\([ ]*\)/g, "");
					}
					str += "{ ";
					for (var i = 0; i < fieldArr[v].length; i++) {
						var v1 = fieldArr[v][i];
						ignore = false;
						if (LocalAttrs) {
							ignore = typeof v1 == "string" && LocalAttrs.includes(v1) && parent == "" ? true : (typeof v1 === 'undefined' ? 'undefined' : _typeof(v1)) == "object" && LocalAttrs.includes(Object.keys(v1)[0]) && parent == "" ? true : false;
						}
						if (!ignore) {
							if (typeof v1 == "string") {
								str = str + v1 + " ";
							} else {
								parent = (parent ? parent + "." : "") + Object.keys(v1)[0];
								str += store.$.buildQuery(modelName, type, v1, variables, parent, qname, sendvar, key, LocalAttrs, Pmodel);
								parent = v == qname ? "" : v;
							}
						}
					}
					str += " } ";
				}
			}
			return str;
		},
		QueryCallback: function QueryCallback(modelName, type, parent, fieldArr, variables, qstuct, qv, queryParams, urlObj) {
			var mdl;
			if ((typeof fieldArr === 'undefined' ? 'undefined' : _typeof(fieldArr)) == "object") {
				var key = Object.keys(fieldArr)[0];
				for (var i = 0; i < fieldArr[key].length; i++) {
					var v = fieldArr[key][i];
					if ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) == "object" && store.modelFor(modelName).fieldList[Object.keys(v)[0]] && store.modelFor(modelName).fieldList[Object.keys(v)[0]].relatedTo) {
						mdl = store.modelFor(modelName).fieldList[Object.keys(v)[0]].relatedTo;
						store.$.QueryCallback(mdl, type, parent, v, variables, qstuct, qv, queryParams, urlObj);
					}
				}
				//console.log("selfquery",modelName,fieldArr,variables);
				var res = store.$.initCB("serializer", modelName, "serializeSelfQuery", { args: [modelName, type, urlObj, fieldArr, variables, qstuct] });
				if (res) {
					var qst = res.data[Object.keys(fieldArr)[0]];
					fieldArr[Object.keys(fieldArr)[0]] = qst;
				}
			}
			// modelName=parent;
		},
		buildFields: function buildFields(modelName, parent, key, pModel, marr, properties) {
			var mdl = store.modelFor(modelName),
			    mdlfl = mdl.fieldList;
			var LocalAttrs = mdl.gql && mdl.gql.localAttrs ? mdl.gql.localAttrs : [];
			if (!properties) {
				marr.set(modelName, true);
			} else {
				mdlfl = properties;
			}
			var obj = {},
			    arr = [];
			for (var v in mdlfl) {
				if (!LocalAttrs.includes(v)) {
					if (mdlfl[v].type == "relation") {
						if (store.modelFor(mdlfl[v].relatedTo) && mdlfl[v].relatedTo != pModel && mdlfl[v].relatedTo != modelName) {
							var check = store.$.getBackwardRel(store.modelFor(modelName), mdlfl[v], store.modelFor(mdlfl[v].relatedTo));
							if (check && check.relatedTo == parent && check.dummy == undefined) {
								continue;
							} else {
								var flag = 0;
								// for(var item =0; item<marr.length;item++){
								// 	var check_=store.$.getBackwardRel(store.model[modelName],mdlfl[v],store.model[marr[item]]);
								// 	if(check_ && check_.relatedTo==modelName && check_.dummy == undefined){
								// 		flag=1;
								// 	}
								// }
								if (!marr.has(mdlfl[v].relatedTo)) {
									arr.push(store.$.buildFields(mdlfl[v].relatedTo, mdlfl[v].relatedTo, v, pModel, marr));
								}
							}
						}
						continue;
					} else if (mdlfl[v].type == "object" && mdlfl[v].properties) {
						arr.push(store.$.buildFields(modelName, parent, v, pModel, marr, mdlfl[v].properties));
					} else {
						arr.push(v);
					}
				}
			}
			obj[key] = arr;
			marr.delete(modelName);
			return obj;
		},
		parseQuery: function parseQuery(modelName, key, type, queryParams, gqlObj, mdlq, gqlvar, urlObj, LocalAttrs, payLoad, customData) {
			var qstr,
			    qv,
			    qlvar = {},
			    ret = {},
			    sendvar,
			    qkey = {};
			if ((typeof mdlq === 'undefined' ? 'undefined' : _typeof(mdlq)) == "object") {
				var qstuct, sq, mparent, k;
				var k = Object.keys(mdlq.query);
				var queryName = k[0] != "variables" ? k[0] : k[1];
				qv = Object.assign({}, mdlq.query.variables);
				qkey[k[0] != "variables" ? k[0] : k[1]] = Object.assign(mdlq.query[k[0] != "variables" ? k[0] : k[1]]);
				if ((typeof qkey === 'undefined' ? 'undefined' : _typeof(qkey)) == "object") {
					qstuct = qkey;
				}
			}
			if (typeof mdlq == "string" && mdlq.search(/[ ]/g) != -1) {
				var cquery = mdlq,
				    cvar = {},
				    qst = '';
				cquery = cquery.replace(new RegExp('\n', 'g'), " ");
				cquery = cquery.replace(/ *[ ]*\(/g, ":{variables:[");
				cquery = cquery.replace(/ *\) *{/g, "],attrs:[");
				cquery = cquery.replace(/\w+/g, '"$&"');
				cquery = cquery.replace(/"!/g, '!"');
				cquery = cquery.replace(/" +"/g, '", "');
				cquery = cquery.replace(/\S+{"variables"/g, "{$&");
				cquery = cquery.replace(/} *"/g, '}, "');
				cquery = cquery.replace(/" *{/g, '" :{"attrs" :[');
				cquery = cquery.replace(/\} *\}/g, "]}}");
				cquery = cquery.replace(/" *}/g, '"]} }');
				cquery = cquery.replace(/]}}/g, "]}}]}}");
				cquery = cquery.replace(/]}}]}} *}/g, "]}}]}}]}}");
				cquery = cquery.replace(/} *{/g, "},{");
				cquery = cquery.replace(/\S+ *:{"attrs"/g, "{$&");
				cquery = JSON.parse(cquery);
				qstuct = store.$.buildQueryFields(cquery, cvar, qst, Object.keys(cquery)[0]);
				qv = cvar;
			}
			if ((typeof qstuct === 'undefined' ? 'undefined' : _typeof(qstuct)) == "object") {
				store.$.QueryCallback(modelName, type, modelName, qstuct, gqlvar, qstuct, qv, queryParams, urlObj);
				gqlObj.query = qstuct;
				if (gqlvar) {
					gqlObj.variables = gqlvar;
				}
				var qvkey = Object.keys(qv)[0];
				gqlObj.type == "Mutation" && Object.keys(qv).length == 1 && (qv[qvkey] == "Object" || qv[qvkey] == "Object!") ? gqlObj.variables[qvkey] = payLoad : gqlObj.variables;
				var res = store.$.initCB("serializer", modelName, "serializeGqlQuery", { args: [modelName, type, key, gqlObj, urlObj, payLoad, customData] });
				if (res) {
					qstuct = res.data.query;
					if (res.data.variables) {
						gqlvar = res.data.variables;
					}
				}
				sendvar = store.$.buildVariables(gqlvar, qv, key, urlObj.type);
				if (sendvar && sendvar.LdEr) {
					return sendvar;
				}
				urlObj.gqlObj = gqlObj;
				qstr = store.$.buildQuery(modelName, type, qstuct, qv, '', Object.keys(qstuct)[0], Object.keys(sendvar).length != 0 ? sendvar : undefined, key, LocalAttrs, modelName);
				qstr = '{ ' + qstr + ' }';
			}
			gqlObj.type == "Query" ? ret.query = qstr : ret.query = 'mutation ' + qstr;
			return ret;
		},
		graphQlconfig: function graphQlconfig(modelName, key, type, queryParams, oprName, gqlvar, urlObj, payLoad, customData) {
			var gQobj = {},
			    model = store.modelFor(modelName),
			    mdlq,
			    mdq,
			    gqlObj = {},
			    mp = new Map();
			var LocalAttrs = model.gql && model.gql.localAttrs ? model.gql.localAttrs : [];
			if (type == "findAll" || type == "findRecord") {
				gqlObj.type = "Query";
				mdq = model.gql && model.gql.query && model.gql.query[oprName] ? model.gql.query[oprName] : oprName;
				if (mdq === undefined) {
					var stq = store.$.buildFields(modelName, null, modelName, modelName, mp);
					mdlq = {};
					mdlq.query = stq;
					gqlObj.queryType = "default";
				} else {
					if (typeof oprName == "string" && oprName.search(/[ ]/g) != -1) {
						mdlq = oprName;
						gqlObj.queryType = "query";
					} else if ((typeof oprName === 'undefined' ? 'undefined' : _typeof(oprName)) == "object") {
						mdlq = oprName;
					} else if ((typeof mdq === 'undefined' ? 'undefined' : _typeof(mdq)) == "object") {
						mdlq = mdq;
					} else {
						if (typeof mdq == "string" && mdq.search(/[ ]/g) != -1) {
							mdlq = mdq;
							gqlObj.queryType = "namedQuery";
							gqlObj.queryName = oprName;
						} else {
							return { LdEr: "LD32", LyteError: "ERR31", key: oprName };
						}
					}
				}
				gqlvar = gqlvar ? Object.assign({}, gqlvar) : undefined;
			} else {
				gqlObj.type = "Mutation";
				mdq = model.gql && model.gql.mutation && model.gql.mutation[oprName] ? model.gql.mutation[oprName] : oprName;
				if (typeof oprName == "string" && oprName.search(/[ ]/g) != -1) {
					mdlq = oprName;
					gqlObj.mutationType = "customMutation";
				} else {
					if (typeof mdq == "string" && mdq.search(/[ ]/g) != -1) {
						mdlq = mdq;
						gqlObj.mutationType = "namedMutation";
						gqlObj.MutationName = oprName;
					} else {
						return { LdEr: "LD32", LyteError: "ERR31", key: oprName };
					}
				}
			}
			var sendQuery = store.$.parseQuery(modelName, key, type, queryParams, gqlObj, mdlq, gqlvar, urlObj, LocalAttrs, payLoad, customData);
			if (!sendQuery.LdEr) {
				gQobj.data = JSON.stringify(sendQuery);
				return gQobj.data;
			}
			return sendQuery;
		},
		setQuery: function value(scope, key, type, Query) {
			var model = scope;
			if (model.gql) {
				model.gql[type] = model.gql[type] ? model.gql[type] : {};
				model.gql[type][key] = model.gql[type][key] ? model.gql[type][key] : {};
			} else {
				model.gql = {};
				model.gql[type] = {};
				model.gql[type][key] = {};
			}
			model.gql[type][key] = Query;
		},
		buildQueryFields: function buildQueryFields(fields, variable, parent, objkey) {
			var key = Object.keys(fields)[0],
			    arr = [],
			    query = {};
			if (fields[key].variables) {
				for (var i = 0; i < fields[key].variables.length; i = i + 2) {
					variable[(parent ? parent + "." : "") + fields[key].variables[i]] = fields[key].variables[i + 1];
				}
			}
			for (var q = 0; q < fields[key].attrs.length; q++) {
				if (_typeof(fields[key].attrs[q]) == "object") {
					parent = (parent ? parent + "." : "") + Object.keys(fields[key].attrs[q])[0];
					arr.push(this.buildQueryFields(fields[key].attrs[q], variable, parent, objkey));
					parent = key != objkey ? key : "";
				} else {
					arr.push(fields[key].attrs[q]);
				}
			}
			query[key] = arr;
			return query;
		},
		LyteStringfy: function LyteStringfy(object, string, fs) {
			if (typeof object == "string") {
				return '\"' + object + '"\ ';
			} else if (Array.isArray(object)) {
				string += '[';
				var i = 0,
				    len = object.length;
				object.forEach(function (val) {
					i++;
					if (typeof val == "string") {
						string = string + '\"' + val + '"\ ';
					} else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == "object") {
						string = store.$.LyteStringfy(val, string);
					} else if (typeof val == "number") {
						string = string + object.toString();
					}
					string = i != len ? string + ',' : string;
				});
				string += ']';
			} else if (object && !Array.isArray(object) && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) == "object") {
				string = string + '{';
				var j = 0;
				for (var i in object) {
					j++;
					if (typeof object[i] == "string") {
						string = string + i + ' : \"' + object[i] + '"\ ';
					} else if (_typeof(object[i]) == "object") {
						string = string + i + " : ";
						string = store.$.LyteStringfy(object[i], string);
					} else {
						string = string + i + ' : ' + object[i].toString();
					}

					if (Object.keys(object).length != j) {
						string = string + ', ';
					}
				}
				string = string + '}';
			} else {
				return object.toString();
			}
			return string;
		},
		cpdGql: function cpdGql(modelName, type, qp, urlObj, changedData, customData) {
			var createdVariables = [];
			if (urlObj.gql) {
				if (_typeof(urlObj.gql) == "object") {
					mutName = urlObj.gql.mutation;
				} else if (urlObj.gql == true) {
					mutName = undefined;
				}
				urlObj.data = store.$.graphQlconfig(modelName, undefined, type, qp, mutName, createdVariables, urlObj, changedData, customData);
			}
		},
		payloadAdd: function payloadAdd(key, index) {
			if (!Array.isArray(key)) {
				key = [key];
			}
			var modelName = this._model,
			    partObj = this._partialObj,
			    payload = this._payloadObj;
			var field = { opts: { serialize: this._serialize } };
			var _pk = {},
			    partial = {};
			for (var i = 0; i < key.length; i++) {
				if (partObj._removedRecords && partObj._removedRecords.hasOwnProperty(key[i])) {
					_pk = partObj._removedRecords[key[i]]._payload;
					partial = partObj._removedRecords[key[i]]._partial;
					delete partObj._removedRecords[key[i]];
				} else {
					var record = store.$.peekRecord(modelName, key[i]);
					var data = store.$.PayloadSerialize(field, _pk, record, undefined, store.modelFor(modelName), partial);
					_pk = data.payload;
					partial = data.partial;
				}
				if (!this.partRecMap.get(key[i])) {
					if (index != undefined && typeof index == "number") {
						Lyte.arrayUtils(partObj, "insertAt", index, partial);
						Lyte.arrayUtils(payload, "insertAt", index, _pK);
						index = index++;
					} else {
						Lyte.arrayUtils(partObj, "push", partial);
						Lyte.arrayUtils(payload, "push", _pk);
					}
					this.partRecMap.set(key[i], true);
				}
			}
		},
		payloadRemove: function payloadRemove(key) {
			var modelName = this._model,
			    partObj = this._partialObj,
			    payload = this._payloadObj;
			if (!Array.isArray(key)) {
				key = [key];
			}
			for (var j = 0; j < key.length; j++) {
				if (Array.isArray(payload)) {
					var len = payload.length;
					if (this._serialize && this._serialize == "id") {
						if (payload.includes(key[j])) {
							var _index = payload.indexOf(key[j]);
							payload.splice(_index, 1);
						}
					} else {
						for (var i = 0; i < len; i++) {
							if (partObj[i] && partObj[i].$.pkVal == key[j]) {
								if (!partObj.hasOwnProperty("_removedRecords")) {
									var val = {};
									val[partObj[i].$.pkVal] = { _partial: partObj[i], _payload: payload[i] };
									Object.defineProperties(partObj, {
										_removedRecords: {
											value: val
										}
									});
								} else {
									partObj._removedRecords[partObj[i].$.pkVal] = {
										_partial: partObj[i],
										_payload: payload[i]
									};
								}
								//!partObj.hasOwnProperty("_removedRecords") ? Object.defineProperties(partObj,{ _removedRecords :{ value : { [partObj[i].$.pkVal] :{ _partial:partObj[i] , _payload : payload[i]} } } } ):partObj._removedRecords[partObj[i].$.pkVal] = { _partial:partObj[i] , _payload : payload[i]};
								Lyte.arrayUtils(partObj, "removeAt", i, 1);
								Lyte.arrayUtils(payload, "removeAt", i, 1);
								this.partRecMap.delete(key[j]);
							}
						}
					}
				} else {
					if (payload[key[j]]) {
						partObj.hasOwnProperty("_removedAttr") && !partObj._removedAttr.hasOwnProperty(key[j]) ? partObj._removedAttr[key[j]] = { _partial: partObj[key[j]], _payload: payload[key[j]] } : !partObj.hasOwnProperty("_removedAttr") ? Object.defineProperties(partObj, { _removedAttr: { value: { _partial: partObj[key[j]], _payload: payload[key[j]] } } }) : undefined;
						if (partObj[key[j]]) {
							partObj._removedAttr[key[j]]._partial = partObj[key[j]];
							Lyte.objectUtils(partObj, "delete", key[j]);
						}
						Lyte.objectUtils(payload, "delete", key[j]);
					}
				}
			}
		},
		payloadSet: function payloadSet(fkey) {
			if (!Array.isArray(fkey)) {
				fkey = [fkey];
			}
			var modelName = this._model,
			    pk = this._pkVal,
			    model = store.modelFor(modelName),
			    payload = this._payloadObj;
			var record = store.$.peekRecord(modelName, pk),
			    partial = this._partialObj;
			for (var i_key = 0; i_key < fkey.length; i_key++) {
				var key = fkey[i_key];
				if (!this._payloadObj[key]) {
					if (partial.hasOwnProperty("_removedAttr")) {
						if (partial._removedAttr.hasOwnProperty(key) && partial._removedAttr[key] != true) {
							payload[key] = partial._removedAttr[key]._payload;
							if (partial._removedAttr[key]._partial) {
								partial[key] = partial._removedAttr[key]._partial;
							}
							Lyte.objectUtils(partial._removedAttr, "delete", key);
							return;
						}
					}
					var field = model.fieldList[key];
					if (record[key] && field.type == "relation") {
						if (field.relType == "hasMany") {
							partial[key] = [];
							payload[key] = [];
							if (field.opts && field.opts.serialize == "id") {
								store.$.payLoadIdSerialize(payload, key, record, model, field, partial);
							}
							store.$.defProp(payload[key], "$", {});
							store.$.defPayArrUtls(payload[key].$);
							Object.defineProperties(payload[key].$, {
								_key: {
									value: field.relKey
								},
								_partialObj: {
									value: partial[key]
								},
								_model: {
									value: field.relatedTo
								},
								_payloadObj: {
									value: payload[key]
								},
								replace: {
									value: store.$.replaceCheck,
									writable: true
								},
								partRecMap: {
									value: new Map()
								}
							});
							if (field.opts && field.opts.serialize && !payload[key].$.serialize) {
								Object.defineProperty(payload[key].$, "_serialize", {
									value: field.opts.serialize
								});
							}
							if (field.opts && field.opts.serialize != "id" || !field.opts) {
								if (field.opts.serialize == "record") {
									for (i = 0; i < record[key].length; i++) {
										payload[key].$.add(record[key][i].$.pK);
									}
								}
								if (field.opts.serialize == "partial") {
									var dirtyRecords = record[key].partial;
									dirtyRecords.forEach(function (value, pk) {
										payload[key].$.add(pk);
									});
								}
							}
						} else {
							partial[key] = {};
							payload[key] = {};
							var data = store.$.PayloadSerialize(field, payload[key], record[key], key, store.modelFor(field.relatedTo), partial[key]);
							payload[key] = data.payload;
							partial[key] = data.partial;
						}
					} else {
						payload[key] = record[key];
						partial[key] = record[key];
					}
				}
			}
		},
		payLoadIdSerialize: function payLoadIdSerialize(payload, key, record, model, field, partial) {
			var rel = {};
			payload[key] = Lyte.deepCopyObject(record[key]);
			store.$.getRelations(model, key, store.modelFor(field.relatedTo), rel);
			store.$.idSerialize(payload, rel, undefined, partial);
		},
		PayloadSerialize: function PayloadSerialize(field, payload, record, key, model, partial) {
			var newKey = {};
			newKey[record.$.model._pK] = record.$.pK;
			var getPayloadData = _typeof(record.$.pK) == "object" ? record.$.pK : newKey;
			var mdl = model;
			var data,
			    part,
			    isModifiedFlag = false;
			if (field.opts && field.opts.serialize) {
				part = store.adapter.$.initPartialObj(model._name);
				if (field.opts.serialize == "record") {
					getPayloadData = store.$.toJSON(model._name, record, undefined, undefined, part);
				}
				if (field.opts.serialize == "partial") {
					var dirty = store.$.isDirty(record, mdl.relations);
					var rec = record;
					if (rec.$.isModified || dirty && dirty.length) {
						data = store.$.updateJSON(rec, mdl, dirty);
						getPayloadData = store.$.toJSON(model._name, data, undefined, undefined, part);
						isModifiedFlag = true;
					} else {
						part.obj.set(record.$.pK, partial);
					}
				}
				partial = part.obj.get(record.$.pK) || partial;
				var partobj = {
					pkVal: {
						value: record.$.pK
					},
					type: {
						value: "related"
					},
					model: {
						value: mdl._name
					},
					record: {
						value: record[key] || record
					}
				};
				if (isModifiedFlag == true) {
					partobj.type.value = "modified";
				}
				if (getPayloadData) {
					payload = store.adapter.$.serializeRecords(model._name, getPayloadData, record, undefined, "serializeRecord", undefined, part.obj);
				}
				if (field.opts && field.opts.serialize == "id") {
					getPayloadData = record.$.pK;
				}
				if ((typeof payload === 'undefined' ? 'undefined' : _typeof(payload)) == "object") {
					if (partial && !partial.$) {
						store.$.defProp(partial, "$", {});
					}
					var nPartial = partial.$;
					Object.defineProperties(nPartial, partobj);
					if (field.opts && field.opts.serialize && payload.$ && !payload.$._serialize && field.relType == "belongsTo") {
						Object.defineProperty(payload.$, "_serialize", {
							value: field.opts.serialize
						});
					}
				}
				var data = {
					"payload": payload,
					"partial": partial
				};
				return data;
			}
		},
		replaceCheck: function replaceCheck(bool) {
			store.$.defProp(this._partialObj, "replace", bool);
		},
		savingDonorRecord: function savingDonorRecord(scope) {
			var donor = scope.donor,
			    dirtAttr = scope.getDirtyAttributes(),
			    relDirty = store.$.isDirty(scope.record, scope.model.relations);
			if (relDirty.length || dirtAttr.length) {
				var state = scope.toJSON("state");
				store.$.setData(donor.$, state, undefined, undefined, undefined, undefined, true);
				scope.persist();
			}
			return donor.$;
		},
		peekRecord: function peekRecord(modelName, pKey, isDeleted, prx) {
			var model = store.modelFor(modelName),
			    modelless = store.$.getFromCB("adapter", modelName, "modelless"),
			    _defless;
			model = modelless ? modelName : model;
			if (!model) {
				Lyte.warn("LD02", "Model ", modelName);
				return;
			} else if (modelless == true && model) {
				model = store.modelless[model];
				if (!model) {
					// Lyte.error("LD02","Model");
					return;
				}
				_defless = true;
			}
			if (isDeleted === true) {
				var deleted = model._deleted;
				var obj = deleted.get(pKey);
				if (obj && obj.data) {
					if (obj.data && Lyte.getConfig("mutable")) {
						return Lyte.mut(obj.data);
					}
					return obj.data;
				}
			} else {
				var isComp = model.isComp;
				pKey = pKey == undefined ? "" : pKey;
				if (!isComp && model.data._recMap) {
					var rec = model.data._recMap.get(pKey.toString());
					if (prx && Lyte.getConfig("mutable")) {
						return Lyte.mut(rec);
					}
					return rec;
				} else {
					var data = model.data,
					    record;
					if (_defless != true) {
						record = data.filter(function (record) {
							if (store.$.comparePk(record, pKey)) {
								if (prx && Lyte.getConfig("mutable")) {
									return Lyte.mut(record);
								}
								return record;
							}
						});
					} else {
						record = data.filter(function (ins) {
							if (ins[model._pK] === pKey) {
								return ins;
							}
						});
					}
					if (record[0]) {
						if (prx && Lyte.getConfig("mutable")) {
							return Lyte.mut(record[0]);
						}
						return record[0];
					}
				}
			}
			return undefined;
		},
		getCreatedTime: function getCreatedTime(cTmap) {
			var time = new Date().getTime().toString();
			var count = 1;
			if (cTmap.get(time)) {
				count = cTmap.get(time);
				count = count + 1;
				cTmap.set(time, count);
			} else {
				cTmap.clear();
				cTmap.set(time, count);
			}
			var numLen = count.toString().length,
			    res;
			switch (numLen) {
				case 1:
					{
						res = "000" + count;
						break;
					}
				case 2:
					{
						res = "00" + count;
						break;
					}
				case 3:
					{
						res = "0" + count;
						break;
					}
				case 4:
					{
						res = "" + count;
						break;
					}
				default:
					{
						res = "9999";
					}
			}
			return time + res;
		}
	}
};

function Adapter(attrs, opts, name) {
	var self = this;
	Object.defineProperty(self, '$lg', {
		value: Lyte.__gl
	});
	store.$.newCB("adapter", this, name, attrs, opts);
}
store.$.cbDef(Adapter, "adapter");
store.adapter = {
	$: {
		buildURL: function buildURL(type, method, modelName, key, snapshot, queryParams, actionName, customData, url, gqlEnables) {
			var adapter = store.$.getAdapter({ name: modelName }),
			    host = store.$.getFromCB("adapter", modelName, "host"),
			    url = url || "",
			    makeBatch = store.$.makeBatch;
			// var modelless = store.$.getFromCB("adapter",modelName,"modelless"), name;	
			// if(typeof modelName == "string" && modelless){
			// 	name = modelName;
			// }
			url = url || "";
			var ret = { method: method };
			if (!url) {
				if (!makeBatch) {
					if (host !== undefined) {
						url += host;
						if (host[host.length - 1] != "/") {
							url += "/";
						}
					}
				}
				// enable = store.$.getFromCB("adapter",modelName,"enableGraphQl");
				// var check = store.$.enableGraphql(enable,type,enableGQl); 
				// var check = store.$.initCB("adapter", modelName, "GraphQl", {args:[modelName,type,queryParams,key,{query:oprName,variables:gqlVariables},customData]});
				if (!gqlEnables) {
					var namespace = store.$.getFromCB("adapter", modelName, "namespace");
					if (namespace !== "" && namespace[namespace.length - 1] != "/") {
						url += namespace + "/";
					} else {
						url += namespace;
					}
					if (type != "batch") {
						url += modelName;
						if (key && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) != "object") {
							url += "/" + key;
						}
					}
					if (type == "action") {
						url += "/" + store.$.getFromCB("adapter", modelName, "actionNamespace");
						var actions = store.modelFor(modelName).actions,
						    action = actions[actionName].endPoint ? actions[actionName].endPoint : actionName;
						url += "/" + action;
					} else if (type == "batch") {
						url += store.$.getFromCB("adapter", "application", "batchNamespace");
					}
					ret.method = method ? method : "";
				} else {
					ret.method = "POST";
					ret.gql = gqlEnables;
					method = ret.method;
					var gqlNamespace = store.$.getFromCB("adapter", modelName, "gqlNamespace");
					url += gqlNamespace ? gqlNamespace : "";
				}
			}
			if (!queryParams) {
				queryParams = {};
			}
			var res = store.$.initCB("adapter", modelName, "headersForRequest", { args: [type, queryParams, customData, actionName, key] });
			if (res) {
				ret.headers = res.data;
			}

			res = store.$.initCB("adapter", modelName, "buildURL", { args: [modelName, type, queryParams, snapshot, url, actionName, customData, key] });
			if (res) {
				url = res.data;
			}

			res = store.$.initCB("adapter", modelName, "methodForRequest", { args: [method, type, queryParams, customData, actionName, key] });
			if (res) {
				ret.method = res.data;
			}
			if (!makeBatch && queryParams && Object.keys(queryParams).length) {
				url += "?";
				var index = 0;
				for (var qKey in queryParams) {
					if (index !== 0) {
						url += "&";
					}
					var res = queryParams[qKey];
					if (res && (typeof res === 'undefined' ? 'undefined' : _typeof(res)) == "object") {
						res = JSON.stringify(res);
					}
					url += qKey + "=" + encodeURIComponent(res);
					index++;
				}
			}
			if (adapter && adapter.withCredentials == true) {
				ret.withCredentials = true;
			}
			ret.url = url;
			ret.qP = queryParams;
			return ret;
		},
		get: function get(type, modelName, key, queryParams, cacheQuery, customData, cacheData, oprName, gqlVariables) {
			var mdl = store.modelFor(modelName),
			    makeBatch = store.$.makeBatch,
			    gqlEnables,
			    gqlobj = gqlVariables || oprName ? {} : undefined,
			    modelless = store.$.getFromCB("adapter", modelName, "modelless");
			if (modelless && typeof modelName == "string") {
				var defobj = store.modelless,
				    _name = modelName;
				def = defobj[_name] = defobj[_name] || {};
				def._name = _name;
			}
			if (mdl || modelName && modelless) {
				customData = customData == undefined ? store.$.getFromCB("adapter", modelName, "customData") : customData;
				oprName ? gqlobj.query = oprName : undefined;
				gqlVariables ? gqlobj.variables = gqlVariables : undefined;
				gqlEnables = store.$.initCB("adapter", modelName, "gql", { args: [modelName, type, queryParams, key, gqlobj, customData] });
				var urlObj = this.buildURL(type, "GET", modelName, key, undefined, queryParams, undefined, customData, undefined, gqlEnables ? gqlEnables.data : undefined),
				    self = this;
				queryParams = urlObj.qP, toCheckParams = cacheQuery && typeof cacheQuery !== "boolean" ? cacheQuery : queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) == "object" ? queryParams : undefined;
				if (urlObj.gql) {
					if (_typeof(urlObj.gql) == "object") {
						oprName = urlObj.gql.query, gqlVariables = urlObj.gql.variables;
					} else if (urlObj.gql === true) {
						oprName = gqlVariables = undefined;
					}
					urlObj.data = store.$.graphQlconfig(modelName, key, type, queryParams, oprName, gqlVariables, urlObj);
					if (urlObj.data.LdEr) {
						Lyte.warn(urlObj.data.LdEr, urlObj.data.key, modelName);
						return Promise.reject({ code: urlObj.data.LyteError, message: Lyte.errorCodes[urlObj.data.LyteError], data: urlObj.data.key });
					}
				}
				if (type == "findAll" && toCheckParams && store.model.cachedQueries && store.model.cachedQueries[modelName]) {
					var cachedQueries = store.model.cachedQueries[modelName],
					    sendData;
					for (var i = 0; i < cachedQueries.length; i++) {
						var qry = cachedQueries[i];
						if (!qry.hasDeletedRecords) {
							var params = qry.cacheQuery;
							if (this.compareData(params, toCheckParams, true)) {
								sendData = [qry.data, "cache", undefined, qry.status];
								break;
							}
						}
					}
					if (sendData) {
						return new Promise(function (resolve) {
							if (makeBatch) {
								store.$.addToCachedBatch(Array.isArray(sendData) ? sendData[0][modelName] : sendData);
							}
							resolve(sendData);
						});
					}
				} else if (type == "findRecord" && toCheckParams && store.model.cachedRecordQueries && store.model.cachedRecordQueries[modelName] && store.model.cachedRecordQueries[modelName][key]) {
					var cachedQueries = store.model.cachedRecordQueries[modelName][key],
					    sendData;
					for (var i = 0; i < cachedQueries.length; i++) {
						var params = cachedQueries[i].cacheQuery;
						if (this.compareData(params, toCheckParams, true)) {
							sendData = [cachedQueries[i].data, "cache", undefined, cachedQueries[i].status];
							break;
						}
					}
					if (sendData) {
						return new Promise(function (resolve) {
							if (makeBatch) {
								store.$.addToCachedBatch(Array.isArray(sendData) ? sendData[0][modelName] : sendData);
							}
							resolve(sendData);
						});
					}
				} else {
					var scope = store.$.cbScp(modelName, type == "findRecord" ? "reloadRecord" : "reloadAll", "adapter");
					if (scope) {
						var records,
						    callReload = false;
						if (type == "findRecord") {
							records = store.$.peekRecord(modelName, key);
							callReload = Lyte.isRecord(records) ? true : false;
						} else if (type == "findAll") {
							records = store.peekAll(modelName);
							callReload = records && records.length ? true : false;
						}
						if (callReload && !store.$.cB(scope, [records, queryParams, customData, modelName])) {
							var toRet = {};
							toRet[modelName] = records;
							return new Promise(function (resolve) {
								if (makeBatch) {
									store.$.addToCachedBatch(toRet[modelName]);
								}
								resolve([toRet, "cache"], "success", undefined, true);
							});
						}
					}
				}
				if (urlObj.method == "POST") {
					var res = store.$.initCB("serializer", modelName, "serialize", { args: [type, urlObj ? urlObj.data : undefined, undefined, customData, modelName, queryParams, undefined, urlObj ? urlObj.gqlObj : undefined] });
					if (res) {
						urlObj.data = res.data;
						if (urlObj.data && (_typeof(urlObj.data) == "object" || Lyte.isRecord(urlObj.data) || Array.isArray(urlObj.data)) && !(urlObj.data instanceof FormData)) {
							// urlObj.reqData = Lyte.deepCopyObject(urlObj.data);
							urlObj.data = JSON.stringify(urlObj.data);
						}
					}
				}
				return new Promise(function (resolve, reject) {
					var model = store.modelFor(modelName);
					var idbObj = store.$.getIDBObj(model, queryParams, type, key, customData);
					var processRequest = store.$.getFromCB("adapter", modelName, "processRequest"),
					    payLoad,
					    sendXHR = true;
					var batchPro = false;
					var argsXHR = [modelName, type, key, urlObj, resolve, reject, "get", undefined, customData];
					var opts = { cacheQuery: cacheQuery, cacheData: cacheData, customD: customData };
					if (processRequest) {
						sendXHR = false;
						var returnPromise = self.callGeneric(type, modelName, undefined, undefined, customData, queryParams, key, urlObj.url, undefined, urlObj.method, urlObj.headers);
						if (returnPromise instanceof Promise) {
							batchPro = true;
							returnPromise.then(function (resp) {
								resp = resp == "" ? JSON.parse("{}") : JSON.parse(resp);
								payLoad = self.getResponse(resp, modelName, type, key, urlObj, undefined, customData, opts);
								resolve([payLoad]);
							}, function (message) {
								reject(message);
							});
						} else {
							sendXHR = true;
						}
					}
					if (makeBatch && !batchPro) {
						store.adapter.$.constructBatch.apply(store.adapter.$, argsXHR).then(function (resObj) {
							var payLoad = resObj.content;
							store.adapter.$.getSuccess(modelName, type, key, urlObj, undefined, resolve, reject, payLoad, resObj, undefined, opts);
							//resolve(payLoad);							
						}, function (resObj) {
							store.adapter.$.getFailure(modelName, type, key, urlObj, undefined, resolve, reject, opts, resObj.content, resObj.code, resObj);
						});
					} else if (idbObj) {
						store.adapter.$.getFromIDB(idbObj, modelName, type, queryParams, key, urlObj, customData).then(function (payLoad) {
							var res = store.$.initCB("serializer", modelName, "idbResponse", { args: [modelName, type, queryParams, key, payLoad] });
							if (res) {
								payLoad = res.data;
							}
							if (payLoad == false) {
								store.adapter.$.sendXHR.apply(store.adapter.$, argsXHR).then(function (xhrReq) {
									store.adapter.$.getSuccess(modelName, type, key, urlObj, xhrReq, resolve, reject, undefined, undefined, undefined, opts);
								}, function (xhrReq) {
									store.adapter.$.getFailure(modelName, type, key, urlObj, xhrReq, resolve, reject, opts);
								});
							} else {
								store.adapter.$.getSuccess(modelName, type, key, urlObj, undefined, resolve, reject, payLoad, undefined, "idb", opts);
							}
						}, function (message) {
							store.adapter.$.sendXHR.apply(store.adapter.$, argsXHR).then(function (xhrReq) {
								store.adapter.$.getSuccess(modelName, type, key, urlObj, xhrReq, resolve, reject, undefined, undefined, undefined, opts);
							}, function (xhrReq) {
								store.adapter.$.getFailure(modelName, type, key, urlObj, xhrReq, resolve, reject, opts);
							});
						});
					} else if (sendXHR) {
						store.adapter.$.sendXHR.apply(store.adapter.$, argsXHR).then(function (xhrReq) {
							store.adapter.$.getSuccess(modelName, type, key, urlObj, xhrReq, resolve, reject, undefined, undefined, undefined, opts);
						}, function (xhrReq) {
							store.adapter.$.getFailure(modelName, type, key, urlObj, xhrReq, resolve, reject, opts);
						});
					}
				});
			} else {
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({ code: "ERR19", message: Lyte.errorCodes.ERR19, data: modelName });
			}
		},
		constructBatch: function constructBatch(modelName, type, key, urlObj) {
			return new Promise(function (resolve, reject) {
				var batch = store.$.currentBatch;
				var q = store.$.batch[batch] = store.$.batch[batch] || [];
				var pro = store.$.batchPromise[batch] = store.$.batchPromise[batch] || [];
				var batchObj = {};
				batchObj.method = urlObj.method;
				batchObj.uri = "/" + urlObj.url;
				batchObj.parameters = urlObj.qP;
				batchObj.content = typeof urlObj.data == "string" ? JSON.parse(urlObj.data) : undefined;
				q.push(batchObj);
				pro.push({ resolve: resolve, reject: reject });
			});
		},
		getFromIDB: function getFromIDB(idbObj, modelName, type, queryParams, key, urlObj, customData) {
			return new Promise(function (resolve, reject) {
				var reqType = idbObj.queryCache ? "getCachedData" : type == "findAll" ? "getAll" : "get";
				var obj = { resolve: resolve, reject: reject, type: reqType, model: modelName, req: type, key: key };
				if (reqType == "getCachedData") {
					obj.queryParams = queryParams;
				}
				obj.queryCache = idbObj.queryCache;
				obj.customData = customData;
				LyteIDB.postMessage(obj);
			});
		},
		sendXHR: function sendXHR(modelName, type, key, urlObj, resolve, reject, xhrType, data, customData) {
			var xhr = new XMLHttpRequest();
			var prm = new Promise(function (res, rej) {
				xhr.open(urlObj.method, urlObj.url, true);
				for (var header in urlObj.headers) {
					xhr.setRequestHeader(header, urlObj.headers[header]);
				}
				xhr.withCredentials = urlObj.withCredentials ? true : false;
				store.$.initCB("adapter", modelName, "parseRequest", { args: [type, modelName, xhr, urlObj ? urlObj.qP : undefined, key, customData, urlObj.method, urlObj.headers, urlObj.url, urlObj.withCredentials ? true : false, urlObj.data] });
				store.emit("beforeRequest", [xhr, modelName, type, key, urlObj.qP, urlObj.method, urlObj.headers, urlObj.url, urlObj.withCredentials ? true : false, customData, urlObj.data]);
				xhr.send(urlObj.data);
				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {
						store.emit("afterRequest", [xhr, modelName, type, key, urlObj.qP, urlObj.method, urlObj.headers, urlObj.url, urlObj.withCredentials ? true : false, customData, urlObj.data]);
						if (xhr.status.toString()[0] == "2" || xhr.status.toString()[0] == "3") {
							return res(xhr);
						} else {
							return rej(xhr);
						}
					}
				};
			});
			prm.xhr = xhr;
			return prm;
		},
		getSuccess: function getSuccess(modelName, type, key, urlObj, xhr, resolve, reject, response, resObj, from, opts) {
			var resp = response,
			    req = xhr,
			    batchIndex,
			    batch,
			    customD = opts.customD,
			    status = xhr ? xhr.status : undefined;;
			if (from != "idb") {
				if (req) {
					resp = req.responseText;
					if (resp && resp.length != 0) {
						resp = JSON.parse(resp);
					} else {
						resp = JSON.parse("{}");
					}
				}
				if (resObj) {
					batchIndex = resObj.index;
					batch = resObj.batch;
					req = resObj.resp;
				}
				if (req) {
					var res = store.$.initCB("adapter", modelName, "parseResponse", { args: [type, modelName, req, resp, urlObj ? urlObj.qP : undefined, key, customD, opts] });
					if (res) {
						resp = res.data;
					}
					if (resp instanceof Promise) {
						return this.handleParseResponsePromise(resp, modelName, type, key, urlObj, xhr, undefined, batchIndex, batch, resolve, reject, opts);
					}
				}
				return this.findParseRequestPromise(resp, modelName, type, key, urlObj, xhr, batchIndex, batch, resolve, opts);
				//resp = this.getResponse(resp,modelName,type,key,urlObj,xhr);
			}
			var resArr = xhr ? [resp, xhr.statusText, xhr] : batchIndex != undefined ? [resp, "batch", { index: batchIndex, batch: batch }] : from ? [resp, "idb"] : [resp];
			resolve(resArr);
		},
		getFailure: function getFailure(modelName, type, key, urlObj, xhr, resolve, reject, opts, content, code, bObj) {
			var customD = opts.customD;
			if (xhr) {
				var resp,
				    response = xhr.responseText;
				if (response) {
					try {
						response = response == "" ? JSON.parse("{}") : JSON.parse(response);
					} catch (exp) {
						Lyte.warn("LD24", exp);
					}
				}
				resp = response;
				var res = store.$.initCB("adapter", modelName, "parseResponse", { args: [type, modelName, xhr, response, urlObj ? urlObj.qP : undefined, key, customD, opts] });
				if (res) {
					resp = res.data;
				}
				if (resp instanceof Promise) {
					return this.handleParseResponsePromise(resp, modelName, type, key, urlObj, xhr, undefined, undefined, undefined, resolve, reject, opts);
				}
			} else if (content) {
				var batch, batchIndex;
				if (bObj) {
					batchIndex = bObj.index;
					batch = bObj.batch;
				}
				store.$.batchResponse[batch][batchIndex] = { code: code, status: "requestFailure", data: content };
				reject({ code: code, status: "requestFailure", data: content });
			}
			reject(xhr);
		},
		getResponse: function getResponse(resp, modelName, type, key, urlObj, xhr, customData, opts) {
			var doNormalize = opts.cacheData !== undefined && opts.cacheData !== null && _typeof(opts.cacheData) == "object" && opts.cacheData.hasOwnProperty("normalize") ? opts.cacheData.normalize : true;
			if (doNormalize === true) {
				resp = store.serializer.$.normalizeResponse(modelName, type, resp, key, xhr ? xhr.status : xhr, urlObj, customData, opts);
				var scope,
				    payLoad = resp,
				    args,
				    qP = urlObj ? urlObj.qP : undefined;
				if ((typeof payLoad === 'undefined' ? 'undefined' : _typeof(payLoad)) != "object") {
					payLoad = JSON.parse(payLoad);
				}
				var res = store.$.initCB("serializer", modelName, "extractMeta", { args: [payLoad, modelName, type, qP, customData, opts] }),
				    metaRes;
				if (res) {
					metaRes = res.data;
					if (!store.$.isEmpty(metaRes)) {
						payLoad.meta = metaRes;
					}
				}
				var keys = Object.keys(payLoad);
				var len = keys.length;
				if (len) {
					res = store.$.initCB("serializer", modelName, "payloadKey", { args: [modelName, type, key, qP, customData, opts] });
					var plKey;
					if (res) {
						plKey = res.data;
						if (plKey && plKey != modelName) {
							var temp = payLoad[plKey];
							payLoad[modelName] = temp;
							delete payLoad[plKey];
						}
					}
					scope = store.$.cbScp(modelName, "deserializeKey", "serializer");
					if (scope) {
						Lyte.warn("LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
						if (len > 2) {
							Lyte.error("LD09");
						}
						var index = 0;
						if (len == 2 && keys[0] == "meta") {
							index = 1;
						}
						args = [modelName, type];
						var deserializeKey = store.$.cB(scope, args),
						    rec = payLoad[keys[index]];
						delete payLoad[keys[index]];
						payLoad[deserializeKey] = rec;
					}
					store.serializer.$.normalize(modelName, type, payLoad, key, xhr ? xhr.status : xhr, urlObj.headers, customData, opts, urlObj);
				}
				return payLoad;
			} else {
				if ((typeof resp === 'undefined' ? 'undefined' : _typeof(resp)) != "object") {
					resp = JSON.parse(resp);
				}
				var res = store.$.initCB("serializer", modelName, "extractMeta", { args: [resp, modelName, type, qP, customData, opts] }),
				    metaRes;
				if (res) {
					metaRes = res.data;
					if (!store.$.isEmpty(metaRes)) {
						resp.meta = metaRes;
					}
				}
				return resp;
			}
		},
		initPartialObj: function initPartialObj(modelName, type, qP, key, url, customData) {
			var partial = { obj: new Map() };
			// partial.ref = new Map();
			// var rKey = "recId", refKey;
			// var res = store.$.initCB("serializer", modelName, "referenceKey", {args:[modelName,type,qP,key,url,customData]});
			// refKey = res ? res.data : undefined;
			// if(!store.$.isEmpty(refKey)){
			// 	rKey = refKey;
			// }
			// partial.ref.refKey = rKey;
			return partial;
		},
		create: function create(modelName, data, isSingleRecord, customData, qP, mutationName) {
			var type = isSingleRecord ? "createRecord" : "create",
			    gqlObj = mutationName ? { "mutation": mutationName } : undefined;
			var gqlEnables = store.$.initCB("adapter", modelName, "gql", { args: [modelName, type, qP, undefined, gqlObj, customData] }),
			    mutName,
			    createdVariables = {};
			customData = customData == undefined ? store.$.getFromCB("adapter", modelName, "customData") : customData;
			var urlObj = this.buildURL(type, "POST", modelName, undefined, data, qP, undefined, customData, undefined, gqlEnables ? gqlEnables.data : undefined);
			qP = urlObj.qP;
			var partial = this.initPartialObj(modelName, type, qP, undefined, urlObj.url, customData);
			var changedData = store.$.toJSON(modelName, data, undefined, "create", partial);
			this.sendingData(modelName, changedData, urlObj, type, customData, data, partial.obj);
			if (urlObj.gql) {
				store.$.cpdGql(modelName, type, qP, urlObj, changedData, customData);
			}
			return this.handleRequest(urlObj, modelName, data, type, changedData, customData, partial.obj, undefined, undefined, partial.ref);
		},
		put: function put(modelName, data, record, isSingleRecord, customData, qP, mutationName) {
			var model = store.model[modelName],
			    bK = model.bK,
			    isComp = model.isComp,
			    gqlObj = mutationName ? { "mutation": mutationName } : undefined;
			var type = isSingleRecord ? "updateRecord" : "update",
			    partialObj = new Map(),
			    key = isSingleRecord ? isComp && bK ? record[bK] : record.$.pK : undefined;
			var gqlEnables = store.$.initCB("adapter", modelName, "gql", { args: [modelName, type, qP, undefined, gqlObj, customData] }),
			    mutName,
			    createdVariables = {};
			customData = customData == undefined ? store.$.getFromCB("adapter", modelName, "customData") : customData;
			var urlObj = this.buildURL(type, "PATCH", modelName, key, data, qP, undefined, customData, undefined, gqlEnables ? gqlEnables.data : undefined);
			qP = urlObj.qP;
			var partial = this.initPartialObj(modelName, type, qP, key, urlObj.url, customData);
			var updatedData = store.$.toJSON(modelName, data, undefined, undefined, partial);
			this.sendingData(modelName, updatedData, urlObj, type, customData, record, partial.obj);
			if (urlObj.gql) {
				store.$.cpdGql(modelName, type, qP, urlObj, updatedData, customData);
			}
			return this.handleRequest(urlObj, modelName, record, type, updatedData, customData, partial.obj, undefined, undefined, partial.ref);
		},
		del: function del(modelName, data, isSingleRecord, destroy, customData, qP, mutationName) {
			var model = store.model[modelName],
			    bK = model.bK,
			    isComp = model.isComp,
			    gqlObj = mutationName ? { "mutation": mutationName } : undefined;
			var type = destroy || "deleteRecord";
			var key = isSingleRecord ? isComp && bK ? data[bK] : data.$.pK : undefined;
			customData = customData == undefined ? store.$.getFromCB("adapter", modelName, "customData") : customData;
			var gqlEnables = store.$.initCB("adapter", modelName, "gql", { args: [modelName, type, qP, undefined, gqlObj, customData] }),
			    mutName,
			    createdVariables = {};
			var urlObj = this.buildURL(type, "DELETE", modelName, key, data, qP, undefined, customData, undefined, gqlEnables ? gqlEnables.data : undefined);
			qP = urlObj.qP;
			var partial = this.initPartialObj(modelName, type, qP, key, urlObj.url, customData);
			var ids = [];
			if (!isSingleRecord) {
				ids = data.map(function (val) {
					return val.$.pK;
				});
			}
			var pkVal = isSingleRecord ? data ? data.$.pK : undefined : ids;
			this.sendingData(modelName, pkVal, urlObj, type, customData, data);
			if (urlObj.gql) {
				store.$.cpdGql(modelName, type, qP, urlObj, pkVal, customData);
			}
			return this.handleRequest(urlObj, modelName, data, type, pkVal, customData, undefined, key);
		},
		sendingData: function sendingData(modelName, data, urlObj, type, customData, snapshot, partial) {
			var serializeKey = modelName,
			    payload = {},
			    qP = urlObj ? urlObj.qP : undefined,
			    tempObj = {};
			for (var key in urlObj) {
				tempObj[key] = urlObj[key];
			}
			tempObj.type = type;
			tempObj.model = modelName;
			var res = store.$.initCB("serializer", modelName, "serializeKey", { args: [modelName, type, customData, qP] });
			if (res) {
				serializeKey = res.data;
			}
			data = this.serializeRecords(modelName, data, snapshot, tempObj, "serializeRecord", customData, partial);
			if (!serializeKey) {
				payload = data;
			} else if (Array.isArray(data) || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object" || Lyte.isRecord(data)) {
				payload[serializeKey] = data;
			}
			var res = store.$.initCB("serializer", modelName, "serialize", { args: [type, payload, snapshot, customData, modelName, qP, urlObj ? urlObj.gqlObj : undefined] });
			if (res) {
				payload = res.data;
			}
			urlObj.data = payload;
		},
		serializeRecords: function serializeRecords(modelName, data, records, urlObj, type, customData, partial) {
			var modelless = store.$.getFromCB("adapter", modelName, "modelless");
			var model = store.modelFor(modelName);
			if (!model) {
				return data;
			}
			var rels = model.relations;
			if (!records && type != "normalizeRecord") {
				records = store.$.peekRecord(model._name, data.$.pK);
			}
			var result, partObj;
			if (Array.isArray(data)) {
				result = [];
				for (var index1 = 0; index1 < data.length; index1++) {
					var record = data[index1];
					if (record && (typeof record === 'undefined' ? 'undefined' : _typeof(record)) === "object") {
						result.push(this.serializeSingleRecord(model._name, record, records ? records[index1] : undefined, urlObj, rels, type, customData, partial));
					} else {
						result.push(record);
					}
				}
			} else if (data) {
				result = data;
				if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === "object") {
					result = this.serializeSingleRecord(model._name, data, records, urlObj, rels, type, customData, partial);
				}
			}
			return result;
		},
		serializeSingleRecord: function serializeSingleRecord(model_name, data, record, urlObj, rels, type, customData, partial) {
			var partObj;
			type == "serializeRecord" && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object" && data.$ == undefined ? store.$.defProp(data, "$", {}) : data;
			if (type == "normalizeRecord" && Lyte.isRecord(data)) {
				return data;
			}
			if ((typeof partial === 'undefined' ? 'undefined' : _typeof(partial)) == "object" && record && record.$ && record.$.pK) {
				partObj = partial.get ? partial.get(record.$.pK) : partial;
				if (data.$ && data.$._partialObj) {
					var data$;
					data$ = Object.assign({}, data.$);
					data = Object.assign({}, data);
					store.$.defProp(data, "$", data$);
				}
				var relDirty = store.$.isDirty(record, record.$.model.relations);
				if (record.$.isModified || Array.isArray(relDirty) && relDirty.length != 0) {
					var dirtAttr = record.$.getDirtyAttributes();
					Array.isArray(relDirty) && dirtAttr.concat(relDirty);
					var keys = Object.keys(data);
					!partObj.hasOwnProperty("_removedAttr") ? Object.defineProperties(partObj, { _removedAttr: { value: {} } }) : undefined;
					dirtAttr.forEach(function (val) {
						if (!keys.includes(val) && !record.$.model._arrPk.includes(val)) {
							partObj._removedAttr[val] = true;
						}
					});
				}
				Object.defineProperties(data.$, {
					_partialObj: {
						value: partObj
					},
					_pkVal: {
						value: record.$.pK
					},
					_model: {
						value: model_name
					},
					_payloadObj: {
						value: data
					}
				});
			}
			type == "serializeRecord" ? store.$.defpayObjUtls(data.$) : undefined;
			var scope = store.$.cbScp(model_name, type, "serializer");
			if (scope) {
				var args;
				if (type == "serializeRecord") {
					args = [urlObj, data, record, model_name, customData];
				} else {
					args = [urlObj, data, model_name, customData];
				}
				data = store.$.cB(scope, args);
			}
			for (var key in rels) {
				var rel = rels[key],
				    relLen = rel.length;
				for (var i = 0; i < relLen; i++) {
					var field = rel[i];
					var val = data[field.relKey],
					    recs,
					    res,
					    relTo,
					    srz,
					    isPoly;
					if (field.type == "relation" && val && (type == "normalizeRecord" || type == "serializeRecord" && field.opts && field.opts.serialize && field.opts.serialize != "id")) {
						recs = record ? record[field.relKey] : undefined, relTo = field.relatedTo, srz = field.opts ? field.opts.serialize : undefined;
						isPoly = field.opts ? field.opts.polymorphic : undefined;
						if (field.relType === "hasMany") {
							if (!Array.isArray(val)) {
								val = [val];
							}
							var valLen = val.length,
							    res = [];
							if (type == "serializeRecord") {
								store.$.defProp(res, "$", {});
								store.$.defPayArrUtls(res.$);
								if (partObj && partObj[field.relKey]) {
									Object.defineProperties(res.$, {
										_key: {
											value: field.relKey
										},
										_partialObj: {
											value: partObj[field.relKey]
										},
										_model: {
											value: relTo
										},
										_payloadObj: {
											value: res
										},
										replace: {
											value: store.$.replaceCheck,
											writable: true
										},
										partRecMap: {
											value: new Map()
										}
									});
									if (field.opts && field.opts.serialize) {
										Object.defineProperty(res.$, "_serialize", {
											value: field.opts.serialize
										});
									}
								}
							}
							for (var index1 = 0; index1 < valLen; index1++) {
								var _relTo = relTo;
								if (isPoly) {
									if (type == "normalizeRecord") {
										_relTo = val[index1] && val[index1]._type ? val[index1]._type : relTo;
									} else if (type == "serializeRecord") {
										if (srz == "record") {
											_relTo = recs && Lyte.isRecord(recs[index1]) ? recs[index1].$.model._name : relTo;
										} else if (srz == "partial") {
											_relTo = val[index1] && val[index1].$ ? val[index1].$.polymorphicType : relTo;
										}
									}
								}
								if (type == "serializeRecord") {
									var relPk = store.modelFor(relTo)._pK;
									res.$.partRecMap.set(val[index1][relPk], true);
								}
								res.push(this.serializeRecords(_relTo, val[index1], undefined, urlObj, type, customData, partObj ? partObj[field.relKey][index1] : undefined));
							}
							data[field.relKey] = res;
						} else {
							var _relTo = relTo;
							if (isPoly) {
								if (type == "normalizeRecord") {
									_relTo = data[field.relKey] && data[field.relKey]._type ? data[field.relKey]._type : relTo;
								} else if (type == "serializeRecord") {
									_relTo = Lyte.isRecord(record[field.relKey]) ? record[field.relKey].$.model._name : relTo;
								}
							}
							if (val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == "object" && !val.$ && field.opts && field.opts.serialize) {
								store.$.defProp(val, "$", {});
								Object.defineProperty(val.$, "_serialize", {
									value: field.opts.serialize
								});
							}
							data[field.relKey] = this.serializeRecords(_relTo, data[field.relKey], record ? record[field.relKey] : undefined, urlObj, type, customData, partObj ? partObj[field.relKey] : undefined);
						}
					} else if (type == "serializeRecord" && field.opts && field.opts.serialize && field.opts.serialize == "id" && field.type == "relation") {
						if (field.relType == "hsaMany") {
							store.$.defProp(data[field.relKey], "$", {});
							store.$.defPayArrUtls(data[field.relKey].$);
							if (partObj && partObj[field.relKey]) {
								Object.defineProperties(data[field.relKey].$, {
									_key: {
										value: field.relKey
									},
									_partialObj: {
										value: partObj[field.relKey]
									},
									_model: {
										value: relTo
									},
									_payloadObj: {
										value: data[field.relKey]
									},
									replace: {
										value: store.$.replaceCheck,
										writable: true
									}
								});
								if (field.opts && field.opts.serialize) {
									Object.defineProperty(res.$, "_serialize", {
										value: field.opts.serialize
									});
								}
							}
						}
					}
				}
			}
			return data;
		},
		handleAjax: function handleAjax(obj) {
			if (obj.url) {
				if (!obj.model) {
					Lyte.error("Please pass model param to ajax call");
					return Promise.reject("Please pass model param to ajax call");
				}
			}
			// var argsObj = { type: "ajax", schemaName : obj.schema, queryParams: obj.queryParams, customData: obj.customData}
			var urlObj = store.adapter.$.buildURL("ajax", obj.type, obj.model, obj.index, undefined, obj.queryParams, undefined, obj.customData, obj.url);
			urlObj.data = obj.data;
			var qP = urlObj.qP,
			    res = store.$.initCB("serializer", obj.model, "serialize", { args: ["ajax", urlObj.data, undefined, obj.customData, obj.model, qP, undefined] });
			// if(res){
			// 	argsObj.data = urlObj.data = res.data;
			// }
			return store.adapter.$.handleRequest(urlObj, obj.model, undefined, "ajax", undefined, obj.customData, undefined, undefined, undefined, undefined);
		},
		handleAction: function handleAction(actionName, model, record, customData, qP, method, data) {
			var pkVal;
			if (record && Lyte.isRecord(record)) {
				pkVal = record.$.get(model._pK);
			}
			var modelName = model._name,
			    type = "action";
			customData = customData == undefined ? store.$.getFromCB("adapter", model._name, "customData") : customData;
			var urlObj = this.buildURL(type, method ? method : "POST", model._name, pkVal, record, qP, actionName, customData);
			urlObj.data = data, qP = urlObj.qP;
			var res = store.$.initCB("serializer", model._name, "serialize", { args: ["action", data, record, customData, modelName, qP, actionName] });
			if (res) {
				urlObj.data = res.data;
			}
			return this.handleRequest(urlObj, model._name, undefined, type, undefined, customData, undefined, undefined, actionName);
		},
		handleRequest: function handleRequest(urlObj, modelName, data, type, changedData, customData, partialObj, key, actionName, partialRef) {
			if (urlObj.data && urlObj.data.LdEr) {
				Lyte.warn(urlObj.data.LdEr, urlObj.data.key, modelName);
				return Promise.reject({ code: urlObj.data.LyteError, message: Lyte.errorCodes[urlObj.data.LyteError], data: urlObj.data.key });
			}
			if (urlObj.data && (_typeof(urlObj.data) == "object" || Lyte.isRecord(urlObj.data) || Array.isArray(urlObj.data)) && !(urlObj.data instanceof FormData)) {
				// urlObj.reqData = Lyte.deepCopyObject(urlObj.data);
				urlObj.data = JSON.stringify(urlObj.data);
			}
			var self = this,
			    xhr,
			    key;
			return new Promise(function (resolve, reject) {
				var processRequest = store.$.getFromCB("adapter", modelName, "processRequest"),
				    sendXHR = true;
				var makeBatch = store.$.makeBatch;
				var batchPro = false;
				if (processRequest) {
					sendXHR = false;
					var returnPromise = self.callGeneric(type, modelName, urlObj.data, data, customData, urlObj ? urlObj.qP : undefined, key, urlObj.url, actionName, urlObj.method, urlObj.headers),
					    response;
					if (returnPromise instanceof Promise) {
						batchPro = true;
						returnPromise.then(function (resp) {
							if (type == "action" || type == "ajax") {
								try {
									resp = JSON.parse(resp);
								} catch (exp) {
									resp = resp;
								}
							} else {
								resp = JSON.parse(resp);
							}
							response = self.genericResponse(resp, modelName, type, data, urlObj, undefined, partialObj, customData);
							resolve(response);
						}, function (message) {
							reject(message);
						});
					} else {
						sendXHR = true;
					}
				}
				if (makeBatch && !batchPro) {
					store.adapter.$.constructBatch(modelName, type, key, urlObj).then(function (respObj) {
						var resp = respObj.content;
						store.adapter.$.handleSuccess(modelName, type, xhr, data, urlObj, resolve, resp, respObj, undefined, reject, key, customData, actionName, partialRef);
						// resolve(resp);
					}, function (resObj) {
						store.adapter.$.handleFailure(modelName, type, xhr, data, urlObj, resolve, resObj.content, undefined, reject, key, customData, resObj.code, actionName, resObj);
					});
				} else if (sendXHR) {
					var argsXHR = [modelName, type, key, urlObj, resolve, reject, "other", data, customData];
					store.adapter.$.sendXHR.apply(store.adapter.$, argsXHR).then(function (xhrReq) {
						store.adapter.$.handleSuccess(modelName, type, xhrReq, data, urlObj, resolve, undefined, undefined, partialObj, reject, key, customData, actionName, partialRef);
					}, function (xhrReq) {
						store.adapter.$.handleFailure(modelName, type, xhrReq, data, urlObj, resolve, undefined, partialObj, reject, key, customData, undefined, actionName);
					});
				}
			});
		},
		handleSuccess: function handleSuccess(modelName, type, xhr, data, urlObj, resolve, resp, respObj, partialObj, reject, key, customData, actionName, partialRef) {
			var response = xhr ? xhr.responseText : undefined,
			    response,
			    req,
			    batchIndex,
			    batch,
			    status = xhr ? xhr.status : undefined;
			if (resp) {
				response = resp;
			} else {
				if (response && response.length != 0) {
					if (type == "action") {
						try {
							resp = JSON.parse(response);
						} catch (exp) {
							resp = response;
						}
					} else {
						resp = JSON.parse(response);
					}
				} else {
					resp = JSON.parse("{}");
				}
			}
			if (xhr) {
				req = xhr;
			}
			if (respObj) {
				batchIndex = respObj.index;
				batch = respObj.batch;
				req = respObj.resp;
			}
			var opts = { customD: customData };
			if (req) {
				var res = store.$.initCB("adapter", modelName, "parseResponse", { args: [type, modelName, req, resp, urlObj ? urlObj.qP : undefined, key, customData, undefined, actionName] });
				if (res) {
					resp = res.data;
					if (resp instanceof Promise) {
						return this.handleParseResponsePromise(resp, modelName, type, data, urlObj, xhr, partialObj, batchIndex, batch, resolve, reject, opts);
					}
				}
			}
			return this.otherParseRequestPromise(resp, modelName, type, data, urlObj, xhr, partialObj, batchIndex, batch, resolve, reject, customData, partialRef, key);
		},
		handleFailure: function handleFailure(modelName, type, xhr, data, urlObj, resolve, respObj, partialObj, reject, key, customData, code, actionName, bObj) {
			if (xhr) {
				var resp;
				var scope = store.$.cbScp(modelName, "parseResponse", "adapter"),
				    args,
				    response = xhr.responseText;
				if (response) {
					try {
						response = response == "" ? JSON.parse("{}") : JSON.parse(response);
					} catch (exp) {
						Lyte.warn("LD24", exp);
					}
				}
				var res = store.$.initCB("adapter", modelName, "parseResponse", { args: [type, modelName, xhr, response, urlObj ? urlObj.qP : undefined, key, customData, undefined, actionName] });
				if (res) {
					resp = res.data;
					if (resp instanceof Promise) {
						return this.handleParseResponsePromise(resp, modelName, type, data, urlObj, xhr, partialObj, undefined, undefined, resolve, reject, customData);
					}
				}
			} else if (respObj) {
				var batch, batchIndex;
				if (bObj) {
					batchIndex = bObj.index;
					batch = bObj.batch;
				}
				store.$.batchResponse[batch][batchIndex] = { code: code, status: "requestFailure", data: respObj };
				reject({ code: code, status: "requestFailure", data: respObj });
			}
			reject(xhr);
		},
		updateIDB: function updateIDB(modelName, type, data, customData, urlObj, key) {
			if (data && !Array.isArray(data)) {
				data = [data];
			}
			var model = store.model[modelName];
			var idb = store.$.getIDBObj(model, urlObj && urlObj.qP ? urlObj.qP : undefined, type, key, customData);
			if (!model || !idb || idb && !idb.hasOwnProperty("queryCache")) {
				data.forEach(function (item, index) {
					if (item && Lyte.isRecord(item)) {
						store.adapter.$.updateRelationsIDB(item, store.model[modelName].relations, customData, type);
					}
				});
				return;
			}
			var q = store.$.idbQ2[modelName] = store.$.idbQ2[modelName] || [];
			var queryCache = idb.queryCache;
			if (data) {
				switch (type) {
					case "update":
					case "updateRecord":
						{
							data.forEach(function (item, index) {
								if (item && Lyte.isRecord(item)) {
									var model = store.model[modelName];
									var relations = model.relations;
									// var parent = item.$.parent;
									// if(parent){
									// 	var pModel = parent.$.model._name;
									// 	var piObj = store.$.getIDBObj(parent.$.model, urlObj && urlObj.qP ? urlObj.qP : undefined, type, key, customData, modelName)
									// 	var pModCacheQuery = piObj.queryCache;
									// 	var parentQ = store.$.idbQ2[pModel] = store.$.idbQ2[pModel] || [];
									// 	parentQ.push({type:"updateRecord",model:pModel,data:parent.$.toJSON(true),queryCache:pModCacheQuery, customData:customData});
									// }
									// else{
									// }
									if (item.$.inIDB && item.$.inIDB.self) {
										q.push({ type: "updateRecord", model: modelName, data: item.$.toJSON("idb"), queryCache: queryCache, customData: customData });
									}
									store.adapter.$.updateRelationsIDB(item, relations, customData);
									store.$.addToIDBonSave(modelName, item);
								}
							});
							break;
						}
					case "delete":
					case "deleteRecord":
					case "destroyRecord":
						{
							var parent,
							    pModel,
							    parentQ,
							    arrPk = store.modelFor(modelName)._arrPk;
							data.forEach(function (item, index) {
								if (item && Lyte.isRecord(item)) {
									var model = store.model[modelName];
									var relations = model.relations;
									parent = item.$.parent;
									var pkObj = {};
									for (var i = 0; i < arrPk.length; i++) {
										pkObj[arrPk[i]] = item[arrPk[i]];
									}
									// if(parent){
									// 	var pMod = parent.$.model;
									// 	pModel = pMod._name;
									// 	var piObj = store.$.getIDBObj(parent.$.model, urlObj && urlObj.qP ? urlObj.qP : undefined, type, key, customData, modelName)
									// 	var pModCacheQuery = piObj.queryCache;
									// 	parentQ = store.$.idbQ2[pModel] = store.$.idbQ2[pModel] || [];
									// 	parentQ.push({type:"updateRecord",model:parent.$.model._name,data:parent.$.toJSON(true), queryCache:pModCacheQuery, customData:customData});
									// }
									// else{
									// }
									if (item.$.inIDB && item.$.inIDB.self) {
										q.push({ type: "deleteRecord", model: modelName, key: pkObj, queryCache: queryCache, customData: customData });
									}
									store.adapter.$.updateRelationsIDB(item, relations, customData);
									store.$.removeOnSave(modelName, item.$.pK);
								}
							});
							break;
						}
					case "create":
					case "createRecord":
						{
							data.forEach(function (item, index) {
								if (item && Lyte.isRecord(item)) {
									var model = store.model[modelName];
									var relations = model.relations;
									q.push({ type: "createRecord", model: modelName, data: item.$.toJSON("idb"), queryCache: queryCache, customData: customData });
									store.adapter.$.updateRelationsIDB(item, relations, customData, "create");
									store.$.addToIDBonSave(modelName, item);
								}
							});
							break;
						}
				}
			}
		},
		updateRelationsIDB: function updateRelationsIDB(item, relations, customData, type) {
			switch (type) {
				case "create":
				case "createRecord":
					{
						for (var key in relations) {
							var rel = relations[key];
							rel.forEach(function (obj) {
								var relKey = obj.relKey,
								    relModel = obj.relatedTo,
								    relQ = store.$.idbQ2[relModel] = store.$.idbQ2[relModel] || [],
								    data,
								    idbObj = item.$.inIDB;
								if (obj.dummy) {
									data = store.$.getRelatedRecord(item, obj.relatedTo, obj.dummy);
								} else {
									data = item[relKey];
								}
								if (data && !Array.isArray(data)) {
									data = [data];
								}
								if (data) {
									data.forEach(function (_data) {
										var pModel = _data.$.model,
										    pRelQ = store.$.idbQ2[pModel._name] = store.$.idbQ2[pModel._name] || [];
										if (_data.$.inIDB.self) {
											pRelQ.push({ type: "updateRecord", model: pModel._name, data: _data.$.toJSON("idb"), customData: customData });
										}
										for (var iKey in _data.$.inIDB) {
											var mp = _data.$.inIDB[iKey],
											    _relQ = store.$.idbQ2[iKey] = store.$.idbQ2[iKey] || [];
											mp.forEach(function (value, pkVal) {
												_relQ.push({ type: "updateRecord", model: iKey, data: store.$.peekRecord(iKey, pkVal).$.toJSON("idb"), customData: customData });
											});
										}
									});
								}
							});
						}
					}
					break;
				default:
					{
						var idbObj = item.$.inIDB;
						if (idbObj) {
							for (mKey in idbObj) {
								var mp = idbObj[mKey];
								mp.forEach(function (value, key) {
									var pRec = store.$.peekRecord(mKey, key);
									var relQ = store.$.idbQ2[mKey] = store.$.idbQ2[mKey] || [];
									relQ.push({ type: "updateRecord", model: mKey, data: pRec.$.toJSON("idb"), customData: customData });
								});
							}
						}
					}
			}
		},
		callGeneric: function callGeneric(type, modelName, data, record, customData, queryParams, key, url, actionName, method, headers) {
			var res = store.$.initCB("adapter", modelName, "processRequest", { args: [type, modelName, data, record, customData, queryParams, key, url, actionName, method, headers] });
			return res ? res.data : undefined;
		},
		genericResponse: function genericResponse(resp, modelName, type, data, urlObj, xhr, partialObj, customData, partialRef) {
			var response = resp,
			    status = xhr ? xhr.status : undefined;
			var scope,
			    args,
			    qP = urlObj ? urlObj.qP : undefined,
			    extractMetaCall;
			scope = store.$.cbScp(modelName, "extractMeta", "serializer");
			if (scope) {
				if (response) {
					var metaRes = store.$.cB(scope, [response, modelName, type, qP, customData]);
					if (!store.$.isEmpty(metaRes)) {
						response.meta = metaRes;
					}
					extractMetaCall = true;
				} else {
					extractMetaCall = false;
				}
			}
			if (response && type != "action" && type != "ajax") {
				response = store.serializer.$.buildJSON(modelName, type, response, Lyte.isRecord(data) ? data[store.modelFor(modelName)._pK] : undefined, xhr ? xhr.status : undefined, urlObj, customData, qP);
				if (extractMetaCall == false && scope && response) {
					var metaRes = store.$.cB(scope, [response, modelName, type, qP, customData]);
					if (!store.$.isEmpty(metaRes)) {
						response.meta = metaRes;
					}
				}
				var keys = Object.keys(response);
				var len = keys.length;
				scope = store.$.cbScp(modelName, "deserializeKey", "serializer");
				if (scope) {
					Lyte.warn("LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
					if (len > 2) {
						Lyte.error("LD09");
					}
					var index = 0;
					if (keys[0] == "meta") {
						index = 1;
					}
					var deserializeKey = store.$.cB(scope, [modelName, type]),
					    rec = response[keys[index]];
					delete response[keys[index]];
					response[deserializeKey] = rec;
				}
				this.handleResponse(data, response, store.modelFor(modelName), type, partialObj, undefined, partialRef);
			}
			return response;
		},
		removePartialKeys: function removePartialKeys(data, model, pK) {
			var rels = model.relations;
			var pkVal = data.$.pK;
			for (var key in rels) {
				var relArr = rels[key];
				relArr.forEach(function (rel) {
					var relObj = {},
					    inv;
					//self.$scope.$.getRelations(model, rel.relKey, self.$scope.model[rel.relatedTo], relObj);
					inv, bMod = store.model[rel.relatedTo];
					// if(relObj){
					// 	inv = relObj;
					// }
					if (bMod) {
						inv = store.$.getBackwardRel(model, rel, bMod);
						if (inv && inv.relType == "hasMany" && inv.opts && inv.opts.serialize) {
							var relKey = rel.relKey;
							var invRelKey = inv.relKey;
							var invObj = data[relKey];
							if (invObj) {
								if (Array.isArray(invObj)) {
									invObj.forEach(function (invRelRec) {
										var invRelObj = invRelRec[invRelKey];
										if (invRelObj && invRelObj.partial && invRelObj.partial.get(pkVal)) {
											invRelObj.partial.delete(pkVal);
										}
									});
								} else if (invObj[invRelKey]) {
									var invRelObj = invObj[invRelKey];
									if (invRelObj && invRelObj.partial && invRelObj.partial.get(pkVal)) {
										invRelObj.partial.delete(pkVal);
									}
								}
							}
						}
					}
				});
			}
		},
		mergeError: function mergeError(model, data, response) {
			if (response && response.$ && response.$.isError) {
				if (response.$.error) {
					var obj = response.$.error;
					for (var key in obj) {
						if (model.fieldList.hasOwnProperty(key)) {
							store.$.setRecErr(data.$, key, obj[key]);
						}
					}
				}
				delete response.$.error;
				delete response.$.isError;
				return true;
			}
		},
		mergeResponse: function mergeResponse(data, model, response, pK, partialObj, cPersist) {
			this.removePartialKeys(data, model, pK);
			if (partialObj && Object.keys(partialObj).length) {
				this.mergeNewDataKeys(partialObj, data, response, cPersist);
			}
			if (this.mergeError(model, data, response)) {
				return;
			}
			var isRec = store.$.peekRecord(data.$.model._name, data.$.pK);
			var dirtyId,
			    mergeDone = false;
			if (data.$.isDeleted) {
				this.mergeDeletedRec(partialObj, data, cPersist);
			}
			if (data.$.isNew && isRec) {
				mergeDone = this.mergeNewRecord(partialObj, data, response, true, cPersist);
			}
			if (data.$.isModified && isRec) {
				this.mergeModifiedRec(partialObj, data, response, true, mergeDone, cPersist);
			}
			if (model.dirty.length) {
				store.$.deleteFromArray(model.dirty, dirtyId);
			}
			if (partialObj && Object.keys(partialObj).length && response && !mergeDone) {
				if (response) {
					if (isRec) {
						result = store.$.validateAndMerge(model, response, partialObj, true);
						if (result && result.data) {
							result = result.data;
						} else if (result && result.type) {
							Lyte[result.type].apply(Lyte, result.args || []);
						}
					} else {
						result = store.$.insertIntoStore(model._name, response, undefined, undefined, partialObj);
					}
				}
			}
			store.adapter.$.removeDirtyStack(data, partialObj);
			// store.$.removeDeepNest(data);
		},
		removeDirtyStack: function removeDirtyStack(data, partial) {
			if (partial && partial._removedAttr && Object.keys(partial._removedAttr).length != 0) {
				for (var key in data.$._attributes) {
					if (!partial._removedAttr.hasOwnProperty(key)) {
						delete data.$._attributes[key];
					}
				}
			} else {
				data.$._attributes = {};
			}
			// data.$._attributes={};
			data.$.undoStack = store.$.genUnRedoStack();
			data.$.redoStack = store.$.genUnRedoStack();
			delete data.$._savedState;
			store.$.clrRecErr(data.$);
		},
		// handleResults: function(results, partialRef){
		// 	if(Array.isArray(results)){
		// 		var self = this;
		// 		results.forEach(function(itm, idx){
		// 			var refKey = partialRef.refKey;
		// 			var refId = itm[refKey], refObj = partialRef.get(refId);
		// 			if(refObj){
		// 				self.mergePartialObj(refObj, undefined, itm, true);
		// 			} 
		// 		});
		// 	}
		// 	else{
		// 		Lyte.warn("results expected be a flat structure of type array, instead it was "+typeof(results));
		// 	}
		// },
		removeBackwardRelDirty: function removeBackwardRelDirty(rec, pkVal) {
			var model = rec.$.model,
			    relations = model.relations;
			for (var rModl in relations) {
				var rArr = relations[rModl];
				rArr.forEach(function (itm) {
					if (rec.hasOwnProperty(itm.relKey)) {
						var bRel;
						if (store.modelFor(itm.relatedTo)) {
							bRel = store.$.getBackwardRel(model, itm, store.modelFor(itm.relatedTo));
						}
						if (bRel && bRel.opts && bRel.opts.serialize) {
							if (bRel.relType == "hasMany") {
								store.adapter.$.removeRelPartial(rec[itm.relKey], bRel, pkVal);
							} else if (bRel.relType == "belongsTo") {
								store.adapter.$.removeRelPartial(rec[itm.relKey], bRel, pkVal);
							}
						}
					}
				});
			}
		},
		removeRelPartial: function removeRelPartial(data, bRel, pK) {
			if (Array.isArray(data)) {
				data.forEach(function (rec) {
					var relData = rec[bRel.relKey];
					if (relData) {
						if (bRel.relType == "hasMany") {
							if (relData.partial) {
								relData.partial.delete(pK);
								if (!relData.partial.size) {
									store.$.deleteDeepNest(rec, bRel.relKey, pK);
								}
							}
						} else {
							store.$.deleteDeepNest(rec, bRel.relKey, pK);
						}
					}
				});
			} else if (Lyte.isRecord(data)) {
				var relData = data[bRel.relKey];
				if (relData) {
					if (bRel.relType == "hasMany") {
						if (relData.partial) {
							relData.partial.delete(pK);
							if (!relData.partial.size) {
								store.$.deleteDeepNest(data, bRel.relKey, pK);
							}
						}
					} else {
						store.$.deleteDeepNest(data, bRel.relKey, pK);
					}
				}
			}
		},
		mergeNewRecord: function mergeNewRecord(partialObj, data, response, doMerge, cPersist) {
			var mName = partialObj.$ ? partialObj.$.model : data.$.model._name,
			    mdl = store.model[mName],
			    pKeys = mdl._arrPk,
			    oldPk = data.$.pK;
			var rec = store.$.peekRecord(mName, oldPk),
			    result;
			var partRec = partialObj.$ ? partialObj.$.record : undefined;
			if (Lyte.isRecord(partRec) && partRec !== rec) {
				return;
			}
			if (rec) {
				var oldRelPk = (typeof oldPk === 'undefined' ? 'undefined' : _typeof(oldPk)) == "object" ? oldPk : oldPk.toString();
				var crProcessed = false;
				if (cPersist !== true) {
					pKeys.forEach(function (item) {
						if (!response || !response.hasOwnProperty(item)) {
							Lyte.error("LD16", mName, Lyte.isRecord(data) ? _typeof(data.$.pK) == "object" ? JSON.stringify(data.$.pK) : data.$.pK : undefined);
							return;
						}
						store.$.cmpSet(data, item, response[item], undefined, true);
						crProcessed = true;
					});
					var newPk = store.$.getpKVal(data);
					store.$.cmpSet(data.$, "pK", store.$.getpKVal(data));
					var newRelPk = (typeof newPk === 'undefined' ? 'undefined' : _typeof(newPk)) == "object" ? newPk : newPk.toString();
					if (mdl.data._recMap) {
						mdl.data._recMap.delete(oldRelPk);
						mdl.data._recMap.set(newRelPk, data);
					}
					store.$.changeRelPkMaps(data, oldRelPk, newRelPk);
					store.$.updateNestScp(data, oldPk);
				}
				if (crProcessed && partialObj && partialObj.$) {
					partialObj.$.processed = true;
				}
				if (doMerge && cPersist !== true) {
					result = store.$.validateAndMerge(mdl, response, partialObj, true);
					if (result && result.data) {
						result = result.data;
					} else if (result && result.type) {
						Lyte[result.type].apply(Lyte, result.args || []);
					}
				}
				store.$.cmpSet(data.$, "isNew", false);
				if (partialObj.hasOwnProperty("_removedAttr") && Object.keys(partialObj._removedAttr).length != 0) {
					return result;
				}
				store.$.cmpSet(data.$, "isModified", false);
				store.$.changePersist(data, true);
				store.$.deleteFromArray(mdl.dirty, oldPk);
				store.adapter.$.removeBackwardRelDirty(data, oldPk);
				if (!data.$.dN || data.$.dN && Object.keys(data.$.dN).length == 0) {
					store.$.removeParentNesting(data);
				}
			}
			return result;
		},
		mergeModifiedRec: function mergeModifiedRec(partialObj, data, response, doMerge, mergeDone, cPersist) {
			var dirtyId = !dirtyId ? data.$.pK : dirtyId,
			    result;
			if (!data.$.isDeleted && response && !mergeDone && cPersist !== true) {
				if (response && doMerge) {
					result = store.$.validateAndMerge(data.$.model, response, partialObj, true);
					if (result && result.data) {
						result = result.data;
					} else if (result && result.type) {
						Lyte[result.type].apply(Lyte, result.args || []);
					}
				}
				mergeDone = true;
			}
			if (partialObj && partialObj.hasOwnProperty("_removedAttr") && Object.keys(partialObj._removedAttr).length) {
				return result;
			}
			store.$.cmpSet(data.$, "isModified", false);
			store.$.changePersist(data, true);
			store.$.deleteFromArray(data.$.model.dirty, data.$.pK);
			store.adapter.$.removeBackwardRelDirty(data, data.$.pK);
			if (!data.$.dN || data.$.dN && Object.keys(data.$.dN).length == 0) {
				store.$.removeParentNesting(data);
			}
			return result;
		},
		mergeDeletedRec: function mergeDeletedRec(partialObj, data) {
			var mName, pkVal, model, obj;
			if (partialObj) {
				mName = partialObj.$.model;
				pkVal = partialObj.$.pkVal;
			} else if (data) {
				mName = data.$.model._name;
				pkVal = data.$.pK;
			}
			model = store.model[mName];
			obj = model._deleted.get(pkVal);
			var rec = obj ? obj.data : undefined;
			var isRec = store.$.peekRecord(mName, pkVal);
			if (rec) {
				store.$.cmpSet(rec.$, "isDeleted", false);
				store.$.cmpSet(rec.$, "isUnloaded", true);
				store.$.cmpSet(rec.$, "isPersisted", true);
				var scpObj = rec.$.__scpObj;
				for (var key in scpObj) {
					var sid = scpObj[key];
					var sidArr = sid.split("_");
					var nestObj = Lyte.nestScp[sidArr[0]];
					nestObj ? Lyte.removeNestScp(nestObj._data, sidArr[0], sidArr[1], undefined, rec, undefined, undefined, { model: mName, pK: pkVal, attr: key }) : undefined;
				}
				model._deleted.delete(pkVal);
				store.$.removeParentNesting(rec);
			}
			if (isRec) {
				store.$.removeFromStore(model, pkVal, true, undefined, undefined, true);
				store.$.removeParentNesting(isRec);
			} else {
				var cqueries = store.model.cachedQueries;
				if (cqueries) {
					var Nm = cqueries[mName],
					    n = mName;
					if (Nm && Nm.length) {
						for (var i = Nm.length - 1; i >= 0; i--) {
							var obj = Nm[i];
							if (obj.hasDeletedRecords) {
								if (obj.data) {
									var ind = obj.data[mName].indexOf(rec);
									if (ind !== -1) {
										Nm.splice(i, 1);
									}
								}
							}
						}
					}
				}
			}
			if (partialObj && partialObj.$ && partialObj.$.parent) {
				partialObj.$.parent.$.partial = {};
			}
			partialObj && partialObj.$ ? partialObj.$.processed = true : undefined;
		},
		mergePartialObj: function mergePartialObj(partialObj, data, response, doMerge, cPersist) {
			var prec = store.$.peekRecord(partialObj.$.model, partialObj.$.pkVal),
			    data = data || prec,
			    isRec = prec ? true : false,
			    mergeDone;
			if (partialObj && partialObj.$ && partialObj.$.processed) {
				return;
			}
			if (this.mergeError(store.model[partialObj.$.model], data, response)) {
				return;
			}
			if (partialObj.$.type == "removed") {
				this.mergeDeletedRec(partialObj, data, cPersist);
				return;
			} else if ((partialObj.$.type == "added" || data && data.$ && data.$.isNew == true) && isRec) {
				mergeDone = this.mergeNewRecord(partialObj, data, response, doMerge, cPersist);
			} else if ((partialObj.$.type == "modified" || partialObj.$.type == "related" || data && data.$ && data.$.isModified == true) && isRec) {
				this.mergeModifiedRec(partialObj, data, response, doMerge, mergeDone, cPersist);
			}
			if (isRec) {
				if (partialObj.$.type != "removed") {
					for (var key in partialObj) {
						var part = partialObj[key];
						this.mergeNewDataKeys(part, data[key], response ? response[key] : undefined, cPersist);
					}
				}
				if (data.$.partial && Object.keys(data.$.partial)) {
					data.$.partial = new Map();
				}
				store.adapter.$.removeDirtyStack(data, partialObj);
			}
		},
		mergeNewDataKeys: function mergeNewDataKeys(partialObj, data, response, cPersist) {
			if (partialObj && (data && data.partial && data.partial.size || partialObj.partial == true)) {
				//true checked since partial key can come in this 
				var self = this;
				if (Array.isArray(partialObj)) {
					var rep = partialObj.replace ? partialObj.replace : false;
					partialObj.forEach(function (item, index) {
						if (item.$) {
							var pK = store.model[item.$.model]._pK;
							var ind = store.$.getIndex(data, pK, item.$.pkVal);
							if (item.$.onlyDetach === true) {
								if (data.record && data.key) {
									store.$.deleteDeepNest(data.record, data.key, item.$.pkVal);
								}
								store.$.handleArrOp(data, "removeAt", undefined, ind, 1);
							} else {
								if (rep && item.$.record && item.$.record.$.isNew) {
									rep = true;
								} else {
									self.mergeNewDataKeys(item, ind != -1 ? data[ind] : undefined, response ? response[index] : undefined, cPersist);
								}
								data.partial ? data.partial.delete(item.$.pkVal) : undefined;
							}
							if (!item._removedAttr || item._removedAttr && Object.keys(item._removedAttr).length) {
								data.partial ? data.partial.delete(item.$.pkVal) : undefined;
							}
						}
					});
					if (Array.isArray(data) && data.partial && data.partial.size && data.record && data.key && data.record.$.model) {
						var relFld = data.record.$.model.fieldList[data.key],
						    toRemPart = [];
						if (relFld.opts && /^(id|record)$/.test(relFld.opts.serialize)) {
							data.partial.forEach(function (pObj, pKey) {
								if (pObj.type == "removed") {
									toRemPart.push(pKey);
								}
							});
							toRemPart.forEach(function (rItm) {
								var rec = store.$.peekRecord(data.model._name, rItm) || store.$.peekRecord(data.model._name, rItm, true);
								data.partial.delete(rItm);
								rec ? store.$.removeParentNesting(rec) : undefined;
							});
						}
					}
				}
			} else if (partialObj && partialObj.$ && partialObj.$.type) {
				if (partialObj.$.onlyDetach) {
					//only for belongsTo
					var parent = partialObj.$.parent;
					if (parent && parent.$.partial && parent.$.partial[partialObj.$.relKey] && parent.$.partial[partialObj.$.relKey].has(partialObj.$.pkVal) && parent.$.partial[partialObj.$.relKey].get(partialObj.$.pkVal).type == "removed") {
						var rec = store.$.peekRecord(partialObj.$.model, partialObj.$.pkVal) || store.$.peekRecord(partialObj.$.model, partialObj.$.pkVal, true);
						parent.$.partial[partialObj.$.relKey].delete(partialObj.$.pkVal);
						if (!parent.$.partial[partialObj.$.relKey].size) {
							delete parent.$.partial[partialObj.$.relKey];
							if (!Object.keys(parent.$.partial).length) {
								delete parent.$.partial;
							}
						}
						rec ? store.$.removeParentNesting(rec) : undefined;
					}
				} else {
					this.mergePartialObj(partialObj, data, response, undefined, cPersist);
				}
			} else {
				if (Array.isArray(partialObj)) {
					var self = this;
					partialObj.forEach(function (item, index) {
						self.mergeNewDataKeys(item, data[index], response ? response[index] : undefined, cPersist);
					});
				} else if ((typeof partialObj === 'undefined' ? 'undefined' : _typeof(partialObj)) == "object") {
					for (var key in partialObj) {
						var part = partialObj[key];
						this.mergeNewDataKeys(partialObj[key], data[key], response ? response[key] : undefined, cPersist);
					}
				}
			}
		},
		handleResponse: function handleResponse(data, response, model, type, partialObj, status, partialRef) {
			var pK = model._pK,
			    partial,
			    obj,
			    pkVal;
			// if(response.results && model._name != "results"){
			// 	this.handleResults(response.results, partialRef);
			// }
			response = response[model._name];
			if (Array.isArray(data)) {
				for (var i = 0; i < data.length; i++) {
					obj = data[i], pkVal = obj.$.pK;
					partial = partialObj && obj && pkVal ? partialObj.get(pkVal) : undefined;
					this.mergeResponse(data[i], model, Array.isArray(response) ? response[i] : response, pK, partial);
				}
			} else {
				pkVal = data.$.pK;
				partial = partialObj && data && pkVal ? partialObj.get(pkVal) : undefined;
				this.mergeResponse(data, model, response, pK, partial);
			}
		},
		/*Compares two objects
  params - obj1, obj2
  return true/false
  */
		compareData: function compareData(data1, data2, isQp) {
			if (!store.$.isEmpty(data1) && !store.$.isEmpty(data2)) {
				var data1Type = typeof data1 === 'undefined' ? 'undefined' : _typeof(data1),
				    data2Type = typeof data2 === 'undefined' ? 'undefined' : _typeof(data2);
				if (data1Type !== data2Type) {
					return false;
				}
				switch (data1Type) {
					case "string":
					case "number":
					case "boolean":
						if (data1 === data2) {
							return true;
						}
						break;
					case "object":
						return this.compareObjects(data1, data2, isQp);
				}
			}
			return false;
		},
		compareObjects: function compareObjects(obj1, obj2, qP) {
			if (!(obj1 instanceof Object) || !(obj2 instanceof Object)) {
				return false;
			}
			if (Object.keys(obj1).length != Object.keys(obj2).length) {
				return false;
			}
			for (var key in obj1) {
				var val1 = obj1[key],
				    val2 = obj2[key];
				if (qP && Array.isArray(val1) && Array.isArray(val2)) {
					if (val1.length != val2.length) {
						return false;
					}
					var len = val1.length;
					for (var i = 0; i < len; i++) {
						var ret = store.adapter.$.compareData(val1[i], val2[i], qP);
						if (!ret) {
							return false;
						}
					}
				} else if (val2 === undefined || !store.adapter.$.compareData(val1, val2, qP)) {
					return false;
				}
			}
			return true;
		},
		handleBatchPromise: function handleBatchPromise(obj) {
			var response = obj.response,
			    batch = obj.batch,
			    fail = obj.fail;
			if (!fail) {
				var res = store.$.initCB("serializer", "application", "normalizeResponse", { args: [undefined, "batch", obj.response] });
				if (res) {
					response = res.data;
				}

				var resp = response.batch_requests;
				resp.forEach(function (item, index) {
					var pro = store.$.batchPromise[batch][index];
					var status = item.status.toString();
					var code = status[0];
					if (code == "2") {
						pro.resolve({ content: item.content, index: index, batch: batch, resp: item });
					} else if (code == "4" || code == "5") {
						store.$.batchResponse[batch][index] = undefined;
						pro.reject({ content: item.content, index: index, batch: batch, resp: item, code: status });
					}
				});
			} else {
				var prmArr = store.$.batchPromise[batch];
				prmArr.forEach(function (itm, idx) {
					itm.reject({ content: {}, index: idx, batch: batch, code: "400", resp: {} });
				});
			}
			// obj.resolve(response);
			delete store.$.batch[batch];
			delete store.$.batchPromise[batch];
		},
		handleParseResponsePromise: function handleParseResponsePromise(response, modelName, type, key, urlObj, xhr, partialObj, batchIndex, batch, resolve, reject, opts) {
			response.then(function (payload) {
				if (type == "findRecord" || type == "findAll") {
					store.adapter.$.findParseRequestPromise(payload, modelName, type, key, urlObj, xhr, batchIndex, batch, resolve, opts);
				} else {
					store.adapter.$.otherParseRequestPromise(payload, modelName, type, key, urlObj, xhr, partialObj, batchIndex, batch, resolve, reject, opts ? opts.customD : undefined, undefined, key);
				}
			}, function (payload) {
				reject(xhr);
			});
		},
		findParseRequestPromise: function findParseRequestPromise(payload, modelName, type, key, urlObj, xhr, batchIndex, batch, resolve, opts) {
			var options = Object.assign({}, opts);
			delete options.customD;
			var resp = this.getResponse(payload, modelName, type, key, urlObj, xhr, opts ? opts.customD : undefined, options);
			var resArr = xhr ? [resp, xhr.statusText, xhr] : batchIndex != undefined ? [resp, "batch", { index: batchIndex, batch: batch }] : [resp];
			resolve(resArr);
		},
		otherParseRequestPromise: function otherParseRequestPromise(resp, modelName, type, data, urlObj, xhr, partialObj, batchIndex, batch, resolve, reject, customData, partialRef, key) {
			var response = this.genericResponse(resp, modelName, type, data, urlObj, xhr, partialObj, customData, partialRef);
			if (batchIndex != undefined) {
				store.$.batchResponse[batch][batchIndex] = response;
			}
			if (type != "action" && type != "ajax") {
				this.updateIDB(modelName, type, data, customData, urlObj, key);
			}
			resolve(response);
		}
	}
};

store.$.defProp(store.adapter, "extends", function value(adapterName, opts, parent) {
	return store.$.scExtd("adapter", adapterName, opts, parent);
}, false);

Lyte.$.requiredMixins.serializer = Lyte.$.requiredMixins.adapter = function (mixin, parent, callback_name) {
	if (Object.keys(mixin).length) {
		parent.forEach(function (item, index) {
			var scope = item.scope,
			    name = item.name,
			    callback = scope[callback_name][name];
			if (callback) {
				for (var key in mixin) {
					callback[key] = mixin[key];
				}
			}
		});
	}
};

if (Lyte.$.injectServices) {
	Lyte.$.injectServices.adapter = Lyte.$.injectServices.serializer = function (key, name, type, ins, cmpIns, data) {
		var cls = store[type];
		var obj = {};
		obj.as = key;
		obj.service = name;
		for (var cName in cls) {
			var def = cls[cName];
			store.$.extendService([obj], type, cName, def, store, true, data);
		}
	};
}

function Serializer(attrs, opts, name) {
	var self = this;
	Object.defineProperty(self, '$lg', {
		value: Lyte.__gl
	});
	store.$.newCB("serializer", this, name, attrs, opts);
}
store.$.cbDef(Serializer, "serializer");
store.serializer = {
	$: {
		buildJSON: function buildJSON(modelName, type, payLoad, id, status, urlObj, customData, qP) {
			var headers = urlObj ? urlObj.headers : undefined,
			    realData = payLoad;
			var res = store.$.initCB("serializer", modelName, "normalizeResponse", { args: [modelName, type, realData, id, status, headers, urlObj ? urlObj.qP : undefined, customData, undefined, urlObj ? urlObj.gqlObj : undefined] });
			if (res) {
				realData = res.data;
			}
			var changed = false,
			    recs,
			    isGet = /^(findRecord|findAll)$/.test(type);
			if (!isGet && realData && (typeof realData === 'undefined' ? 'undefined' : _typeof(realData)) == "object") {
				res = store.$.initCB("serializer", modelName, "payloadKey", { args: [modelName, type, undefined, qP, customData] });
				if (res) {
					var plKey = res.data;
					if (plKey && plKey != modelName) {
						var temp = realData[plKey];
						realData[modelName] = temp;
						delete realData[plKey];
					}
				}
			}
			if (isGet || realData && realData[modelName]) {
				recs = realData[modelName], changed = true;
				scope = store.$.cbScp(modelName, "normalize", "serializer");
				if (scope) {
					if (Array.isArray(recs)) {
						for (var i = 0; i < recs.length; i++) {
							recs[i] = store.$.cB(scope, [modelName, type, recs[i], customData]);
						}
					} else {
						recs = store.$.cB(scope, [modelName, type, recs, customData]);
					}
				}
				var flUrlObj = type != "pushPayload" ? { url: urlObj.url, method: urlObj.method, headers: urlObj.headers, type: type, qP: urlObj.qP, withCredentials: urlObj.withCredentials, model: modelName } : undefined;
				recs = store.adapter.$.serializeRecords(modelName, recs, undefined, flUrlObj, "normalizeRecord", customData);
				realData[modelName] = recs;
			}
			return realData;
		},
		normalizeResponse: function normalizeResponse(modelName, type, payLoad, id, status, urlObj, customData, opts) {
			var headers = urlObj ? urlObj.headers : undefined,
			    realData = payLoad;
			var res = store.$.initCB("serializer", modelName, "normalizeResponse", { args: [modelName, type, realData, id, status, headers, urlObj ? urlObj.qP : undefined, customData, opts, urlObj ? urlObj.gqlObj : undefined] });
			if (res) {
				realData = res.data;
			}
			return realData;
		},
		normalize: function normalize(modelName, type, payLoad, id, status, headers, customData, opts, urlObj) {
			var realData = payLoad,
			    changed = false;
			if (/^(findRecord|findAll)$/.test(type) || realData[modelName]) {
				realData = realData[modelName];
				changed = true;
			}
			var scope = store.$.cbScp(modelName, "normalize", "serializer");
			if (scope && realData) {
				if (Array.isArray(realData)) {
					for (var i = 0; i < realData.length; i++) {
						realData[i] = store.$.cB(scope, [modelName, type, realData[i], customData, opts]);
					}
				} else {
					realData = store.$.cB(scope, [modelName, type, realData, customData, opts]);
				}
			}
			if (changed && realData) {
				//payLoad = {};
				realData = store.adapter.$.serializeRecords(modelName, realData, undefined, { url: urlObj.url, method: urlObj.method, headers: urlObj.headers, type: type, qP: urlObj.qP, withCredentials: urlObj.withCredentials, model: modelName }, "normalizeRecord", customData);
				payLoad[modelName] = realData;
			}
		}
	}
};
store.$.defProp(store.serializer, "extends", function value(serializerName, opts, parent) {
	return store.$.scExtd("serializer", serializerName, opts, parent);
});

Object.defineProperties(store, {
	modelless: {
		value: {}
	},
	registerModel: {
		get: function get() {
			Lyte._preRegister();
			return store.$.registerModel;
		}
	},
	ajax: {
		value: function ajax(obj) {
			if (!obj.model) {
				return Promise.reject("Model name is mandatory for ajax method");
			}
			var defless = store.$.getFromCB("adapter", obj.model, "modelless");
			if (defless != true) {
				return Promise.reject("Modelless behaviour is not enabled. Please enable it to make ajax call for models that are not defined");
			}
			if (!obj.type) {
				return Promise.reject(obj.type + " is not a valid HTTP method");
			}
			var def = typeof obj.model === "string" ? this.model[obj.model] : undefined;
			if (def && def.fieldList) {
				return Promise.reject(obj.model + " is a defined model. ajax is supported only for a model which is not defined");
			}
			return store.adapter.$.handleAjax(obj);
		}
	},
	triggerUpdate: {
		value: function value(modelName, pkVal, keys, qP, customData, mutationName) {
			var model = store.modelFor(modelName),
			    ArrayOfKeys,
			    sendData = [],
			    recordsArray = [];
			if (model == undefined) {
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({ code: "ERR19", message: Lyte.errorCodes.ERR19, data: modelName });
			}
			ArrayOfKeys = Array.isArray(pkVal) ? pkVal : [pkVal];
			for (var update_Rec = 0; update_Rec < ArrayOfKeys.length; update_Rec++) {
				var record = store.$.peekRecord(modelName, ArrayOfKeys[update_Rec]);
				if (record) {
					var obj = {};
					var model = record.$.model;
					var pK = model._arrPk;
					var fields = keys || Object.keys(model.fieldList);
					fields.forEach(function (item) {
						obj[item] = record[item];
					});
					pK.forEach(function (item) {
						obj[item] = record[item];
					});
					sendData.push(obj);
					recordsArray.push(record);
				} else {
					return Promise.reject("No such record found");
				}
			}
			var isSingleRecord = false;
			if (!Array.isArray(pkVal)) {
				sendData = sendData[0];
				recordsArray = recordsArray[0];
				isSingleRecord = true;
			}
			return store.adapter.$.put(modelName, sendData, recordsArray, isSingleRecord, customData, qP, mutationName);
		}
	},
	batch: {
		value: function value(arg) {
			return new Promise(function (resolve, reject) {
				store.$.makeBatch = true;
				store.$.batch = store.$.batch || {};
				store.$.batchPromise = store.$.batchPromise || {};
				var method,
				    customData,
				    bLen = store.$.currentBatch === undefined ? Object.keys(store.$.batch).length : store.$.currentBatch + 1,
				    batch = store.$.currentBatch = bLen;
				if (arg && typeof arg == "function") {
					method = arg;
				} else if (arg && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) == "object") {
					method = arg.method;
					customData = arg.customData;
				}
				try {
					method();
				} catch (e) {
					store.$.makeBatch = false;
					throw e;
				}
				store.$.makeBatch = false;
				var payLoad = { batch: store.$.batch[batch] };
				var urlObj = store.adapter.$.buildURL("batch", "POST", "application", undefined, payLoad, undefined, undefined, customData);
				var batchPl = payLoad.batch;
				if (store.$.isEmpty(batchPl)) {
					if (store.$.cachedBatch && store.$.cachedBatch[batch] && store.$.cachedBatch[batch].length) {
						var finalRes = store.$.handleCachedResponse(batch, []);
						return resolve(finalRes);
					}
					return resolve();
				}
				var res = store.$.initCB("serializer", "application", "serialize", { args: ["batch", payLoad, undefined, customData] });
				if (res) {
					payLoad = res.data;
				}
				var xhr = new XMLHttpRequest();
				xhr.open("POST", urlObj.url, true);
				for (var header in urlObj.headers) {
					xhr.setRequestHeader(header, urlObj.headers[header]);
				}
				xhr.withCredentials = urlObj.withCredentials ? true : false;
				xhr.send(JSON.stringify(payLoad));
				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {
						if (xhr.status.toString()[0] == "2" || xhr.status.toString()[0] == "3") {
							var resp = JSON.parse(xhr.responseText);
							store.$.batchResponse = store.$.batchResponse || {};
							store.$.batchResponse[batch] = [];
							store.adapter.$.handleBatchPromise({ response: resp, batch: batch, resolve: resolve });
							setTimeout(function () {
								var finalRes = store.$.handleCachedResponse(batch, store.$.batchResponse[batch]);
								resolve(finalRes);
								store.$.batchResponse[batch] = [];
							}, 0);
						} else {
							store.$.batchResponse[batch] = [];
							store.adapter.$.handleBatchPromise({ batch: batch, resolve: resolve, fail: true });
							setTimeout(function () {
								var finalRes = store.$.handleCachedResponse(batch, store.$.batchResponse[batch]);
								reject(finalRes);
							}, 0);
						}
					}
				};
			});
		}
	},
	pushPayload: {
		value: function value(modelName, data, deserialation, ind, Deserialize) {
			var model = store.modelFor(modelName),
			    modelless = store.$.getFromCB("adapter", modelName, "modelless"),
			    _defless;
			model = modelless ? modelName : model;
			if (!model) {
				Lyte.warn("LD02", "Model", modelName);
				return;
			}
			var result = data,
			    len;
			if (deserialation) {
				data = store.serializer.$.buildJSON(modelName, "pushPayload", data);
				var scope = store.$.cbScp(modelName, "deserializeKey", "serializer");
				len = data ? Object.keys(data).length : undefined;
				if (scope) {
					Lyte.warn("LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
					if (len > 2) {
						Lyte.error("LD09");
					}
					var keys = Object.keys(data),
					    index = 0;
					if (keys.length == 2 && keys[0] == "meta") {
						index = 1;
					}
					var deserializeKey = store.$.cB(scope, [modelName, "pushPayload"]),
					    rec = data[keys[index]];
					delete data[keys[index]];
					data[deserializeKey] = rec;
				}
				result = data[modelName];
			}
			data = store.$.insertIntoStore(modelName, result, true, undefined, undefined, index, true, undefined, ind, Deserialize);
			var nData = data || [];
			if (!Array.isArray(nData)) {
				nData = [nData];
			}
			var idb = model && model.hasOwnProperty("idb");
			if (window.LyteIDB) {
				nData.forEach(function (itm) {
					if (Lyte.isRecord(itm)) {
						if (idb) {
							store.$.idbQ2Push(modelName, itm, undefined, "pushPayload");
						}
						if (!itm.$.isError) {
							if (itm.$.inIDB && Object.keys(itm.$.inIDB).length) {
								store.adapter.$.updateRelationsIDB(itm, itm.$.model.relations);
							}
						}
					}
				});
			}
			model ? delete model.rel : undefined;
			return data && Lyte.getConfig("mutable") ? Lyte.mut(data) : data;
		}
	},
	unregisterModel: {
		value: function value(data, inherit) {
			inherit = inherit === false ? false : true;
			if (Array.isArray(data)) {
				data.forEach(function (item) {
					store.$.unregisterModel(item, inherit);
				});
			} else {
				store.$.unregisterModel(data, inherit);
			}
		}
	},

	unregisterAdapter: {
		value: function value(data) {
			if (Array.isArray(data)) {
				data.forEach(function (item) {
					store.$.unRegCb("adapter", item);
				});
			} else {
				store.$.unRegCb("adapter", data);
			}
		}
	},
	unregisterSerializer: {
		value: function value(data) {
			if (Array.isArray(data)) {
				data.forEach(function (item) {
					store.$.unRegCb("serializer", item);
				});
			} else {
				store.$.unRegCb("serializer", data);
			}
		}
	},
	addField: {
		value: function value(modelName, key, type, options, ignoreValidation, deserialize) {
			var model = store.modelFor(modelName),
			    fieldType;
			var obs = [];
			if (model.fieldList.hasOwnProperty(key)) {
				if (model.fieldList[key].type == "relation") {
					var relfld = model.fieldList[key];
					var rel = model.relations[relfld.relatedTo];
					if (Array.isArray(rel)) {
						var index = rel.indexOf(relfld);
						rel.splice(index, 1);
					}
					if (relfld.relType == "hasMany") {
						delete model._fldGrps.hasMany[key];
					}
				}
			}
			if (type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) == "object") {
				// if(type && type.type !== "relation" && model.fieldList.hasOwnProperty(key) && type.type === model.fieldList[key].type && store.adapter.$.compareData(type, model.fieldList[key])){
				// 	ignoreValidation = true;
				// }
				store.$.registerField(model, key, type, obs);
				if (type.type == "relation") {
					fieldType = "relation";
				} else {
					fieldType = "attr";
				}
				var deserialize = arguments[4],
				    ignoreValidation = ignoreValidation === undefined ? arguments[3] : ignoreValidation;
			} else {
				var field = Lyte.attr(type, options);
				// if(field.type !== "relation" && model.fieldList.hasOwnProperty(key) && model.fieldList[key].type === field.type && store.adapter.$.compareData(field, model.fieldList[key])){
				// 	ignoreValidation = true;
				// }
				store.$.registerField(model, key, field, obs);
			}
			if (fieldType != "relation") {
				if (!ignoreValidation || deserialize) {
					store.$.updateFieldValidation(model, key, deserialize, ignoreValidation);
				}
			}
		}
	},
	modelFor: {
		value: function value(name) {
			return store.model[name];
		}
	},
	createRecord: {
		value: function value(modelName, opts, withoutValidation) {
			var rec = this.$.newRecord(modelName, opts, withoutValidation);
			if (rec && Lyte.getConfig("mutable")) {
				return Lyte.mut(rec);
			}
			return rec;
		}
	},
	deleteRecord: {
		value: function value(modelName, key) {
			this.$.removeFromStore(store.modelFor(modelName), key, undefined);
		}
	},
	/*
 args - modelName, queryParams, cacheQuery, cacheData, customData
 cacheQuery - true/false (default false) -> whether to cache the request with queryparams or not
 cacheData - true/false (default true) -> whether to store the data in the store or not
 customData - some custom data that can be sent, which will be received as the last param in all adapter functions
 */
	findAll: {
		value: function value(modelName, queryParams, cacheQuery, cacheData, customData, oprName, variables, index) {
			return store.adapter.$.get("findAll", modelName, undefined, queryParams, cacheQuery, customData, cacheData, oprName, variables).then(function () {
				var args = arguments,
				    data = args[0][0],
				    xhr = args[0][2],
				    status = xhr ? xhr.status : args[0][3],
				    fromCache = args[0][1] == "cache" ? true : false,
				    batchObj = args[0][1] == "batch" ? args[0][2] : undefined,
				    fromIDB = args[0][1] == "idb" ? true : false,
				    model,
				    toCacheParams;
				var modelless = store.$.getFromCB("adapter", modelName, "modelless"),
				    _defless;
				// if(!modelless){
				model = store.model[modelName];
				// }
				toCacheParams = cacheQuery && cacheQuery !== true ? cacheQuery : cacheQuery === true && queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) == "object" && Object.keys(queryParams).length ? queryParams : undefined;
				if (!model && cacheData == undefined) {
					cacheData = false;
				} else if (modelless && !model && cacheData == true) {
					_defless = true;
				}
				if (cacheData !== undefined && (typeof cacheData === 'undefined' ? 'undefined' : _typeof(cacheData)) == "object" && cacheData !== null) {
					cacheData = cacheData.hasOwnProperty("cache") ? cacheData.cache : true;
				}
				if (cacheData === false) {
					if (!fromCache && toCacheParams) {
						store.$.cacheQuery(modelName, toCacheParams, data, status);
					}
					if (batchObj != undefined) {
						store.$.batchResponse[batchObj.batch][batchObj.index] = data;
					}
					return data;
				}
				if (data && !data.save) {
					if (!fromCache) {
						if (!data || !data.hasOwnProperty(modelName)) {
							Lyte.error("LD13", "findAll", modelName, queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) == "object" ? ",queryParams-" + JSON.stringify(queryParams) : "" /*, Lyte.isRecord(data) ? data: JSON.stringify(data)*/);
							return;
						}
						// if(!fromIDB){
						// 	store.$.idbQ2Push(modelName,data,queryParams,"findAll",undefined,undefined,customData);
						// }
						var payLoad = data[modelName];
						if (payLoad === undefined || payLoad === null || store.$.isEmptyArray(payLoad)) {
							data[modelName] = [];
						} else {
							if (!Array.isArray(payLoad)) {
								Lyte.warn("LD19");
							}
							var defnd = _defless ? "id" : undefined,
							    ind = _defless && index != undefined ? index : defnd;
							var records = store.$.toInsertData(modelName, data, true, ind),
							    nRec = records;
							if (records && !Array.isArray(records)) {
								nRec = [records];
							}
							if (window.LyteIDB && !fromIDB && (nRec && !nRec.$ || records && records.$ && !records.$.isError)) {
								if (model && model.hasOwnProperty('idb')) {
									store.$.idbQ2Push(modelName, nRec, queryParams, "findAll", undefined, undefined, customData);
								}
								nRec.forEach(function (itm) {
									if (itm && itm.$ && itm.$.inIDB && Object.keys(itm.$.inIDB).length) {
										store.adapter.$.updateRelationsIDB(itm, itm.$.model.relations);
									}
								});
							}
							if (window.LyteIDB && fromIDB && nRec && Array.isArray(nRec)) {
								nRec.forEach(function (itm) {
									LyteIDB.changeIDBState(itm);
								});
							}
							data[modelName] = records;
						}
						if (data.hasOwnProperty("meta")) {
							data[modelName].$ || store.$.defProp(data[modelName], "$", {});
							data[modelName].$.meta = data.meta;
						}
						if (toCacheParams) {
							store.$.cacheQuery(modelName, toCacheParams, data);
						}
					}
					if (batchObj != undefined) {
						store.$.batchResponse[batchObj.batch][batchObj.index] = data[modelName];
					}
					return Lyte.getConfig("mutable") ? Lyte.mut(data[modelName]) : data[modelName];
				}
				return arguments;
			}, function (e) {
				return Promise.reject(e);
			});
		}
	},
	/*
 args - modelName , key, queryParams, cacheQuery, cacheData, customData
 cacheQuery - true/false (default - false) -> to cache the query with queryParams and key
 cacheData - true/false (default - true) -> to store the data in store / not
 customData - custom data that will be available as last param in all adapter callbacks 
 */
	findRecord: {
		value: function value(modelName, key, queryParams, cacheQuery, cacheData, customData, oprName, variables, index) {
			if (key == undefined) {
				return Promise.reject({ code: "ERR20", message: Lyte.errorCodes.ERR20 });
			}
			return store.adapter.$.get("findRecord", modelName, key, queryParams, cacheQuery, customData, cacheData, oprName, variables).then(function () {
				var data = arguments[0][0],
				    fromCache = arguments[0][1] == "cache" ? true : false;
				var xhr = arguments[0][2];
				var status = xhr ? xhr.status : arguments[0][3];
				var batchObj = arguments[0][1] == "batch" ? arguments[0][2] : undefined;
				var fromIDB = arguments[0][1] == "idb" ? true : false;
				var model = store.model[modelName];
				var toCacheParams = cacheQuery && cacheQuery !== true ? cacheQuery : cacheQuery === true && queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) == "object" && Object.keys(queryParams).length ? queryParams : undefined;
				var modelless = store.$.getFromCB("adapter", modelName, "modelless"),
				    _defless;
				if (!model && cacheData == undefined) {
					cacheData = false;
				} else if (modelless && !model && cacheData == true) {
					_defless = true;
				}
				if (cacheData !== undefined && (typeof cacheData === 'undefined' ? 'undefined' : _typeof(cacheData)) == "object" && cacheData !== null) {
					cacheData = cacheData.hasOwnProperty("cache") ? cacheData.cache : true;
				}
				if (cacheData === false) {
					if (!fromCache && toCacheParams) {
						store.$.cacheRecordQuery(modelName, key, toCacheParams, data, status);
					}
					if (batchObj != undefined) {
						store.$.batchResponse[batchObj.batch][batchObj.index] = data;
					}
					return data;
				}
				if (data) {
					if (!fromCache) {
						var isEmpty;
						if (!data || !data.hasOwnProperty(modelName)) {
							Lyte.error("LD13", "findRecord", modelName, ",key-" + ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) == "object" ? JSON.stringify(key) : key) + (queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) == "object" ? ", queryParams-" + JSON.stringify(queryParams) + "" : "") /*, Lyte.isRecord(data) ? data: JSON.stringify(data)*/);
							return;
						}
						// if(!fromIDB){
						// 	store.$.idbQ2Push(modelName,data,queryParams,"findRecord",key,data && data.meta ? data.meta : undefined,customData);
						// }
						if (!Lyte.isRecord(data)) {
							var payLoad = data[modelName];
							if (store.$.isEmpty(payLoad) || store.$.isEmptyObj(payLoad)) {
								data[modelName] = {};
								isEmpty = true;
							}
							if ((typeof payLoad === 'undefined' ? 'undefined' : _typeof(payLoad)) != "object" || Array.isArray(payLoad)) {
								Lyte.warn("LD11");
							}
							if (!isEmpty) {
								var defnd = _defless ? "id" : undefined,
								    ind = _defless && index != undefined ? index : defnd;
								var record = store.$.insertIntoStore(modelName, payLoad, true, true, undefined, undefined, undefined, undefined, ind),
								    nRec;
								if (window.LyteIDB && !fromIDB && Lyte.isRecord(record) && !record.$.isError) {
									if (!Array.isArray(record)) {
										nRec = [record];
									}
									if (model && model.hasOwnProperty('idb')) {
										store.$.idbQ2Push(modelName, nRec, queryParams, "findRecord", key, data && data.meta ? data.meta : undefined, customData);
									}
									nRec.forEach(function (itm) {
										if (itm && itm.$ && itm.$.inIDB && Object.keys(itm.$.inIDB).length) {
											store.adapter.$.updateRelationsIDB(itm, itm.$.model.relations);
										}
									});
								}
								if (window.LyteIDB && fromIDB && nRec && Array.isArray(nRec)) {
									nRec.forEach(function (itm) {
										LyteIDB.changeIDBState(itm);
									});
								}
								data[modelName] = record;
							}
							if (data.hasOwnProperty("meta")) {
								if (Lyte.isRecord(record)) {
									record.$.meta = data.meta;
								} else {
									payLoad = data[modelName];
									payLoad.$ || store.$.defProp(payLoad, "$", {});
									payLoad.$.meta = data.meta;
								}
							}
						}
						if (!fromCache && toCacheParams) {
							store.$.cacheRecordQuery(modelName, key, toCacheParams, data);
						}
					}
					if (batchObj != undefined) {
						store.$.batchResponse[batchObj.batch][batchObj.index] = data[modelName];
					}
					return Lyte.getConfig("mutable") ? Lyte.mut(data[modelName]) : data[modelName];
				}
				return arguments;
			}, function (e) {
				return Promise.reject(e);
			});
		}
	},
	peekRecord: {
		value: function value(modelName, pKey, isDeleted) {
			return store.$.peekRecord(modelName, pKey, isDeleted, true);
		}
	},
	peekAll: {
		value: function value(modelName) {
			var model = this.modelFor(modelName),
			    modelless = store.$.getFromCB("adapter", modelName, "modelless"),
			    _defless;
			model = modelless ? modelName : model;
			if (!model) {
				Lyte.warn("LD02", "Model ", modelName);
				return;
			} else if (modelless == true && model) {
				model = store.modelless[model];
				if (!model) {
					// Lyte.error("LD02","model ",modelName);
					return;
				}
			}
			arr = model.data;
			if (modelless) {
				return arr;
			}
			if (Lyte.getConfig("mutable")) {
				return Lyte.mut(arr);
			} else {
				return arr;
			}
		}
	},
	deleteMany: {
		value: function value(modelName, keys) {
			this.$.removeFromStore(store.modelFor(modelName), keys, undefined);
		}
	},
	unloadRecord: {
		value: function value(modelName, key, inherit, idbPersist) {
			var model = this.modelFor(modelName),
			    modelless = store.$.getFromCB("adapter", modelName, "modelless"),
			    _defless;
			model = modelless ? modelName : model;
			if (!model) {
				Lyte.warn("LD02", "Model ", modelName);
				return;
			} else if (modelless == true && model) {
				model = store.modelless[model];
				if (!model) {
					// Lyte.error("LD02","model ",modelName);
					return;
				}
				_defless = true;
			}
			if (key == undefined) {
				Lyte.warn("LD18", "key");
			}
			var data = store.$.peekRecord(modelName, key);
			var pkVal;
			if (_defless == true) {
				var ind = store.$.getInd(model.data, model._pK, key);
				if (ind != -1) {
					store.$.handleArrOp(model.data, "removeAt", undefined, ind, 1);
				}
			} else if (data) {
				var inhFldLen = model._fldGrps.inherit && Object.keys(model._fldGrps.inherit).length;
				inherit = inherit === false ? false : true;
				pkVal = data.$.pK;
				//this.$.removeFromStore(model, pkVal, true, true);
				if (inherit && inhFldLen) {
					var recmp = new Map();
					store.$.removeChildRecords(model, data, recmp, true);
				} else {
					this.$.removeFromStore(model, pkVal, true, true, undefined, undefined, true, idbPersist);
				}
				model._deleted.delete(key);
				var crq = this.model.cachedRecordQueries;
				if (crq && crq[modelName] && crq[modelName][key]) {
					crq[modelName][key] = [];
				}
				var cqueries = store.model.cachedQueries;
				if (cqueries) {
					var Nm = cqueries[modelName],
					    n = modelName;
					if (Nm && Nm.length) {
						for (var i = Nm.length - 1; i >= 0; i--) {
							var obj = Nm[i];
							if (obj && obj.data) {
								var ind = obj.data[modelName].indexOf(data);
								if (ind != -1) {
									Nm.splice(i, 1);
								}
							}
						}
					}
				}
			}
		}
	},
	unloadAll: {
		value: function value(modelName, arr, inherit, idbPersist) {
			var model = this.modelFor(modelName),
			    modelless = store.$.getFromCB("adapter", modelName, "modelless"),
			    _defless;
			model = modelless ? modelName : model;
			if (!model) {
				Lyte.warn("LD02", "Model ", modelName);
				return;
			} else if (modelless == true && model) {
				model = store.modelless[model];
				if (!model) {
					// Lyte.error("LD02","model ",modelName);
					return;
				}
				_defless = true;
			}
			var keys = [];
			var data = arr || store.peekAll(modelName);
			if (_defless == true) {
				store.$.handleArrOp(model.data, "removeAt", undefined, 0, model.data.length);
			} else {
				if (data) {
					for (var i = 0; i < data.length; i++) {
						keys.push(data[i].$.pK);
					}
				}
				var inhFldLen = model._fldGrps.inherit && Object.keys(model._fldGrps.inherit).length;
				inherit = inherit === false ? false : true;
				if (inherit && inhFldLen) {
					for (var i = keys.length - 1; i >= 0; i--) {
						var pk = data[i];
						var recmp = new Map();
						store.$.removeChildRecords(model, pk, recmp, true);
					}
				} else {
					this.$.removeFromStore(model, keys, true, true, undefined, undefined, true, idbPersist);
				}
				this.model[modelName].dirty = [];
				this.model[modelName]._deleted = new Map();
				var cq = store.model.cachedQueries;
				if (cq && cq[modelName]) {
					cq[modelName] = [];
				}
				var crq = this.model.cachedRecordQueries;
				if (crq && crq[modelName]) {
					crq[modelName] = [];
				}
			}
		}
	},
	triggerAction: {
		value: function value(modelName, actionName, customData, qP, method, data) {
			var model = store.modelFor(modelName);
			if (model == undefined) {
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({ code: "ERR19", message: Lyte.errorCodes.ERR19, data: modelName });
			}
			var actions = model.actions,
			    action = actions ? model.actions[actionName] : undefined;
			if (action) {
				return store.adapter.$.handleAction(actionName, model, store.peekAll(modelName), customData, qP, method, data).then(function (data) {
					return data;
				}, function (err) {
					return Promise.reject(err);
				});
			} else {
				return Promise.reject({ code: "ERR18", message: Lyte.errorCodes.ERR18 });
			}
		}
	},
	rollBack: {
		value: function value(modelName) {
			var model = this.modelFor(modelName),
			    rel = model.relations;
			if (model == undefined) {
				Lyte.warn("LD02", "Model", modelName);
				return;
			}
			var pK = model._pK,
			    self = this,
			    dirty = Array.from(model.dirty);
			var len = dirty.length;
			for (var i = 0; i < len; i++) {
				var rec = self.peekRecord(modelName, dirty[i]);
				if (rec && rec.$.isDeleted) {
					continue;
				} else if (rec && rec.$.isNew) {
					self.$.rollBackNew(model, rec, pK);
				} else if (rec && rec.$.isModified) {
					rec.$.rollBackAttributes(rec.$.getDirtyAttributes());
				}
			}
			this.$.rollBackDelete(model, undefined, true);
		}
	},
	create: {
		value: function value(modelName, data, customData, qP, toFilterRecords, mutationName) {
			var model = store.modelFor(modelName);
			if (model == undefined) {
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({ code: "ERR19", message: Lyte.errorCodes.ERR19, data: modelName });
			}
			if (Array.isArray(data)) {
				var self = this;
				data.forEach(function (item) {
					var resp = self.$.newRecord(modelName, item);
					if (resp.$.isError) {
						return Promise.reject(resp);
					}
				});
			} else if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object") {
				var resp = this.$.newRecord(modelName, data);
				if (resp.$.isError) {
					return Promise.reject(resp);
				}
			}
			var dirty = model.dirty,
			    len = dirty.length,
			    created = [],
			    err;
			for (var i = 0; i < len; i++) {
				var rec = store.peekRecord(modelName, dirty[i]);
				if (rec && rec.$.isNew) {
					if (toFilterRecords && toFilterRecords.indexOf(rec) == -1) {
						continue;
					}
					err = new error1();
					store.$.validateRecord(rec, model.fieldList);
					if (rec.$.isError && Object.keys(rec.$.error).length > 0) {
						return Promise.reject(err);
					}
					created.push(rec.$.record);
				}
			}
			if (created.length) {
				return store.adapter.$.create(modelName, created, false, customData, qP, mutationName);
			}
			return Promise.resolve();
		}
	},
	update: {
		value: function value(modelName, customData, qP, toFilterRecords, mutationName) {
			var model = this.modelFor(modelName);
			if (model == undefined) {
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({ code: "ERR19", message: Lyte.errorCodes.ERR19, data: modelName });
			}
			var changed = [],
			    recordsChanged = [];
			var records = toFilterRecords || store.peekAll(modelName);
			var model = store.model[modelName];
			var rels = model.relations;
			records.forEach(function (item) {
				if (Lyte.isRecord(item) && item.$.model._name == modelName) {
					var rec = item;
					var dirty = store.$.isDirty(rec, rels);
					if (rec && !rec.$.isNew && !rec.$.isDeleted && (rec.$.isModified || dirty && dirty.length)) {
						var obj = store.$.updateJSON(rec, model, dirty);
						changed.push(obj);
						recordsChanged.push(rec.$.record);
					}
				}
			});
			if (changed.length) {
				return store.adapter.$.put(modelName, changed, recordsChanged, false, customData, qP, mutationName);
			}
			return Promise.resolve();
		}
	},
	delete: {
		value: function value(modelName, key, customData, qP, toFilterRecords, mutationName) {
			var model = store.modelFor(modelName);
			if (model == undefined) {
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({ code: "ERR19", message: Lyte.errorCodes.ERR19, data: modelName });
			}
			if (key) {
				this.deleteRecord(modelName, key);
			}
			var deleted = [];
			model._deleted.forEach(function (itm, idx) {
				deleted.push(itm.data);
			});
			if (toFilterRecords) {
				var newDel = [];
				toFilterRecords.forEach(function (itm) {
					var ind = deleted.indexOf(itm.$.record);
					if (ind != -1) {
						newDel.push(itm.$.record);
					}
				});
				deleted = newDel;
			}
			// for(var i=0; i<model._deleted.length; i++){
			// 	if(!model._deleted[i].$.isNew){
			// 		deleted.push(model._deleted[i]);					
			// 	}
			// 	else{
			// 		// store.adapter.$.handleResponse(model._deleted[i], model._deleted[i], undefined, undefined, model);
			// 	}
			// }
			if (deleted.length) {
				var prm = store.adapter.$.del(modelName, deleted, undefined, "delete", customData, qP, mutationName);
				return prm.then(function (resp) {
					return resp;
				}, function (e) {
					return Promise.reject(e);
				});
				// return prm;
			}
			return Promise.resolve();
		}
	},
	registerAdapter: {
		value: store.adapter.extends
	},
	registerSerializer: {
		value: store.serializer.extends
	},
	// removeCachedQuery: {
	// 	value: function(obj){
	// 		var modelName = obj.modelName,
	// 		key = obj.key,
	// 		params = obj.params,
	// 		cq;
	// 		if(params === undefined){
	// 			if(key !== undefined){
	// 				if(modelName !== undefined){
	// 					var cq = this.model.cachedQueries;
	// 					var crq = this.model.cachedRecordQueries;
	// 					cq && cq.hasOwnProperty(modelName) ? delete cq[modelName] : undefined;
	// 					crq && crq.hasOwnProperty(modelName) ? ( key ? delete crq[modelName][key] : delete crq[modelName] )  : undefined;	
	// 				}
	// 				else{
	// 					this.model.cachedRecordQueries = {};
	// 					this.model.cachedQueries = {};
	// 				}
	// 			}
	// 			else {

	// 			}
	// 		}
	// 	}
	// },
	clearCachedQuery: {
		value: function value(modelName, key, cacheQuery) {
			var isObj = modelName && (typeof modelName === 'undefined' ? 'undefined' : _typeof(modelName)) == "object" ? true : false,
			    qP,
			    obj;
			if (isObj) {
				obj = modelName;
				modelName = obj.modelName;
				key = obj.key;
				qP = cacheQuery = obj.cacheQuery;
			} else {
				if (key && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) == "object") {
					qP = key;
					key = undefined;
				} else if (cacheQuery && (typeof cacheQuery === 'undefined' ? 'undefined' : _typeof(cacheQuery)) == "object") {
					qP = cacheQuery;
				}
			}
			var cachedQueries = [];
			if (!qP) {
				if (modelName) {
					var cq = this.model.cachedQueries;
					var crq = this.model.cachedRecordQueries;
					cq && cq.hasOwnProperty(modelName) ? delete cq[modelName] : undefined;
					crq && crq.hasOwnProperty(modelName) ? key ? delete crq[modelName][key] : delete crq[modelName] : undefined;
				} else {
					this.model.cachedQueries = [];
					this.model.cachedRecordQueries = {};
				}
				return;
			}
			if (qP) {
				if (key == undefined) {
					var cq = this.model.cachedQueries;
					if (cq && cq[modelName]) {
						cachedQueries = cq[modelName];
					}
				} else {
					var crq = this.model.cachedRecordQueries;
					if (crq && crq[modelName] && crq[modelName][key]) {
						cachedQueries = crq[modelName][key];
					}
				}
				for (var i = 0; i < cachedQueries.length; i++) {
					if (this.adapter.$.compareData(cachedQueries[i].cacheQuery, qP, true)) {
						cachedQueries.splice(i, 1);
						break;
					}
				}
			}
		}
	},
	getErrorMessage: {
		value: function value(code) {
			return Lyte.errorCodes[code];
		}
	},
	setErrorMessages: {
		value: function value(obj) {
			Object.assign(Lyte.errorCodes, obj);
		}
	},
	addEventListener: {
		value: function value(type, func) {
			return store.$.eventListeners.add(store, type, func);
		}
	},
	removeEventListener: {
		value: function value(id) {
			store.$.eventListeners.remove(store, id);
		}
	},
	emit: {
		value: function value(type, args) {
			store.$.eventListeners.emit(store, type, args);
		}
	},
	getPrimaryKey: {
		value: function value(modelName) {
			var model = store.model[modelName];
			if (!model) {
				Lyte.warn("LD02", "Model ", modelName);
				return;
			}
			return model._pK;
		}
	},
	getDirtyRecords: {
		value: function value(modelName, filters, deepNest) {
			var model = store.modelFor(modelName);
			if (!model) {
				Lyte.warn("LD02", "Model ", modelName);
				return;
			}
			var DirtyKeys = model.dirty,
			    dirtyRecords = [],
			    dirty = { isNew: [], isModified: [], isDeleted: [] };
			for (var i_dirty = 0; i_dirty < DirtyKeys.length; i_dirty++) {
				var record = store.$.peekRecord(modelName, DirtyKeys[i_dirty]);
				if (record) {
					record.$.isNew ? dirty.isNew.push(record) : dirty.isModified.push(record);
				}
			}
			if (model._deleted.size) {
				var deletedRecord = model._deleted;
				deletedRecord.forEach(function (value) {
					dirty.isDeleted.push(value.data);
				});
			}
			if (model.dirty || model._deleted.size) {
				if (filters == undefined || filters == true) {
					dirtyRecords = dirtyRecords.concat(dirty.isNew, dirty.isModified, dirty.isDeleted);
				}
				if (Array.isArray(filters)) {
					filters.forEach(function (value) {
						dirtyRecords = dirtyRecords.concat(dirty[value]);
					});
				}
				if (typeof filters == "string") {
					dirtyRecords = dirty[filters];
				}
			}
			if (deepNest) {
				var records = store.peekAll(modelName);
				records.forEach(function (rec) {
					if (rec && !rec.$.isNew && !rec.$.isDeleted && rec.$.isDirty() && !dirtyRecords.includes(rec)) {
						dirtyRecords.push(rec);
					}
				});
			}
			return dirtyRecords;
		}
	}
});

var error1 = function error1(attr, obj, message) {
	Object.defineProperties(this, {
		$: {
			value: { isError: true, error: message ? message : {} }
		}
	});
	if (attr) {
		store.$.setError(this, attr, obj);
	}
};