/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) });

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
  defineProperty(
    GeneratorFunctionPrototype,
    "constructor",
    { value: GeneratorFunction, configurable: true }
  );
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    defineProperty(this, "_invoke", { value: enqueue });
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per GeneratorResume behavior specified since ES2015:
        // ES2015 spec, step 3: https://262.ecma-international.org/6.0/#sec-generatorresume
        // Latest spec, step 2: https://tc39.es/ecma262/#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method;
    var method = delegate.iterator[methodName];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method, or a missing .next method, always terminate the
      // yield* loop.
      context.delegate = null;

      // Note: ["return"] must be used for ES3 parsing compatibility.
      if (methodName === "throw" && delegate.iterator["return"]) {
        // If the delegate iterator has a return method, give it a
        // chance to clean up.
        context.method = "return";
        context.arg = undefined;
        maybeInvokeDelegate(delegate, context);

        if (context.method === "throw") {
          // If maybeInvokeDelegate(context) changed context.method from
          // "return" to "throw", let that override the TypeError below.
          return ContinueSentinel;
        }
      }
      if (methodName !== "return") {
        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a '" + methodName + "' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(val) {
    var object = Object(val);
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable != null) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    throw new TypeError(typeof iterable + " is not iterable");
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
;var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*Polyfills for functions not available in other browsers. */

/*Polyfill for Node.after
//Not supported out of the box in IE and Edge. 
//from: https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/after()/after().md */
(function (arr) {
	arr.forEach(function (item) {
		if (item.hasOwnProperty('after')) {
			return;
		}
		Object.defineProperty(item, 'after', {
			configurable: true,
			enumerable: true,
			writable: true,
			value: function after() {
				var argArr = Array.prototype.slice.call(arguments),
				    docFrag = document.createDocumentFragment();

				argArr.forEach(function (argItem) {
					var isNode = argItem instanceof Node;
					docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
				});

				this.parentNode.insertBefore(docFrag, this.nextSibling);
			}
		});
	});
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);

/*Polyfill for replaceWith. 
//Not supported out of the box for IE and Edge. */
function ReplaceWith(Ele) {
	var parent = this.parentNode,
	    i = arguments.length,
	    firstIsNode = +(parent && (typeof Ele === 'undefined' ? 'undefined' : _typeof(Ele)) === 'object');
	if (!parent) {
		return;
	}

	while (i-- > firstIsNode) {
		if (parent && _typeof(arguments[i]) !== 'object') {
			arguments[i] = document.createTextNode(arguments[i]);
		}if (!parent && arguments[i].parentNode) {
			arguments[i].parentNode.removeChild(arguments[i]);
			continue;
		}
		parent.insertBefore(this.previousSibling, arguments[i]);
	}
	if (firstIsNode) {
		parent.replaceChild(this, Ele);
	}
}
if (!Element.prototype.replaceWith) {
	Element.prototype.replaceWith = ReplaceWith;
}
if (!CharacterData.prototype.replaceWith) {
	CharacterData.prototype.replaceWith = ReplaceWith;
}
if (!DocumentType.prototype.replaceWith) {
	DocumentType.prototype.replaceWith = ReplaceWith;
}

/*Polyfill for startsWith
//Not supported out of the box for  IE */
if (!String.prototype.startsWith) {
	String.prototype.startsWith = function (searchString, position) {
		position = position || 0;
		return this.indexOf(searchString, position) === position;
	};
}

/*Polyfill for endsWith
//Not supported out of the box for  IE */
if (!String.prototype.endsWith) {
	String.prototype.endsWith = function (search, this_len) {
		if (this_len === undefined || this_len > this.length) {
			this_len = this.length;
		}
		return this.substring(this_len - search.length, this_len) === search;
	};
}

var _Lyte = {
	version: "3.7.0-BETA1",
	$: {
		consoleTime: []
	},
	registeredMixins: {},
	registeredServices: {},
	requiredServices: {},
	toBeInjectedServices: {},
	_registeredComponents: {},
	_keywords: {
		"component": ["init", "didConnect", "didDestroy", "constructor", "onError", "actions", "methods", "data"],
		"adapter": ["namespace", "actionNamespace", "host", "withCredentials", "buildURL", "methodForRequest", "headersForRequest", "reloadRecord", "reloadRecord", "reloadAll", "processRequest", "parseResponse", "parseRequest", "super"],
		"serializer": ["normalize", "normalizeResponse", "serialize", "serializeKey", "deserializeKey", "extractMeta", "payloadKey", "serializeRecord", "normalizeRecord", "super"],
		"route": ["getDependencies", "getResources", "beforeModel", "model", "afterModel", "redirect", "renderTemplate", "afterRender", "beforeExit", "didDestroy", "queryParams", "title", "routeName", "component", "parent", "currentModel", "forceFetch", "setTitle", "setQueryParams", "getQueryParams", "setDynamicParam", "getDynamicParam", "removeFromCache", "refresh", "transitionTo", "replaceWith", "actions"],
		"is": function is(key, scope) {
			var arr = ["component", "adapter", "serializer", "route"];
			if (scope) {
				arr = [scope];
			}
			var len = arr.length;
			for (var i = 0; i < len; i++) {
				var keyArr = this[arr[i]];
				if (keyArr) {
					var res = keyArr.indexOf(key);
					if (res != -1) {
						return true;
					}
				}
			}
			return false;
		}
	},
	Mixin: {},
	Service: {},
	debug: false,
	performance: false,
	toBeRegistered: [],
	browser: {},
	registeredCustomComponent: {},
	Globals: {}
};
if (window.isLyteWidgetParent) {
	_widgetLyte = _Lyte;
	_Lyte.isWidgetBuild = true;
	window.__lyteConfig.isWidgetBuild = true;
} else {
	Lyte = _Lyte;
}

var IdleTaskScheduler = function () {
	function IdleTaskScheduler(obj) {
		_classCallCheck(this, IdleTaskScheduler);

		this.idleCallback = this.idleCallback.bind(this);
		this.timeout = 50;
		this.chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
		this.tasks = new Map();
		this.idleCallbackRequested = false;
		this.delayInit = false;
		this.useRequestIdleCallback = true;
		this.priorityQueue = [];
		this.processTime = {};
		this.perf = false;
		if (obj != undefined) {
			if (obj.useRequestIdleCallback !== undefined) {
				this.useRequestIdleCallback = obj.useRequestIdleCallback;
			}
			if (obj.delayInit !== undefined) {
				this.delayInit = obj.delayInit;
			}
			if (obj.timeout !== undefined) {
				this.timeout = obj.timeout;
			}
			if (obj.priorityQueue !== undefined) {
				this.priorityQueue = obj.priorityQueue;
			}
			if (obj.perf !== undefined) {
				this.perf = obj.perf;
			}
		}
	}

	_createClass(IdleTaskScheduler, [{
		key: 'isGenerator',
		value: function isGenerator(obj) {
			return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === "object" && typeof obj.next === "function" && typeof obj[Symbol.iterator] === "function";
		}
	}, {
		key: 'init',
		value: function init(obj) {
			if (this.delayInit == true) {
				if (obj !== undefined) {
					if (obj.useRequestIdleCallback !== undefined) {
						this.useRequestIdleCallback = obj.useRequestIdleCallback;
					}
					if (obj.timeout !== undefined) {
						this.timeout = obj.timeout;
					}
					if (obj.perf !== undefined) {
						this.perf = obj.perf;
					}
				}
				this.delayInit = false;
				this.tasksScheduler();
			}
		}
	}, {
		key: 'getUniqueKey',
		value: function getUniqueKey(len) {
			var result;
			while (result == undefined || this.tasks.has(result)) {
				result = undefined;
				result = this.generateUniqueKey(len);
			}
			return result;
		}
	}, {
		key: 'generateUniqueKey',
		value: function generateUniqueKey(length) {
			var result = '',
			    clen = this.chars.length;
			for (var i = 0; i < length; i++) {
				result += this.chars.charAt(Math.floor(Math.random() * clen));
			}
			return result;
		}
	}, {
		key: 'enqueueTask',
		value: function enqueueTask(handler, data, id) {
			if (!id) {
				id = this.getUniqueKey(6);
			}
			if (this.tasks.has(id)) {
				console.error("Task with id-" + id + " is alreaded queued for execution.");
				return;
			}
			this.tasks.set(id, { handler: handler, data: data });
			this.tasksScheduler();
			return id;
		}
	}, {
		key: 'deleteTask',
		value: function deleteTask(id) {
			if (id) {
				var val = this.tasks.get(id);
				this.tasks.delete(id);
				if (this.priorityQueue.length) {
					var ind = this.priorityQueue.indexOf(id);
					if (ind != -1) {
						this.priorityQueue.splice(ind, 1);
					}
				}
				return val;
			}
		}
	}, {
		key: 'getPriorityQObj',
		value: function getPriorityQObj() {
			var id,
			    i = 0,
			    pObj;
			if (this.priorityQueue.length) {
				var len = this.priorityQueue.length;
				while (i < len) {
					id = this.priorityQueue[i];
					if (this.tasks.has(id)) {
						pObj = this.tasks.get(id);
						break;
					}
					i++;
				}
				if (pObj) {
					return { id: id, obj: pObj, ind: i };
				}
			}
			return false;
		}
	}, {
		key: 'dequeueTask',
		value: function dequeueTask(id) {
			if (id) {
				var val = this.tasks.get(id);
				// console.log("dequeud-",id);
				this.tasks.delete(id);
				return val;
			} else if (this.tasks.size || this.priorityQueue.length) {
				var pqObj = this.getPriorityQObj(),
				    gnxt,
				    gval,
				    obj,
				    isPriority = false,
				    ind;
				if (pqObj !== false) {
					id = pqObj.id;
					obj = pqObj.obj;
					ind = pqObj.ind;
					isPriority = true;
				} else {
					if (!this.tasks.size) {
						return;
					}
					var val = this.tasks.entries().next().value;
					id = val[0];
					obj = val[1];
				}
				// console.log("dequeud-",id);
				this.currentTask = { id: id, handler: obj.handler };
				Lyte.extendEventListeners(this.currentTask);
				if (this.isGenerator(obj.handler)) {
					gnxt = obj.handler.next();
					if (gnxt.done == false) {
						gval = gnxt.value;
						if (typeof gval == "function") {
							return gval;
						}
					} else {
						this.currentTask.triggerEvent("done", id);
						if (isPriority) {
							this.priorityQueue.splice(ind, 1);
						}
						this.tasks.delete(id);
						return this.dequeueTask();
					}
				} else {
					this.currentTask.triggerEvent("done", id);
					if (isPriority) {
						this.priorityQueue.splice(ind, 1);
					}
					this.tasks.delete(id);
				}
				return obj;
			}
		}
	}, {
		key: 'tasksScheduler',
		value: function tasksScheduler() {
			if (this.delayInit == false) {
				if (this.tasks.size) {
					if (this.idleCallbackRequested == false) {
						if ('requestIdleCallback' in window && this.useRequestIdleCallback) {
							this.idleCallbackRequested = true;
							requestIdleCallback(this.idleCallback);
						} else {
							this.requestIdleCallback(this.idleCallback);
						}
					}
				} else {
					if ('cancelIdleCallback' in window && this.useRequestIdleCallback) {
						cancelIdleCallback(this.idleCallback);
					}
				}
			}
		}
	}, {
		key: 'idleCallback',
		value: function idleCallback(deadline) {
			var task,
			    i = 0,
			    remTime = deadline.timeRemaining();
			while (remTime > 0 && this.tasks.size) {
				task = this.dequeueTask();
				if (this.perf) {
					var p1 = performance.now();
				}
				if (typeof task == "function") {
					// setTimeout(function(){
					task();
					// },1);
				}
				if ((typeof task === 'undefined' ? 'undefined' : _typeof(task)) == "object") {
					// setTimeout(function(){
					var data = task.data || [];
					if (typeof task.handler == "function") {
						var _task;

						(_task = task).handler.apply(_task, _toConsumableArray(data));
					}
					// },1);
				}
				if (this.perf) {
					var p2 = performance.now();
					var id = this.currentTask.id;
					this.processTime[id] = (this.processTime.hasOwnProperty(id) ? this.processTime[id] : 0) + (p2 - p1);
				}
				remTime = deadline.timeRemaining();
			}
			this.idleCallbackRequested = false;
			this.tasksScheduler();
		}
	}, {
		key: 'requestIdleCallback',
		value: function requestIdleCallback(callback) {
			var self = this;
			setTimeout(function () {
				setTimeout(function () {
					var startTime = Date.now();
					callback({
						timeRemaining: function timeRemaining() {
							var diffTime = Date.now() - startTime;
							if (diffTime > self.timeout) {
								return 0;
							}
							return self.timeout - diffTime;
						}
					});
				}, 1);
			}, 50);
		}
	}]);

	return IdleTaskScheduler;
}();

(function (Lyte) {
	var userAgent = Lyte.$.userAgent = window.userAgent = navigator.userAgent;
	var singletonServices = new Map();
	//temporary fix for IE 11
	if (userAgent.match(/rv:11/)) {
		Lyte.browser.ie = true;
		window.action = function () {
			return;
		};
	}
	if (userAgent.match('Edge')) {
		var s = createElement("div");
		s.innerHTML = "<template><div>c</div></template>";
		if (s.querySelector("template").childNodes.length) {
			Lyte.browser.ie = true;
		} else {
			Lyte.browser.edge = true;
		}
		s.remove();
	}

	Lyte.Globals.set = function (scope, value) {
		Lyte.Component.set(Lyte.__gl, scope, value);
	};

	Lyte.Globals.get = function (scope) {
		return Lyte.Component._get(Lyte.__gl, scope);
	};

	Object.defineProperty(Lyte.Service, "__Lyte__", {
		value: Lyte
	});
	Object.defineProperty(Lyte.Mixin, "__Lyte__", {
		value: Lyte
	});
	Object.defineProperty(Lyte.$, "__Lyte__", {
		value: Lyte
	});
	Lyte.Mixin.__Lyte__.requiredMixins = {};
	Lyte.oldProxy = typeof $Lt != "undefined" && $Lt.oldProxy ? $Lt.oldProxy : undefined;

	Lyte.$.assetsDiv = document.createElement("div");
	Lyte.$.assetsDiv.setAttribute("id", "lyteAssetsDiv");
	Lyte.assetsDivContainer = document.head;

	Lyte.$.widgetWrapper = document.createElement("shadow-wrapper");
	Lyte.$.widgetWrapper.attachShadow({ "mode": "open" }); //af
	Lyte.$.widgetWrapper.setAttribute("id", "widgetWrapperDiv");

	Lyte.domContentLoaded = function (callback) {
		if (document.readyState === "complete" || document.readyState === "interactive") {
			callback();
		} else {
			window.addEventListener('DOMContentLoaded', function () {
				callback();
			});
		}
	};

	Lyte.createApplication = function (name, obj) {
		if (obj.init) {
			obj.init.apply(Lyte);
		}
	};

	Lyte.registerErrorCodes = function (obj) {
		Object.assign(Lyte.errorCodes, obj);
	};

	Lyte.establishObserverBindings = function (observers, fromStore, properties, model) {
		var scope = this;
		var watchProps = model && fromStore ? model._fldGrps.JsonPathWatch : scope.constructor._deepWatchProperties;
		if (fromStore) {
			scope = fromStore;
		}
		for (var i = 0; i < observers.length; i++) {
			var props = observers[i].properties;
			var obsAttr = {},
			    obsDuplicate = false;
			var Jpath = {};
			for (var j = 0; j < props.length; j++) {
				var actProp;
				var isArrayObserver = false;
				if (typeof props[j] == "string") {
					if (props[j].search(/^\$\./g) != -1) {

						var JsonPath = props[j];

						var CmpPropertyPath = JsonPath.match(/[^\$.][^\.]*/g)[0];
						if (CmpPropertyPath.search(/\[[0-9*]\]/g) != -1) {
							CmpPropertyPath = CmpPropertyPath.split(/\[[0-9*]\]/g)[0];
						}
						if (watchProps[CmpPropertyPath] == undefined) {
							watchProps[CmpPropertyPath] = [];
						}

						if (Jpath[CmpPropertyPath] == undefined) {
							Jpath[CmpPropertyPath] = [];
						}

						var JSONPATH;
						var reg = "^\\$\\." + CmpPropertyPath + "\\.?";
						reg = new RegExp(reg);
						JSONPATH = props[j].replace(reg, "$.");
						if (!watchProps[CmpPropertyPath].includes(JSONPATH)) {
							watchProps[CmpPropertyPath].push(JSONPATH);
						}

						if (!Jpath[CmpPropertyPath].includes(JSONPATH)) {
							Jpath[CmpPropertyPath].push(JSONPATH);
						}

						CmpPropertyPath = CmpPropertyPath + ".*";
						if (!obsAttr.hasOwnProperty(CmpPropertyPath)) {
							actProp = Lyte.getProperty.call(this, CmpPropertyPath, fromStore, properties);
							obsAttr[CmpPropertyPath] = true;
							obsDuplicate = false;
						} else {
							obsDuplicate = true;
						}
					} else if (props[j].indexOf('.[]') !== -1) {
						isArrayObserver = true;
						actProp = Lyte.getProperty.call(this, props[j].substring(0, props[j].indexOf('.[]')), fromStore, properties);
					} else {
						if (props[j].indexOf('.*') !== -1) {
							var prop = props[j].split(".")[0];
							var isDeepObs = !fromStore && this.component.__data[prop] && this.component.__data[prop].watch || fromStore && model && model.fieldList && model.fieldList[prop] && model.fieldList[prop].watch ? true : false;
							if (!isDeepObs) {
								continue;
							}
						}
						actProp = Lyte.getProperty.call(this, props[j], fromStore, properties);
					}
					if (!obsDuplicate) {
						if (!actProp._observers) {
							Object.defineProperty(actProp, '_observers', {
								value: new Set(),
								enumerable: false,
								writable: true,
								configurable: true
							});
						}
						actProp._observers.add({ callee: scope, observer: observers[i], isArrayObserver: isArrayObserver });
					}
				} else {
					Lyte.warn("ERR27", JSON.stringify(props[j]), observers[i].fnName, this.tagName);
				}
			}
			observers[i].Jpath = Jpath;
			obsAttr = {};
		}
	};

	Lyte.getProperty = function (key, fromStore, properties) {
		var arr = key.match(/([^[\].]+|\[\])/g);
		var property = this;
		if (fromStore) {
			property = properties;
			if (!properties[arr[0]]) {
				properties[arr[0]] = {};
			}
			property = properties[arr[0]];
		} else {
			if (!property._properties[arr[0]]) {
				property._properties[arr[0]] = {};
			}
			property = property._properties[arr[0]];
		}

		Object.defineProperty(property, '_path', { enumerable: false, value: arr[0] });
		for (var i = 1; i < arr.length; i++) {
			if (arr[i].startsWith("'") || arr[i].startsWith('"')) {
				arr[i] = arr[i].substring(1, arr[i].length - 1);
			}
			if (!property[arr[i]]) {
				property[arr[i]] = {};
				Object.defineProperty(property[arr[i]], '_path', { enumerable: false, value: property._path + "." + arr[i] });
			}
			property = property[arr[i]];
		}
		return property;
	};

	Lyte.getErrorMessage = function (code) {
		var args = Array.from(arguments).slice(1);
		if (Lyte.errorCodes[code]) {
			return Lyte.errorCodes[code].replace(/{(\d+)}/g, function (t, i) {
				return args[i];
			});
		} else {
			return code;
		}
	};

	Lyte.error = function () {
		var errorObj = arguments[0],
		    parse = errorObj.stack;
		errorObj = parse ? errorObj : Error(Lyte.getErrorMessage.apply(Lyte, arguments));
		if (Lyte.onerror) {
			Lyte.onerror.call(this, errorObj, arguments[1]);
		}
		Lyte.triggerEvent("error", errorObj, arguments[1]);
		var safari = errorObj.stack && errorObj.stack.indexOf(errorObj.message) == -1;
		if (parse && !safari) {
			errorObj = JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj)));
		}
		if (arguments[1]) {
			console.error(errorObj.stack ? safari ? errorObj : errorObj.stack : errorObj.message, arguments[1]);
		} else {
			console.error(errorObj.stack ? safari ? errorObj : errorObj.stack : errorObj.message);
		}
	};

	Lyte.warn = function () {
		var errorObj = arguments[0];
		errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : Error(Lyte.getErrorMessage.apply(Lyte, arguments));
		console.warn(errorObj.stack ? errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace("Error: ", "") : errorObj : errorObj.message);
	};

	var requiredMixins = {};
	var fnProto = Function.prototype;
	if (!fnProto.on) {
		fnProto.on = function () {
			Lyte.warn("'.on()' method with the argument '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "callBack", "value": this.type === "observer" ? this.value : this, "properties": arguments, "observes": this.type === "observer" ? this : undefined };
		};
	}
	if (!fnProto.observes) {
		fnProto.observes = function () {
			Lyte.warn("'.observes()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "observer", "value": this, "properties": arguments, "on": Lyte._onObj, "lyteOn": Lyte._onObj };
		};
	}
	if (!fnProto.computed) {
		fnProto.computed = function () {
			Lyte.warn("'.computed()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "computed", "value": this, "properties": arguments };
		};
	}
	Lyte._onObj = function () {
		return { "type": "callBack", "value": this.type === "observer" ? this.value : this, "properties": arguments, "observes": this.type === "observer" ? this : undefined };
	};
	Lyte._observesObj = function () {
		return { "type": "observer", "value": this, "properties": arguments, "on": Lyte._onObj, "lyteOn": Lyte._onObj };
	};
	Lyte._computedObj = function () {
		return { "type": "computed", "value": this, "properties": arguments };
	};
	Lyte._preRegister = function () {
		Lyte._actualFnProtoOn = Function.prototype.on;
		Lyte._actualFnProtoObserves = Function.prototype.observes;
		Lyte._actualFnProtoComputed = Function.prototype.computed;
		var fnProto = Function.prototype;
		fnProto.on = fnProto.lyteOn = Lyte._onObj;
		fnProto.observes = fnProto.lyteObserves = Lyte._observesObj;
		fnProto.computed = fnProto.lyteComputed = Lyte._computedObj;
	};
	Lyte._postRegister = function () {
		var fnProto = Function.prototype;
		fnProto.on = Lyte._actualFnProtoOn;
		fnProto.observes = Lyte._actualFnProtoObserves;
		fnProto.computed = Lyte._actualFnProtoComputed;
	};
	Object.defineProperty(Lyte.Mixin, "register", {
		get: function get() {
			Lyte._preRegister();
			return Lyte.registerMixinWrapper;
		},
		"enumerable": true });
	Lyte.registerMixinWrapper = function () {
		try {
			Lyte.registerMixin.apply(Lyte, arguments);
			Lyte._postRegister();
		} catch (e) {
			Lyte._postRegister();
		}
	};
	Lyte.registerMixin = function (name, mixin) {
		Lyte.registeredMixins[name] = mixin;
		var req;
		if (req = requiredMixins[name]) {
			for (var key in req) {
				Lyte.$.requiredMixins[key](mixin, req[key], key);
			}
		}
	};

	Lyte.Mixin.get = function (name) {
		return Lyte.registeredMixins[name];
	};

	Lyte.$.instantiateService = function (name, data) {
		var service = Lyte.registeredServices[name];
		if (service.singleton == true) {
			if (singletonServices.has(name)) {
				return singletonServices.get(name);
			} else {
				var ins = new service(data);
				singletonServices.set(name, ins);
				return ins;
			}
		} else {
			return new service(data);
		}
	};

	Lyte.Service.register = function (name, service, isSingleton) {
		if (Lyte.registeredServices.hasOwnProperty(name)) {
			Lyte.warn('Service -' + name + ' is already registered');
			return;
		}
		if (!Lyte._keywords.is(name)) {
			var data = service,
			    req;
			if (isSingleton) {
				data.singleton = isSingleton;
			}
			Lyte.registeredServices[name] = data;
			var serv = Lyte.requiredServices[name];
			if (serv && serv.size) {
				serv.forEach(function (obj) {
					var toSend = data;
					if (obj.isGlobal) {
						toSend = Lyte.__gS[obj.key] = Lyte.__gS[obj.key] || Lyte.$.instantiateService(name, obj.data);
					}
					obj.cB(toSend, obj.key, obj.name, name);
				});
			}
			return data;
		} else {
			Lyte.warn('Service name-' + name + ' should not be a keyword used in Lyte');
		}
	};

	Lyte.Service.getInjected = function (key) {
		if (Lyte.__gS.hasOwnProperty(key)) {
			return Lyte.__gS[key];
		}
	};

	// Lyte.Service.get = function(name) {
	//   return Lyte.registeredServices[name];
	// }

	Lyte.$.requiredServices = function (key, serviceName, cB, type, name, isGlobal, data) {
		var reqServ = Lyte.requiredServices[serviceName];
		var req = reqServ ? reqServ : Lyte.requiredServices[serviceName] = new Map();
		var id = Lyte.$.genMapId(req);
		req.set(id, { key: key, cB: cB, type: type, name: name, serviceName: serviceName, isGlobal: isGlobal, data: data });
		return serviceName + "-" + id;
	};

	Lyte.$.lazyRegisterService = function (service, obj) {
		var scope = obj.scope,
		    name = obj.name,
		    callback = scope[obj.type][name];
		if (callback) {
			callback[obj.key] = service;
		}
	};

	Lyte.$.injectServices = {};
	Object.defineProperty(Lyte, "__gS", {
		value: {}
	});
	Lyte.injectServices = function (data) {
		var serv = {};
		if (!Array.isArray(data)) {
			data = [data];
		}
		data.forEach(function (itm) {
			if (itm && (typeof itm === 'undefined' ? 'undefined' : _typeof(itm)) == 'object') {
				var key = itm.as,
				    service = itm.service,
				    args = itm.data;
				if (!Lyte._keywords.is(key)) {
					if (!Lyte.toBeInjectedServices.hasOwnProperty(key)) {
						Lyte.toBeInjectedServices[key] = service;
						serv[key] = { service: service, data: args };
						if (Lyte.registeredServices[service]) {
							Lyte.__gS[key] = Lyte.$.instantiateService(service, args);
						}
					} else {
						Lyte.warn("A service has already been injected in the key named, ", key);
					}
				} else {
					Lyte.warn("Service cannot be used in any keywords of Lyte.");
				}
			} else if (typeof itm == "string") {
				if (!Lyte.toBeInjectedServices.hasOwnProperty(itm)) {
					Lyte.toBeInjectedServices[itm] = itm;
					serv[itm] = { service: itm };
					if (Lyte.registeredServices[itm]) {
						Lyte.__gS[itm] = Lyte.$.instantiateService(itm);
					}
				} else {
					Lyte.warn("A service has already been injected in the key named, ", itm);
				}
			} else {
				Lyte.warn("Invalid data passed to injectServices", itm);
			}
		});
		var mdlObj = Lyte.$.injectServices;
		for (var mKey in mdlObj) {
			for (var key in serv) {
				mdlObj[mKey](key, serv[key].service, mKey, Lyte.__gS[key], undefined, serv[key].data);
			}
		}
	};

	Lyte.$.genMapId = function (map) {
		var id = Math.floor(Math.random() * 10000000000 + 1);
		while (map.get(id)) {
			id = Math.floor(Math.random() * 10000000000 + 1);
		}
		return id.toString();
	};

	Lyte.$.toRemoveFromRequiredServices = function (str) {
		var arr = str.split("-"),
		    id = arr[arr.length - 1],
		    idLen = id.length,
		    servName = str.substr(0, str.length - (idLen + 1));
		var reqArr = Lyte.requiredServices[servName];
		if (reqArr) {
			reqArr.delete(id);
		}
	};

	Lyte.toBeUsedServices = function (obj) {
		// var serviceToBeUsed = obj.callback ? Object.assign({}, Lyte.toBeInjectedServices) : {};
		var serviceToBeUsed = {};
		var arr = obj.services;
		if (arr) {
			arr.forEach(function (service) {
				if (typeof service == "string") {
					serviceToBeUsed[service] = service;
				} else if (service && (typeof service === 'undefined' ? 'undefined' : _typeof(service)) == "object") {
					var key = service.as,
					    serv = service.service;
					if (!Lyte._keywords.is(key, obj.type)) {
						serviceToBeUsed[key] = serv;
					} else {
						Lyte.warn("Service cannot be used in any keywords of Lyte.");
					}
				}
			});
		}
		return serviceToBeUsed;
	};

	Lyte.extendService = function (arg) {
		var servObj = Lyte.toBeUsedServices(arg),
		    name;
		for (var serv in servObj) {
			name = servObj[serv];
			// var scp = arg.isGlobal && Lyte.__gS.hasOwnProperty(serv) : Lyte.registeredServices; 
			if (arg.isGlobal && Lyte.__gS.hasOwnProperty(serv) || !arg.isGlobal && Lyte.registeredServices.hasOwnProperty(name)) {
				var ins = arg.ins,
				    service = arg.isGlobal ? Lyte.__gS[serv] : Lyte.$.instantiateService(name);
				if (!Array.isArray(ins)) {
					ins = [arg.ins];
				}
				ins.forEach(function (insObj) {
					insObj[serv] = arg.isGlobal ? Lyte.__gS[serv] : Lyte.$.instantiateService(name);
				});
			} else {
				Lyte.$.requiredServices(serv, name, arg.callback, arg.type, arg.name, arg.isGlobal, arg.data);
			}
		}
	};

	Lyte.$.requiredMixins = function (mixin, dir, type) {
		var req = requiredMixins[mixin] ? requiredMixins[mixin] : requiredMixins[mixin] = {};
		if (!req[type]) {
			req[type] = [dir];
		} else {
			req[type].push(dir);
		}
	};

	Lyte.Mixin.exists = function (name) {
		if (!Lyte.registeredMixins[name]) {
			// Lyte.error('Mixin used before being registered.');
			return false;
		}
		return true;
	};

	Lyte.log = function (text, src, color) {
		if (Lyte.debug) {
			if (color) {
				console.log("%c" + text, 'color:' + color);
			} else {
				console.log(text);
			}
		}
	};

	Lyte.time = function (fn) {
		if (Lyte.performance) {
			var index;
			if ((index = Lyte.$.consoleTime.indexOf(fn)) != -1) {
				Lyte.$.consoleTime.splice(index, 1);
				console.timeEnd(fn);
			} else {
				Lyte.$.consoleTime.push(fn);
				console.time(fn);
			}
		}
	};
	/* disable async function */
	Lyte.isRecord = function (object) {
		if (object && object.$ && object.$.hasOwnProperty("isModified")) {
			return true;
		}
		return false;
	};

	Lyte.isComponent = function (object) {
		if (object && object.$node && object.__data) {
			return true;
		}
		return false;
	};

	/* --------- lyte router v2 changes starts---- */
	Lyte.$.reqFiles = {};

	Lyte.injectResources = function (files, every, completed, options) {
		var successFiles = [],
		    errorFiles = [];
		every = every || function () {};
		completed = completed || function () {};
		return new Promise(function (resolve, reject) {
			processRequirements(files, function () {
				if (options && options.defer) {
					options.defer({
						injectJS: injectJS,
						files: files,
						errorFiles: errorFiles
					});
					resolve();
				} else {
					injectJS(files, function () {
						completed(successFiles, errorFiles);
						if (errorFiles.length) {
							reject(successFiles, errorFiles);
						} else {
							resolve(successFiles, errorFiles);
						}
					});
				}
			}.bind(this));
		});

		function injectJS(files, resolve, execFiles) {
			var len;
			execFiles = execFiles || [];
			if (!files) {
				resolve(successFiles, errorFiles);
			} else {
				if (!Array.isArray(files)) {
					files = [files];
				}
				if (!files.length) {
					resolve(successFiles, errorFiles);
				}
				len = -files.length;
				files.forEach(function (file) {
					if (typeof file == "string") {
						var type = getFileExtn(file);
						if (type && (type == ".js" || type == ".css") && execFiles.indexOf(file) == -1) {
							execFiles.push(file);
							createScript(file, function () {
								loaded();
							});
						} else {
							loaded();
						}
					} else if (Array.isArray(file)) {
						injectJS(file, function () {
							loaded();
						});
					} else {
						len--;
						injectJS(file.parent, function () {
							injectJS(file.child, function () {
								loaded();
							});
							loaded();
						});
					}
				});
			}

			function loaded() {
				len++;
				if (len == 0) {
					resolve(successFiles, errorFiles);
				}
			}
		}

		function createScript(file, resolve) {
			var ev = Lyte.injectResources.respObj[file];
			if (ev && (!Lyte.injectResources.availableTags[file] || Lyte.injectResources.availableTags[file].tag.getAttribute("rel") == "preload")) {
				var type = getFileExtn(file),
				    tag;
				if (type == ".js") {
					tag = document.createElement('script');
					tag.setAttribute('type', "text/javascript");
					tag.setAttribute('src', file);
				} else if (type == ".css") {
					tag = document.createElement('link');
					tag.setAttribute('type', "text/css");
					tag.setAttribute('rel', "stylesheet");
					tag.setAttribute('href', file);
				}
				ev.getAttributeNames().forEach(function (attr) {
					if (["href", "as", "rel"].indexOf(attr) == -1) {
						tag.setAttribute(attr, ev.getAttribute(attr));
					}
				});
				tag.onerror = tag.onload = function (event) {
					if (event.type == "error") {
						errorFiles.push(event);
					} else {
						successFiles.push(event);
					}
					delete Lyte.injectResources.respObj[file];
					Lyte.injectResources.availableTags[file].tag.remove();
					Lyte.injectResources.availableTags[file] = { tag: tag, event: event, type: event.type == "error" ? "error" : "load" };
					resolve();
					tag.onerror = tag.onload = undefined;
				};
				Lyte.$.assetsDiv.appendChild(tag);
			} else {
				var t = Lyte.injectResources.availableTags[file];
				if (t.type == "error") {
					errorFiles.push(t.event);
				} else {
					successFiles.push(t.event);
				}
				resolve();
			}
		}

		function processRequirements(files, resolve) {
			var len;
			if (!files) {
				resolve();
			} else {
				if (!Array.isArray(files)) {
					files = [files];
				}
				if (!files.length) {
					resolve();
				}
				len = -files.length;
				files.forEach(function (file) {
					if (typeof file == "string") {
						requestFile(file, Lyte.injectResources.availableTags[file], function () {
							loaded();
						});
					} else if (Array.isArray(file)) {
						new Promise(function (r) {
							processRequirements(file, r);
						}).then(function () {
							loaded();
						});
					} else {
						len--;
						new Promise(function (r) {
							processRequirements(file.parent, r);
						}).then(function () {
							loaded();
						});
						new Promise(function (r) {
							processRequirements(file.child, r);
						}).then(function () {
							loaded();
						});
					}
				});
			}

			function loaded() {
				len++;
				if (len == 0) {
					resolve();
				}
			}

			function requestFile(file, cached, resolve) {
				if (Lyte.$.reqFiles[file]) {
					Lyte.$.reqFiles[file].push(resolve);
				} else {
					Lyte.$.reqFiles[file] = [resolve];
					if (cached && cached.event.type != "error") {
						if (Lyte.removeFromCache.arr.indexOf(file) != -1) {
							Lyte.removeFromCache.arr.splice(Lyte.removeFromCache.arr.indexOf(file), 1);
						}
						fileLoaded.call(cached.tag, file, cached.event, true);
						resolve();
					} else {
						makeRequest(file, function (event) {
							Lyte.injectResources.respObj[file] = this;
							Lyte.$.reqFiles[file].forEach(function (resolve) {
								resolve();
							});
							// filesObj[file] = this;
							fileLoaded.call(this, file, event);
							every.call(this, event);
						});
					}
				}
			}

			function fileLoaded(file, event, cached) {
				delete Lyte.$.reqFiles[file];
				if (!cached) {
					if (Lyte.injectResources.availableTags[file]) {
						Lyte.injectResources.availableTags[file].tag.remove();
						delete Lyte.injectResources.respObj[file];
					}
					Lyte.injectResources.availableTags[file] = { tag: this, event: event, type: event.type };
				}
			}
		}

		function makeRequest(file, callBack) {
			var tag,
			    ev = every.internal || {},
			    type = getFileExtn(file);
			ev.file = file;
			if (type == null) {
				Lyte.error('Type of file is not specified in injectResources.');
				return;
			}
			tag = document.createElement('link');
			tag.setAttribute('href', file);
			ev.tag = tag;
			if (type == '.css') {
				tag.setAttribute('as', "style");
			} else {
				tag.setAttribute('as', "script");
			}
			tag.setAttribute('rel', "preload");
			tag.onerror = tag.onload = function (event) {
				callBack.call(this, event);
				this.onerror = this.onload = undefined;
			};
			Lyte.triggerEvent("onBeforeInject", ev);
			Lyte.$.assetsDiv.appendChild(tag);
		};
	};

	function getFileExtn(file) {
		return file.match(/\.[a-zA-Z]+(?=\?|$)/);
	}

	Lyte.injectResources.availableTags = [];
	Lyte.injectResources.respObj = [];

	function getFileExtn(file) {
		return file.match(/\.[a-zA-Z]+(?=\?|$)/);
	}

	Lyte.$.replaceOldInjectResource = function () {
		Lyte.injectResources = function (files, every, completed) {
			var successFiles = [],
			    errorFiles = [];
			every = every || function () {};
			completed = completed || function () {};
			return new Promise(function (resolve) {
				processRequirements(files, resolve);
			}).then(function () {
				completed(successFiles, errorFiles);
			});

			function processRequirements(files, resolve) {
				var len;
				if (!files) {
					resolve();
				} else {
					if (!Array.isArray(files)) {
						files = [files];
					}
					if (!files.length) {
						resolve();
					}
					len = -files.length;
					files.forEach(function (file) {
						if (typeof file == "string") {
							requestFile(file, Lyte.injectResources.availableTags[file], function () {
								loaded();
							});
						} else if (Array.isArray(file)) {
							new Promise(function (r) {
								processRequirements(file, r);
							}).then(function () {
								loaded();
							});
						} else {
							new Promise(function (r) {
								processRequirements(file.parent, r);
							}).then(function () {
								new Promise(function (r1) {
									processRequirements(file.child, r1);
								}).then(function () {
									loaded();
								});
							});
						}
					});
				}

				function loaded() {
					len++;
					if (len == 0) {
						resolve();
					}
				}

				function requestFile(file, cached, resolve) {
					if (Lyte.$.reqFiles[file]) {
						Lyte.$.reqFiles[file].push(resolve);
					} else {
						Lyte.$.reqFiles[file] = [resolve];
						if (cached && cached.event.type != "error") {
							if (Lyte.removeFromCache.arr.indexOf(file) != -1) {
								Lyte.removeFromCache.arr.splice(Lyte.removeFromCache.arr.indexOf(file), 1);
							}
							fileLoaded.call(cached.tag, cached.event, true);
							resolve();
						} else {
							makeRequest(file, function (event) {
								Lyte.$.reqFiles[file].forEach(function (resolve) {
									resolve();
								});
								fileLoaded.call(this, event);
								every.call(this, event);
							});
						}
					}
				}

				function fileLoaded(event, cached) {
					var file = this.getAttribute('src') || this.getAttribute('href');
					delete Lyte.$.reqFiles[file];
					if (!cached) {
						if (Lyte.injectResources.availableTags[file]) {
							Lyte.injectResources.availableTags[file].tag.remove();
						}
						this.onerror = this.onload = undefined;
						Lyte.injectResources.availableTags[file] = { tag: this, event: { type: event.type } };
					}
				}
			}

			function makeRequest(file, callBack) {
				var tags = { ".js": 'script', ".css": 'link' },
				    type = getFileExtn(file);
				tag = document.createElement(tags[type]);
				if (!type) {
					Lyte.error('Type of file is not specified in injectResources.');
					return;
				} else if (type == '.css') {
					tag.setAttribute('href', file);
					tag.setAttribute('type', "text/css");
					tag.setAttribute('rel', "stylesheet");
				} else {
					tag.setAttribute('src', file);
				}
				tag.onerror = tag.onload = function (event) {
					if (event.type == "error") {
						errorFiles.push(event);
					} else {
						successFiles.push(event);
					}
					if (callBack) {
						callBack.call(this, event);
					}
				};
				var ev = every.internal || {};
				ev.file = file;
				ev.tag = tag;
				Lyte.triggerEvent("onBeforeInject", ev);
				Lyte.$.assetsDiv.appendChild(tag);
			};
		};

		Lyte.injectResources.availableTags = [];
		Lyte.injectResources.respObj = [];
	};

	Lyte.removeFromCache = function (arr) {
		Lyte.removeFromCache.assign(arr);
		if (Lyte.removeFromCache.arr.length) {
			Lyte.removeFromCache.arr.forEach(function (file) {
				if (Lyte.injectResources.availableTags[file]) {
					Lyte.injectResources.availableTags[file].tag.remove();
					delete Lyte.injectResources.availableTags[file];
					delete Lyte.injectResources.respObj[file];
				}
			});
			Lyte.removeFromCache.arr = [];
		}
	};

	Lyte.removeFromCache.arr = [];

	Lyte.removeFromCache.assign = function (arr) {
		arr = arr == "*" ? Object.keys(Lyte.injectResources.availableTags) : Array.isArray(arr) ? arr : [arr];
		Lyte.removeFromCache.arr = Lyte.removeFromCache.arr.concat(arr);
		return;
	};

	Lyte.$.prefetchSupport = false;
	try {
		if (!Lyte.browser.ie) {
			var link = document.createElement('link');
			Lyte.$.prefetchSupport = link.relList.supports('prefetch') && link.relList.supports('preload');
		}
	} catch (e) {}
	if (!Lyte.$.prefetchSupport) {
		console.log("Prefetch is not supported. Falling back to old implementation");
		Lyte.$.replaceOldInjectResource();
	}

	/* --------- lyte router v2 changes ends ---- */

	Lyte.checkProperty = function (property, dataVal, key, fieldVal, field, record, type, name, init) {
		var exts = "extends";
		switch (property) {
			case "type":
				if (Lyte.Transform.hasOwnProperty(fieldVal) && dataVal !== undefined && dataVal !== null) {
					var _fld = Lyte.Transform[fieldVal],
					    _ret = true;
					if (Array.isArray(dataVal)) {
						if (Lyte.Transform[fieldVal][exts] != "array") {
							return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
						}
						if (_fld.hasOwnProperty("items")) {
							_ret = Lyte.checkProperty("items", dataVal, key, _fld.items);
						}
					} else if ((typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal)) === "object" && Lyte.Transform[fieldVal][exts] == "object" && _fld.hasOwnProperty("properties")) {
						_ret = Lyte.checkProperty("properties", dataVal, key, _fld.properties);
					} else if (Lyte.Transform[fieldVal][exts] != (typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal))) {
						return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
					}
					if (_ret !== true) {
						return _ret;
					}
				} else if (dataVal !== undefined && dataVal !== null) {
					if (Array.isArray(dataVal)) {
						if (fieldVal != "array") {
							return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
						}
					} else if (fieldVal != (typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal))) {
						return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
					}
				}
				break;
			case "mandatory":
				var validateFlag = fieldVal;
				if ((typeof fieldVal === 'undefined' ? 'undefined' : _typeof(fieldVal)) == "object") {
					if (init && fieldVal.skipValidationOnInit == true) {
						validateFlag = false;
					}
				}
				if (validateFlag && (dataVal == undefined || dataVal == null || dataVal === "")) {
					return { code: "ERR02", message: Lyte.errorCodes.ERR02 };
				}
				break;
			case "maximum":
				if (typeof dataVal == "number" && dataVal > fieldVal) {
					return { code: "ERR04", message: Lyte.errorCodes.ERR04, expected: fieldVal };
				}
				break;
			case "minimum":
				if (typeof dataVal == "number" && dataVal < fieldVal) {
					return { code: "ERR05", message: Lyte.errorCodes.ERR05, expected: fieldVal };
				}
				break;
			case "maxLength":
			case "maxItems":
				if (dataVal && dataVal.length > fieldVal) {
					return { code: "ERR06", message: Lyte.errorCodes.ERR06, expected: fieldVal };
				}
				break;
			case "minLength":
			case "minItems":
				if (dataVal && dataVal.length < fieldVal) {
					return { code: "ERR07", message: Lyte.errorCodes.ERR07, expected: fieldVal };
				}
				break;
			case "pattern":
				if (typeof dataVal == "string" && !new RegExp(fieldVal).test(dataVal)) {
					return { code: "ERR08", message: Lyte.errorCodes.ERR08, expected: fieldVal };
				}
				break;
			case "uniqueItems":
				{
					if (Array.isArray(dataVal) && fieldVal) {
						var newArr = [];
						for (var i = 0; i < dataVal.length; i++) {
							var val = dataVal[i];
							if (newArr.indexOf(val) != -1) {
								return { code: "ERR09", message: Lyte.errorCodes.ERR09 };
							}
							newArr.push(val);
						}
					}
					break;
				}
			case "constant":
				if (Array.isArray(dataVal)) {
					var resp = dataVal.length == fieldVal.length && dataVal.every(function (v, i) {
						return v === fieldVal[i];
					});
					if (!resp) {
						return { code: "ERR10", message: Lyte.errorCodes.ERR10, expected: fieldVal };
					}
				} else if ((typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal)) == "object") {
					var resp = store.adapter.$.compareObjects(dataVal, fieldVal);
					if (!resp) {
						return { code: "ERR10", message: Lyte.errorCodes.ERR10, expected: fieldVal };
					}
				} else if (dataVal && dataVal != fieldVal) {
					return { code: "ERR10", message: Lyte.errorCodes.ERR10, expected: fieldVal };
				}
				break;
			case "items":
				{
					if (Array.isArray(dataVal)) {
						for (var i = 0; i < dataVal.length; i++) {
							if (!(fieldVal.any && Array.isArray(fieldVal))) {
								fieldVal = [fieldVal];
							}
							var fldLen = fieldVal.length,
							    _ret = true;
							for (var j = 0; j < fldLen; j++) {
								var _fld = fieldVal[j];
								for (var property in _fld) {
									var resp = Lyte.checkProperty(property, dataVal[i], i, _fld[property], _fld);
									if (resp !== true) {
										if (_ret === true) {
											resp.path = resp.path ? i + "." + resp.path : resp.path;
											_ret = resp;
										}
										break;
									}
								}
							}
							if (_ret !== true) {
								return _ret;
							}
						}
					}
					break;
				}
			case "properties":
				if ((typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal)) == "object" && !Array.isArray(dataVal)) {
					for (var key in dataVal) {
						if (fieldVal.hasOwnProperty(key)) {
							var fld = fieldVal[key];
							if (!(fld.any && Array.isArray(fld))) {
								fld = [fld];
							}
							var fldLen = fld.length,
							    _ret = true;
							for (var i = 0; i < fldLen; i++) {
								var _fld = fld[i];
								for (var property in _fld) {
									var resp = Lyte.checkProperty(property, dataVal[key], key, _fld[property], _fld);
									if (resp != true) {
										if (_ret === true) {
											resp.path = resp.path ? key + "." + resp.path : key.toString();
											_ret = resp;
										}
										break;
									}
								}
							}
							if (_ret !== true) {
								return _ret;
							}
						}
						// else if(field.exact){
						// 	return { code : "ERR29", message: Lyte.errorCodes.ERR29, property: key };
						// }
					}
				}
				break;
			case "validation":
				{
					var resp = Lyte.customValidator[fieldVal].apply(record, [key, dataVal, name]);
					if (resp != true) {
						return resp;
					}
					break;
				}
			case "instanceof":
				{
					if ((typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal)) === "object" && !Array.isArray(dataVal) && !(dataVal instanceof fieldVal)) {
						return { code: "ERR30", message: Lyte.errorCodes.ERR30, property: key, instanceof: fieldVal };
					}
				}
		}
		return true;
	};

	Lyte.checkNestedProp = function (id, path, dtype, wobj, object, property, value, check, fromStore) {
		if (Lyte.Transform[dtype.type]) {
			dtype = Lyte.Transform[dtype.type];
			dtype.type = dtype.extends;
		}
		if (path.length != 0) {
			if (dtype.type == 'array') {
				if (dtype.items && !isNaN(path[0]) && _typeof(dtype.items) == 'object') {
					path = path.slice(1);
					Lyte.checkNestedProp(id, path, dtype.items, wobj, object, property, value, check, fromStore);
				}
			} else if (dtype.type == "object") {
				if (dtype.properties && dtype.properties.hasOwnProperty(path[0])) {
					var k = path[0];
					path = path.slice(1);
					Lyte.checkNestedProp(id, path, dtype.properties[k], wobj, object, property, value, check, fromStore);
				}
			}
		} else {
			var err;
			if (dtype && (dtype.properties || dtype.items) && !check.hasOwnProperty("warn")) {
				var component = {};component.__data = {};
				if (dtype.properties) {
					component.__data[property] = dtype.properties[property];
				} else if (dtype.items && wobj.index) {
					component.__data[wobj.index] = dtype;
				} else {
					component.__data[property] = dtype.items;
				}
				var cp = Lyte.validate(object, property, value, component);
				var errKey = wobj.attr ? wobj.attr : wobj.key,
				    _path = wobj.path.split(".");
				var PathWay = wobj.index == undefined && property ? wobj.path + (wobj.path != "" ? "." : "") + property : wobj.index != undefined ? wobj.path + (wobj.path != "" ? "." : "") + wobj.index : wobj.path;
				if (cp && (typeof cp === 'undefined' ? 'undefined' : typeof cp === 'undefined' ? 'undefined' : _typeof(cp)) == "object" && cp.code) {
					cp.value = value;
					cp.path = wobj.path != "" ? wobj.path : property;
					if (wobj.isRec && fromStore && wobj.key == undefined && wobj.path != "") {
						errKey = wobj.path.split(".")[0];
						_path.shift();
						_path = _path.length == 1 && _path[0] == property ? [] : _path;
					}
					// wobj.Error ? true : wobj.Error = {}
					wobj.Error && wobj.Error[errKey] ? wobj.Error[errKey].code && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : wobj.Error[errKey].nested = {} : wobj.Error[errKey] = { nested: {} };
					wobj.Error[errKey].code = "ERR34";
					wobj.Error[errKey].message = Lyte.errorCodes.ERR34;
					err = wobj.Error[errKey].nested;
					wobj._cmpErr[errKey] ? true : wobj._cmpErr[errKey] = {};
					wobj._cmpErr[errKey].code = "ERR34";
					wobj._cmpErr[errKey].message = Lyte.errorCodes.ERR34;
					var cmpErrPath = wobj._cmpErr[errKey].path ? wobj._cmpErr[errKey].path : [];
					if (wobj.path != "") {
						_path.forEach(function (k) {
							if (err && !err[k]) {
								err = err[k] = {};
							} else {
								err = err[k];
							}
						});
					}
					wobj.index != undefined ? err[wobj.index] = cp : err[property] = cp;
					if (!cmpErrPath.includes(PathWay)) {
						cmpErrPath.push(PathWay);
					}
					wobj._cmpErr[errKey].path = cmpErrPath;
				} else {
					if (wobj.isRec && fromStore && wobj.key == undefined) {
						errKey = wobj.path.split(".")[0];
						_path.shift();
						_path = _path.length == 1 && _path[0] == property ? [property] : _path;
					}
					err = wobj.Error[errKey] && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : undefined;
					var cmpErr = wobj._cmpErr[errKey] || undefined;
					if (cmpErr && cmpErr.path && cmpErr.path.includes(PathWay)) {
						var ind = cmpErr.path.indexOf(PathWay);
						cmpErr.path.splice(ind, 1);
					}
					//var p = object.$.error[property];
					if (err) {
						var key = wobj.index || property;
						var flag = true,
						    p = PathWay.split(".");
						p.forEach(function (r) {
							if (err[r] && err[r].code) {
								delete err[r];
								if (err && Object.keys(err).length == 0) {
									flag = true;
								} else {
									flag = false;
								}
							} else {
								err = err[r];
							}
						});
						if (flag == true && wobj.Error[errKey] && wobj._cmpErr[errKey]) {
							delete wobj.Error[errKey];
							delete wobj._cmpErr[errKey];
						}
					}
				}
				if (check.value && check.value.hasOwnProperty("code") && cp.code || !check.value) {
					check.value = cp;
				}
			}
		}
		wobj.index && delete wobj.index;
	};

	Lyte.types = ["string", "object", "number", "boolean", "array"];

	Lyte.attr = function (type, opts) {
		var obj = {};
		obj.type = type;
		if (opts == undefined) {
			opts = {};
		}
		if (Lyte.types.indexOf(type) == -1 && !Lyte.Transform.hasOwnProperty(type)) {
			throw new Error("Not a valid field type - " + type);
		}
		Object.assign(obj, opts);
		return obj;
	};

	window.prop = Lyte.attr;
	Lyte.defineRelation = function (name, type, opts) {
		var relation = { type: "relation", relType: type, relatedTo: name };
		if (opts) {
			relation.opts = opts;
		}
		return relation;
	};

	Lyte.belongsTo = function (name, opts) {
		return this.defineRelation(name, "belongsTo", opts);
	};

	Lyte.hasMany = function (name, opts) {
		return this.defineRelation(name, "hasMany", opts);
	};

	Lyte.Transform = {};

	Lyte.customValidator = {};

	Lyte.registerDataType = function (fieldTypeName, properties) {
		var exts = "extends";
		if (this.Transform.hasOwnProperty(fieldTypeName)) {
			Lyte.warn("Custom Field Type - " + fieldTypeName + " -  already exists.");
			return;
		}
		if (properties[exts] == undefined || Lyte.types.indexOf(properties[exts]) == -1) {
			Lyte.error("Not a valid field type - " + properties[exts]);
			return;
		}
		this.Transform[fieldTypeName] = properties;
	};

	Lyte.registerValidator = function (customValidatorName, func) {
		if (this.customValidator.hasOwnProperty(customValidatorName)) {
			Lyte.warn("Custom Validator with name - " + customValidatorName + " - already exists");
			return;
		}
		this.customValidator[customValidatorName] = func;
	};

	Lyte.patterns = {
		email: /^([A-Za-z0-9._%\-'+/]+@[A-Za-z0-9.-]+\.[a-zA-Z]{2,22})$/,
		url: /(^(ht|f)tp(s?):\/\/[0-9a-zA-Z][-.\w]*(:[0-9])*(\/?)([a-zA-Z0-9\-.?,:'/\\+=&amp;%$#_[\]@!()*;~]*)?$)/,
		ampm: /^(AM|PM|am|pm)$/,
		hour: /^(0?[0-9]|1[0-9]|2[0-4])$/,
		minute: /^(0?[0-9]|[1-5][0-9]|60)$/,
		boolean: /^(true|false|TRUE|FALSE)$/,
		alphaNumeric: /([a-zA-Z0-9])+/,
		alphabetsOnly: /([a-zA-Z])+/,
		numeric: /([0-9])+/,
		phoneNo: /^[0-9a-zA-Z+.()\-;\s]+$/
	};

	Lyte.validate = function (object, key, value, component, init) {
		var definition = component.__data[key];
		var isError = false;
		var type = definition ? definition.type : undefined;
		var _def = definition;
		if (_def) {
			if (!(_def.any && Array.isArray(_def))) {
				_def = [_def];
			}
			var defLen = _def.length,
			    _ret = true;
			for (var i = 0; i < defLen; i++) {
				var _d = _def[i];
				for (var defKey in _d) {
					isError = Lyte.checkProperty(defKey, value, key, _d[defKey], _d, object, type, undefined, init);
					if (isError !== true) {
						if (_ret === true) {
							_ret = isError;
						}
					}
				}
			}
			if (_ret !== true) {
				return _ret;
			}
		}
		return false;
	};

	Lyte.registerPattern = function (patternName, pattern) {
		this.patterns[patternName] = pattern;
	};

	Lyte.errorCodes = {
		ERR01: "Primary key cannot be modified", ERR02: "Mandatory field cannot be empty", ERR03: "Type of value does not match the specified data type", ERR04: "Value is greater than the maximum value allowed",
		ERR05: "Value is less than the minimum value allowed", ERR06: "Length of string/array is greater than the maximum limit allowed", ERR07: "Length of string/array is less than the minimum limit allowed",
		ERR08: "String does not match the specified pattern", ERR09: "Values in array are not unique", ERR10: "Value is not equal to the specified constant", ERR11: "Model of related field is not defined",
		ERR12: "Model of backward relation is not defined", ERR13: "Record not found", ERR14: "Model does not match the related field model", ERR15: "Error in creating a record as a relation",
		ERR16: "Record with primary key already exists", ERR17: "Value cannot be changed because record has been deleted", ERR18: "Action not defined", ERR19: "Model not defined",
		ERR20: "Key not specified", ERR21: "'belongsTo' relationship expects a single object/id", ERR22: "Type not specified for polymorphic relation", ERR23: "Primary Key value not present", ERR24: "Error while relating record", ERR25: "Backward relation not present", ERR26: "Primary key value cannot be undefined or null",
		ERR27: "Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'",
		ERR28: "Unloaded record cannot be saved",
		ERR29: "Property not defined in the object",
		ERR30: "Error in variables declaration for Query", ERR31: "Query not registered for the Model",
		ERR32: "Property not defined in the object",
		ERR33: "Property's value is not an instanceof the mentioned class",
		ERR34: "Type definition for nested properties / items does not match with the value",
		ERR35: "A datatype mismatch has occurred for custom DataType '{0}'"
	};

	Lyte.registeredGlobalEvents = Lyte.__lyteRegisteredEvents = {};
	Lyte.__lyteRegisteredEventsGlobal = {};
	Lyte.triggerEvent = function (obj) {
		var args;
		var actArgs;
		var eventObjectPath;
		if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == "object" && obj.global) {
			actArgs = obj.args;
			args = Array.prototype.slice.call(actArgs, 1);
			eventName = actArgs[0];
			eventObjectPath = "__lyteRegisteredEventsGlobal";
		} else {
			args = Array.prototype.slice.call(arguments, 1);
			eventName = arguments[0];
			eventObjectPath = "__lyteRegisteredEvents";
		}
		var stopEvent = false;
		var s = this[eventObjectPath][eventName];
		if (!s) {
			s = this[eventObjectPath][eventName] = { "listeners": [] };
		} else {
			for (var i = 0; i < s.listeners.length; i++) {
				var func = s.listeners[i];
				if (func) {
					var ret = func.apply(this, args);
					if (ret === false) {
						stopEvent = true;
						break;
					}
				}
			}
		}
		var customEvent = new CustomEvent(eventName, { "detail": args });
		if (!stopEvent) {
			document.dispatchEvent(customEvent);
		}
	};
	Lyte.triggerGlobalEvent = function () {
		return Lyte.triggerEvent({ "global": true, "args": Array.from(arguments) });
	};

	Lyte.addEventListener = function (eventName, func, options) {
		if (typeof func !== "function") {
			Lyte.error("Second parameter to Lyte.Component.addGlobalEventListener() must be a function");
			return;
		}
		var eventObjectPath = options && options.global ? "__lyteRegisteredEventsGlobal" : "__lyteRegisteredEvents";
		var s = this[eventObjectPath][eventName];
		if (!s) {
			s = this[eventObjectPath][eventName] = { "listeners": [] };
		}
		var d = s.listeners.push(func);
		return eventName + "-" + (d - 1);
	};

	Lyte.removeEventListener = function (id, options) {
		var lastIndex = void 0;
		if (!id || (lastIndex = id.lastIndexOf("-")) == -1) {
			Lyte.error("listener unique id not specified / invalid");
			return;
		}
		var globalId = id.split("-");
		if (options) {
			var globalId = id.split("-");
			var eventObjectPath = options && options.global ? "__lyteRegisteredEventsGlobal" : "__lyteRegisteredEvents";
			var s = this[eventObjectPath][globalId[0]];
			if (!s || !s.listeners[globalId[1]]) {
				Lyte.error("No such listener registered");
				return;
			}
			s.listeners[globalId[1]] = null;
		} else {
			var eventName = id.substring(0, lastIndex);
			var eventId = id.substring(lastIndex + 1);
			var s = this.__lyteRegisteredEvents[eventName];
			if (!s || !s.listeners[eventId]) {
				Lyte.error("No such listener registered");
				return;
			}
			s.listeners[eventId] = null;
		}
	};

	Lyte.extendEventListeners = function (scp) {
		if (scp && (typeof scp === 'undefined' ? 'undefined' : _typeof(scp)) == "object" && !scp.hasOwnProperty("__lyteRegisteredEvents")) {
			Object.defineProperties(scp, {
				__lyteRegisteredEvents: {
					value: {}
				},
				addEventListener: {
					value: Lyte.addEventListener
				},
				removeEventListener: {
					value: Lyte.removeEventListener
				},
				triggerEvent: {
					value: Lyte.triggerEvent
				}
			});
		}
	};

	Lyte.deepCopyObject = function (obj) {
		var targetVal = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
		var current,
		    copies = [{ source: obj, target: targetVal }],
		    keys,
		    propertyIndex,
		    descriptor,
		    nextSource,
		    indexOf,
		    sourceReferences = [obj];
		var cloneObject = copies[0].target,
		    targetReferences = [cloneObject];
		while (current = copies.shift()) {
			keys = Object.keys(current.source);
			for (propertyIndex = 0; propertyIndex < keys.length; propertyIndex++) {
				descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
				if (!descriptor) {
					continue;
				}
				if (!descriptor.value || _typeof(descriptor.value) != "object") {
					Object.defineProperty(current.target, keys[propertyIndex], descriptor);
					continue;
				}
				nextSource = descriptor.value;
				descriptor.value = Array.isArray(nextSource) ? [] : nextSource instanceof Set ? new Set() : Object.create(Object.getPrototypeOf(nextSource));
				indexOf = sourceReferences.indexOf(nextSource);
				if (indexOf != -1) {
					descriptor.value = targetReferences[indexOf];
					Object.defineProperty(current.target, keys[propertyIndex], descriptor);
					continue;
				}
				sourceReferences.push(nextSource);
				targetReferences.push(descriptor.value);
				Object.defineProperty(current.target, keys[propertyIndex], descriptor);
				copies.push({ source: nextSource, target: descriptor.value });
			}
			if (Lyte.isRecord(current.source)) {
				Object.defineProperty(current.target, "$", {
					value: {}
				});
				current.target.$.isNew = current.source.$.isNew;
				current.target.$.isModified = current.source.$.isModified;
				current.target.$.isDeleted = current.source.$.isDeleted;
				current.target.$.pK = current.source.$.pK;
				current.target.$._attributes = current.source.$._attributes;
				current.target.$.isCloned = true;
				current.target.$.model = { _name: current.source.$.model._name };
				if (current.source.$.hasOwnProperty("deepNest")) {
					current.target.$.deepNest = current.source.$.deepNest;
				}
				if (current.source.$.hasOwnProperty("partialType")) {
					current.target.$.partialType = current.source.$.partialType;
				}
			}
			if (Array.isArray(current.source)) {
				if (current.source.partial) {
					Object.defineProperty(current.target, "partial", {
						value: current.source.partial
					});
				}
			}
		}
		return cloneObject;
	};

	Lyte.nestScpId = 1;
	Lyte.nestScp = {};
	Lyte.__nestRef__ = {};
	// Lyte.__nestScp__ = {};
	Lyte.__nestScp__ = new Map();
	// Lyte.__nestScp1__ = new Map();
	Lyte.establishObjectBinding = function (data, attr, fromStore, update, storeRecord, watch) {
		var model, fld, nestObj;
		var checkAttrs = data.__component__ && data.__component__.component.__data ? data.__component__.component.__data[attr] : undefined;
		if (fromStore) {
			if (data && !data.$ && data._scp) {
				var keys = Array.from(data._scp.keys());
				keys.forEach(function (id) {
					var recObj = Lyte.nestScp[id];
					model = store.modelFor(recObj.model);
				});
			} else {
				model = data.$.model;
			}
			fld = model && model.fieldList && model.fieldList.hasOwnProperty(attr) ? model.fieldList[attr] : {};
			var _checkDtype = false;
			if (fld) {
				var _dtype = Lyte.Transform[fld.type];
				if (_dtype && (_dtype.hasOwnProperty("properties") || _dtype.hasOwnProperty("items"))) {
					_checkDtype = true;
				}
			}
			if (fld && fld.type !== "relation" && fld.watch || _checkDtype) {
				checkAttrs = fld;
			} else {
				if (data._scp) {
					var keys = Array.from(data._scp.keys());
					keys.forEach(function (id) {
						var _mpObj = data._scp.get(id),
						    mpObj = _mpObj.paths;
						var _dtype = Lyte.nestScp[id] || undefined;
						watch = _dtype && _dtype["watch"] ? _dtype["watch"] : watch;
						for (var key in mpObj) {
							var path = key ? key.split(".") : [];
							path.push(attr);
							Lyte.bindObj(data, attr, id, path, new Map(), undefined, checkAttrs, watch, true);
						}
					});
				}
				return;
			}
		}
		if (update && data._scp && data._scp.size) {
			var keys = Array.from(data._scp.keys());
			keys.forEach(function (id) {
				var _mpObj = data._scp.get(id),
				    mpObj = _mpObj.paths;
				var _dtype = Lyte.nestScp[id] || undefined;
				watch = _dtype && _dtype["watch"] ? _dtype["watch"] : watch;
				for (var key in mpObj) {
					var path = key ? key.split(".") : [];
					path.push(attr);
					Lyte.bindObj(data, attr, id, path, new Map(), undefined, checkAttrs, watch, true);
				}
			});
		}
		var customDtype = false;
		if (checkAttrs && Lyte.Transform[checkAttrs.type]) {
			var dtype = Lyte.Transform[checkAttrs.type];
			if (dtype.hasOwnProperty("properties") || dtype.hasOwnProperty("items")) {
				checkAttrs = Lyte.Transform[checkAttrs.type];
				customDtype = true;
			}
		}
		if ((!fromStore || fld.watch || fld.properties || fld.items || watch || customDtype) && data[attr]) {
			var _scpObj, kmpKey;
			if (data && data.__component__) {
				data.__component__.__scpObj || Object.defineProperty(data.__component__, "__scpObj", {
					value: {}
				});
				kmpKey = data.__component__;
				_scpObj = data.__component__.__scpObj;
			} else if (Lyte.isRecord(data)) {
				data.$.__scpObj || Object.defineProperty(data.$, "__scpObj", {
					value: {}
				});
				kmpKey = data;
				_scpObj = data.$.__scpObj;
			}
			var obj = _scpObj,
			    id;
			if (_scpObj) {
				var __nestScp1Set__ = false,
				    __nestScp2Set__ = false;
				if (fromStore) {
					if (data[attr] && !Lyte.__nestScp__.has(data[attr])) {
						nestObj = { model: model._name, attr: attr, pK: data.$.pK, Error: {} };
						__nestScp1Set__ = true;
					} else {
						// var kmp = Lyte.__nestScp__[kid] = Lyte.__nestScp__[kid] || new Map();
						// data ? kmp.set(data, true) : undefined;
						var __nId = Lyte.__nestScp__.get(data[attr]);
						var refMp = Lyte.__nestRef__[__nId] = Lyte.__nestRef__[__nId] || new Map();
						var refMpId = Lyte.$.genMapId(refMp);
						refMp.set(refMpId, true);
						Lyte.setRecBindMap(Lyte.nestScp[__nId], { model: model._name, attr: attr, pK: data.$.pK, Error: {} });
						obj[attr] = __nId + "_" + refMpId;
					}
				} else {
					if (data[attr] && !Lyte.__nestScp__.has(data[attr])) {
						var ErrMap = [],
						    cmpDataKeys = {};
						cmpDataKeys.key = attr;
						cmpDataKeys.dtype = data.__component__.component.__data[attr];
						cmpDataKeys._cmpErr = data.errors;
						cmpDataKeys.Error = {};
						ErrMap.push(cmpDataKeys);
						nestObj = { data: data[attr], PropsInfo: ErrMap };
						if (cmpDataKeys.dtype.watch) {
							nestObj.watch = true;
						}
						__nestScp2Set__ = true;
					} else {
						var __nId = Lyte.__nestScp__.get(data[attr]);
						var scope = Lyte.nestScp[__nId];
						if (scope) {
							if (!scope.PropsInfo) {
								scope.PropsInfo = [];
							}
							var errMp = scope.PropsInfo;
							var cmpDataKeys = {};
							cmpDataKeys.key = attr;
							cmpDataKeys.Error = {};
							cmpDataKeys._cmpErr = data.errors;
							cmpDataKeys.dtype = data.__component__.component.__data[attr];
							if (cmpDataKeys.dtype.watch) {
								scope.watch = true;
							}
							errMp.push(cmpDataKeys);
						}
						var refMp = Lyte.__nestRef__[__nId] = Lyte.__nestRef__[__nId] || new Map();
						var refMpId = Lyte.$.genMapId(refMp);
						refMp.set(refMpId, true);
						obj[attr] = __nId + "_" + refMpId;
					}
				}
				if (nestObj) {
					var nestScpId = Lyte.nestScpId++;
					var refMp = Lyte.__nestRef__[nestScpId] = Lyte.__nestRef__[nestScpId] || new Map();
					var refMpId = Lyte.$.genMapId(refMp);
					refMp.set(refMpId, true);
					// var kmp = Lyte.__nestScp__[nestScpId] = Lyte.__nestScp__[nestScpId] || new Map();
					// kmp.set(kmpKey, true);
					Lyte.__nestScp__.set(data[attr], nestScpId);
					if (__nestScp1Set__) {
						Lyte.nestScp[nestScpId] = {};
						Lyte.setRecBindMap(Lyte.nestScp[nestScpId], nestObj);
						Lyte.nestScp[nestScpId].Error = nestObj.Error;
						//     Lyte.setRecBindMap(model._name, attr, data.$.pK, nestScpId); 
					}
					if (__nestScp2Set__) {
						Lyte.nestScp[nestScpId] = nestObj;
						//     Lyte.__nestScp2__.set(data[attr], nestScpId);
					}
					Lyte.nestScp[nestScpId]._data = data[attr];
					obj[attr] = obj[attr] || nestScpId + "_" + refMpId;
					var path = [];
					// fromStore ? path.push(attr) : undefined;
					Lyte.bindObj(data, attr, nestScpId, path, new Map(), undefined, checkAttrs, watch);
				}
			}
		}
	};

	Lyte.removeNestScp2Bind = function (mp, mdlObj) {
		var mp = mp.model;
		if (mp.has(mdlObj.model)) {
			var mp1 = mp.get(mdlObj.model);
			if (mp1.has(mdlObj.pK)) {
				var mp2 = mp1.get(mdlObj.pK);
				if (mp2.has(mdlObj.attr)) {
					mp2.delete(mdlObj.attr);
				}
				!mp2.size ? mp1.delete(mdlObj.pK) : undefined;
			}
			!mp1.size ? mp.delete(mdlObj.model) : undefined;
		}
	};

	Lyte.setRecBindMap = function (obj, nestObj) {
		var mp = obj.model = obj.model || new Map(),
		    modelName = nestObj.model,
		    pK = nestObj.pK,
		    attr = nestObj.attr;
		if (modelName && !mp.has(modelName)) {
			mp.set(modelName, new Map());
		}
		mp = mp.get(modelName);
		if (pK && !mp.has(pK)) {
			mp.set(pK, new Map());
		}
		mp = mp.get(pK);
		if (attr && !mp.has(attr)) {
			mp.set(attr, true);
		}
	};

	Lyte.bindObj = function (data, key, id, path, mp, check, checkAttrs, watch, ignoreCyclicDelete) {
		mp = mp || new Map();
		var value = key != undefined ? data[key] : data;
		var cyclic = false;
		if (!ignoreCyclicDelete && !path.length && Lyte.__nestScp__.get(data) === id) {
			delete Lyte.nestScp[id].cyclic;
		}
		if (path.length > 1 && value && Lyte.nestScp[id] && Lyte.nestScp[id].hasOwnProperty("data") && Lyte.nestScp[id].data === value) {
			if (mp.get(value)) {
				cyclic = true;
			} else {
				try {
					JSON.stringify(value);
				} catch (exp) {
					cyclic = true;
				}
			}
			if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
				Lyte.estObjScp(value, id, path, cyclic);
			}
			return;
		}
		var attrs, nestedSCP;
		if (checkAttrs) {
			if (checkAttrs.hasOwnProperty("items") || checkAttrs.hasOwnProperty("properties")) {
				attrs = checkAttrs.items || checkAttrs.properties;
				nestedSCP = true;
			} else if (watch == undefined && checkAttrs.watch == true) {
				watch = checkAttrs.watch;
			}
		}
		attrs = watch ? undefined : attrs;
		if (Array.isArray(value)) {
			if (!mp.get(value)) {
				mp.set(value, true);
				value.forEach(function (val, idx) {
					path.push(idx);
					if (watch || checkAttrs && checkAttrs.hasOwnProperty("items") && _typeof(checkAttrs.items) == "object") {
						Lyte.bindObj(value, idx, id, path, mp, undefined, attrs, watch);
					}
					path.pop();
				});
			} else {
				cyclic = true;
			}
			if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
				var _establish;
				if (Array.isArray(watch)) {
					_establish = Lyte.checkEstablishingSCP(value, path, watch);
				}
				if (_establish || typeof watch == "boolean" && watch || nestedSCP) {
					Lyte.estObjScp(value, id, path, cyclic);
				}
			}
		} else if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == "object") {
			var cyclic = false;
			if (!mp.get(value)) {
				mp.set(value, true);
				for (var str in value) {
					path.push(str);
					if (watch || attrs && attrs.hasOwnProperty(str)) {
						Lyte.bindObj(value, str, id, path, mp, undefined, attrs ? attrs[str] : undefined, watch);
					}
					path.pop();
				}
			} else {
				cyclic = true;
			}
			if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
				var _establish;
				if (Array.isArray(watch)) {
					_establish = Lyte.checkEstablishingSCP(value, path, watch);
				}
				if (_establish || typeof watch == "boolean" && watch || nestedSCP) {
					Lyte.estObjScp(value, id, path, cyclic);
				}
			}
		}
	};

	Lyte.checkAndAddBind = function (value, id, path, cyclic) {
		if (!value._scp || !value._scp.size) {
			return true;
		}
		if (value._scp.size) {
			if (value._scp.has(id)) {
				var _obj = value._scp.get(id);
				var obj = _obj.paths;
				if (obj.hasOwnProperty(path.join("."))) {
					if (cyclic) {
						Lyte.nestScp[id].cyclic = true;
					}
					return false;
				}
			}
		}
		return true;
	};

	Lyte.estObjScp = function (value, id, path, cyclic) {
		if (!value._scp) {
			Object.defineProperty(value, "_scp", {
				value: new Map(),
				enumerable: false,
				configurable: true
			});
		}
		var mp = value._scp;
		if (!mp.has(id)) {
			mp.set(id, {});
		}
		var obj = mp.get(id),
		    path = path ? path.join(".") : path;
		var pathObj = obj.paths = obj.paths || {};
		pathObj[path] = true;
		var nestObj = Lyte.nestScp[id];
		if (!nestObj.cyclic && cyclic == true) {
			nestObj.cyclic = true;
		}
	};

	Lyte.cmpObjs = function (obj1, obj2) {
		if (Object.keys(obj1).length !== Object.keys(obj2).length) {
			return false;
		}
		for (var key in obj1) {
			if (!obj2.hasOwnProperty(key)) {
				return false;
			}
			var ret = Lyte.cmpData(obj1[key], obj2[key]);
			if (ret == false) {
				return false;
			}
		}
		return true;
	};

	Lyte.cmpData = function (data1, data2) {
		if (Array.isArray(data1)) {
			if (!Array.isArray(data2) || data1.length !== data2.length) {
				return false;
			}
			if (data1 === data2) {
				return true;
			}
			var len = data1.length,
			    ret;
			for (var i = 0; i < len; i++) {
				ret = Lyte.cmpData(data1[i], data2[i]);
				if (ret == false) {
					return false;
				}
			}
		} else if (data1 && data2 && (typeof data1 === 'undefined' ? 'undefined' : _typeof(data1)) == "object" && (typeof data2 === 'undefined' ? 'undefined' : _typeof(data2)) == "object") {
			if (data1 === data2) {
				return true;
			}
			return Lyte.cmpObjs(data1, data2);
		}
		// else if(Lyte && Lyte.isRecord(data1) && Lyte.isRecord(data2)){
		//   if( (data1.$.model._name !== data1.$.model._name) || (Lyte.getpKVal(data1) !== Lyte.getpKVal(data2)) ){
		//     return false;
		//   }
		// }
		else if (data1 !== data2) {
				return false;
			}
		return true;
	};

	Lyte.nestScpRmPath = function (obj, path) {
		if (obj && obj.paths) {
			obj = obj.paths;
			for (var key in obj) {
				if (key.startsWith(path + ".")) {
					delete obj[key];
				}
			}
		}
	};

	Lyte.nestScpRemove = function (data, id, path) {
		var mp = data._scp;
		if (mp && mp.size) {
			if (path) {
				Lyte.nestScpRmPath(mp.get(id), path);
				var _obj = mp.get(id);
				var obj = _obj ? _obj.paths : undefined;
				if (obj && !Object.keys(obj).length) {
					mp.delete(id);
				}
			} else {
				mp.delete(id);
			}
			if (!mp.size) {
				delete data._scp;
			}
		}
	};

	Lyte.rmNestScp = function (value, id, mp, data, path) {
		if (Array.isArray(value)) {
			if (!mp.get(value)) {
				mp.set(value, true);
				value.forEach(function (val, idx) {
					Lyte.rmNestScp(val, id, mp, undefined, path);
				});
			}
			Lyte.nestScpRemove(value, id, path);
		} else if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == "object") {
			if (!mp.get(value)) {
				mp.set(value, true);
				for (var str in value) {
					Lyte.rmNestScp(value[str], id, mp, undefined, path);
				}
			}
			Lyte.nestScpRemove(value, id, path);
		}
	};

	Lyte.removeNestScp = function (value, id, mpId, path, context, mp, data, recObj) {
		mp = mp || new Map();
		id = Number.parseInt(id);
		var obj = Lyte.nestScp[id],
		    kmp = Lyte.__nestRef__[id];
		if (recObj && obj.model) {
			Lyte.removeNestScp2Bind(obj, recObj);
		}
		if (context) {
			if (kmp && kmp.has(mpId)) {
				kmp.delete(mpId);
			}
			if (!kmp || kmp && !kmp.size) {
				delete Lyte.__nestRef__[id];
				if (Lyte.__nestScp__.has(value)) {
					Lyte.__nestScp__.delete(value);
				}
				Lyte.rmNestScp(value, id, mp, true, path);
				if (!data) {
					delete Lyte.nestScp[id];
				}
			}
		} else {
			Lyte.rmNestScp(value, id, mp, true, path);
		}
	};

	Lyte.resolvePromises = function (promises) {
		if (typeof promises == "string" || promises instanceof Promise) {
			return promises;
		} else {
			if (Array.isArray(promises)) {
				return promiseArray(promises);
			} else if ((typeof promises === 'undefined' ? 'undefined' : _typeof(promises)) == "object") {
				return promiseHash(promises);
			}
		}

		function promiseHash(promiseObj) {
			var actPromKeys = [],
			    promises = [],
			    promiseKeys = Object.keys(promiseObj);
			promiseKeys.forEach(function (key) {
				var value = promiseObj[key];
				if (value instanceof Promise || value && !Array.isArray(value) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == "object" && typeof value.then == "function") {
					actPromKeys.push(key);
					promises.push(value);
				}
			});
			if (!promises.length) {
				return Promise.resolve(promiseObj);
			} else {
				var obj = {},
				    promise = new Promise(function (resolve, reject) {
					Promise.all(promises).then(function (data) {
						promiseKeys.forEach(function (promiseKey) {
							if (actPromKeys.indexOf(promiseKey) != -1) {
								obj[promiseKey] = data[actPromKeys.indexOf(promiseKey)];
							} else {
								obj[promiseKey] = promiseObj[promiseKey];
							}
						});
						resolve(obj);
					}, function (err) {
						reject(err);
						Lyte.error('Error on resolve promises', err);
					});
				});
				return promise;
			}
		}

		function promiseArray(promiseArray) {
			var array = [],
			    hasPromise = false;
			promiseArray.every(function (item, i) {
				if (item instanceof Promise || item && !Array.isArray(item) && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) == "object" && typeof item.then == "function") {
					hasPromise = true;
					return false;
				}
				return true;
			});
			if (!hasPromise) {
				return Promise.resolve(promiseArray);
			}
			var promise = new Promise(function (resolve, reject) {
				Promise.all(promiseArray).then(function (data) {
					promiseArray.forEach(function (key, index) {
						array[index] = data[index];
					});
					resolve(array);
				}, function (err) {
					reject(err);
					Lyte.error('Error on resolve promises', err);
				});
			});
			return promise;
		}
	};
	function domContentLoaded1() {
		Lyte.assetsDivContainer.appendChild(Lyte.$.assetsDiv);
	}

	if (document.readyState === "complete" || document.readyState === "interactive") {
		domContentLoaded1();
	} else {
		document.addEventListener("DOMContentLoaded", function (e) {
			domContentLoaded1();
		}, true);
	};

	var XHRSend = XMLHttpRequest.prototype.send;
	XMLHttpRequest.prototype.send = function () {
		var event = window.event;
		var type,
		    target = event ? event.target : undefined;
		if (Lyte.getConfig("stateHandling")) {
			if (event) {
				type = event.type;
				/^(click|dblclick)$/.test(type) && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false" ? addStateToMap(type, target, this) : undefined;
			} else {
				var router = Lyte && Lyte.Router ? Lyte.Router.getRouteInstance() : undefined;
				if (router) {
					var currentAction = router.transition ? router.transition.ev : undefined;
					if (currentAction && currentAction.target && currentAction.target.getAttribute && currentAction.target.getAttribute("lyte-state-handling") != "false") {
						var mp = Lyte.__transXHRMap = Lyte.__transXHRMap || new Map();
						mp.set(router.transition, { currentAction: currentAction, XHR: this });
						addStateToMap(currentAction.type, currentAction.target, this);
					}
				}
			}
		}
		XHRSend.apply(this, arguments);
	};

	Lyte.addEventListener("transitionStart", function (obj) {
		var trans = obj.nextTrans;
		if (trans && obj.prevTrans) {
			if (window.event && /^(click|dblclick)$/.test(window.event.type)) {
				trans.ev = window.event;
				if (obj.prevTrans.ev) {
					delete obj.prevTrans.ev;
				}
			} else if ((obj.prevTrans.state == 409 || obj.prevTrans.state == 308) && obj.prevTrans.ev) {
				trans.ev = obj.prevTrans.ev;
				delete obj.prevTrans.ev;
			}
		}
	});

	Lyte.addEventListener("afterRouteTransition", function (obj) {
		if (obj && obj.trans) {
			var mp = Lyte.__transXHRMap,
			    removeEv = false;
			if (obj.trans.state == 409 || obj.trans.state == 308) {
				var ev1 = window.event,
				    ev2 = obj.trans.ev;
				if (!ev1 || ev1 && ev2 && ev1 != ev2 && ev1.target == ev2.target && ev1.type == ev2.type) {
					obj.trans.nested = true;
				} else {
					removeEv = true;
				}
				if (mp) {
					var mpObj = mp.get(obj.trans);
					if (mpObj) {
						removeStateFromMap(mpObj.XHR, mpObj.currentAction.type, mpObj.currentAction.target);
						mp.delete(obj.trans);
					}
				}
			} else if (obj.trans.state == 200) {
				mp ? mp.delete(obj.trans) : undefined;
				removeEv = true;
			}
			if (removeEv) {
				obj.trans.ev ? delete obj.trans.ev : undefined;
			}
		}
	});

	Lyte.addEventListener("beforeRouteTransition", function (obj) {
		if (obj && obj.prevTrans && obj.prevTrans.nested) {
			obj.trans.ev = obj.prevTrans.ev;
			delete obj.prevTrans.ev;
			obj.trans.fromPrevTrans = true; // temp check
		}
	});

	function addStateToMap(event, target, XHR, stateName) {
		var mp = Lyte.__nodeXHRMap = Lyte.__nodeXHRMap || new Map();
		var nodeMap = mp.get(target);
		if (!nodeMap) {
			mp.set(target, new Map());
		}
		nodeMap = mp.get(target);
		var sr = target.lyteState = target.lyteState || [],
		    type = stateName || XHR;
		if (sr.indexOf(type) == -1) {
			sr.push(type);
		}
		target.setAttribute("lyte-state", "");
		var evMap = nodeMap.get(event);
		if (!evMap) {
			nodeMap.set(event, []);
			evMap = nodeMap.get(event);
		}
		if (stateName) {
			evMap.push({ state: stateName });
			return { target: target, event: event };
		} else {
			evMap.push({ isXHR: true, xhr: XHR });
			var callback = function callback(arg) {
				if (XHR.readyState == 4) {
					removeStateFromMap(XHR, event, target);
					XHR.removeEventListener("readystatechange", callback);
				}
			};
			XHR.addEventListener("readystatechange", callback);
		}
	}
	function removeStateFromMap(type, event, target) {
		var mp = Lyte.__nodeXHRMap;
		var nodeMap = mp.get(target);
		if (!nodeMap) {
			return;
		}
		var evMap = nodeMap.get(event);
		if (!evMap) {
			return;
		}
		if (evMap) {
			var arr = evMap;
			var ind = -1;
			arr.every(function (itm, idx) {
				if (itm && itm.isXHR && itm.xhr == type || typeof type == "string" && itm.state == type) {
					ind = idx;
					return false;
				}
				return true;
			});
			if (ind != -1) {
				arr.splice(ind, 1);
				var sind = target.lyteState.indexOf(type);
				target.lyteState.splice(sind, 1);
				if (!arr.length) {
					nodeMap.delete(event);
					var tyInd = target && Array.isArray(target.lyteState) ? target.lyteState.indexOf(type) : -1;
					tyInd != -1 ? target.lyteState.splice(tyInd, 1) : undefined;
					if (target && target.lyteState && target.lyteState.length == 0) {
						target.lyteState = null;
						target.removeAttribute("lyte-state");
					}
				}
				if (!nodeMap.size) {
					mp.delete(target);
				}
			}
		}
	}

	Lyte.setState = function (str) {
		if (!str) {
			console.error("Please provide a state name");
		}
		var evnt = window.event;
		if (/^(click|dblclick)$/.test(evnt.type)) {
			var target = evnt.target;
			if (Lyte.getConfig("stateHandling") == true && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false") {
				var state = target.getAttribute("lyte-state");
				if (!state) {
					var mp = Lyte.__stateMap = Lyte.__stateMap || new Map();
					var mpobj = mp.get(str);
					if (!mpobj) {
						var obj = addStateToMap(evnt.type, target, undefined, str);
						mp.set(str, obj);
					} else {
						console.error("There is already a open state by the name", str);
					}
				}
			}
		}
	};

	Lyte.removeState = function (str) {
		if (!str) {
			console.error("Please provide a state name");
		}
		var mp = Lyte.__stateMap;
		if (mp) {
			var obj = mp.get(str);
			if (obj) {
				mp.delete(str);
				removeStateFromMap(str, obj.event, obj.target);
			}
		}
	};
	Lyte.setConfig = function (key, value, cons) {
		if (key == "mutable") {
			if (value == true) {
				Lyte.__gl = Lyte.mut(Lyte.__gl__);
			} else if (value == false) {
				Lyte.__gl = Lyte.__gl__;
			}
		}
		var configObj = Lyte.__config = Lyte.__config || {};
		if (cons) {
			Object.defineProperty(configObj, key, {
				value: value
			});
		} else {
			configObj[key] = value;
		}
	};
	/*disable async function*/
	Lyte.getConfig = function (key) {
		var configObj = Lyte.__config;
		if (configObj) {
			return configObj[key];
		}
	};
	Lyte.establishWatchScope = function (watchProps, model) {
		var scope = this,
		    object;
		for (var v in watchProps) {
			var property = v;
			var watch = watchProps[v];
			if (scope.component && scope.component.__data && scope.component.__data[property]) {
				object = scope.getData(property);
				watch = scope.component.__data[property].watch ? true : watch;
				if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) == "object") {
					Lyte.establishObjectBinding(scope.component.data, v, false, undefined, undefined, watch);
				}
				var dataDef = scope.component.__data;
				if (Lyte.nestScp[Lyte.__nestScp__.get(object)]) {
					// nestScp[__nestScp__.get(object)].dtype.watch = watch;
					dataDef[v].watch = watch;
				}
			} else {
				if (model) {
					var fieldList = model.fieldList;
					if (fieldList[v] && fieldList[v].watch == undefined) {
						fieldList[v].watch = watch;
						model._fldGrps.watch[v] = fieldList[v];
					}
				}
			}
		}
	};

	Lyte.checkEstablishingSCP = function (value, path, watch) {
		if (Array.isArray(watch)) {
			var _path = '';
			_path = path.join(".");
			if (Lyte.checkWatchPath(_path, watch, true) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) != "object") {
				return true;
			}
			var _key = Object.keys(value);
			for (var i_scp = 0; i_scp < _key.length; i_scp++) {
				var spiePath = _key[i_scp];
				var finalaUth = _path == "" ? spiePath : _path + "." + spiePath;
				if (Lyte.checkWatchPath(finalaUth, watch, true)) {
					return true;
				}
			}
		}
	};
	Lyte.checkWatchPath = function (actualPath, watchArr, establishBind) {
		if (typeof watchArr == "boolean" && watchArr === true) {
			return true;
		} else if (Array.isArray(watchArr)) {
			for (var i_watch = 0; i_watch < watchArr.length; i_watch++) {
				var path = watchArr[i_watch];
				path = path.replace(/ /g, "");
				path = path.replace(/\$\.\./g, "..");
				path = path.replace(/\$\./g, "");
				var weirdPath = path.search(/\.\./g) != -1 || path.search(/\[|\\]|\{|\}/g) != -1 ? true : false || path.includes("*");
				if (actualPath == path) {
					return true;
				} else if (weirdPath) {
					if (establishBind) {
						if (path.search(/\.\./) != -1) {
							path = path.replace(/\.\.\S+/g, "..*");
							if (path == "..*") {
								return true;
							}
						}
					}
					path = path.search(/\[/) == 0 ? path.replace("[", "") : path;
					path = path.search(/\.\.\[/) == 0 ? path.replace("..[", "..") : path;
					path = path.replace(/\.*\[/g, ".");
					path = path.replace(/\]/g, "");
					var _watchPath = Lyte.checkWeirdPath(path, actualPath);
					if (_watchPath) {
						return true;
					}
				}
			}
		}
	};
	Lyte.checkWeirdPath = function (watchPath, actualPath) {
		if (actualPath == watchPath) {
			return true;
		} else if (watchPath.includes("..") || watchPath.includes("*")) {
			var cmpPath = watchPath;
			cmpPath = cmpPath.replace(/\*/g, "$$");
			cmpPath = cmpPath.replace(/\.\./g, "::");
			// cmpPath = cmpPath.replace("[","\\[")
			cmpPath = cmpPath.replace(/\./g, "\\.");
			cmpPath = cmpPath.replace(/\:\:/g, "\\.?.*\\.?");
			cmpPath = cmpPath.replace(/\$/g, ".*");
			var _wildCard = watchPath.split(".");
			var _wClenght = _wildCard.length;
			if (_wildCard[_wClenght - 2] == "" && _wildCard[_wClenght - 1] != "*") {
				cmpPath = cmpPath + "$";
			}
			var regularExp = new RegExp(cmpPath);
			if (regularExp.test(actualPath)) {
				return true;
			}
			return false;
		}
	};

	var ignoreMut = false;
	Lyte.ignoreMut = function (method) {
		ignoreMut = true;
		method();
		ignoreMut = false;
	};

	/*disable async function*/
	var wkMap = new WeakMap();
	/*disable async function*/
	Lyte.mut = function mut(data) {
		if (data && data.__ltPrx__) {
			return data;
		}
		if (data && wkMap.has(data)) {
			return wkMap.get(data);
		}
		if (!data || data && data.constructor.name !== "Object" && data.constructor.name !== "Record" && !Array.isArray(data) && !data.__ltPrx__) {
			return data;
		}
		var prxVal = new Proxy(data, {
			set: function set(target, prop, value) {
				if (!Array.isArray(target)) {
					Lyte.Component.set(target, prop, value);
				} else {
					target[prop] = value;
				}
				return true;
			},
			get: function get(target, prop) {
				if (prop === "__ltPrx__") {
					return true;
				}
				if (prop === "__target__") {
					return target;
				}
				var value = target[prop];
				if (value && value.__ltPrx__) {
					return value;
				}
				if (value && wkMap.has(value)) {
					return wkMap.get(value);
				}
				var descriptor = Object.getOwnPropertyDescriptor(target, prop);
				if (value && (value.constructor.name === "Object" || Array.isArray(value) || value && value.$ && value.$.hasOwnProperty("isModified")) && !value.__ltPrx__ && descriptor && descriptor.configurable) {
					// path = path || [];
					// path.push(prop);
					// if(Array.isArray(value) && value.model && value.key){
					//     var hmPrx = value.record.$.__hmPrx = value.record.$.__hmPrx || {};
					//     var retVal;
					//     if(!hmPrx[value.key]){
					//         retVal = hmPrx[value.key] = Lyte.mut(value)
					//     }
					//     else{
					//         retVal = hmPrx[value.key]
					//     }
					//     return retVal;
					// }
					var _prxVal = Lyte.mut(value);
					wkMap.set(value, _prxVal);
					// Object.defineProperty(value, "__mcln__", { value: prxVal});
					return _prxVal;
				}
				return value;
			}
		});
		wkMap.set(data, prxVal);
		// Object.defineProperty(data, "__mcln__", { value: prxVal});
		return prxVal;
	};
	/*disable async function*/
	Lyte.immut = function immut(data, mp) {
		var mp = mp || new WeakMap(),
		    nData;
		if (data && Array.isArray(data)) {
			nData = Array.from(data);
		} else if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object") {
			nData = Object.assign({}, data);
		}
		mp.get(data, nData);
		return new Proxy(data, {
			get: function get(data, prop) {
				var _obj = mp.get(data),
				    val;
				val = _obj[prop];
				if (val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == "object" && !mp.has(val)) {
					return Lyte.immut(val, mp);
				}
				return val;
			},
			set: function set(data, prop, value) {
				var _obj = mp.get(obj);
				// _obj[prop] = value;

				Lyte.Component.set(_obj, prop, value);
				return true;
			}
		});
	};
	// Lyte.mut = function mut(data){
	//     if(data && data.__ltPrx__){
	//         return data;
	//     }
	//     if(data && data.__mcln__){
	//         return data.__mcln__;
	//     }
	//     if(!data || (data && !data.constructor.name === "Object" && !Array.isArray(data)) && !value.__ltPrx__){
	//         return data;
	//     }
	//     // parent = parent || data;
	//     let prxVal =  new Proxy(data, {
	//         set:function(target, prop, value){
	//             if(!Array.isArray(target)){
	//                 Lyte.Component.set(target, prop, value);
	//             }else{
	//                 target[prop] = value;
	//             }
	//             return true;
	//         },
	//         get: function(target, prop){
	//             if(prop === "__mcln__"){
	//                 debugger
	//                 return target[prop];
	//             }
	//             if(prop === "__ltPrx__"){
	//                 return true;
	//             }
	//             if(prop === "__target__"){
	//                 return target;
	//             }
	//             var value = target[prop];
	//             if(value && value.__mcln__){
	//                 return value.__mcln__;
	//             }
	//             var descriptor = Object.getOwnPropertyDescriptor(target, prop);
	//             if((value && value.$ && value.$.hasOwnProperty("isModified") && value.$.getProxy)){
	//                 let prxVal = value.$.getProxy();
	//                 return prxVal;
	//             }
	//             else if(value && (value.constructor.name === "Object" || Array.isArray(value)) && !value.__ltPrx__ && descriptor && descriptor.configurable){
	//                 // path = path || [];
	//                 // path.push(prop);
	//                 if(Array.isArray(value) && value.model && value.key){
	//                     var hmPrx = value.record.$.__hmPrx = value.record.$.__hmPrx || {};
	//                     var retVal;
	//                     if(!hmPrx[value.key]){
	//                         retVal = hmPrx[value.key] = Lyte.mut(value)
	//                     }
	//                     else{
	//                         retVal = hmPrx[value.key]
	//                     }
	//                     return retVal;
	//                 }
	//                 let prxVal = Lyte.mut(value);
	//                 Object.defineProperty(value, "__mcln__", { value: prxVal});
	//                 return prxVal;
	//             }
	//             return value;
	//         }
	//     });
	//     Object.defineProperty(data, "__mcln__", { value: prxVal});
	//     return prxVal;
	// }
	Object.defineProperty(Lyte, "__gl__", {
		value: {}
	});
	Lyte.__gl = Lyte.__gl__;
})(_Lyte);
;(function (window) {
	//latest
	function Router(routes) {
		/*-----------string declaration starts------------*/
		var functionStr = "function",
		    routeStr = "route",
		    TransitionStr = "Transition",
		    pendingStr = "pending",
		    completedStr = "completed",
		    abortedStr = "aborted",
		    TransitionAbortedStr = TransitionStr + " " + abortedStr + ".",
		    TransitionResumedStr = TransitionStr + " resumed.",
		    TransitionPausedStr = TransitionStr + " paused.",
		    TransitionComletedStr = TransitionStr + " " + completedStr + ".",
		    parseRouteMappingStr = "parseRouteMapping",
		    constructRunLoopStr = "constructRunLoop",
		    RouteTransitionStr = "Route" + TransitionStr,
		    getDependenciesStr = "getDependencies",
		    getResourcesStr = "getResources",
		    beforeStr = "before",
		    afterStr = "after",
		    beforeModelStr = beforeStr + "Model",
		    modelStr = "model",
		    afterModelStr = afterStr + "Model",
		    redirectStr = "redirect",
		    renderTemplateStr = "renderTemplate",
		    afterRenderStr = afterStr + "Render",
		    beforeExitStr = beforeStr + "Exit",
		    didDestroyStr = "didDestroy",
		    willTransitionStr = "will" + TransitionStr,
		    didTransitionStr = "did" + TransitionStr,
		    onErrorStr = "onError",
		    beforeLoadStr = "beforeLoad",
		    onBeforeLoadStr = "onBeforeLoad",
		    beforeRouteTransitionStr = beforeStr + "Route" + TransitionStr,
		    afterRouteTransitionStr = afterStr + "Route" + TransitionStr,
		    beforeTemplateDestroyStr = beforeStr + "TemplateDestroy",
		    resourcesStr = "resources",
		    dependenciesStr = "dependencies",
		    ltPropStr = "lt-prop",
		    pReplace = ltPropStr + "-replace",
		    startHFromStr = "start-from",
		    pStartFrom = ltPropStr + "-" + startHFromStr,
		    pRoute = ltPropStr + "-" + routeStr,
		    pFragment = ltPropStr + "-fragment",
		    pDp = ltPropStr + "-dp",
		    pQp = ltPropStr + "-qp",
		    pTd = ltPropStr + "-td",
		    pTrans = ltPropStr + "-trans",
		    refreshHRouteStr = "refresh-" + routeStr,
		    pRefreshRoute = ltPropStr + "-" + refreshHRouteStr,
		    linktoStr = "link-to",
		    LINKTOStr = "LINK-TO",
		    stateChangeStr = "stateChange",
		    dependencyRequestLog = 'Requesting files in ' + getDependenciesStr + ' will stall execution of route till download completes. Please validate files ' + beforeStr + ' requesting.',
		    renderTemplateWarning = renderTemplateStr + " hook should return either component or HTML. Rendering of HTML directly into the DOM within the " + renderTemplateStr + " hook is deprecated.",
		    addRoutesWarning = "addRoutes function will be deprecated from next version",
		    ltPropWarning = "Error while parsing ltProp in " + linktoStr,

		/*-----------string declaration ends------------*/
		fontColor = 'MediumOrchid',
		    newTransInfo,
		    newTransInfoClone,
		    newTransInfoTimer,
		    t = Lyte.time,
		    log = Lyte.log,
		    parse = JSON.parse,
		    LR = this,
		    d = document,
		    dloc = d.location,
		    config = {
			routeHash: {},
			urlCache: {},
			stickyRoutes: {},
			allLinks: {},
			activeLinkTags: []
		},
		    trans,
		    prevTrans,
		    newTrans,
		    visibleTrans,
		    historyObj,
		    initialLoad = true,
		    allowHistoryChange = false,
		    historyLength = getMeta() ? getMeta().index : 0,
		    fromHistoryGo = false,
		    routeParser,
		    processedDispatch,
		    Processed,
		    emptyFn = function emptyFn() {},
		    run = {},
		    reqestedType = {
			getResources: resourcesStr,
			getDependencies: dependenciesStr
		};

		run[getDependenciesStr] = run[getResourcesStr] = function (hook, index) {
			var routeInstance = this.routes[index],
			    fnType = hook == getDependenciesStr ? "loadDependencies" : "loadResources",
			    callback = this.R[index][hook];
			routeInstance.__lp[reqestedType[hook] + 'Loaded'] = true;
			if (callback && validateTransition(this)) {
				var require = callHookWithoutPromise.call(this, callback, this.routes[index], hook, index, params(index));
				if (require && require instanceof Promise) {
					return require;
				}
				routeInstance.__lp[reqestedType[hook]] = require;
				routeInstance.__lp[reqestedType[hook] + 'Loaded'] = !require || !(require.length || (typeof require === 'undefined' ? 'undefined' : _typeof(require)) == "object");
				if (require) {
					if (hook == getDependenciesStr) {
						console.warn(dependencyRequestLog);
					}
					routeInstance.__lp[fnType] = function () {
						routeInstance.__lp[fnType] = pendingStr;
					};
					getRequirements.call(this, { reqType: reqestedType[hook], r: routeInstance, index: index });
				}
			}
			return callHookWithPromise();
		};

		run[beforeModelStr] = run[modelStr] = run[afterModelStr] = function (hook, index) {
			var routeInstance = this.routes[index],
			    callback = this.R[index][hook],
			    args = [this.R[index][hook], routeInstance, params(index)];
			if (hook == afterModelStr) {
				args.splice(2, 0, routeInstance.currentModel);
			}
			if (callback) {
				var setDataIns = function setDataIns(data) {
					routeInstance.$[hook] = data;
					if (hook == modelStr) {
						routeInstance.currentModel = data;
					}
					delete callback.then;
				};

				callback.then = { success: setDataIns, failure: setDataIns };
			}
			return callHookWithPromise.apply(this, args);
		};

		run[redirectStr] = function (hook, index) {
			var routeInstance = this.routes[index],
			    args = [this.R[index][hook], routeInstance, params(index)];
			args.splice(2, 0, routeInstance.currentModel);
			return callHookWithPromise.apply(this, args);
		};

		run[onErrorStr] = function (hook, index, err, state, options) {
			setPendingResume.call(trans, trans.prom);
			trans._trans.triggerEvent(onErrorStr, { error: err, hook: hook });
			var errIns = this.routes[index];
			for (; index >= 0 && !this.aborted && this.paused; index--) {
				var instance = this.routes[index];
				log(onErrorStr + " of " + instance.routeName, routeStr, fontColor);
				if (callAction.call(this, onErrorStr, index, [err, this._trans, params(index), hook]) == false) {
					break;
				}
			}
			consoleErrorFromCallback(err, hook, errIns.routeName, state, options);
		};

		run[willTransitionStr] = function (hook, index) {
			if (callAction.call(prevTrans, hook, index, [trans._trans]) == false) {
				removeHook(trans.runLoop.previous, hook);
			}
			return callHookWithPromise();
		};

		run[beforeRouteTransitionStr] = function () {
			if (validateTransition(this)) {
				var pt;
				if (pt = prevTrans && prevTrans._trans) {
					delete pt.abort;
					delete pt.pause;
				}
				var obj = {
					prevTrans: pt,
					trans: trans._trans,
					history: LR.history
				};
				LR[beforeRouteTransitionStr](obj.prevTrans, obj.trans, obj.history);
				trans._trans.triggerEvent(beforeRouteTransitionStr, obj);
				Lyte.triggerEvent(beforeRouteTransitionStr, obj);
			}
			return callHookWithPromise();
		};

		run[afterRouteTransitionStr] = function (_trans) {
			LR[afterRouteTransitionStr](_trans);
			trans._trans.triggerEvent(afterRouteTransitionStr, { trans: _trans });
			Lyte.triggerEvent(afterRouteTransitionStr, { trans: _trans });
		};

		run[beforeLoadStr] = function (hook, index) {
			var route = this.routes[index],
			    loadingTemplate = callHookWithoutPromise.call(this, this.R[index][hook], this.routes[index], hook, index, params(index)),
			    outlet;
			if (loadingTemplate && loadingTemplate.outlet && (outlet = getOutlet(loadingTemplate.outlet, route.parent))) {
				if (outlet.childNodes[0]) {
					triggerTemplateDestroy({ outlet: outlet, route: route }, false);
				}
				if (loadingTemplate.component) {
					var component = d.createElement(loadingTemplate.component);
					setDataInComponent.call(this, component, loadingTemplate.data, routeInstance, hook, index);
					outlet.innerHTML = '';
					outlet.appendChild(routeInstance.component = component);
				} else if (renderTemplate.html) {
					routeInstance.component = undefined;
					outlet.innerHTML = renderTemplate.html;
					var scripts = outlet.getElementsByTagName('script');
					if (scripts.length) {
						scriptExecution(Array.from(scripts), outlet);
					}
				}
			}
			return callHookWithPromise();
		};

		run[onBeforeLoadStr] = function () {
			return new Promise(function (resolve, reject) {
				for (var len = trans.matched.route.length, i = 1; i <= len && validateTransition(trans); i++) {
					var l = len - i;
					if (trans.R[l].actions && trans.R[l].actions.onBeforeLoad) {
						console.log(onBeforeLoadStr + ' action is depricated. Use beforeLoad callback');
					}
					if (callAction.call(trans, onBeforeLoadStr, l, [params(l)]) == false || i == len) {
						resolve();
						break;
					}
				}
			});
		};

		run[afterRenderStr] = run[didTransitionStr] = function (hook, index) {
			return new Promise(function (resolve, reject) {
				var st = setTimeout(function () {
					if (hook == afterRenderStr) {
						var routeInstance = this.routes[index];
						routeInstance.__ltp.rendered = true;
						callHookWithPromise.call(this, this.R[index][hook], routeInstance, routeInstance.currentModel, params(index), routeInstance.component).then(function (data) {
							if (!trans.routes[index + 1]) {
								trans._trans.triggerEvent(afterRenderStr);
							}
							resolve(data);
						}, function (data) {
							reject(data);
						});
					} else {
						run.removeTemplate.call(this);
						if (callAction.call(this, hook, index, [params(index), trans._trans]) == false) {
							removeHook(trans.runLoop.current, hook);
							index = 0;
						}
						resolve();
						if (index == 0) {
							transitionCompleted({ state: 200 });
						}
					}
				}.bind(this, hook, index), 0);
				this.fns.push(st);
			}.bind(this));
		};

		run[beforeExitStr] = function (hook, index) {
			var prevTransRouteInstance = prevTrans.routes[index],
			    callback = prevTrans.R[index][hook];
			return callHookWithPromise.call(this, callback, prevTransRouteInstance, prevTransRouteInstance.currentModel, params(index, prevTrans));
		};

		run[renderTemplateStr] = function (hook, index) {
			var routeInstance = this.routes[index],
			    r = this.R[index];
			if (r[hook]) {
				run.removeTemplate.call(this);
				var renderTemplate = callHookWithoutPromise.call(this, r[hook], routeInstance, hook, index, routeInstance.currentModel, params(index));
				if (validateTransition(this)) {
					if (renderTemplate && (routeInstance.outletName = renderTemplate.outlet)) {
						var data = routeInstance.currentModel,
						    outlet;
						if (routeInstance.outlet = outlet = getOutlet(renderTemplate.outlet, routeInstance.parent)) {
							var obj = {
								outlet: renderTemplate.outlet,
								route: routeInstance
							};
							if (renderTemplate.component) {
								if (routeInstance.component && !renderTemplate.reRender && routeInstance.component.tagName.toLocaleLowerCase() == renderTemplate.component && routeInstance.outlet == outlet && outlet.contains(routeInstance.component)) {
									setDataInComponent.call(this, routeInstance.component, data, routeInstance, hook, index);
								} else {
									triggerTemplateDestroy(obj, false);
									var component = d.createElement(renderTemplate.component);
									component._route = routeInstance.__lp.objPath;
									setDataInComponent.call(this, component, data, routeInstance, hook, index);
									outlet.innerHTML = '';
									outlet.appendChild(routeInstance.component = component);
								}
							} else if (renderTemplate.html) {
								routeInstance.component = undefined;
								triggerTemplateDestroy(obj, false);
								outlet.innerHTML = renderTemplate.html;
								var scripts = outlet.getElementsByTagName('script');
								if (scripts.length) {
									scriptExecution(Array.from(scripts), outlet);
								}
							}
						}
					} else {
						Lyte.warn(renderTemplateWarning);
					}
				}
			} else if (validateTransition(this) && this.runLoop.templateToRemove && this.R.length == index + 1) {
				run.removeTemplate.call(this);
			}
			return callHookWithPromise();
		};

		function setDataInComponent(component, data, routeInstance, hook, index) {
			if (data) {
				if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object" && !Array.isArray(data)) {
					component.setData(data);
				} else {
					processError.call(this, { stopTrans: true, err: Error(getError(203)).stack, instance: routeInstance, hook: hook, index: index });
				}
			}
		}

		function getOutlet(outlet, parent) {
			var _outlet;
			if (parent) {
				_outlet = parent.outlet ? parent.outlet.querySelector(outlet) : undefined;
				if (!_outlet) {
					return getOutlet(outlet, parent.parent);
				}
			} else if (!(_outlet = d.querySelector(outlet))) {
				consoleError(428, outlet);
			}
			return _outlet;
		}

		function scriptExecution(scriptNode) {
			for (var i = 0, currentScript; currentScript = scriptNode[i]; i++) {
				var parent = currentScript.parentNode,
				    s = d.createElement("script");
				for (var j = 0, attributes; attributes = currentScript.attributes[j]; j++) {
					s.setAttribute(attributes.name, attributes.value);
				}
				s.innerHTML = currentScript.innerHTML;
				parent.appendChild(s);
				parent.removeChild(currentScript);
			}
		}

		run.removeTemplate = function () {
			var arr = this.runLoop.templateToRemove;
			if (!this.cleared) {
				if (prevTrans && arr) {
					templateDelete(arr);
				}
				this.cleared = true;
				if (visibleTrans != this) {
					visibleTrans = this;
				}
				delete this.runLoop.templateToRemove;
				Lyte.removeFromCache();
			}
		};

		function params(index, t) {
			t = t || trans;
			var routeInstance = t.routes[index];
			return {
				queryParams: routeInstance.__ltp.queryParams,
				dynamicParam: routeInstance.__ltp.dynamicParam
			};
		}

		function validateTransition(trans) {
			return !trans.aborted && !trans.paused;
		}

		function addToHistory(obj) {
			var type = obj.replace ? "replaceState" : "pushState",
			    url = config.history ? _delimit(shiftBaseURL(obj.url, true)) : '#' + (config.slashAfterHash ? _delimit(obj.url) : obj.url[0] == "/" && obj.url.length > 1 ? obj.url.substring(1, obj.url.length) : obj.url);
			obj.title = obj.title || d.title;
			/* support for windows, undefined is appended to url */
			var args = [obj.state, obj.title];
			if (url) {
				args.push(url);
			}
			window.history[type].apply(history, args);
		}

		function getMeta() {
			return history.state && history.state.meta;
		}

		function getData() {
			return history.state && history.state.data;
		}

		function getHistoryState(obj) {
			/* 
   	state data which needs to be pushed to history. 
   	- Matched object is added to process url directly with history back and forward.
   	- Index is used to detect browser back or forward.
   */

			return {
				meta: {
					matched: obj.matched,
					url: obj.url,
					index: obj.fromHistory ? getMeta() ? getMeta().index : historyLength : obj.replace && getMeta() ? getMeta().index : historyLength = historyLength + 1
				},
				data: obj.data
			};
		}

		function getHistoryObj(obj) {
			/* parses history state to history object. */
			if (!LR.history) {
				historyRegistration();
			}
			LR.history.index = obj.state.meta.index;
			LR.history.fromHistory = obj.fromHistory ? prevTrans ? prevTrans.stateObj.meta.index < trans.stateObj.meta.index ? 'forward' : 'back' : 'reload' : false;
			allowHistoryChange = true;
			LR.history.state = getData() || {};
			LR.history.initial = initialLoad;
			return LR.history;
		}

		this.configureDefaults = function (options) {
			options = options || {};
			config.history = options.history == "html5";
			config.baseURL = options.baseURL;
			config.slashAfterHash = options.slashAfterHash == undefined ? true : options.slashAfterHash;
			config.deferInit = options.deferInit || false;
			config.preserveUrlOnBrowserNavigation = options.preserveUrlOnBrowserNavigation;
			config.linkActiveClass = options.hasOwnProperty("linkActiveClass") ? options.linkActiveClass : "";
			config.cipher = options.cipher;
			config.queryParamOptions = {
				sticky: options.queryParamOptions && options.queryParamOptions.hasOwnProperty('sticky') ? options.queryParamOptions.sticky : true
			};
			if (!Lyte.$.prefetchSupport || options.execRouteRequirementsOnDemand == false) {
				Lyte.$.replaceOldInjectResource && Lyte.$.replaceOldInjectResource();
				config.execRouteRequirementsOnDemand = false;
			} else {
				config.execRouteRequirementsOnDemand = true;
			}

			this.__lp.config = config;
		};

		this.__lp = {
			version: "3.2.7",
			pendingReg: [],
			getDefinition: function getDefinition(arr, def) {
				if (arr == "*") {
					return config.routes;
				} else {
					def = def || config.routes;
					def = _getObj(arr, def);
					return def && def.__lp && def.__lp.def || undefined;
				}
			}
		};

		this.configureRoutes = function (map) {
			if (!this.__lp.config) {
				this.configureDefaults();
			}
			parseRouteMapping.call(this, map);
			for (var i = 0, l = this.__lp.pendingReg.length; i < l; i++) {
				registerRoute.apply({}, this.__lp.pendingReg[i]);
			}
			this.__lp.pendingReg = [];
			Lyte.domContentLoaded(init);
			this.__lp.routesConfigured = true;
		};

		function init() {
			if (!config.deferInit && LR.init) {
				LR.init();
			}
		}

		this.init = function (r) {
			delete this.init;
			this.popstate = function (onChangeEvent) {
				var goValue, url;
				if (config.preserveUrlOnBrowserNavigation) {
					if (fromHistoryGo) {
						fromHistoryGo = false;
						return;
					}
					if (getMeta() && prevTrans && prevTrans.stateObj.meta.index != getMeta().index) {
						fromHistoryGo = true;
						url = getUrlFromMeta(onChangeEvent);
						goValue = prevTrans.stateObj.meta.index - getMeta().index;
						history.go(goValue);
					}
				}
				url = url || getUrlFromMeta(onChangeEvent);
				historyObj = {
					fromHistory: true,
					url: url,
					goValue: goValue
				};
				if (onChangeEvent && history.state) {
					historyObj.data = history.state;
				}
				if (trans && !trans.aborted) {
					console.log("aborting from dispatch");
					trans.abort({ state: 308, iAbort: true });
				}
				dispatch(url);
			};
			window.addEventListener('popstate', this.popstate);
			if (config.history) {
				this.popstate();
			} else {
				historyObj = {
					fromHistory: true,
					url: getLocation()
				};
				dispatch(historyObj.url);
			}
			linkToRegistration();
			return this;
		};

		function getUrlFromMeta(onChangeEvent) {
			var url;
			if (!(getMeta() && (url = getMeta().url))) {
				if (config.history) {
					url = getLocation();
				} else {
					var newURL = onChangeEvent && onChangeEvent.newURL || dloc.hash;
					url = checkForEmptyPath(newURL.replace(/.*#/, ''));
				}
			}
			return url;
		}

		this.beforeScroll = this[beforeRouteTransitionStr] = this[afterRouteTransitionStr] = emptyFn;

		function setRouteDef(dir, value) {
			var cache = config.routes,
			    len = dir.length,
			    dirLen = len - 1;
			for (var i = 0, key; i < len; i++) {
				key = dir[i];
				if (dirLen === i) {
					var obj = cache[key];
					if (obj && obj.__lp) {
						obj.__lp.def = value;
					} else if (obj) {
						obj.__lp = { def: value };
					} else {
						cache[key] = { __lp: { def: value } };
					}
				} else if (!cache[key]) {
					cache[key] = {};
				}
				cache = cache[key];
			}
		}

		function linkToRegistration() {
			var LinkTo = function (_HTMLElement) {
				_inherits(LinkTo, _HTMLElement);

				function LinkTo() {
					_classCallCheck(this, LinkTo);

					return _possibleConstructorReturn(this, (LinkTo.__proto__ || Object.getPrototypeOf(LinkTo)).apply(this, arguments));
				}

				_createClass(LinkTo, [{
					key: 'attributeChangedCallback',
					value: function attributeChangedCallback(attr, oldValue, newValue) {
						if (this.matched && this.hasAttribute("lyte-rendered")) {
							var aTag = this.getElementsByTagName('A')[0];
							//If attr is ltProp
							if (aTag) {
								if (attr === ltPropStr) {
									this.handleLtProp();
									if (!this.hasAttribute("lt-prop-custom")) {
										this.setCustomAttributes(aTag, true);
									}
									this.constructHref(aTag);
								} else if (/^(lt-prop-route|lt-prop-fragment|lt-prop-dp|lt-prop-qp)$/.test(attr)) {
									//if it is a route transition attribute
									this.getMatchedObject();
									this.constructHref(aTag, attr, oldValue, newValue);
								} else if (!this.hasAttribute('lt-prop-custom')) {
									//for rest of the attributes
									aTag.setAttribute(attr.substring(8), newValue);
								}
							}
						}
					}
				}, {
					key: 'connectedCallback',
					value: function connectedCallback() {
						this.ltProp = this.ltProp || {};
						this.handleLtProp();
						if (this.hasAttribute("lyte-rendered")) {
							if (this.getElementsByTagName('A')[0] && !this.matched) {
								this.getMatchedObject();
							}
							return;
						}
						var isCustom = this.hasAttribute("lt-prop-custom") || this.ltProp.custom,
						    aTag;
						if (isCustom) {
							if (aTag = this.getElementsByTagName('A')[0]) {
								this.getMatchedObject();
								this.constructHref(aTag);
							}
						} else {
							aTag = d.createElement("a");
							while (this.childNodes[0]) {
								aTag.appendChild(this.childNodes[0]);
							}
							this.setCustomAttributes(aTag);
							this.getMatchedObject();
							this.constructHref(aTag);
							this.appendChild(aTag);
						}
						if (Lyte.Component) {
							this._linkToEventId = Lyte.Component.addLyteEventListener(this, "click", function (event) {
								linkToEventListener(event, this);
							}, this);
						} else {
							this.addEventListener("click", linkToEventListener);
						}
						this.setAttribute("lyte-rendered", "");
					}
				}, {
					key: 'modifyLinkToTagsInRoute',
					value: function modifyLinkToTagsInRoute(remove) {
						var strRoute = Array.isArray(this.matched.route) ? this.matched.route.join('.') : this.matched.route,
						    allLinks = config.allLinks[strRoute];
						if (remove) {
							if (allLinks) {
								var pos = allLinks.indexOf(this);
								if (pos != -1) {
									allLinks.splice(pos, 1);
								}
							}
						} else {
							if (allLinks) {
								allLinks.push(this);
							} else {
								config.allLinks[strRoute] = [this];
							}
						}
						if (config.stickyRoutes[strRoute]) {
							var routesObj = config.routes,
							    _routes = void 0;
							if (remove) {
								if (this.matched) {
									_routes = remove;
								} else {
									return;
								}
							} else {
								_routes = this.matched.route;
							}
							if (!_routes) {
								return;
							}
							_routes = Array.isArray(_routes) ? _routes : dotSerperator(_routes);
							for (var i = 0, l = _routes.length, r; i < l; i++) {
								r = _routes[i];
								routesObj = _getObj(r, routesObj);
								if (!routesObj || !routesObj.__lp) {
									consoleError(422, _routes, i);
									return false;
								}
								var def = routesObj.__lp.def.__lp;
								if (remove) {
									var _pos = def.stickyLinks.indexOf(this);
									if (_pos !== -1) {
										def.stickyLinks.splice(_pos, 1);
									}
								} else if (def.qpdef) {
									def.stickyLinks.push(this);
								}
							}
						}
					}
				}, {
					key: 'disconnectedCallback',
					value: function disconnectedCallback() {
						var m = this.modifyLinkToTagsInRoute.bind(this);
						if (!Lyte.Component.shouldIgnoreDisconnect()) {
							if (this.matched && this.matched.route) {
								m(this.matched.route);
							}
							if (this._linkToEventId) {
								Lyte.Component.removeLyteEventListener(this, this._linkToEventId);
							}
						}
					}
				}, {
					key: 'handleLtProp',
					value: function handleLtProp() {
						var ltProp = this.getAttribute(ltPropStr);
						if (ltProp) {
							try {
								this.ltProp = parse(ltProp);
							} catch (e) {
								Lyte.warn(ltPropWarning);
							}
						}
					}
				}, {
					key: 'setCustomAttributes',
					value: function setCustomAttributes(linkTag, onlyLtProp) {
						for (var key in this.ltProp) {
							if (/^(id|class|style|target)$/.test(key)) {
								linkTag.setAttribute(key, this.ltProp[key]);
							}
						}
						if (!onlyLtProp) {
							for (var i = 0, attr, attrName; attr = this.attributes[i]; i++) {
								if ((attrName = attr.nodeName) !== ltPropStr && /^(lt-prop-id|lt-prop-rel|lt-prop-class|lt-prop-style|lt-prop-target|lt-prop-tabindex|lt-prop-aria-label|lt-prop-aria-attributes)$/.test(attrName)) {
									linkTag.setAttribute(attrName.substring(8), attr.nodeValue);
								}
							}
						}
					}
				}, {
					key: 'constructHref',
					value: function constructHref(linkTag, attr, oldValue) {
						var href,
						    m = this.modifyLinkToTagsInRoute.bind(this);
						if (href = LR.getURL.call(this, this.matched)) {
							linkTag.setAttribute("href", href);
							if (attr === pRoute) {
								m(oldValue);
								m();
							} else {
								m();
							}
						}
					}
				}], [{
					key: 'observedAttributes',
					get: function get() {
						return [pRoute, pDp, pFragment, pQp, ltPropStr, 'lt-prop-class', 'lt-prop-data-tabindex', 'lt-prop-data-tabindex', 'lt-prop-tabindex', 'lt-prop-aria-label', 'lt-prop-aria-attributes', 'lt-prop-id', 'lt-prop-rel', 'lt-prop-title', 'lt-prop-style', 'lt-prop-target'];
					}
				}]);

				return LinkTo;
			}(HTMLElement);

			LinkTo.prototype.getMatchedObject = function () {
				var matched = this.matched || {},
				    ga = this.getAttribute.bind(this),
				    dynamicParams = ga(pDp) || this.ltProp.dp || [],
				    queryParams = ga(pQp) || this.ltProp.qp || {};
				if (!(dynamicParams instanceof Array)) {
					try {
						dynamicParams = parse(dynamicParams);
					} catch (e) {
						consoleError(498, "dynamicParams", this.outerHTML);
						return;
					}
				}
				if (!(queryParams instanceof Object)) {
					try {
						queryParams = parse(queryParams);
						if (Array.isArray(queryParams)) {
							consoleError(498, "queryParams", this.outerHTML);
							return;
						}
					} catch (e) {
						consoleError(498, "queryParams", this.outerHTML);
						return;
					}
				}
				matched.route = ga(pRoute) || this.ltProp.route;
				matched.fragment = ga(pFragment) || this.ltProp.fragment;
				matched.dynamicParams = dynamicParams || [];
				matched.queryParams = queryParams || {};
				matched.refreshRoute = ga(pRefreshRoute) != undefined ? ga(pRefreshRoute) : this.ltProp[refreshHRouteStr];
				matched.refreshRoute = matched.refreshRoute == "" || matched.refreshRoute == 'true' ? matched.route : matched.refreshRoute;
				matched.startFrom = ga(pStartFrom) || this.ltProp[startHFromStr];
				return this.matched = matched;
			};
			customElements.define(linktoStr, LinkTo);
		}

		function linkToEventListener(event, linkTo) {
			if (event.button == 2 || event.defaultPrevented) {
				return;
			}
			var targetElem = linkTo || event.currentTarget;
			if (targetElem.children[0].tagName === "A" && (event.ctrlKey == true || event.metaKey == true || event.which == 2 || targetElem.children[0].hasAttribute("target") && targetElem.children[0].getAttribute("target") !== "_self")) {
				return;
			}
			event.preventDefault();
			if (!targetElem.matched) {
				targetElem.getMatchedObject();
			}
			var matched = Object.assign({}, targetElem.matched);
			matched.route = Array.isArray(matched.route) ? matched.route.join('.') : matched.route;
			var replace = targetElem.ltProp.replace || targetElem.hasAttribute(pReplace),
			    transitionInstance = LR[replace && replace != "false" ? "replaceWith" : "transitionTo"](targetElem.matched);
			var transObj = {},
			    transProp;
			if (transProp = targetElem.getAttribute(pTrans)) {
				try {
					transObj = parse(transProp);
				} catch (e) {
					consoleError(498, pTrans, linkTo.outerHTML);
				}
			}
			var transitionData = targetElem.getAttribute(pTd);
			if (transitionData = transitionData || transObj.data) {
				if (typeof transitionData === "string") {
					try {
						transitionData = parse(transitionData);
					} catch (e) {
						consoleError(498, pTd, linkTo.outerHTML);
					}
				}
				transObj.data = transitionData;
			}
			for (var key in transObj) {
				transitionInstance[key] = transObj[key];
			}
		}

		this.checkIfSameRoute = function (transInfo1, transInfo2) {
			if (transInfo1.route == transInfo2.route && transInfo1.fragment == transInfo2.fragment && transInfo1.dynamicParams.length === transInfo2.dynamicParams.length && _compareObj(transInfo1.queryParams, transInfo2.queryParams)) {
				return checkIfSameDp(transInfo1.dynamicParams, transInfo2.dynamicParams);
			}
			return false;
		};

		function checkIfSameDp(dp1, dp2) {
			if (dp1.length) {
				for (var i = 0, dp; dp = dp1[i]; i++) {
					if (dp != dp2[i]) {
						return false;
					}
				}
			}
			return true;
		}

		function convertMatchedObjToRouteInfo(matched) {
			var info = {
				route: matched.route.join("."),
				fragment: matched.fragment,
				dynamicParams: matched.dynamicParams.filter(_arrayClean),
				queryParams: matched.queryParams

			};
			return info;
		}

		this.addRoutes = function (map, route) {
			var clr = setInterval(function () {
				if (Lyte.Router.__lp.routesConfigured) {
					clearInterval(clr);
					Lyte.warn(addRoutesWarning);
					var routeArr = route ? route.split(".") : [],
					    routes = _getObj(routeArr, config.routes);
					if (!routes) {
						console.error(route + " is not specified in router map.");
						return;
					}
					Object.assign(routes, parseRouteMapping.call(routeParser, map));
				}
			}, 0);
		};

		function dotSerperator(str) {
			return str.split('.').filter(function (s) {
				return s != "";
			});
		}

		function _arrayClean(e) {
			return e != undefined;
		}

		function parseRouteMapping(map) {
			t(parseRouteMappingStr);
			var routesObj = config.routes ? config.routes : config.routes = {},
			    mapObj = {},
			    pathStringArr = [],
			    routeStringArr = [];
			routeParser = {
				route: function route(routeName, obj, nestedFn) {
					if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == "object") {
						if (!obj.path) {
							obj.path = _delimit(routeName);
						} else {
							if (_presence(obj.path, "?")) {
								var split = obj.path.split('?');
								obj.defQP = frameQueryParams(split[1]);
								obj.path = split[0] || "/";
							}
						}
						if (obj.queryParams) {
							obj.defQP = obj.queryParams;
						}
					} else {
						if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == functionStr) {
							nestedFn = obj;
						}
						obj = { path: _delimit(routeName) };
					}
					mapObj = _getObj(pathStringArr, config.routeHash)[obj.path] = { __lp: {} };
					if (obj.path == '/') {
						pathStringArr.push('/');
					} else {
						var trimedPath = obj.path;
						if (dynamicRouteCheck(trimedPath) || wildcardRouteCheck(trimedPath)) {
							_splitPath(trimedPath).every(function (seg, index, arr) {
								if (dynamicRouteCheck(seg) || wildcardRouteCheck(seg)) {
									var dkey;
									if (dynamicRouteCheck(seg)) {
										dkey = seg.replace(":", "");
									} else {
										dkey = seg.replace("*", "");
										obj.wildcard = mapObj.__lp.wildcard = true;
										obj.sufix = mapObj.__lp.sufix = [];
										for (var i = index + 1, j; j = arr[i]; i++) {
											mapObj.__lp.sufix.push(j);
										}
									}
									obj.dkey = mapObj.__lp.dkey = dkey;
									obj.dIndex = mapObj.__lp.dIndex = index;
									return false;
								}
								return true;
							});
						}
						pathStringArr.push(trimedPath);
					}
					var routes = _getObj(routeStringArr, routesObj) || routesObj;
					routeStringArr.push(routeName);
					mapObj.__lp.route = Array.from(routeStringArr);
					routes[routeName] ? Object.assign(routes[routeName].__lp, obj) : routes[routeName] = { __lp: obj };
					if (nestedFn) {
						nestedFn.call(this, {});
					}
					routeStringArr.pop();
					pathStringArr.pop();
				}
			};
			map.call(routeParser, {});
			t(parseRouteMappingStr);
			return routesObj;
		}

		this.replaceWith = function () {
			var args = normalizeMatchedObj.call(this, normalizeTransitionParams.apply(this, arguments));
			if (args) {
				args.matched.replace = true;
				return routeTransition(args);
			}
		};

		this.transitionTo = function () {
			var processed;
			if (processed = normalizeMatchedObj.call(this, normalizeTransitionParams.apply(this, arguments))) {
				return routeTransition(processed);
			}
		};

		this.getURL = function (matched) {
			if (matched) {
				if (!matched.route) {
					matched = normalizeTransitionParams.apply(this, arguments);
				} else if (!matched.queryParams) {
					matched.queryParams = {};
				}
				var url,
				    l,
				    linkTo = this.tagName == LINKTOStr,
				    cache = config.urlCache,
				    matchedCache,
				    sticky = config.queryParamOptions.sticky;
				if (!sticky && (matchedCache = cache[Array.isArray(matched.route) ? matched.route.join('.') : matched.route])) {
					url = matchedCache.url;
					if (l = matched.dynamicParams && matched.dynamicParams.length) {
						for (var i = 0; i < l; i++) {
							url = url.replace('<<dp>>', matched.dynamicParams[i]);
						}
					} else if (url.indexOf('<<dp>>') != -1) {
						consoleError(499, matched.route, linkTo ? this : undefined);
					}
					for (var key in matchedCache.defQP) {
						if (!matched.queryParams[key] && matchedCache.defQP[key]) {
							matched.queryParams[key] = matchedCache.defQP[key];
						}
					}
					url = appendQueryParamsAndFrag(url, matched);
				} else {
					if (linkTo) {
						url = constructURLFromRoute.apply(this, arguments);
					} else {
						url = constructURLFromRoute.call(this, matched);
					}
				}
				if (url) {
					url = config.history ? shiftBaseURL(url, true) : '#' + url;
					return url;
				}
			}
		};

		this.getRoute = function (url) {
			var matched = traverse(shiftBaseURL(url), true);
			if (matched) {
				matched.dynamicParams = matched.dynamicParams.filter(_arrayClean);
				matched.route = matched.route.join('.');
			}
			return matched;
		};

		function routeTransition(processed) {
			if (LR.init) {
				consoleError(405);
				return;
			}
			var matched = processed.matched,
			    currRoute;
			processed.currRoute = currRoute = matched.route.join('.');
			matched.refreshRoute && currRoute == prevTrans.info.route;
			newTransInfo = {
				replace: matched.replace || (matched.refreshRoute && LR.checkIfSameRoute(convertMatchedObjToRouteInfo(processed.matched), convertMatchedObjToRouteInfo(prevTrans.matched)) ? true : matched.replace),
				title: trans ? trans.title : d.title,
				fromHistory: false
			};
			var url = dispatchTransition(processed);
			if (url && newTrans) {
				log('Transitioning to ' + currRoute + ' ' + url, routeStr);
				return newTrans._trans;
			} else {
				log('Transition failed');
				return {};
			}
		}

		function getLocation() {
			if (config.history) {
				var path = checkForEmptyPath(dloc.pathname + dloc.search + (dloc.hash || ""));
				path = shiftBaseURL(path);
				return _delimit(path);
			} else {
				return _delimit(checkForEmptyPath(dloc.hash.replace('#', '')));
			}
		}

		function checkForEmptyPath(path) {
			if (!path) {
				path = '/';
			}
			return path;
		}

		function shiftBaseURL(path, append) {
			var baseURL;
			if ((baseURL = config.baseURL) && path) {
				baseURL = _delimit(baseURL);
				if (path.indexOf(baseURL) == 0 && !append) {
					return path.replace(baseURL, '');
				} else if (append && path.indexOf(baseURL) != 0) {
					return baseURL + path;
				}
			}
			return path;
		}

		function constructURLFromRoute(matched) {
			if (matched && matched.route) {
				var strRoute;
				if (!Array.isArray(matched.route)) {
					matched.route = dotSerperator(strRoute = matched.route);
				} else {
					strRoute = matched.route.join('.');
				}
				matched.queryParams = matched.queryParams || {};
				matched.dynamicParams = matched.dynamicParams || [];
				matched.refreshModel = false;
				var url,
				    sameRoute = !!trans,
				    dynamicPos = matched.dynamicParams.length != matched.route.length,
				    dynamicParamPos = 0,
				    linkTo = this.tagName == LINKTOStr,
				    routeObj = config.routes,
				    templateUrl = url = '',
				    defQPTemp = {},
				    route;
				for (var i = 0, l = matched.route.length; i < l; i++) {
					route = matched.route[i];
					if (sameRoute && trans.matched.route[i] != route) {
						sameRoute = false;
					}
					routeObj = _getObj(route, routeObj);
					if (!routeObj && !routeObj.__lp && routeObj.__lp.path) {
						consoleError(422, matched.route, i);
						return false;
					}
					var def = routeObj.__lp.def;
					if (!def && !linkTo) {
						consoleError(422, matched.route, i);
					}
					var path = routeObj.__lp.path,
					    defaultQP;
					if (!def || !def.__lp) {
						if (defaultQP = routeObj.__lp.defQP) {
							for (var key in defaultQP) {
								if (matched.queryParams && !matched.queryParams.hasOwnProperty(key)) {
									matched.queryParams[key] = defaultQP[key];
								}
							}
						}
					} else if (def.queryParams) {
						defaultQP = routeObj.__lp.defQP;
						var qpdef = def.__lp.qpdef;
						for (var key in qpdef) {
							if (!matched.queryParams.hasOwnProperty(key)) {
								if (sameRoute && qpdef[key].sticky) {
									matched.queryParams[key] = trans.routes[i].__ltp.queryParams[key];
								} else if (defaultQP && defaultQP.hasOwnProperty(key)) {
									defQPTemp[key] = matched.queryParams[key] = defaultQP[key];
								}
							}
							if (constructURLFromRoute.caller.name != "pathProcessor" && qpdef[key].cipher && config.cipher.encryptor) {
								matched.queryParams[key] = config.cipher.encryptor(matched.queryParams[key]);
							}
							if (!linkTo && !matched.refreshModel && qpdef[key].refreshModel) {
								matched.refreshModel = true;
							}
						}
					}
					if (routeObj.__lp.dkey) {
						var dynamicPathSplit = _splitPath(path),
						    dynamicPathSplitTemp = _splitPath(path),
						    pos = dynamicPos ? dynamicParamPos : i;
						if (!matched.dynamicParams || !matched.dynamicParams[pos]) {
							consoleError(499, route, linkTo ? this : undefined);
							return false;
						} else {
							dynamicPathSplit[routeObj.__lp.dIndex] = encodeURI(matched.dynamicParams[pos]);
							dynamicPathSplitTemp[routeObj.__lp.dIndex] = _delimit('<<dp>>');
							templateUrl += _delimit(dynamicPathSplitTemp.join('/'));
							url += _delimit(dynamicPathSplit.join('/'));
							dynamicParamPos++;
						}
					} else {
						templateUrl += _delimit(path);
						url += _delimit(path);
					}
				}
				if (!config.stickyRoutes[strRoute]) {
					config.urlCache[strRoute] = { url: validateURL(templateUrl), defQP: defQPTemp };
				}
				return appendQueryParamsAndFrag(url, matched);
			}
		}

		function appendQueryParamsAndFrag(url, matched) {
			url = url[url.length - 1] == '/' && url.length != 1 ? url.slice(0, -1) : url;
			if (matched.queryParams) {
				var ques = true;
				for (var key in matched.queryParams) {
					if (matched.queryParams[key] != undefined) {
						if (ques) {
							url += '?';
							ques = false;
						} else {
							url += '&';
						}
						url += key + '=' + encodeURIComponent(matched.queryParams[key]);
					}
				}
			}
			if (config.history && matched.fragment) {
				url = url + "#" + matched.fragment;
			}
			return validateURL(url);
		}

		function historyRegistration() {
			LR.history = new History();
			function History() {
				return this;
			}

			Object.defineProperty(History.prototype, 'state', {
				get: function get() {
					return getData();
				},
				set: function set(data) {
					if (allowHistoryChange) {
						allowHistoryChange = false;
					} else {
						Lyte.warn('setting on data will not be pushed to history. If needed, use `LR.history.replaceState`.');
					}
					return data;
				}
			});

			History.prototype.replaceState = function () {
				stateChange.apply(Array.from(arguments).push(true));
			};

			History.prototype.pushState = function () {
				stateChange.apply(Array.from(arguments));
			};

			function stateChange(data, title, url, replace) {
				if (!replace) {
					getMeta().index++;
				}
				addToHistory({
					state: {
						meta: getMeta(),
						data: data
					},
					title: title,
					url: url
				});
			}
		}

		var invokeRunLoop;
		function dispatch(path, processed, data) {
			t(RouteTransitionStr);
			if (path && config.baseURL && d.location.pathname.indexOf(config.baseURL) == -1) {
				consoleError(400);
				return;
			}
			processed = processed || (!initialLoad && getMeta() && getMeta().matched && getMeta().url == getLocation() ? normalizeMatchedObj(getMeta().matched) : traverse(path));
			if (processed && processed.matched.route.length) {
				clearTimeout(invokeRunLoop);
				processed.prevTrans = processed.prevTrans || Lyte.Router.__lp.prevTrans;
				processed.path = processed.path || path;
				processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched, processed.R);
				invoke(Processed = processed);
				Lyte.triggerEvent("transitionStart", { prevTrans: prevTrans && prevTrans._trans, nextTrans: newTrans._trans });
				invokeRunLoop = setTimeout(function () {
					Processed = undefined;
					if (trans && trans.state == 102 && newTrans && LR.checkIfSameRoute(newTrans.info, trans.info) && !trans.aborted && JSON.stringify(trans._data) == JSON.stringify(newTrans._trans.data)) {
						if (trans.iPause == true) {
							trans.resume();
						}
						return;
					} else if (trans && trans.state == 102) {
						trans.abort({ state: 409 });
					}
					trans = newTrans;
					trans._data = trans._trans.data ? Lyte.deepCopyObject(trans._trans.data) : undefined;
					processed.previous = true;
					trans.transComp = processed.transComp;
					// trans.transComp = processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched,processed.R);
					trans.runLoop = constructRunLoop(processedDispatch = processed);
					if (trans._trans.data) {
						newTransInfo.data = trans._trans.data;
					}
					newTransInfo.state = trans.stateObj = getHistoryState({
						replace: newTransInfo.replace,
						data: newTransInfo.data,
						url: trans.url,
						matched: trans.matched,
						fromHistory: newTransInfo.fromHistory
					});
					getHistoryObj(newTransInfo);
					trans.run();
				}, 0);
			}
		}

		function getTransitionDiffernce(prevTrans, matched, R) {
			var like = true,
			    similar = true,
			    rendered = [],
			    common = [],
			    unRendered = [],
			    templateToRemove,
			    currRoute = matched.route.join('.'),
			    r,
			    tar = "";

			if (prevTrans) {
				var prevMatched = prevTrans.matched,
				    route,
				    startFrom = matched.refreshRoute && currRoute == prevTrans.info.route ? matched.refreshRoute : matched.startFrom;
				for (var i = 0, l = matched.route.length; i < l; i++) {
					route = matched.route[i];
					tar = tar + (tar ? "." : "") + route;
					if (similar && route == prevMatched.route[i] && (!startFrom || tar != startFrom)) {
						r = R ? R[i] : LR.__lp.getDefinition(route.slice(0, i));
						if (like && compareRoute(r, i, prevMatched, matched)) {
							common.push(route);
							if (prevTrans.routes[i].__ltp.rendered) {
								rendered.push(route);
							} else {
								// like = false; dont change this code. It is commented for decideTransition function
								unRendered.push(route);
							}
						} else {
							like = false;
							unRendered.push(route);
						}
					} else {
						similar = false;
						if (templateToRemove == undefined && prevTrans.routes[i] && prevTrans.routes[i].__ltp.rendered && prevTrans.routes[i].outlet) {
							templateToRemove = i;
						}
						unRendered.push(route);
					}
				}
				if (prevMatched.route.length > matched.route.length) {
					var index = matched.route.length;
					if (templateToRemove == undefined && prevTrans.routes[index].__ltp.rendered /* && prevTrans.routes[i].outlet */) {
							templateToRemove = index;
						}
				}
			} else {
				unRendered = unRendered.concat(matched.route);
			}
			return {
				rendered: rendered,
				unRendered: unRendered,
				common: common,
				templateToRemove: templateToRemove
			};
		}

		function compareRoute(r, index, prevMatched, matched) {
			var same = true,
			    routeObj = _getObj(r.__lp.objPath, config.routes);
			if (!r.queryParams && !routeObj.__lp.dkey) {
				return true;
			}
			if (routeObj.__lp.dkey && prevMatched.dynamicParams[index] != matched.dynamicParams[index]) {
				return false;
			} else if (r.queryParams && matched.refreshModel) {
				r.queryParams.every(function (key) {
					if (same && r.__lp.qpdef[key].refreshModel && (matched.queryParams || prevMatched.queryParams) && matched.queryParams[key] != prevMatched.queryParams[key]) {
						return same = false;
					} else {
						return true;
					}
				});
			}
			return same;
		}

		var basicHooks = [beforeModelStr, modelStr, afterModelStr, redirectStr, renderTemplateStr, afterRenderStr];
		function constructRunLoop(processed) {
			t(constructRunLoopStr);
			var transComp = processed.transComp,
			    runLoop = [],
			    forceFetch = {},
			    beforeLoad = [],
			    req = [],
			    b4Exit = [],
			    willTransit = [],
			    didTransit = [];

			if (processed.previous) {
				var b4RouteTrans = [{ hook: beforeRouteTransitionStr }];
				if (prevTrans) {
					for (var i = prevTrans.matched.route.length - 1, r; r = prevTrans.matched.route[i]; i--) {
						var r1 = trans.matched._routes[i];
						if (!r1 || r1.join('.') != prevTrans.matched._routes[i].join('.')) {
							b4Exit.push({ hook: beforeExitStr, index: i });
						}
						willTransit.push({ hook: willTransitionStr, index: i });
					}
					t(constructRunLoopStr);
					return { previous: willTransit.concat(b4RouteTrans).concat(b4Exit), current: b4Exit };
				}
				t(constructRunLoopStr);
				return { previous: b4RouteTrans };
			}
			if (transComp.rendered && transComp.rendered.length) {
				transComp.rendered.forEach(function (hook, index) {
					trans.routes[index].__ltp.rendered = true;
					runLoop.push({ hook: redirectStr, index: index });
					didTransit.push({ hook: didTransitionStr, index: trans.matched.route.length - index - 1 });
				});
			}
			if (transComp.unRendered && transComp.unRendered.length) {
				// beforeLoad.push({hook : beforeLoadStr, index : transComp.rendered.length});
				transComp.unRendered.forEach(function (hook, orgIndex) {
					var index = transComp.rendered.length + orgIndex;
					if (!transComp.redirected || transComp.redirected && transComp.redirected.index != index) {
						beforeLoad.push({ hook: beforeLoadStr, index: index });
						req = req.concat([{ hook: getDependenciesStr, index: index }, { hook: getResourcesStr, index: index }]);
					}
					var routeInstance = trans.routes[index];
					if (_typeof(routeInstance.forceFetch) == functionStr ? callHookWithoutPromise.call(this, routeInstance.forceFetch, routeInstance, "forceFetch", index, params(index)) : routeInstance.forceFetch) {
						forceFetch[index] = [{ hook: beforeModelStr, index: index }, { hook: modelStr, index: index }, { hook: afterModelStr, index: index }];
						newTrans.routes[index].__ltp.fetchStatus = pendingStr;
						[redirectStr, renderTemplateStr, afterRenderStr].forEach(function (h) {
							runLoop.push({ hook: h, index: index });
							if (h == renderTemplateStr && transComp.unRendered[orgIndex + 1]) {
								runLoop.push({ hook: beforeLoadStr, index: index + 1 });
							}
						});
					} else {
						basicHooks.forEach(function (h) {
							if (transComp.redirected && transComp.redirected.index == index && h != redirectStr) {
								if ([beforeModelStr, modelStr, afterModelStr].indexOf(h) == -1) {
									runLoop.push({ hook: h, index: index });
								}
								if (h == renderTemplateStr && transComp.unRendered[orgIndex + 1]) {
									runLoop.push({ hook: beforeLoadStr, index: index + 1 });
								}
							} else {
								runLoop.push({ hook: h, index: index });
								if (h == renderTemplateStr && transComp.unRendered[orgIndex + 1]) {
									runLoop.push({ hook: beforeLoadStr, index: index + 1 });
								}
							}
						});
					}
					didTransit.push({ hook: didTransitionStr, index: trans.matched.route.length - index - 1 });
				});
			}

			runLoop = {
				previous: [],
				current: [{ hook: onBeforeLoadStr }].concat(beforeLoad).concat(req.concat(runLoop).concat(didTransit)),
				forceFetch: forceFetch
			};
			runLoop.templateToRemove = prevTrans && prevTrans.runLoop.templateToRemove ? prevTrans.runLoop.templateToRemove : [];
			if (transComp.templateToRemove != undefined) {
				runLoop.templateToRemove.push({ index: transComp.templateToRemove, routes: visibleTrans.routes });
			}
			t(constructRunLoopStr);
			return runLoop;
		}

		function invoke(processed) {
			newTrans = new Transition(processed);
			newTrans._processed = processed;
			newTrans.url = processed.path;
			newTrans.runLoop = {};
			newTrans._trans = limitTransition(newTrans);
			Lyte.extendEventListeners(newTrans._trans);
			newTrans.routes = initRoute(processed);
			if (historyObj) {
				newTransInfo = historyObj;
				newTransInfo.url = processed.path;
				newTrans._trans.data = getData() || {};
				newTransInfo.replace = true;
				historyObj = undefined;
			} else if (newTrans._trans.data) {
				LR.history.replaceState(newTrans._trans.data);
			}
		}

		function _getObj(arr, obj) {
			if (!obj) {
				return;
			} else if (!arr) {
				return obj;
			} else if (!Array.isArray(arr) && typeof arr == 'string') {
				arr = dotSerperator(arr);
			}
			arr.every(function (key) {
				if (obj && obj[key]) {
					obj = obj[key];
					return true;
				}
				return obj = false;
			});
			return obj;
		}

		function abortRunningPromises(trans) {
			if (trans.runningProm) {
				trans.runningProm.reject(abortedStr);
			}
			if (trans.fRunningProm) {
				trans.fRunningProm.reject(abortedStr);
			}
		}

		var transId = 0;
		function Transition(processed) {
			this.transId = transId = transId + 1;
			this.matched = processed.matched;
			this.target = processed.matched.target;
			this.fns = [];
			this.pending = {
				dependencies: new Set(),
				resources: new Set(),
				forceFetch: new Set()
			};
			this.info = {
				route: processed.matched.target,
				queryParams: processed.matched.queryParams,
				dynamicParams: processed.matched.dynamicParams.filter(_arrayClean)
			};
			if (processed.matched.fragment) {
				this.info.fragment = processed.matched.fragment;
			}
			this.R = processed.R;
			this.running = this.aborted = this.paused = false;
			this.abort = function (obj) {
				if (newTransInfo && newTransInfo.goValue) {
					fromHistoryGo = false;
				}
				this.abort = emptyFn;
				abortRunningPromises(this);
				this.aborted = true;
				if (!obj) {
					obj = { state: 308 };
				}
				if (this.running) {
					log(TransitionAbortedStr, routeStr);
				}
				// if(this.running && newTransInfo && !newTransInfo.replace) {
				// 	historyLength--;
				// }
				if (!obj.iAbort) {
					delete this.runLoop.templateToRemove;
					// if(prevTrans && prevTrans.url != getLocation() && this.state == 201) {
					// if(prevTrans && visibleTrans && prevTrans.url != getLocation() && trans != visibleTrans) {
					// fromHistoryGo = true;
					// if(getMeta() && getMeta().index != undefined && getMeta().index+1 == history.length) {
					// 	history.go(1);
					// } else {
					// 	history.go(-1);
					// }
					// }  
				}
				transitionCompleted(obj);
			}.bind(this);
			this.pause = function (obj) {
				log(TransitionPausedStr, routeStr);
				if (obj && obj.iPause) {
					this.iPause = true;
				} else {
					this.iPause = false;
					this.state = this._trans.state = 307;
					this._trans.triggerEvent(stateChangeStr, this.state);
				}
				this.paused = trans.prom || true;
				this.resume = this._trans.resume = function (t) {
					t = t || this;
					if (t.prom != t.eProm) {
						if (!t.pendingResume) {
							t.pendingResume = t.resume;
							delete t._trans.resume;
							delete t.resume;
						}
						return;
					}
					delete t._trans.resume;
					delete t.resume;
					log(TransitionResumedStr, routeStr);
					if (t.paused) {
						var state,
						    prom = t.prom;
						if (t.paused != true) {
							state = t.paused.state;
						}
						if (t.runLoop[state]) {
							if (state == "forceFetch") {
								var newProm = t.runLoop.forceFetch[prom.index];
								if (newProm[0] && prom.hook == newProm[0].hook) {
									newProm.splice(0, 1);
								}
							} else if (t.runLoop[state][0] && t.runLoop[state][0].hook == t.paused.hook && t.runLoop[state][0].index == t.paused.index) {
								removeHook(t.runLoop[state], t.paused.hook, t.paused.index);
							}
						}
						t.iPause = t.paused = false;
						t.state = t._trans.state = 102;
						this._trans.triggerEvent(stateChangeStr, t.state);
						if (this.forceFetchRunning) {
							if (t.runLoop.forceFetch[prom.index][0]) {
								t.run(t.runLoop.forceFetch[prom.index][0]);
							} else {
								t.routes[prom.index].__ltp.fetchStatus = completedStr;
								if (t.pending.waitingForFF != undefined && t.pending.waitingForFF == prom.index) {
									delete t.pending.waitingForFF;
									t.run();
								}
							}
						} else {
							if (state && state == "forceFetch" && !t.runLoop.forceFetch[prom.index][0]) {
								t.routes[prom.index].__ltp.fetchStatus = completedStr;
							}
							t.run();
						}
					}
				}.bind(this);
				return this._trans;
			}.bind(this);
		}

		function debugLog() {
			if (Lyte.debug) {
				console.log.apply(this, Array.from(arguments));
			}
		}

		function getRequirements(object) {
			/* download files that are returned from getResources and getDependencies */
			var every = function every() {};
			every.internal = {};
			var r = object.r,
			    reqType = object.reqType,
			    index = object.index,
			    ins = r.__lp,
			    hook = every.internal.hook = trans.prom.hook;
			every.internal.route = ins.objPath;
			debugLog(reqType + ' before inject', this.transId, ins.objPath);
			Lyte.injectResources(ins[reqType], every, function (successFiles, errorFiles) {
				if (!config.execRouteRequirementsOnDemand) {
					if (!trans.aborted || ins.objPath == this.routes[index].__lp.objPath && trans.transComp.redirected && index <= trans.transComp.common.length - 1 || Processed && Processed.transComp.redirected && index <= Processed.transComp.common.length - 1) {
						if (trans.aborted) {
							trans = !LR.__lp.trans.aborted ? !LR.__lp.trans.aborted : newTrans;
							ins = trans.routes[index].__lp;
						}
						var fnType = hook == getDependenciesStr ? "loadDependencies" : "loadResources";
						var errorType = hook == getDependenciesStr ? "errorDependencies" : "errorResources";
						if (trans.pending[reqType].has(index)) {
							ins = trans.routes[index].__lp;
							ins[reqType + 'Loaded'] = true;
							delete ins[fnType];
							trans.pending[reqType].delete(index);
							if (!errorFiles.length) {
								debugLog(reqType + ' inject completed', 'success', trans.transId, ins.objPath);
								if (trans.pending.forceFetch.has(index)) {
									trans.pending.forceFetch.delete(index);
									nestedForcedPromises.call(trans, trans.runLoop.forceFetch, trans.fRunningProm.resolve, trans.runLoop.forceFetch[index][0]);
								} else {
									nestedPromises.call(trans, trans.runLoop, "current", trans.runningProm.resolve);
								}
							} else {
								debugLog(reqType + ' inject completed', 'failure', trans.transId);
								if (!trans.paused) {
									trans.pause({ iPause: true });
								}
								run[onErrorStr].call(trans, hook, index, r.__lp[errorType] = errorFiles, 424);
							}
						} else {
							trans.routes[index].__lp[fnType] = function () {
								if (errorFiles.length) {
									debugLog(reqType + ' inject completed', 'failure', trans.transId, this.objPath);
									trans.routes[index].__lp[reqType + 'Loaded'] = true;
									delete trans.routes[index].__lp[fnType];
									// ins[reqType+'Loaded'] = true;
									// delete this[fnType];
									if (!trans.paused) {
										trans.pause({ iPause: true });
									}
									run[onErrorStr].call(trans, hook, index, r.__lp[errorType] = errorFiles, 424);
									return false;
								} else {
									trans.routes[index].__lp[reqType + 'Loaded'] = true;
									delete trans.routes[index].__lp[fnType];
									// this[reqType+'Loaded'] = true;
									// delete this[fnType];
								}
							};
						}
						// if(!errorFiles.length) {
						// 	ins[reqType+'Loaded'] = true;
						// 	delete ins[fnType];
						// 	debugLog(reqType+' inject completed','success',trans.transId)
						// 	var pos = trans.pending[reqType].indexOf(index);
						// 	if(pos != -1) {
						// 		delete trans.pending[reqType].splice(pos,1);
						// 		if(trans.pending.forceFetch != undefined && trans.pending.forceFetch == index) {
						// 			delete trans.pending.forceFetch;
						// 			nestedForcedPromises.call(trans, trans.runLoop.forceFetch , trans.fRunningProm.resolve ,trans.runLoop.forceFetch[index][0]);
						// 		}
						// 		nestedPromises.call(trans,trans.runLoop,"current",trans.runningProm.resolve);
						// 	}
						// } else {
						// 	ins[fnType] = function() {
						// 		debugLog(reqType+' inject completed','failure',trans.transId);
						// 		ins[reqType+'Loaded'] = true;
						// 		delete ins[fnType];
						// 		if(!trans.paused) {
						// 			trans.pause({iPause : true});  
						// 		}
						// 		run[onErrorStr].call(trans,hook,index, (r.__lp[errorType] = errorFiles), 424);  
						// 	}
						// }
					}
				}
			}.bind(trans), {
				defer: function (opt) {
					var trans = this;
					console.log("fromDefer", ins, trans.routes[index].__lp, newTrans);
					function setTrans() {
						if (this.aborted) {
							if (newTrans && ins.objPath == (newTrans.routes[index] && newTrans.routes[index].__lp.objPath)) {
								if (newTrans._processed.transComp.redirected && index <= newTrans._processed.transComp.common.length - 1) {
									trans = newTrans;
									ins = trans.routes[index].__lp;
									return true;
								} else if (this != trans) {
									return true;
								} else {
									return false;
								}
							} else {
								return false;
							}
						} else {
							return true;
						}
					}

					if (ins.objPath == trans.routes[index].__lp.objPath) {
						if (!setTrans.call(this)) {
							return;
						}
						var injectJS = opt.injectJS,
						    files = opt.files,

						// errorFiles = opt.errorFiles,
						fnType = hook == getDependenciesStr ? "loadDependencies" : "loadResources",
						    errorType = hook == getDependenciesStr ? "errorDependencies" : "errorResources",
						    completed = function (errorFiles) {
							/* completed callback */
							if (!setTrans.call(this)) {
								return;
							}
							var _trans = trans;
							_trans.routes[index].__lp[reqType + 'Loaded'] = true;
							if (!errorFiles.length) {
								debugLog(reqType + ' inject completed', 'success', _trans.transId, ins.objPath);
								if (_trans.pending[reqType].has(index)) {
									_trans.pending[reqType].delete(index);
									if (_trans.pending.forceFetch.has(index)) {
										_trans.pending.forceFetch.delete(index);
										nestedForcedPromises.call(_trans, _trans.runLoop.forceFetch, _trans.fRunningProm.resolve, _trans.runLoop.forceFetch[index][0]);
									} else {
										nestedPromises.call(_trans, _trans.runLoop, "current", _trans.runningProm.resolve);
									}
								}
							} else {
								debugLog(reqType + ' inject completed', 'failure', _trans.transId, ins.objPath);
								if (!_trans.paused) {
									_trans.pause({ iPause: true });
								}
								run[onErrorStr].call(_trans, hook, index, r.__lp[errorType] = errorFiles, 424);
							}
						}.bind(this);
						if (ins[fnType] == 'pending') {
							if (!setTrans.call(this)) {
								return;
							}
							injectJS(files, function (successFiles, errorFiles) {
								debugLog(reqType + ' after inject', trans.transId, this.objPath);
								// delete this[fnType];
								delete trans.routes[index].__lp[fnType];
								completed(errorFiles);
							});
						} else {
							ins[fnType] = function () {
								injectJS(files, function (successFiles, errorFiles) {
									if (!setTrans.call(this)) {
										return;
									}
									debugLog(reqType + ' after inject', trans.transId, this.objPath);
									delete trans.routes[index].__lp[fnType];
									completed(errorFiles);
								}.bind(trans));
							};
						}
						// }
					}
				}.bind(trans)
			});
		}

		var requirements = {
			get: function get(ins, type) {
				var status = ins.__lp[type + 'Loaded'] == true;
				var fnType = type == dependenciesStr ? "loadDependencies" : "loadResources";
				if (!ins.__lp[fnType] || typeof ins.__lp[fnType] != 'function' || status) {
					return status;
				} else {
					var err = ins.__lp[fnType]();
					return err == false ? false : ins.__lp[type + 'Loaded'] == true;
				}
			}
		};

		function templateDelete(arr) {
			/* clears outlet, from parent to child */
			for (var i = 0, l = arr.length, obj; i < l; i++) {
				obj = arr[i];
				for (var inst, j = obj.routes.length - 1; j >= obj.index; j--) {
					inst = obj.routes[j];
					// delete inst.__lp.rendered;  
					if (inst.outlet) {
						triggerTemplateDestroy({ outlet: inst.outletName, route: inst }, true);
						inst.outlet.innerHTML = "";
						if (!trans.routes[j] || trans.routes[j].__lp.objPath != inst.__lp.objPath) {
							callDidDestroy.call(this, inst, j, obj);
						}
					}
				}
			}
		}

		function triggerTemplateDestroy(obj, bool) {
			// if(!obj.route.__lp.triggeredTemplateDestroy) {
			Lyte.triggerEvent(beforeTemplateDestroyStr, obj);
			// obj.route.__lp.triggeredTemplateDestroy = bool;
			// }
		}

		function callDidDestroy(inst, index, obj) {
			log(didDestroyStr + " of " + inst.routeName, routeStr, fontColor);
			callHookWithoutPromise.call(this, inst.didDestroy, inst, didDestroyStr, index, inst.currentModel, params(index, obj));
		}

		var stoppableHooks = [getDependenciesStr, getResourcesStr, beforeModelStr, modelStr, afterModelStr];
		// error in these hooks should pause transition and call onerror action
		function errorStoppableHook(hook) {
			return _presence(stoppableHooks, hook);
		}

		function callHookWithPromise(callback, instance) {
			/* executes route hooks which will returns promise */
			if (callback) {
				var args = arguments,
				    resp,
				    t = trans,
				    prom = trans.prom,
				    hook = prom.hook,
				    index = prom.index,
				    stopTrans = errorStoppableHook(hook),
				    self = this;
				return new Promise(function (resolve, reject) {
					try {
						var result = callback.apply(instance, Array.from(args).slice(2));
						if (stopTrans && result) {
							result = Lyte.resolvePromises(result);
						}
						resp = Promise.resolve(result);
					} catch (err) {
						processError.call(self, { hook: hook, index: index, stopTrans: stopTrans, err: err, instance: instance, promise: { resolve: resolve, reject: reject } });
						return;
					}
					resp.then(function (data) {
						if (prom.state != "previous" && trans._trans != instance.transition) {
							reject("old transition's promise rejected");
						} else {
							resolve(data);
							callback.then && callback.then.success.apply(this, arguments);
						}
					}, function (err) {
						t.prom = prom;
						reject(err);
						callback.then && callback.then.failure.apply(this, arguments);
						processError.call(self, { hook: hook, index: index, stopTrans: stopTrans, err: err, instance: instance, PR: true });
					});
				});
			} else {
				return Promise.resolve();
			}
		}

		function callHookWithoutPromise(callback, instance, hook, index) {
			/* executes route hooks which wont return promise  */
			if (callback) {
				var stopTrans = errorStoppableHook(hook);
				try {
					return callback.apply(instance, Array.from(arguments).slice(4));
				} catch (err) {
					processError.call(this, { hook: hook, index: index, stopTrans: stopTrans, err: err, instance: instance });
					return;
				}
			}
		}

		function callAction(hook, index, args) {
			/* executes route's actions  */
			var action,
			    routeInstance = this.routes[index];
			if (routeInstance.actions && (action = routeInstance.actions[hook])) {
				try {
					if (action.apply(routeInstance, args) == false) {
						return false;
					}
				} catch (e) {
					consoleErrorFromCallback(e, hook, routeInstance.routeName);
					return false;
				}
			}
		}

		function consoleErrorFromCallback(err, hook, routeName, state, options) {
			if (typeof err == "string" || (typeof err === 'undefined' ? 'undefined' : _typeof(err)) == "object" && err.stack && !err.$) {
				if (!err.stack) {
					err = Error(err);
				}
				err.$ = true;
				var internalErr = getError(state || 420, hook, routeName);
				err.stack = err.stack.replace(err.message, err.message = err.message + "\n\t" + internalErr);
				consoleError(err);
			} else {
				consoleError(state, hook, routeName, err, options && options.PR);
			}
		}

		function processError(options) {
			/* handles error in hooks */
			var instance = options.instance,
			    stopTrans = options.stopTrans,
			    err = options.err,
			    hook = options.hook,
			    index = options.index;
			if (stopTrans) {
				trans.pause();
				run[onErrorStr].call(this, hook, index, err, 420, options);
			} else {
				consoleErrorFromCallback(err, hook, instance.routeName);
				// if(_presence([willTransitionStr,didTransitionStr,beforeExitStr,redirectStr],hook)) {
				if (options.promise) {
					options.promise.resolve();
				}
				// } else {
				// trans.abort({state : 4, iAbort : true});
				// }
			}
		}

		function runLoopPromise(fn, fnName, loop, success, failure) {
			success = success || emptyFn;
			failure = failure || function (error) {
				if (error != abortedStr) {
					consoleError(error);
				}
			};
			new Promise(function (resolve, reject) {
				if (fnName == "nestedForcedPromises") {
					this.fRunningProm = { resolve: resolve, reject: reject };
					fn.call(this, this.runLoop.forceFetch, resolve);
				} else {
					this.runningProm = { resolve: resolve, reject: reject };
					fn.call(this, this.runLoop, loop, resolve);
				}
			}.bind(this)).then(success, failure);
		}

		Transition.prototype.run = function (pausedForcedProm) {
			if (pausedForcedProm) {
				nestedForcedPromises.call(this, this.runLoop.forceFetch, this.fRunningProm.resolve, pausedForcedProm);
				return;
			}
			processRunLoop.call(this);
			d.title = this.title = this.routes[this.routes.length - 1].title || d.title;
		};

		function processRunLoop() {
			runLoopPromise.call(this, nestedPromises, "nestedPromises", 'previous', function () {
				if (processedDispatch && !trans.running && !trans.aborted) {
					trans.state = trans._trans.state = 102;
					trans._trans.triggerEvent(stateChangeStr, trans.state);
					if (newTransInfo) {
						if (config.preserveUrlOnBrowserNavigation) {
							if (newTransInfo.fromHistory && !!newTransInfo.goValue) {
								fromHistoryGo = true;
								history.go(-newTransInfo.goValue);
							}
							newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
							newTransInfoClone = Lyte.deepCopyObject(newTransInfo);
							trans.stateObj = newTransInfo.state;
							var newTransInfoTimer = setInterval(function () {
								if (!newTransInfoClone) {
									clearInterval(newTransInfoTimer);
									return;
								}
								if (!fromHistoryGo) {
									clearInterval(newTransInfoTimer);
									addToHistory(newTransInfoClone);
									newTransInfoClone = undefined;
								}
							}, 0);
						} else {
							newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
							addToHistory(newTransInfo);
							trans.stateObj = newTransInfo.state;
						}
					}
					LR.__lp.trans = trans;
					processedDispatch.previous = false;
					trans.runLoop = constructRunLoop(processedDispatch);
					setParamsInInst(processedDispatch, trans.info);
					processedDispatch = newTransInfo = undefined;
					trans.running = true;
				}
				runLoopPromise.call(this, nestedPromises, "nestedPromises", 'current');
			}.bind(this));
		}

		function setPendingResume(promise) {
			trans.eProm = promise;
			if (this.pendingResume) {
				var resume = this.pendingResume;
				delete this.pendingResume;
				resume();
			}
		}

		function nestedForcedPromises(forcedLoop, resolve, promise) {
			if (validateTransition(this) && forcedLoop) {
				if (!promise) {
					for (var key in forcedLoop) {
						var routeLoop = forcedLoop[key],
						    p = routeLoop[0];
						if (p) {
							if (!p.running) {
								nestedForcedPromises.call(this, forcedLoop, resolve, p);
							}
						}
					}
					return;
				}
				var r = this.R[promise.index],
				    routeInstance = this.routes[promise.index];
				promise.state = "forceFetch";
				trans.prom = promise;
				if (promise.hook == beforeModelStr && !requirements.get(routeInstance, dependenciesStr)) {
					this.pending.dependencies.add(promise.index);
					this.pending.forceFetch.add(promise.index);
					return;
					// var fn = r.__lp.loadDependencies;
					// r.__lp.loadDependencies = 'pending';
					// if(fn) {
					// 	fn();
					// 	// delete r.__lp.loadDependencies;
					// }
					// if(r.__lp.loadDependencies) {
					// 	this.pausedRunloop = true;
					// 	return;
					// }
				}
				logCallbacks(promise);
				forcedLoop[promise.index][0].running = true;
				forcedLoop[promise.index].splice(0, 1);
				run[promise.hook].call(this, promise.hook, promise.index).then(function (data) {
					setPendingResume.call(trans, trans.prom);
					if (promise.hook == afterModelStr) {
						routeInstance.__ltp.fetchStatus = completedStr;
						if (this.pending.waitingForFF != undefined && this.pending.waitingForFF == promise.index) {
							delete this.pending.waitingForFF;
							nestedPromises.call(this, this.runLoop, "current", this.runningProm.resolve);
						}
					} else if (promise.hook == modelStr) {
						if (forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == afterModelStr) {
							nestedForcedPromises.call(this, forcedLoop, resolve, forcedLoop[promise.index][0]);
						}
					} else {
						if (forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == modelStr) {
							nestedForcedPromises.call(this, forcedLoop, resolve, forcedLoop[promise.index][0]);
						}
					}
				}.bind(this), function () {
					debugger;
				});
			} else {
				this.forceFetchRunning = false;
			}
		}

		function logCallbacks(promise) {
			if (Lyte.debug) {
				var hook = promise.hook,
				    index = promise.index;
				if ([beforeRouteTransitionStr, onBeforeLoadStr].indexOf(promise.hook) != -1) {
					log(hook, routeStr, fontColor);
					return;
				}
				var route = promise.state == "previous" ? prevTrans.R[index] : trans.R[index];
				log(hook + ' of route ' + route.routeName, routeStr, fontColor);
			}
		}

		function nestedPromises(loop, state, resolve) {
			if (validateTransition(this)) {
				var runLoop = loop[state];
				if (runLoop && runLoop.length) {
					var promise = runLoop[0],
					    r = this.R[promise.index],
					    routeInstance = this.routes[promise.index];
					var cond;
					if (promise.hook == beforeModelStr) {
						cond = requirements.get(routeInstance, dependenciesStr);
					}
					if (promise.hook == beforeModelStr && !cond) {
						this.pending.dependencies.add(promise.index);
						return;
						// this.pending.dependencies.push(promise.index);
						// var fn = r.__lp.loadDependencies;
						// r.__lp.loadDependencies = 'pending';
						// if(fn) {
						// 	fn();
						// 	// delete r.__lp.loadDependencies
						// } 
						// if(r.__lp.loadDependencies) {
						// 	this.pausedRunloop = true;
						// 	return;
						// }
					} else if (promise.hook == renderTemplateStr && !requirements.get(routeInstance, resourcesStr)) {
						this.pending.resources.add(promise.index);
						return;
						// this.pending.resources.push(promise.index);
						// var fn = r.__lp.loadResources;
						// r.__lp.loadResources = 'pending';
						// if(fn) {
						// 	fn();
						// 	// delete r.__lp.loadResources
						// } 
						// if(r.__lp.loadResources) {
						// 	this.pausedRunloop = true;
						// 	return;
						// }
					} else if (promise.hook == redirectStr && r.forceFetch && routeInstance.__ltp.fetchStatus == pendingStr) {
						if (!this.forceFetchRunning) {
							this.forceFetchRunning = true;
							runLoopPromise.call(this, nestedForcedPromises, "nestedForcedPromises");
						}
						this.pending.waitingForFF = promise.index;
						return;
					} else {
						promise.state = state;
						trans.prom = promise;
						logCallbacks(promise);
						t(promise.hook + promise.index);
						run[promise.hook].call(this, promise.hook, promise.index).then(function (data) {
							setPendingResume.call(trans, trans.prom);
							t(promise.hook + promise.index);
							if (this.runningProm.resolve == resolve) {
								removeHook(loop[state], promise.hook, promise.index);
								nestedPromises.call(this, loop, state, resolve);
							}
						}.bind(this));
					}
				} else if (resolve) {
					resolve();
				}
			} else if (this.paused && this.runningProm) {
				this.runningProm.reject(abortedStr);
			}
		}

		function removeHook(loop, hook, index) {
			for (var i = 0, obj; obj = loop[i]; i++) {
				if (obj.hook == hook) {
					if (index != undefined) {
						if (index == obj.index) {
							loop.splice(i, 1);
							break;
						}
					} else {
						loop.splice(i, 1);
						i--;
					}
				}
			}
		}

		function frameQueryParams(url) {
			if (url) {
				var qp = {},
				    split,
				    params = _presence(url, "?") ? url.split("?")[1] : url;
				params = _presence(params, "&") ? params.split(/&/g) : [params];
				for (var i = 0, l = params.length; i < l; i++) {
					qp[(split = params[i].split('='))[0]] = split[1] ? decodeURIComponent(split[1]) : split[1];
				}
				return qp;
			}
		}

		function frameDynamicParams(url, matched) {
			var routesObj = config.routes,
			    dynamicParam,
			    fdp,
			    framedDP = [],
			    urlSplit = _splitPath(url.split('?')[0]);
			for (var i = 0, l = matched.route.length, r; i < l; i++) {
				r = matched.route[i];
				routesObj = _getObj([r], routesObj);
				var routeObj = routesObj.__lp;
				if (routeObj.wildcard) {
					if (routeObj.sufix.length) {
						var dp = urlSplit.slice(0, urlSplit.indexOf(routeObj.sufix[0]));
						fdp = decodeURI(dp.join('/'));
						_pop(dp.concat(routeObj.sufix), urlSplit);
					} else {
						fdp = decodeURI(urlSplit.join('/'));
					}
				} else if (routeObj.dkey) {
					dynamicParam = urlSplit[routeObj.dIndex];
					_pop(_splitPath(routeObj.path), urlSplit);
					fdp = decodeURI(dynamicParam);
				} else {
					_pop(_splitPath(routeObj.path), urlSplit);
					fdp = undefined;
				}
				framedDP.push(fdp);
			};
			return framedDP;
		}

		function _pop(path, urlSplit) {
			for (var i = 0, l = path.length; i < l; i++) {
				urlSplit.shift();
			};
		}

		function _presence(str, char) {
			return str.indexOf(char) != -1;
		}

		function transitionCompleted(obj) {
			/* called after a atransition is completed or aborted*/
			if (trans.running) {
				if (trans == newTrans) {
					newTrans = undefined;
				}
				if (newTransInfoClone) {
					clearInterval(newTransInfoTimer);
					addToHistory(newTransInfoClone);
					newTransInfoClone = undefined;
				}
				setActiveClassForLink(trans.info);
				for (var i = 0, l = trans.fns.length; i < l; i++) {
					clearTimeout(trans.fns[i]);
				};
				trans.pendingResume = undefined;
				trans.running = false;
				trans.state = trans._trans.state = obj.state;
				trans._trans.triggerEvent(stateChangeStr, trans.state);
				if (initialLoad || trans.state == 200) {
					LR.__lp.prevTrans = prevTrans = trans;
					t(RouteTransitionStr);
					log(TransitionComletedStr, routeStr);
					if (config.history && trans.info.fragment) {
						var elem;
						if ((elem = d.getElementById(trans._trans.info.fragment)) && elem.scrollIntoView && LR.beforeScroll(trans._trans) != false) {
							elem.scrollIntoView();
						}
					}
					run[afterRouteTransitionStr](trans._trans);
				} else if (obj.iAbort || visibleTrans == trans) {
					LR.__lp.prevTrans = prevTrans = trans;
					if (trans.state && trans.state != 201) {
						run[afterRouteTransitionStr](trans._trans);
					}
				} else {
					if (trans.state && trans.state != 201) {
						run[afterRouteTransitionStr](trans._trans);
					}
					LR.__lp.trans = trans = prevTrans;
				}
				if (initialLoad) {
					initialLoad = false;
				}
			} else if (prevTrans) {
				LR.__lp.trans = trans = prevTrans;
			}
		}

		function _delimit(seg) {
			return seg[0] == "/" ? seg : "/" + seg;
		}

		function _splitPath(path) {
			return path.match(/[^/?]+/g) || [];
		}

		function validateURL(url) {
			url = url.replace(/\/\//g, '/');
			url = url.replace(/\/\?/g, '?');
			return url;
		}

		function getError() {
			var args = arguments,
			    error;
			switch (args[0]) {
				case 400:
					error = args[1] ? "url '" + args[1] + "' is not defined in router." : "Base path of url is not specified.";
					break;
				case 405:
					error = "Method not allowed before router initialization.";
					break;
				case 422:
					error = "There is no route definition for the route " + args[1].splice(0, args[2] + 1).join('.') + ".";
					break;
				case 424:
					error = "File not loaded in " + args[1] + " of route " + args[2] + ".\n" + args[3][0].target.outerHTML;
					break;
				case 498:
					error = "Invalid argument " + args[1] + (args[2] ? " provided in " + args[2] : ".");
					break;
				case 499:
					error = args[1] ? "Dynamic params for the route " + args[1] + " is not provided" + (args[2] && args[2].outerHTML ? " in " + args[2].outerHTML : ".") : "Transition tried without arguments.";
					break;
				case 420:
					error = (args[3] ? "Promise rejected" : "Error") + " in " + args[1] + " of route " + args[2] + ".";
					break;
				case 428:
					error = "There is no outlet named " + args[1] + ".";
					break;
				case 203:
					error = "Data provided for component is not valid.";
					break;
			}
			return 'LR ' + args[0] + ': ' + error;
		}

		function consoleError() {
			Lyte.error(arguments[0].stack ? arguments[0] : getError.apply(this, arguments), arguments[3]);
		}

		function traverse(path, get) {
			if (!path) {
				consoleError(400, '');
				return;
			}
			var selectedPaths = [],
			    fragment;
			if (config.history) {
				var fragSplit = path.split('#');
				if (fragment = fragSplit[1]) {
					path = fragSplit[0];
				}
			}
			var pathSplit = path.split('?');
			path = decodeURI(pathSplit[0]);
			if (path == '/') {
				if (_getObj(['/'], config.routeHash)) {
					selectedPaths.push([path]);
				} else {
					consoleError(400, path);
					return;
				}
			} else {
				var findPossibleMatch = function findPossibleMatch(mapObj) {
					for (var mapPath in mapObj) {
						if (!exactMatch) {
							var pathObj = mapObj[mapPath],
							    innerLevel;
							if (mapPath != "__lp") {
								var mapPathSplit = _splitPath(mapPath);
								if (mapPathSplit) {
									if ((innerLevel = checkArrayMatch(mapPathSplit, pathSplitArr, pathLevel, pathObj, matchedPath)) !== false) {
										pathArrLevel.push(innerLevel);
										pathLevel = pathArrLevel[pathArrLevel.length - 1];
										if (pathSplitArr.length == pathLevel) {
											var path = Array.from(matchedPath.concat(mapPath));
											if (pathObj["/"]) {
												path = path.concat('/');
											}
											selectedPaths.push(path);
											if (pathObj.__lp.wildcard || pathObj.__lp.dkey) {
												pathArrLevel.pop();
												pathLevel = pathArrLevel[pathArrLevel.length - 1];
											} else {
												if (!/[:*]/.test(path.join(''))) {
													exactMatch = path;
												}
												return;
											}
										} else {
											var innerRoutes = Object.keys(pathObj);
											matchedPath.push(mapPath);
											if (pathSplitArr[pathLevel]) {
												if (pathObj.__lp.wildcard && !pathObj.__lp.sufix.length && innerRoutes.length == 1) {
													var wildcard = Array.from(matchedPath);
													if (pathObj["/"]) {
														wildcard = wildcard.concat('/');
													}
													selectedPaths.push(wildcard);
												} else if (innerRoutes.length > 1) {
													findPossibleMatch(pathObj);
												}
											}
											matchedPath.pop();
											pathArrLevel.pop();
											pathLevel = pathArrLevel[pathArrLevel.length - 1];
										}
									}
								}
							}
						}
					}
				};

				var params = pathSplit[1],
				    pathSplitArr = _splitPath(path);
				var pathLevel = 0,
				    pathArrLevel = [0],
				    exactMatch,
				    matchedPath = [];
				matchedPath.dynamicParams = [];
				findPossibleMatch(config.routeHash);
			}
			if (exactMatch) {
				return pathProcessor(get, exactMatch, path, params, fragment);
			} else if (selectedPaths.length == 1) {
				return pathProcessor(get, selectedPaths[0], path, params, fragment);
			} else if (selectedPaths.length) {
				var getBestMatch = function getBestMatch(staticMatches, selectedPaths, position) {
					position = position || 0;
					var traversedStaticMatch = traversedStaticMatch || traverseArray(staticMatches),
					    maxStaticSeg = Math.max.apply(Math, _toConsumableArray(traversedStaticMatch[position])),
					    duplicatePos;
					while (duplicatePos = checkForArrayDuplicates(traversedStaticMatch[position], maxStaticSeg, selectedPaths, staticMatches)) {
						position = position + 1;
						var newSelectedPaths = [],
						    newStaticMatches = [];
						for (var i = 0, l = duplicatePos.length; i < l; i++) {
							newSelectedPaths.push(selectedPaths[i]);
							newStaticMatches.push(staticMatches[i]);
						}
						var newSelectedPathsFiltered = [],
						    newStaticMatchesFiltered = [];
						for (var i = 0, l = newStaticMatches.length; i < l; i++) {
							if (newStaticMatches[i][position] != undefined) {
								newSelectedPathsFiltered.push(newSelectedPaths[i]);
								newStaticMatchesFiltered.push(newStaticMatches[i]);
							}
						}
						if (!newSelectedPathsFiltered.length) {
							return newSelectedPaths[0];
						} else if (newSelectedPathsFiltered.length == 1) {
							return newSelectedPathsFiltered[0];
						}
						return getBestMatch(newStaticMatchesFiltered, newSelectedPathsFiltered, position);
					}
					return selectedPaths[traversedStaticMatch[position].indexOf(maxStaticSeg)];
				};

				var getStaticMatches = function getStaticMatches(selectedPaths) {
					var staticSegmentsInMatch = [];
					for (var i = 0, l = selectedPaths.length; i < l; i++) {
						var arr = Array.from(selectedPaths[i]),
						    staticPath = 0,
						    result = [];
						if (arr[0] == "/") {
							arr.shift();
						}
						if (arr[arr.length - 1] == "/") {
							arr.pop();
						}
						var counter = -1;
						arr.every(function (seg, i) {
							var noWildcard = true;
							_splitPath(seg).every(function (innerSeg, j) {
								counter++;
								if (innerSeg == pathSplitArr[counter]) {
									staticPath++;
									if (arr.length == i + 1) {
										result.push(staticPath);
									}
									return true;
								} else if (innerSeg.indexOf(':') != -1) {
									result.push(staticPath);
									staticPath = 0;
									return true;
								} else {
									if (innerSeg.indexOf('*') != -1) {
										noWildcard = false;
									}
									result.push(staticPath);
									return false;
								}
							});
							return noWildcard;
						});
						staticSegmentsInMatch.push(result);
					}
					return staticSegmentsInMatch;
				};

				return pathProcessor(get, getBestMatch(getStaticMatches(selectedPaths), selectedPaths), path, params, fragment);
			} else {
				consoleError(400, path);
			}
		}

		function checkArrayMatch(arr1, arr2, l, pathObj, matchedPath) {
			if (!(pathObj.__lp.wildcard || pathObj.__lp.dkey)) {
				var prevObj;
				if (prevObj = _getObj(matchedPath, config.routeHash).__lp) {
					if (prevObj.wildcard) {
						var pathArr = arr2.slice(l);
						if (!(l += pathArr.indexOf(arr1[0]))) {
							return false;
						}
					}
				}
			}
			for (var i = 0, a1; a1 = arr1[i]; i++, l++) {
				if (a1 != arr2[l] && !dynamicRouteCheck(a1)) {
					if (wildcardRouteCheck(a1)) {
						if (pathObj.__lp.sufix.length) {
							l = arr2.indexOf(pathObj.__lp.sufix[0]) - 1;
						}
					} else if (arr1[l] == '/') {
						l--;
					} else {
						return false;
					}
				}
			}
			return l;
		}

		function checkForArrayDuplicates(arr, value, selectedPaths, staticMatches) {
			var pos = [];
			for (var i = 0, l = arr.length; i < l; i++) {
				if (arr[i] == value) {
					pos.push(i);
				}
			}
			return pos.length == 1 ? false : pos;
		}

		function traverseArray(arr) {
			var res = [],
			    maxArrLen = 0;
			for (var i = 0, l = arr.length; i < l; i++) {
				var a = arr[i];
				maxArrLen = a.length > maxArrLen ? a.length : maxArrLen;
			}
			for (var i = 0, a; a = arr[i]; i++) {
				for (var j = 0; j < maxArrLen; j++) {
					res[j] = res[j] || [];
					res[j][i] = a[j];
				}
			}
			return res;
		}

		function pathProcessor(get, selectedPath, path, params, fragment) {
			var newURL,
			    orgMatched,
			    newMatched,
			    matched = {
				route: _getObj(selectedPath, config.routeHash).__lp.route,
				queryParams: params ? frameQueryParams(params) : {}
			};
			if (config.history) {
				matched.fragment = fragment;
			}
			matched.dynamicParams = frameDynamicParams(path, matched);
			if (get) {
				return matched;
			}
			matched.dpProcessed = true;
			var transInfo = normalizeMatchedObj(matched);
			if (transInfo != false) {
				orgMatched = Lyte.deepCopyObject(transInfo.matched);
				newMatched = Lyte.deepCopyObject(transInfo.matched);
				if (!transInfo.matched.hasOwnProperty('refreshModel')) {
					constructURLFromRoute(transInfo.matched);
				}
				newURL = constructURLFromRoute(newMatched);
				if (!_compareObj(newMatched.queryParams, orgMatched.queryParams)) {
					addToHistory({ replace: true, state: window.history.state, url: newURL, fromHistory: true });
					transInfo.path = newURL;
				}
			}
			return transInfo;
		}

		function setParamsInInst(processed, transInfo) {
			if (config.linkActiveClass) {
				config.activeLinkTags.forEach(function (tag) {
					tag.classList.remove(config.linkActiveClass);
				});
			}
			config.activeLinkTags = [];
			var R,
			    r,
			    matched = processed.matched;
			try {
				var linkTagPush = function linkTagPush(tag) {
					if (tag.getAttribute('lt-prop-route') == matched.target && activeLinkTags.indexOf(tag) == -1) {
						activeLinkTags.push(tag);
					}
				};

				var pushQP = function pushQP(key) {
					r.__ltp.queryParams[key] = R.__lp.qpdef[key].cipher && config.cipher.decryptor ? config.cipher.decryptor(matched.queryParams[key]) : matched.queryParams[key];
				};

				for (var i = 0, l = trans.R.length; i < l; i++) {
					R = trans.R[i];
					r = trans.routes[i];
					if (R.queryParams) {
						R.queryParams.forEach(pushQP);
					}
					r.__ltp.dynamicParam = matched.dynamicParams[i];
					if (i + 1 == l) {
						R.__lp.linkTags.forEach(linkTagPush);
					}
				}
				setActiveClassForLink(transInfo);
			} catch (e) {
				consoleError(e);
			}
			return;
		}

		function setActiveClassForLink(transInfo) {
			if (config.linkActiveClass && config.allLinks[transInfo.route]) {
				config.allLinks[transInfo.route].forEach(function (tag) {
					var tagDp = tag.getAttribute(pDp);
					if (checkIfSameDp(transInfo.dynamicParams, tagDp ? JSON.parse(tagDp) : [])) {
						tag.classList.add(config.linkActiveClass);
						config.activeLinkTags.push(tag);
						var aTag = tag.getElementsByTagName('A')[0];
						if (aTag) {
							aTag.setAttribute("href", LR.getURL(tag.getMatchedObject()));
						}
					}
				});
			}
		}

		function assignMixin(options, fns, dir, lazyload) {
			if (options && options.mixins) {
				if (!Array.isArray(options.mixins)) {
					options.mixins = [options.mixins];
				}
				options.mixins.forEach(function (mixin) {
					if (Lyte.registeredMixins[mixin]) {
						mixin = Lyte.registeredMixins[mixin];
						if (lazyload) {
							var prevTransRouteInstance = LR.getRouteInstance(dir, prevTrans),
							    transRouteInstance = LR.getRouteInstance(dir, trans),
							    newTransInstance = newTrans && LR.getRouteInstance(dir, newTrans);
							if (prevTransRouteInstance || transRouteInstance) {
								prevTransRouteInstance = prevTransRouteInstance || {};
								transRouteInstance = transRouteInstance || {};
								setMixinPropInDefandIns(mixin, fns, prevTransRouteInstance, transRouteInstance, newTransInstance);
							} else {
								setMixinPropInDef(mixin, fns);
							}
						} else {
							setMixinPropInDef(mixin, fns);
						}
					} else if (!lazyload) {
						Lyte.$.requiredMixins(mixin, dir, "router");
					}
				});
			}
		}

		// function setServicePropInDef(dir) {
		// 	var prevTransRouteInstance = LR.getRouteInstance(dir,prevTrans),
		// 	transRouteInstance = LR.getRouteInstance(dir,trans);
		// 	if(prevTransRouteInstance) {
		// 		Lyte.extendService({services : serv, type:"route", name : dir, ins: prevTransRouteInstance});
		// 	}
		// 	if(transRouteInstance) {
		// 		Lyte.extendService({services : serv, type:"route", name : dir, ins: transRouteInstance});	
		// 	}
		// }

		Lyte.$.requiredMixins.router = function (mixin, dir) {
			dir.forEach(function (d) {
				var fns = LR.__lp.getDefinition(d);
				if (mixin && fns) {
					assignMixin(fns.__lp.options, fns, d, true);
				}
			});
		};

		Lyte.$.injectServices.router = function (key, name, type, ins, cIns, data) {
			var obj = {};
			obj.as = key;
			obj.service = name;
			// Lyte.extendService({services : [obj], type:"route", ins: arr});
			includeServices({ services: [obj] }, undefined, undefined, getDefinitionArr(), true, data);
		};

		function includeServices(options, fns, dir, def, isGlobal, data) {
			if (options && options.services) {
				var toBeUsed = [],
				    laterToBeUsed = [];
				options.services.forEach(function (itm) {
					if (typeof itm == "string") {
						toBeUsed.push(itm);
					} else if (itm && (typeof itm === 'undefined' ? 'undefined' : _typeof(itm)) == "object") {
						if (isGlobal || !itm.scope || itm.scope && itm.scope == "static") {
							toBeUsed.push(itm);
						} else {
							laterToBeUsed.push(itm);
						}
					}
				});
			}
			if (toBeUsed && toBeUsed.length) {
				assignService(toBeUsed, fns, dir, def, isGlobal, data);
			}
			if (laterToBeUsed && laterToBeUsed.length) {
				var arr = getFnsAndIns(dir, fns);
				arr.forEach(function (itm) {
					if (itm && itm.__lp) {
						itm.__lp.toBeUsed = laterToBeUsed;
					}
				});
			}
		}

		function assignService(servArr, fns, dir, def, isGlobal, data) {
			var arr = getFnsAndIns(dir, fns);
			Lyte.extendService({ services: servArr || [], type: "route", ins: def || arr, isGlobal: isGlobal, data: data, callback: function callback(serv, key, aName, serName) {
					var obj = {};
					obj.as = key;
					obj.service = serName;
					Lyte.extendService({ services: [obj], type: "route", isGlobal: isGlobal, ins: dir ? getFnsAndIns(dir, fns) : getDefinitionArr() });
				} });
		}

		function getFnsAndIns(dir, fns) {
			var arr = [fns],
			    ins;
			[prevTrans, newTrans, trans].forEach(function (t) {
				if (t && (ins = LR.getRouteInstance(dir, t))) {
					arr.push(ins);
				}
			});
			// var prevTransRouteInstance = LR.getRouteInstance(dir,prevTrans),
			// transRouteInstance = LR.getRouteInstance(dir,trans);
			// if(prevTransRouteInstance) {
			// 	arr.push(prevTransRouteInstance)
			// }
			// if(transRouteInstance) {
			// 	arr.push(transRouteInstance)
			// }
			return arr;
		}

		function getDefinitionArr(def, arr) {
			var parent = !def;
			def = def || config.routes;
			arr = arr || [];
			for (var key in def) {
				if (key == "__lp") {
					if (def.__lp.def) {
						arr.push(def.__lp.def);
					}
				} else {
					getDefinitionArr(def[key], arr);
				}
			}
			if (parent) {
				if (prevTrans && prevTrans != trans) {
					arr = arr.concat(prevTrans.routes);
				}
				if (trans) {
					arr = arr.concat(trans.routes);
				}
				return arr;
			}
		}

		function setMixinPropInDef(mixin, fns) {
			for (var key in mixin) {
				if (key == "actions") {
					fns.actions = Object.assign(fns.actions || {}, mixin.actions);
				} else if (key == "queryParams") {
					fns[key] = Lyte.deepCopyObject(mixin[key]);
				} else {
					fns[key] = mixin[key];
				}
			}
		}

		function setMixinPropInDefandIns(mixin, fns, prev, curr, newTrans) {
			for (var key in mixin) {
				if (key == "actions") {
					if (!fns.actions) {
						curr.actions = prev.actions = fns.actions = {};
					}
					prev.actions = curr.actions = Object.assign(fns.actions, mixin.actions);
					if (newTrans) {
						newTrans.actions = prev.actions;
					}
				} else {
					prev[key] = curr[key] = fns[key] = mixin[key];
					if (newTrans) {
						newTrans[key] = prev[key];
					}
				}
			}
		}

		this.registerRoute = function () {
			if (config.routes) {
				registerRoute.apply({}, arguments);
			} else {
				this.__lp.pendingReg.push(arguments);
			}
		};

		function registerRoute(dir, fns, options) {
			assignMixin(options, fns, dir);
			fns.__lp = {
				options: options,
				objPath: dir.replace(/\//g, '.'),
				stickyLinks: [],
				linkTags: []
			};
			includeServices(options, fns, dir);
			if (Lyte.toBeInjectedServices) {
				var tbServ = Lyte.toBeInjectedServices,
				    arr = [];
				for (var key in tbServ) {
					arr.push({ as: key, service: tbServ[key] });
				}
				includeServices({ services: arr }, fns, dir, undefined, true);
			}

			var sticky = config.queryParamOptions.sticky;
			if (fns.queryParams) {
				fns.__lp.qpdef = {};
				fns.queryParams.forEach(function (qp, i) {
					if (typeof qp == "string") {
						fns.__lp.qpdef[qp] = {
							sticky: sticky,
							refreshModel: true
						};
						if (config.stickyRoutes[dir] == undefined && sticky) {
							config.stickyRoutes[dir] = sticky;
						}
					} else if ((typeof qp === 'undefined' ? 'undefined' : _typeof(qp)) == "object") {
						for (var key in qp) {
							fns.__lp.qpdef[key] = {
								cipher: qp[key].cipher,
								sticky: qp[key].hasOwnProperty('sticky') ? qp[key].sticky : sticky,
								refreshModel: qp[key].hasOwnProperty('refreshModel') ? qp[key].refreshModel : true
							};
							if (!config.stickyRoutes[dir] && fns.__lp.qpdef[key].sticky) {
								config.stickyRoutes[dir] = true;
							}
						}
						fns.queryParams[i] = key;
					}
				});
			}
			dir = dotSerperator(dir);
			fns.routeName = dir[dir.length - 1];
			setRouteDef(dir, fns);
		}

		var transPredefined = ['runLoop', 'running', 'paused', 'R', 'routes', abortedStr, 'prom', 'run', pendingStr, 'matched', 'fns'];

		function limitTransition(int) {
			var _trans = new transition(int);
			int.state = _trans.state = 201;
			return _trans;
		}

		function dummy() {
			/*
   Dont delete this function.
   This one is to avoid function to be merged during minification.
   */
			var _trans = new transition(int);
		}

		function transition(int) {
			for (var prop in int) {
				if (transPredefined.indexOf(prop) == -1) {
					if (prop == 'info') {
						this.info = Lyte.deepCopyObject(int[prop]);
					} else {
						this[prop] = int[prop];
					}
				}
			}
		}

		function dynamicRouteCheck(route) {
			return _presence(route, ":");
		}

		function wildcardRouteCheck(route) {
			return _presence(route, "*");
		}

		function _compareObj(obj1, obj2) {
			var obj1keys = Object.keys(obj1),
			    obj2keys = Object.keys(obj2);
			if (obj1keys.length != obj2keys.length) {
				return false;
			} else {
				for (var key in obj1) {
					if (obj1[key] != obj2[key]) {
						return false;
					}
				}
				return true;
			}
		}

		this.getRouteInstance = function (routeName, t) {
			var newTrans;
			if (LR && !LR.init && (newTrans = t || LR.__lp && LR.__lp.trans || trans) && newTrans.routes) {
				var routeLen = newTrans.routes.length;
				if (!routeName) {
					return newTrans.routes[routeLen - 1];
				} else if (routeName == "*") {
					return newTrans.routes;
				} else {
					var reqRouteLen = routeName.split('.').length - 1,
					    reqRoute = newTrans.routes[reqRouteLen];
					return reqRoute && reqRoute.__lp.objPath == routeName ? reqRoute : undefined;
				}
			}
		};

		function normalizeTransitionParams(obj) {
			// To normalize argument for transition, returns matched obj from obj or native tranisitionTo argument.
			var params;
			if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == "object") {
				params = obj;
			} else {
				params = {
					queryParams: {},
					dynamicParams: []
				};
				Array.from(arguments).forEach(function (arg, index) {
					if (Array.isArray(arg)) {
						consoleError(498, JSON.stringify(arg));
						return;
					} else {
						if (index == 0) {
							params.route = arg;
						} else if (arg && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) == "object") {
							params.queryParams = Lyte.deepCopyObject(arg);
						} else {
							params.dynamicParams.push(arg);
						}
					}
				});
			}
			return params;
		}

		function normalizeMatchedObj(obj) {
			// To construct dynamic params array.
			if (obj.route) {
				var routesObj = config.routes,
				    matched,
				    def,
				    R = [],
				    errorCheck = function errorCheck(route, i) {
					routesObj = _getObj(route, routesObj);
					if (!routesObj) {
						throw Error(getError(400, matched.target));
					}
					if (!(def = routesObj.__lp.def)) {
						throw Error(getError(422, matched.route, i));
					}
					R.push(def);
				};
				if (obj._routes) {
					matched = obj;
				} else {
					var matched = {
						route: Array.isArray(obj.route) ? obj.route : dotSerperator(obj.route),
						queryParams: obj.queryParams || {},
						dynamicParams: [],
						fragment: obj.fragment,
						target: "",
						refreshRoute: obj.refreshRoute,
						startFrom: obj.startFrom,
						_routes: []
					};
					if (obj.dynamicParams) {
						if (obj.dpProcessed) {
							matched.dynamicParams = Array.from(obj.dynamicParams);
						} else {
							var dynamicParams = Array.from(obj.dynamicParams);
						}
					}
				}
				try {
					matched.route.forEach(obj._routes ? errorCheck : function (route, i) {
						matched.target = matched.target ? matched.target + '.' + route : route;
						matched._routes.push(dotSerperator(matched.target));
						errorCheck(route, i);
						if (dynamicParams) {
							matched.dynamicParams.push(routesObj.__lp.dkey ? dynamicParams.shift() : undefined);
						}
					});
					if (dynamicParams && dynamicParams.length) {
						Lyte.error('Extra dynamic params found. Provide exact numbers dynamic params required for the transition ' + JSON.stringify(dynamicParams));
					}
				} catch (e) {
					consoleError(e);
					return false;
				}
				return {
					matched: matched,
					R: R
				};
			} else {
				if (this.tagName == LINKTOStr) {
					consoleError(498, pRoute, this.outerHTML);
				} else {
					consoleError(499);
				}
			}
		}

		function initRoute(processed) {
			var routeObj,
			    matched = processed.matched,
			    routes = [],
			    refMatch = processed.prevTrans,
			    similarRoute = true;

			for (var i = 0, route; route = matched.route[i]; i++) {
				routeObj = LR.__lp.getDefinition(newTrans.matched._routes[i]);
				if (!routeObj) {
					return false;
				}
				if (refMatch && similarRoute && refMatch.matched && refMatch.matched.route[i] == route) {
					routes.push(new Route(routes, routeObj, i, processed, refMatch.routes[i]));
				} else {
					routes[i] = new Route(routes, routeObj, i, processed);
					similarRoute = false;
				}
			}
			refMatch = undefined;
			return routes;
		}

		var routePredefined = [getDependenciesStr, getResourcesStr, beforeModelStr, modelStr, afterModelStr, redirectStr, renderTemplateStr, afterRenderStr, beforeExitStr],
		    Route = function Route(routes, fns, index, processed, prevInstance) {
			var self = this;
			var src = prevInstance || fns;
			for (var key in src) {
				if (prevInstance || !_presence(routePredefined, key)) {
					if (key == "__lp") {
						this.__lp = Lyte.deepCopyObject(src.__lp);
					} else {
						this[key] = src[key];
					}
				}
			}
			if (processed.transComp && !processed.transComp.rendered[index] && processed.transComp.redirected && processed.transComp.redirected.index < index) {
				delete this.__lp.loadDependencies;
				delete this.__lp.loadResources;
				this.$ = {};
				delete this.currentModel;
			}
			this.__ltp = {
				queryParams: {}
			};
			if (this.__lp && this.__lp.toBeUsed && this.__lp.toBeUsed.length) {
				var self = this;
				Lyte.extendService({ services: this.__lp.toBeUsed || [], type: "route", ins: this, callback: function callback(serv, key, aName, serName) {
						var obj = {};
						obj.key = key;
						obj.service = serName;
						Lyte.extendService({ services: [obj], type: "route", ins: self });
					} });
			}
			this.transition = newTrans._trans;
			this.parent = routes[index - 1];
			if (!prevInstance) {
				this.$ = {};
				if (this.init) {
					this.init();
				}
				this.throwEvent = typeof Lyte.Component !== "undefined" && Lyte.Component.throwEvent;
			}
			this.replaceWith = LR.replaceWith;
			this.transitionTo = LR.transitionTo;
			this.removeFromCache = function (arr) {
				Lyte.removeFromCache.assign(arr);
			};
			this.refresh = function (obj) {
				var refreshFrom = dotSerperator(this.__lp.objPath).length - 1,
				    route = Array.from(trans.matched.route),
				    processed = {
					matched: trans.matched,
					R: trans.R,
					transComp: {
						unRendered: route.splice(refreshFrom),
						rendered: route
					}
				};
				trans.abort({ state: 308, iAbort: true });
				newTransInfo = { replace: true, data: trans.data, fromHistory: false, url: trans.url };
				dispatch(trans.url, processed);
				if (obj && obj.refreshTemplate) {
					for (var i = refreshFrom, r; r = newTrans.routes[i]; i++) {
						delete r.component;
					}
				}
				return newTrans._trans;
			};
			this.setTitle = function (title) {
				d.title = this.title = title;
			};
			this.getQueryParams = function () {
				return this.__ltp.queryParams || {};
			};
			this.getDynamicParam = function () {
				return this.__ltp.dynamicParam;
			};
			Object.defineProperty(self, '$lg', {
				value: Lyte.__gl
			});
			this.getRouteInstance = function (routeName) {
				return LR.getRouteInstance(routeName);
			};
			this.setDynamicParam = function (value) {
				if (value && this.__ltp.dynamicParam && this.__ltp.dynamicParam != value) {
					var dynamicParams = Array.from(trans.matched.dynamicParams);
					dynamicParams.splice(this.__lp.objPath.split(".").length - 1, 1, value);
					return paramChangeTrans(cloneMatchedObj(trans.matched, { dynamicParams: dynamicParams }));
				}
				return trans._trans;
			};
			function paramChangeTrans(matched) {
				var url = constructURLFromRoute(matched),
				    processed = {
					matched: matched,
					R: trans.R
				};
				newTransInfo = {
					data: trans.data,
					url: url,
					fromHistory: false
				};
				dispatch(url, decideTransition(processed));
				return newTrans._trans;
			}
			this.setQueryParams = function (key, value, options) {
				var obj = {},
				    refresh;
				if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) == "object") {
					obj = key;
					options = value;
				} else {
					obj[key] = value;
				}
				if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) == "object") {
					refresh = options.refresh;
				}
				refresh = options;
				var matched = cloneMatchedObj(trans.matched, { queryParams: Object.assign({}, trans.matched.queryParams, obj) });
				if (!_compareObj(trans.matched.queryParams, matched.queryParams)) {
					matched.refreshModel = matched.refreshModel == undefined ? refresh : matched.refreshModel;
					return paramChangeTrans(matched);
				}
				return trans._trans;
			};
		};

		function cloneMatchedObj(matched, data) {
			var obj = Object.assign({}, matched);
			obj.route = data.route || Array.from(matched.route);
			obj.dynamicParams = data.dynamicParams || Array.from(matched.dynamicParams);
			obj.queryParams = data.queryParams || Object.assign(matched.queryParams);
			return obj;
		}

		function dispatchTransition(processed) {
			// processed = setParamsInDef(newMatch);
			var url = constructURLFromRoute(processed.matched);
			if (url) {
				processed.path = newTransInfo.url = url;
				dispatch(url, decideTransition(processed));
			}
			return url;
		}

		var allHooks = [getDependenciesStr, getResourcesStr, beforeModelStr, modelStr, afterModelStr, redirectStr, renderTemplateStr, afterRenderStr];
		function decideTransition(processed) {
			/* determines which transition to consider as previous transition */
			if (trans) {
				if (trans.running) {
					var matched = processed.matched;
					if (trans.state == 102 && trans.prom && trans.prom.hook == redirectStr) {
						var transComp = getTransitionDiffernce(trans, matched, processed.R),
						    transitioningRoute = allHooks.indexOf(trans.prom.hook) <= 5 ? trans.prom.index : trans.prom.index + 1,
						    visibleTransComparison = getTransitionDiffernce(visibleTrans, matched, processed.R);
						if (transComp.common.length < visibleTransComparison.common.length) {
							if (transComp.rendered.length < visibleTransComparison.rendered.length) {
								processed.prevTrans = visibleTrans;
								if (trans.runLoop.templateToRemove.length) {
									trans.runLoop.templateToRemove.pop();
								}
							}
							transComp = visibleTransComparison;
							if (trans.prom.index <= visibleTransComparison.common.length - 1) {
								transComp.redirected = trans.prom;
							}
						} else if (transComp.common.length - 1 >= transitioningRoute) {
							if (trans.prom.index <= transComp.common.length - 1) {
								processed.prevTrans = trans;
								transComp.redirected = trans.prom;
							}
						}
					}
					var info = {
						route: matched.target,
						queryParams: matched.queryParams,
						dynamicParams: matched.dynamicParams.filter(_arrayClean)
					};
					if (LR.checkIfSameRoute(trans.info, info) && !trans.aborted) {
						trans.pause({ iPause: true });
					} else {
						trans.abort({ state: 409, iAbort: true });
					}
					processed.transComp = transComp;
				} else if (trans && !trans.aborted) {
					trans.abort({ state: 409, iAbort: true });
				}
			}
			return processed;
		}

		// function getRequirements(object) {
		// 	/* download files that are returned from getResources and getDependencies */
		// 	var every = function() {};
		// 	every.internal = {};
		// 	var reqType = object.reqType,
		// 	r = object.r,
		// 	index = object.index,
		// 	hook = every.internal.hook = trans.prom.hook,
		// 	errorType = reqType == dependenciesStr ? "errorDependencies" : "errorResources",
		// 	self = this;
		// 	every.internal.route = r.__lp.objPath;
		// 	Lyte.injectResources(
		// 	r.__lp[reqType],
		// 	every,
		// 	function(successFiles,errorFiles) {
		// 		/* completed callback */
		// 		r.__lp[reqType+'Loaded'] = true;
		// 		if(!errorFiles.length) {
		// 			var pending;
		// 			if(trans.pending && (pending = trans.pending[reqType]) != undefined && pending == index) {
		// 				delete trans.pending[reqType];
		// 				if((pending = trans.pending.forceFetch) != undefined && pending == index && trans.forceFetchRunning) {
		// 					delete trans.pending.forceFetch;
		// 					nestedForcedPromises.call(trans, trans.runLoop.forceFetch , trans.fRunningProm.resolve ,trans.runLoop.forceFetch[index][0]);
		// 				}
		// 				nestedPromises.call(trans,trans.runLoop,"current",trans.runningProm.resolve);
		// 			}
		// 		} else {
		// 			if(!self.aborted) {
		// 				if(!self.paused) {
		// 					self.pause({iPause : true});  
		// 				}
		// 				run[onErrorStr].call(self,hook,index, (r.__lp[errorType] = errorFiles), 424);  
		// 		}
		// 		}         
		// 	}
		// 	);
		// }

		// function nestedPromises(loop,state,resolve) {
		// 	if(validateTransition(this)) {
		// 	var runLoop = loop[state];
		// 	if(runLoop && runLoop.length) {
		// 		var promise = runLoop[0],
		// 		r = this.R[promise.index],
		// 		routeInstance = this.routes[promise.index];
		// 		if(promise.hook == beforeModelStr && !requirements.get(r,dependenciesStr)) {
		// 		this.pending[dependenciesStr] = promise.index;
		// 		return;
		// 		} else if(promise.hook == renderTemplateStr && !requirements.get(r,resourcesStr)) {
		// 		this.pending[resourcesStr] = promise.index;
		// 		return;
		// 		} else if(promise.hook == redirectStr && r.forceFetch && routeInstance.__lp.fetchStatus == pendingStr) {
		// 		if(!this.forceFetchRunning) {
		// 			this.forceFetchRunning = true;
		// 			runLoopPromise.call(this,nestedForcedPromises,"nestedForcedPromises");
		// 		}
		// 		this.pending.forceFetch = promise.index;
		// 		return;
		// 		} else {
		// 		promise.state = state;
		// 		trans.prom = promise;
		// 		logCallbacks(promise);
		// 		t(promise.hook+promise.index);
		// 		run[promise.hook].call(this,promise.hook,promise.index).then(function(data) {
		// 			setPendingResume.call(trans,trans.prom);
		// 			t(promise.hook+promise.index);
		// 			// if(promise.hook == modelStr) {
		// 			// 	routeInstance.currentModel = data;
		// 			// }
		// 			if(this.runningProm.resolve == resolve) {
		// 			removeHook(loop[state],promise.hook,promise.index);
		// 			nestedPromises.call(this,loop,state,resolve);  
		// 			}
		// 		}.bind(this));
		// 		}
		// 	} else if(resolve) {
		// 		resolve();
		// 	}
		// 	} else if(this.paused && this.runningProm) {
		// 	this.runningProm.reject(abortedStr);  
		// 	}
		// }

		// function nestedForcedPromises(forcedLoop, resolve, promise) {
		// 	if (validateTransition(this) && forcedLoop) {
		// 		if(!promise) {
		// 			for(var key in forcedLoop) {
		// 			var routeLoop = forcedLoop[key],
		// 			p = routeLoop[0];
		// 			if(p) {
		// 				if(requirements.get(this.R[p.index],dependenciesStr)) {
		// 				if(!routeLoop[0].running) {
		// 					nestedForcedPromises.call(this, forcedLoop, resolve,routeLoop[0]);    
		// 				}
		// 				} else {
		// 				this.pending[dependenciesStr] = p.index;
		// 				} 
		// 			}
		// 			}
		// 			return;
		// 		}
		// 		var r = this.R[promise.index],
		// 		routeInstance = this.routes[promise.index];
		// 		promise.state = "forceFetch";
		// 		trans.prom = promise;
		// 		if (promise.hook == beforeModelStr && !requirements.get(routeInstance, dependenciesStr)) {
		// 			this.pending[dependenciesStr] = promise.index;
		// 			return;
		// 		}
		// 		logCallbacks(promise);
		// 		forcedLoop[promise.index][0].running = true;
		// 		forcedLoop[promise.index].splice(0, 1);
		// 		run[promise.hook].call(this, promise.hook, promise.index).then(function (data) {
		// 			setPendingResume.call(trans, trans.prom);
		// 			if(promise.hook == afterModelStr) {
		// 				routeInstance.__lp.fetchStatus = completedStr;
		// 				if (this.pending.forceFetch != undefined && this.pending.forceFetch == promise.index) {
		// 				delete this.pending.forceFetch;
		// 				nestedPromises.call(this,this.runLoop,"current",this.runningProm.resolve);
		// 				}
		// 			} else if(promise.hook == modelStr) {
		// 				routeInstance.currentModel = data;
		// 				if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == afterModelStr) {
		// 					nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
		// 				}
		// 			} else {
		// 				if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == modelStr) {
		// 					nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
		// 				}
		// 			}
		// 		}.bind(this));
		// 	} else {
		// 	this.forceFetchRunning = false;
		// 	}
		// }

		return this;
	}
	Lyte.Router = new Router();
})(window);