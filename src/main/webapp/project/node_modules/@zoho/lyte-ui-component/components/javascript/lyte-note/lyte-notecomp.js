/**
 * This component is used to create note view
 * @component lyte-notecomp
 * @version 4.0.0
 * @dependency lyte-popover
 * 	components/lyte-popover.js
 * 	components/lyte-wormhole.js
 *  theme/compiledCSS/default/ltr/lyte-ui-popover.css
 * @dependency lyte-button
 * 	components/lyte-button.js
 *  theme/compiledCSS/default/ltr/lyte-ui-button.css
 * @dependency lyte-checkbox
 * 	components/lyte-checkbox.js
 *  theme/compiledCSS/default/ltr/lyte-ui-checkbox.css
 * @dependency lyte-menu
 * 	components/lyte-menu.js
 *  theme/compiledCSS/default/ltr/lyte-ui-menu.css
 * @dependency lyte-colorpicker
 * 	components/lyte-colorpicker.js
 *  theme/compiledCSS/default/ltr/lyte-ui-colorpicker.css
 * @dependency lyte-colorbox
 * 	components/lyte-colorbox.js
 *  theme/compiledCSS/default/ltr/lyte-ui-colorbox.css
 * @dependency lyte-fileupload
 * 	components/lyte-fileupload.js
 *  theme/compiledCSS/default/ltr/lyte-ui-fileupload.css
 * @dependency lyte-messagebox
 * 	components/lyte-messagebox.js
 *  theme/compiledCSS/default/ltr/lyte-ui-messagebox.css
 * @dependency lyte-voicenote
 * 	components/lyte-voicenote.js
 *  theme/compiledCSS/default/ltr/lyte-ui-voicenote.css
 * @dependency lyte-emoji
 * 	components/lyte-emoji.js
 *  theme/compiledCSS/default/ltr/lyte-ui-emoji.css
 * @dependency lyte-comment
 * 	components/lyte-note/lyte-comment.js
 * @dependency lyte-note-editor
 * 	components/lyte-note/lyte-note-editor.js
 * @methods onTimeConstruction, onCommentUnpin, onViewReaction,onCommentDelete,onCommentPin, onCommentEdit, onEmojiSelect, onTrigger, onCommentCancel, onMainCommentCancel, onMainCommentSave, onButtonClick, onBeforeSend, onSuccess, onFailure, onError, onBeforeRemove, onEditorPaste
 * @utility removeAllFiles, getBackground, setBackground, viewReactions 
 */

Lyte.Component.register( 'lyte-notecomp', {
	
	init : function(){

		this.__word_cache = {};

		var __id = this.$node.id || ( "lyteNote_" +  Date.now() );
		this.data.id = ( this.$node.id = __id );
	},

	data: function() {
			return {

				// comment

				/**
				 * @componentProperty {array} ltPropComments
				 * @default []
				 * @version 4.0.0
				 */

				ltPropComments : Lyte.attr( 'array', { default : [] } ),
				/**
				 * @componentProperty {boolean} ltPropEditMode=false
				 * @version 4.0.0
				 */				
				ltPropEditMode : Lyte.attr( 'boolean', { default : false } ),
				/**
				 * @componentProperty {object} ltPropPopover
				 * @default { "freeze" : false , "wrapperClass" : "lyteNoteEmojiPopover","type" : "box", "showCloseButton" : false}
				 * @component lyte-popover
				 * @version 4.0.0
				 */		
				ltPropPopover : Lyte.attr( 'object', { default : { 
					freeze : false ,
					wrapperClass : 'lyteNoteEmojiPopover',
					type : 'box',
					showCloseButton : false,
					focusOnClose : true
				} } ),
				/**
				 * @componentProperty {object} ltPropColorPicker
				 * @default {"freeze":false,"wrapperClass":"lyteNoteBgSwitchPopover","type":"box","showCloseButton":false,"noFillButton":true}
				 * @component lyte-colorpicker
				 * @version 4.0.0
				 */					
				ltPropColorPicker : Lyte.attr( 'object', { default : { 
					freeze : false ,
					wrapperClass : 'lyteNoteBgSwitchPopover',
					type : 'box',
					showCloseButton : false,
					noFillButton : true
				} } ),
				/**
				 * @componentProperty {string} ltPropButtons='[{"text":"Cancel","method":"cancel","properties":{"size":"small"}},{"text":"Save","method":"save","properties":{"appearance":"primary","size":"small"}}]'
				 * @version 4.0.0
				 */					

				ltPropButtons : Lyte.attr( 'string', { default : '[{"text":"' + _lyteUiUtils.i18n( 'note', 'cancel', 'Cancel' ) + '","method":"cancel","properties":{"size":"small"}},{"text":"' + _lyteUiUtils.i18n( 'note', 'save', 'Save' ) + '","method":"save","properties":{"appearance":"primary","size":"small"}}]', hideAttr : true } ),
				/**
				 * @componentProperty {object} ltPropTooltipConfig
				 * @default { "position" : "bottom" }
				 * @component lyte-tooltip ltPropTooltipConfig
				 * @version 4.0.0
				 */	

				ltPropTooltipConfig : Lyte.attr( 'object', { default : { position : "bottom" } } ),
				/**
				 * @componentProperty {string} ltPropAvatar=''
				 * @version 4.0.0
				 */	

				ltPropAvatar : Lyte.attr( 'string', { default : '' } ),
				/**
				 * @componentProperty {object} ltPropTextEditor
				 * @default  { "wordStyle": { "whiteSpace":"break-spaces" }, "placeholder":"Add a note ...", "checkbox":{"prevent":true} }
				 * @version 4.0.0
				 */	
				ltPropTextEditor : Lyte.attr( 'object', { default : { wordStyle : {
						whiteSpace: "break-spaces"
					},
					placeholder : _lyteUiUtils.i18n( 'note', 'add.note', 'Add a note ' ) + "...",
					checkbox : {
						prevent : true
					}
				} } ),
				/**
				 * @componentProperty {object} ltPropEditorPanel
				 * @default { "tooltipConfig":{"position":"bottom"},"moreIcon":false,"icons":[{"class":"formatting","subIcons":[{"type":"switch","name":"bold","display":"","functionName":"toggleWordClass","arguments":["fontWeight","bold"],"title":"bold","active":false},{"type":"switch","name":"italic","display":"","functionName":"toggleWordClass","arguments":["fontStyle","italic"],"title":"italic","active":false},{"type":"switch","name":"underline","display":"","functionName":"toggleWordClass","arguments":["textDecoration","underline"],"title":"underline","active":false},{"type":"switch","name":"strike","display":"","functionName":"toggleWordClass","arguments":["textDecoration","line-through"],"title":"strike","active":false}]},{"class":"formatting","subIcons":[{"type":"switch","name":"ul","display":"","functionName":"list","selected":"","arguments":["{{selected}}"],"title":"ul","active":false},{"type":"switch","name":"decimal","display":"","functionName":"ordered","selected":"","arguments":["3"],"title":"ol","active":false},{"type":"anchor","name":"anchor","display":"","functionName":"toggleWordClass","arguments":["lyteEditorAnchor"],"title":"anchor","active":false}]},{"class":"colorpicker","subIcons":[{"type":"colorpicker","name":"color","display":"","selected":"black","functionName":"toggleWordClass","arguments":["color","{{selected}}"],"title":"color","active":false},{"type":"colorpicker","name":"bg","display":"","selected":"white","functionName":"toggleWordClass","arguments":["backgroundColor","{{selected}}"],"title":"background","active":false}]},{"class":"clearformatting","subIcons":[{"type":"switch","name":"clear","display":"","functionName":"clearFormat","title":"clear format","arguments":[""],"action":false}]}]}
				 * @version 4.0.0
				 */					

				ltPropEditorPanel : Lyte.attr( 'object', { default : {
					tooltipConfig : {
						position : "bottom"
					},
					moreIcon : false,
					icons : [
								{
									class : "lyteUIEditorPanelTextFormat",
									subIcons : [
										{
											type : "switch",
											name : "bold",
											display : '',
											functionName : "toggleWordClass",
											arguments : [ 'fontWeight', 'bold' ],
											title : _lyteUiUtils.i18n( "bold", "note", "bold" ),
											active : false
										},
										{
											type : "switch",
											name : "italic",
											display : '',
											functionName : "toggleWordClass",
											arguments : [ 'fontStyle', 'italic' ],
											title : _lyteUiUtils.i18n( "italic", "note", "italic" ),
											active : false
										},
										{
											type : "switch",
											name : "underline",
											display : '',
											functionName : "toggleWordClass",
											arguments : [ 'textDecoration', 'underline' ],
											title : _lyteUiUtils.i18n( "underline", "note", "underline" ),
											active : false
										},
										{
											type : "switch",
											name : "strike",
											display : '',
											functionName : "toggleWordClass",
											arguments : [ 'textDecoration', 'line-through' ],
											title : _lyteUiUtils.i18n( "strike", "note", "strike" ),
											active : false
										}
									]
								},
								{
									class : "lyteUIEditorPanelList",
									subIcons : [
										{
											type : "switch",
											name : "ul",
											display : "",
											functionName : "list",
											selected : "",
											arguments : [ '{{selected}}' ],
											title : _lyteUiUtils.i18n( "ul", "note", "ul" ),
											active : false
										},
										{
											type : "switch",
											name : "decimal",
											display : "",
											functionName : "ordered",
											selected : "",
											arguments : [ '3' ],
											title : _lyteUiUtils.i18n( "ol", "note", "ol" ),
											active : false
										},
										{
											type : "anchor",
											name : "anchor",
											display : "",
											functionName : "toggleWordClass",
											arguments : [ 'lyteEditorAnchor' ],
											title : _lyteUiUtils.i18n( "anchor", "note", "anchor" ),
											active : false
										}
									]
								},
								{
									class : 'lyteUIEditorPanelColorpicker',
									subIcons : [
										{
											type : "colorpicker",
											name : "color",
											display : "",
											selected : "black",
											functionName : "toggleWordClass",
											arguments : [ 'color', '{{selected}}' ],
											title : _lyteUiUtils.i18n( "color", "note", "color" ),
											active : false
										},
										{
											type : "colorpicker",
											name : "bg",
											display : "",
											selected : "white",
											functionName : "toggleWordClass",
											arguments : [ 'backgroundColor', '{{selected}}' ],
											title : _lyteUiUtils.i18n( "background", "note", "background" ),
											active : false
										}
									]
								},
								{
									class : 'lyteUIEditorClearformatting',
									subIcons : [
										{
											type : "switch",
											name : "clear",
											functionName : "clearFormat",
											display : "",
											title : _lyteUiUtils.i18n( "clear.format", "note", "clear format" ),
											arguments : [
												""
											],
											active : true,
											prevent_true : true,
											disabled : false,
											action : false
										}
									]
								}				
							]
				} } ),
				/**
				 * @componentProperty {Object[]} ltPropColors
				 * @default [{"background":"#DDF2D9","border":"1px solid #A9E198"},{"background":"#CEF7F8","border":"1px solid #97E4E3"},{"background":"#F8DDCE","border":"1px solid #F5B388"},{"background":"#F5E5FA","border":"1px solid #E3B2EE"},{"background":"#F8DCEA","border":"1px solid #F39BBF"},{"background":"#fff","border":""}]
				 * @version 4.0.0
				 */	
				ltPropColors : Lyte.attr( 'array', { default : [
					{
					      background: '#DDF2D9',
					      border: '1px solid #A9E198'
					},
					{
					      background: '#CEF7F8',
					      border: '1px solid #97E4E3'
					},
					{
					      background: '#F8DDCE',
					      border: '1px solid #F5B388'
					},
					{
					      background: '#F5E5FA',
					      border: '1px solid #E3B2EE'
					},
					{
					      background: '#F8DCEA',
					      border: '1px solid #F39BBF'
					},
					{
					      background: '#fff',
					      border: ''
					}
				] } ),
				/**
				 * @componentProperty {object} ltPropFileUpload
				 * @default {"filesCount":5,"totalFilesSize":"20MB","thumb":true,"appearance":"Btn","ajax":{"url":"/imageupload"}}
				 * @component lyte-fileupload
				 * @version 4.0.0
				 */					

				ltPropFileUpload : Lyte.attr( 'object', { default : { filesCount : 5, totalFilesSize : '20MB', thumb : true, appearance : "Btn", ajax : { url : "/imageupload" } } } ),
				/**
				 * @componentProperty {string} ltPropEditorAnimation='slide'
				 * @version 4.0.0
				 */	

				ltPropEditorAnimation : Lyte.attr( 'string', { default : 'slide' } ),
				/**
				 * @componentProperty {object} ltPropEmojiProps
				 * @default {}
				 * @component lyte-emoji
				 * @version 4.0.0
				 */
				ltPropEmojiProps : Lyte.attr( 'object', { default : {} } ),
				/**
				 * @componentProperty {string} ltPropUploadInfoMessage
				 * @version 4.0.0
				 */
				ltPropUploadInfoMessage : Lyte.attr( "string" ),
				/**
				 * @componentProperty {string} ltPropEmptyInfoMessage
				 * @version 4.0.0
				 */
				ltPropEmptyInfoMessage : Lyte.attr( "string" ),

				/**
				 * @typedef textObj
				 * @property {string} fileUpload=File upload
				 * @property {string} storage=Storage
				 * @property {string} limit=Limit 5 files
				 * @property {string} smileyIcon=smileys
				 * @property {string} attachFiles=Attach files
				 * @property {string} noteBackground=Note background
				 * @property {string} more=More
				 * @property {string} failureMessage=Attachment failed
				 * @property {string} retryText=Retry
				 * @property {string} noPreviewMessage=Sorry, No preview is available for this format
				 * @property {string} thumbnailIndex={{index}} of {{total}}
				 * @property {string} noResult=No results found
				 * @property {string} all=All
				 * @property {string} editAlertHeader=Discard the changes in the current note?
				 * @property {string} editAlertMessage=You will lose any unsaved changes in your note
				 * @property {string} keepEditing=Cancel
				 * @property {string} continue=Discard
				 * @property {string} delete=Delete
				 * @property {string} pin=Pin
				 * @property {string} unpin=Unpin
				 * @property {string} edit=Edit
				 * @property {string} viewReactions=View reactions
				 * @property {string} pinnedBy=Pinned by <span class = \"lyteNotePinnedBy\">{{0}}</span>
				 */

				/**
				 * @componentProperty {textObj} ltPropText
				 * @version 4.0.0
				 */

				ltPropText : Lyte.attr( "object", { default : {
					fileUpload : _lyteUiUtils.i18n( "upload.file", "note", "File upload" ),
					storage : _lyteUiUtils.i18n( "storage", "note", "Storage" ),
					limit : _lyteUiUtils.i18n( "limit.files", "note", "( Limit {{0}} files )" ).replace( '{{0}}', 5 ),
					smileyIcon : _lyteUiUtils.i18n( "smileys", "note", "smileys" ),
					attachFiles : _lyteUiUtils.i18n( "attach.files", "notes", "Attach files" ),
					noteBackground : _lyteUiUtils.i18n( "note.background", "notes", "Note background" ),
					more : _lyteUiUtils.i18n( "more", "note", "More" ),
					failureMessage : _lyteUiUtils.i18n( 'Attachment failed', 'fileupload', "Attachment failed" ), 
					retryText : _lyteUiUtils.i18n( 'retry', "fileupload", "Retry" ),
					noPreviewMessage : _lyteUiUtils.i18n( "no.preview", "note", "Sorry, No preview is available for this format" ),
					thumbnailIndex : _lyteUiUtils.i18n( "of", "note", "{{index}} of {{total}}" ),
					noResult : _lyteUiUtils.i18n( "no.results.found", void 0, "No results found" ),
					all : _lyteUiUtils.i18n( "all", "note", "All" ),
					editAlertHeader : _lyteUiUtils.i18n( 'discard.header', "note", "Discard the changes in current note?" ),
					editAlertMessage : _lyteUiUtils.i18n( "discard.message", "note", "You will lose any unsaved changes in your note" ),
					keepEditing : _lyteUiUtils.i18n( "cancel", "note", "Cancel" ),
					continue : _lyteUiUtils.i18n( "discard", "note", "Discard" ),
					delete : _lyteUiUtils.i18n( "delete", "note", "Delete" ),
					pin : _lyteUiUtils.i18n( "pin", "note", "Pin" ),
					unpin : _lyteUiUtils.i18n( "unpin", "note", "Unpin" ),
					edit : _lyteUiUtils.i18n( "edit", "note", "Edit" ),
					viewReactions : _lyteUiUtils.i18n( "view.reaction", "note", "View reactions" ),
					pinnedBy : _lyteUiUtils.i18n( "pinned.by", "note", "Pinned by <span class = \"lyteNotePinnedBy\">{{0}}</span>" )
				} } ),
				/**
				 * @componentProperty {number} ltPropScrollDuration=400
				 * @version 4.0.0
				 */				

				ltPropScrollDuration : Lyte.attr( 'number', { default : 400 } ),
				/**
				 * @componentProperty {string} ltPropReaction='{}'
				 * @version 4.0.0
				 */	
				ltPropReaction : Lyte.attr( 'string', { default : '{}' } ),
				/**
				 * @componentProperty {boolean} ltPropEditAlert=true
				 * @version 4.0.0
				 */
				ltPropEditAlert : Lyte.attr( 'boolean', { default : true } ),
				/**
				 * @componentProperty {string} ltPropUserId
				 * @version 4.0.0
				 */
				ltPropUserId : Lyte.attr( 'string' ),
				/**
				 * @componentProperty {number} ltPropMaxTooltipNames=6
				 * @version 4.0.0
				 */
				ltPropMaxTooltipNames : Lyte.attr( 'number', { default : 6 } ),
				/**
				 * @componentProperty {array} ltPropPinnedComments
				 * @default []
				 * @version 4.0.0
				 */
				ltPropPinnedComments : Lyte.attr( 'array', { default : [] } ),
				/**
				 * @componentProperty {boolean} ltPropAddNewComment=true
				 * @version 4.0.0
				 */
				ltPropAddNewComment : Lyte.attr( 'boolean', { default : true } ),
				/**
				 * @componentProperty {boolean} ltPropReplyYield=false
				 * @version 4.0.0
				 */
				ltPropReplyYield : Lyte.attr( 'boolean', { default : false } ),
				/**
				 * @typedef editorProps
				 * @property {boolean} background=true
				 * @property {boolean} attachment=true
				 * @property {boolean} emoji=true
				 * @property {boolean} editorpanel=true
				 */

				/**
				 * @componentProperty {editorProps} ltPropEditorProps
				 * @version 4.0.0
				 */
				ltPropEditorProps : Lyte.attr( 'object', { default : {
				        background : true,
				        attachment : true,
				        emoji : true,
				        editorpanel : true
				    } 
				}),
				/**
				 * @componentProperty {boolean} ltPropTitleYield=false
				 * @version 4.0.0
				 */				

				ltPropTitleYield : Lyte.attr( 'boolean', { default : false } ),
				ltPropAlert : Lyte.attr( 'string' , { default : "" } ),

				ltPropCommentsCommonHeaderYield : Lyte.attr( "boolean", { default : false } ),
				ltPropCommentsCommonFooterYield : Lyte.attr( "boolean", { default : false } ),
				ltPropOptionsMenuProperties : Lyte.attr( "object", { default : undefined } ),

				ltPropMessageBoxProps : Lyte.attr("string", { default : '{"type":"info"}' }),
				ltPropYield : Lyte.attr( 'boolean', { default : false } ),
				ltPropCurrentComment : Lyte.attr( 'string', { default : '' } ),
				ltPropShowReactionView : Lyte.attr( 'boolean', { default : false } ),
				ltPropKeywords : Lyte.attr( "object", { default : {} } ),
	
				ltPropDateFormats : Lyte.attr( "array", { default : [] } ),
				ltPropHandlePastedImage : Lyte.attr( 'boolean', { default : false } ),
				ltPropTabindex : Lyte.attr( 'number', { default : 0 } ),
				// system

				pastedFileName : Lyte.attr( 'string', { default : 'attachment.jpg' } ),
				popoverShow : Lyte.attr( 'boolean', { default : false } ),

				bgSwitch : Lyte.attr( 'boolean', { default : false } ),

				messageShow : Lyte.attr( "boolean", { default : false } ),

				message : Lyte.attr( "string", { default : "" } ),

				fileDate : Lyte.attr( 'string' ),

				fileTime : Lyte.attr( 'string' ),

				fileSize : Lyte.attr( 'string' ),

				isImage : Lyte.attr( 'boolean' ),

				isNoPreview : Lyte.attr( 'boolean' ),

				previewType : Lyte.attr( 'string' ),

				thumbnails : Lyte.attr( 'array', { default : [] } ),

				thumbnailValue : Lyte.attr( 'string' ),

				thumbIndex : Lyte.attr( 'number' ),

				prevIconClass : Lyte.attr( 'string' ),

				nextIconClass : Lyte.attr( 'string' ),

				renderView : Lyte.attr( 'boolean', { default : false } ),

				currentComment : Lyte.attr( 'object', { default : {} } ),

				showViewArray : Lyte.attr( 'boolean', { default : false } ),

				previewDate : Lyte.attr( 'object', { default : {} } ),

				editAlertRender : Lyte.attr( 'boolean' ),

				alertShow : Lyte.attr( 'boolean' ),

				hovercardShow : Lyte.attr( 'boolean', { default : false }),

				hoverEmoji : Lyte.attr( 'object', { default : {} } ),

				isDelete : Lyte.attr( 'boolean' ),
				isPin : Lyte.attr( 'boolean' ),
				isEdit : Lyte.attr( 'boolean' ),
				isReact : Lyte.attr( 'boolean' ),
				isPinned : Lyte.attr( 'boolean' ),

				pinShow : Lyte.attr( 'boolean' ),
				pin : Lyte.attr( 'object' ),

				sanitizer : Lyte.attr( 'object', {
					default : {
						attr : Lyte.Security.createSanitizer( { ADD_URI_SAFE_ATTR : [ "style" ], ALLOWED_STYLE : "ALL", STYLE_VALIDATION : false })
					}
				}),

				id : Lyte.attr( 'string' )
		}
	},

	clear_cbox : function(){
		delete this.__comment;
		delete this.__index;
		this.setData( 'thumbnails', [] );
	},

	clear_alert : function(){
		delete this.__promeditor;
		delete this.__promcomment;
		delete this.__executeArg;
	},

	didDestroy : function(){
		this.clear_cbox();
		this.clear_alert();

		clearTimeout( this.__pintime );
	},

	comments_obs : function( arg ){
		if( arg.insertedItems ){
			var index = arg.index,
			wrapper = $L( this.$node ).children( '.lyteNoteCommentWrapper' ),
			comment = wrapper.children().get( this.data.ltPropPinnedComments.length + index ),
			_top = this.get_scrolltop( wrapper.get( 0 ), comment );

			wrapper.scrollTo( { top : _top }, {
				duration : this.data.ltPropScrollDuration,
				onAfter : function(){
					$L( comment ).addClass( "lyteNoteNewComment" );
				}.bind( this )	
			} );

		}
	}.observes( 'ltPropComments.[]' ),

	didConnect : function(){
		this.$node.removeAllFiles = this.removeAllFiles.bind( this );

		this.$node.handleMenuAction = function(type, event, menu, element ){
			return this.optionsMenuSelect( type, event, menu, element );
		}.bind(this);

		this.$node.getBackground = function( editor ){
			var note_comp = $L( editor ).closest( 'lyte-note-editor' ).get( 0 ),
			obj = {};

			[ 'background', 'border' ].forEach( function( item ){
				obj[ item ] = note_comp.ltProp( item );
			});

			return obj;
		};

		this.$node.setBackground = function( editor, obj ){
			$L( editor ).closest( 'lyte-note-editor' ).get( 0 ).ltProp( obj );
		};

		this.$node.viewReactions = this.viewReactions.bind( this );
	},

	viewReactions : function( comment_obj ){
		this.setData( 'renderView', true );
		this.setData( 'currentComment', comment_obj );
		this.setData( 'showViewArray', true );
	},	

	get_element : function( selector ){
		if( !selector || selector.constructor == String ){
			return $L( selector ? ( '#' + selector ) : ( ".lyteNoteMainComment" ), this.$node );
		}
		return $L( selector ).closest( '.lyteNoteEditorWrapper' );
	},

	removeAllFiles : function( editor ){

		if( this.data.ltPropEditorProps.attachment ){
			var file = this.get_element( editor ).find( 'lyte-fileupload' ).get( 0 ),
			queueList = file.component.data.queueList,

			files = queueList.map( function( item ){
				return item.id;
			});

			files.forEach( function( item ){
				file.removeUpload( item );
			});
		}
	},

	setup_file_data : function( comment, index ){
		var attachments = comment.ltProp( 'attachments' ),
		 current = attachments[ index ],
		 time = comment.ltProp( 'createdTime' ),
		 ctype = current.ctype,
		 arrow_class = 'lyteColorboxHideVisibility';

		 if( time ){
		 	 this.setData( 'previewDate', this.timeConversion( time, 'colorbox' ) );
		 }

		 this.setData( 'fileSize', _lyteUiUtils.lyteUiFileSize( current.size, '', 1 ) );

		 this.setData( 'isImage', ctype == 'photo' );

		 this.setData( 'previewType', $L( ctype.split( '/' ) ).get( -1 ) );
		 this.setData( 'isNoPreview', /^custom/i.test( ctype ) );

		 this.setData( 'thumbnailValue', this.get_thumb_index( index, attachments ) );

		 this.setData( 'thumbIndex', index );

		 this.setData( 'prevIconClass', index == 0 ? arrow_class : '' );
		 this.setData( 'nextIconClass', ++index == attachments.length ? arrow_class : '' );
	},

	get_thumb_index : function( index, attachments ){
		return this.data.ltPropText.thumbnailIndex.replace( "{{index}}", ++index ).replace( "{{total}}", attachments.length );
	},

	timeConversion : function(){
		var name = 'onTimeConversion';
		if( this.getMethods( name ) ){
			var arg = Array.from( arguments );
			arg.unshift( name );
			return this.executeMethod.apply( this, arg );
		}
	},

	construct_react : function( obj, id, count ){
		var arr = [],
		_reacted = obj.reacted,
		_index,
		i = 0;

		if( obj.selected ){
			_reacted.every( function( item, index ){
				if( item.id == id ){
					arr.push( 'you' /*item.name*/ );
					_index = index;
					return false;
				}
				return true;
			});
			count--;
		}

		while( true ){
			if( i == _index && ++i ){
				continue;
			}

			if( _reacted[ i ] == void 0 ){
				break;
			}

			arr.push( _reacted[ i++ ].name );

			if( arr.length == count ){
				arr.push( '+' + ( _reacted.length - count ) + 'more...' );
				break;
			}
		}
		return arr;
	},

	methods : {

		pinHide : function(){
			$L( '.lyteNotePinOrigin', this.$node ).removeClass( 'lyteNotePinOrigin' );
			this.setData( 'pin', {} );
		},

		unpinSelect : function(){
			var cb = 'onCommentUnpin',
			args = arguments;

			if( this.getMethods( cb ) ){
				var elem = args[ 3 ],
				comment = this.$node.querySelector( 'lyte-comment#' + elem.parentNode.id );
				return this.executeMethod( cb, args[ 1 ], elem, comment, this.get_comment_index( comment ) );
			}
		},

		optionsMenuSelect : function( type, evt, menu, element ){
			var cb,
			data = this.data;

			switch( type ){
				case 'view' : {
					if( data.isReact ){
						cb = 'onViewReaction';
					}
				}
				break;
				case 'delete' : {
					if( data.isDelete ){
						cb = "onCommentDelete";
					}
				}
				break;
				case 'pin' : {
					if( data.isPin ){
						if( data.isPinned ){
							cb = "onCommentUnpin";
						} else{
							cb = "onCommentPin";
						}
					}
				}
				break;
				case 'edit' : {
					var args = [ 'onCommentEdit', evt, element,  element.closest( 'lyte-comment' ) ];
					
					if( this.close_all_comments() || this.make_main_draft() ){
						this.__executeArg = args;
						return;
					}
					return this.execute( Array.from( args ) );
				}
				break;
			}

			if( cb && this.getMethods( cb ) ){
				var comment = element.closest( 'lyte-comment' );
				return this.executeMethod( cb, evt, element, comment, this.get_comment_index( comment ) );
			}
		},

		beforeCloseOptionsMenu : function( menu ){
			$L( menu.element ).closest( 'lyte-comment' ).removeClass( 'lyteNoteOptionsMenuOpened' );
		},

		beforeOpenOptionsMenu : function(){
			var comment = arguments[ 2 ].closest( 'lyte-comment' ),
			data = comment.component.data;

			$L( comment ).addClass( 'lyteNoteOptionsMenuOpened' );

			this.setData({
				isDelete : 	data.ltPropDelete,
				isPin : data.ltPropPin,
				isEdit : data.ltPropEdit,
				isReact : data.isReacted,
				isPinned : this.data.ltPropPinnedComments.findIndex( function( item ){
					return item.id == comment.id;
				}) != -1
			});
		},

		hoverHide : function(){
			$L( '.lyteNoteHoverOrigin', this.$node ).removeClass( 'lyteNoteHoverOrigin' );
			this.setData( 'hoverEmoji', {} );
		},

		hovercard_show : function( evt, element, comment, comment_data ){
			var $element = $L( element ), 
			index = Number( $element.parent().attr( 'data-index' ) ),
			data = comment_data.sectionArray[ comment_data.sectionIndex ],
			current_emoji = data.emoji[ index ],
			count = this.data.ltPropMaxTooltipNames,
			id = this.data.ltPropUserId;

			$element.addClass( 'lyteNoteHoverOrigin' );

			this.setData( 'hoverEmoji', {
				name : current_emoji.name,
				reacted : this.construct_react( current_emoji, id, count )
			});

			this.setData( 'hovercardShow', true );
		},

		close_comment : function(){
			return this.close_all_comments();
		},

		cboxClose : function(){
			$L( '.lyteCommentAttachments', this.__comment )[0].children[ this.__index ].focus();
			this.clear_cbox();
		},	

		cboxBeforeOpen : function(){
			this.setup_file_data( this.__comment, this.__index );
		},

		cboxNavigate : function(){
			this.setup_file_data( this.__comment, arguments[ 2 ] - 1 );
		},

		timeConversion : function(){
			return this.timeConversion.apply( this, arguments );
		},

		emojiselect : function( obj ){
			var origin = $L( '.lyte_note_origin_elem', this.$node );

			if( origin.hasClass( 'lyteNoteSmileyIcon' ) ){
				var editor = origin.closest( '.lyteNoteEditorWrapper' ).find( 'lyte-texteditor' ).get( 0 );
				
				editor.insertHTML( obj.encode );
				editor.focus();

			} else {
				var callback = 'onEmojiSelect';
				if( this.getMethods( callback ) ){
					this.executeMethod( callback, obj, this.get_comment_index( $L( '.lyte_note_origin_elem' ).closest( 'lyte-comment' ).get( 0 ) ) );
				}
			}
			this.setData( 'popoverShow', false );
		},

		onTrigger : function( value, position, editor ){
			if( this.getMethods( 'onTrigger' ) ){
				return this.executeMethod( 'onTrigger', value, position, editor );
			}
		},

		colorPickerSelect : function(){
			$L( '.lyte_note_bgswitch_elem', this.$node ).closest( 'lyte-note-editor' ).get( 0 ).ltProp( 'background', arguments[ 1 ].hex );
			this.setData( 'bgSwitch', false );
		},

		onBeforeCommentDownload : function(){
			if( this.getMethods( 'onBeforeDownload' ) ){
				return this.executeMethod( 'onBeforeDownload' , arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]  );
			}
		}
	},

	emoji_obs : function(){
		if( !this.data.popoverShow ){
			$L( $L( 'lyte-popover.lyteNoteEmojiPopover', this.$node ).get( 0 ).component.actualModalDiv ).find( 'lyte-emoji' ).get( 0 ).resetValue();
		}
	}.observes( 'popoverShow' ),

	get_comment_index : function( comment, prev ){

		var index = this.get_comment_index_fork( comment, prev ),
		format = this.get_correct_data( index, this.data.ltPropComments ); 

		index.sectionArray = format.array;
		index.sectionIndex = format.index;

		return index;
	},

	get_comment_index_fork : function( comment, prev ){
		var jobj = $L( comment ),
		obj = {
			node : comment,
			index : parseInt( jobj.attr( 'data-index' ) )
		},
		parent_comment = jobj.parent().closest( 'lyte-comment' ).get( 0 );

		if( prev ){
			obj.child = prev;
		}

		if( parent_comment ){
			return this.get_comment_index_fork( parent_comment, obj );
		}
		return obj;
	},

	find_index : function( array, key, value ){
		var index = -1;

		array.every( function( item, _index ){

			if( item[ key ] == value ){
				index = _index;
			}

			return index == -1;
		});

		return index;
	},

	preview_click : function(){ 

		if( arguments[ 1 ].type == 'keydown' && arguments[ 1 ].target.tagName === 'A' ){
			return;
		}

		var arg = arguments,
		evt = arg[ 1 ],
		comment = arg[ 3 ],
		image = $L( arg[ 2 ] ),
		index = Number( image.attr( "data-index" ) ),
		attachments = comment.ltProp( "attachments" ),
		colorbox = $L( this.$node ).children().get( -1 );

		this.__comment = comment;
		this.__index = index;

		this.setData( 'thumbnails', attachments );

		colorbox.ltProp( "selectors", [ "." + comment.id +"_preview" ] );

		if( evt.type == 'keydown' ){
			colorbox.ltProp( 'show', true );
		}
		
		return false;
	},

	get_files : function( editor ){
		if( this.data.ltPropEditorProps.attachment ){
			var file = $L( editor ).closest( '.lyteNoteEditorWrapper' ).find( 'lyte-fileupload' ).get( 0 ),
			queueList = file.component.data.queueList,
			fn = function( name ){
				return queueList.filter( function( item ){
					return item.status == name;
				});
			};

			return[ fn( "success" ), fn( "uploading" ), fn( "failure" ) ]; 
		}
		return [ [], [], [] ];
	},

	/*
		Recursive function for finding exact data for comment / reply

		data format will be 

		{
			node : comment / reply element,
			index : comment / reply index,
			child : {
				// same set. inner most child is the comment to be altered
			}
		}
	*/

	get_correct_data : function( data, array ){
		if( data.child ){
			return this.get_correct_data( data.child, array[ data.index ].reply );
		} 
		return {
			array : array,
			index : data.index
		};
	},

	make_main_draft : function(){
		if( this.data.ltPropEditMode ){
			var editor_comp = $L( 'lyte-note-editor', this.$node ).eq( 0 ),
			text_editor = editor_comp.find( 'lyte-texteditor' ).get( 0 ),
			files = this.get_files( text_editor ),
			isEmpty = text_editor.getData( 'showPlaceholder' ),
			is_zero = function( arr ){
				return arr.length == 0;
			},
			_this = this,
			draft_need = !( isEmpty && is_zero( files[ 0 ] ) && is_zero( files[ 1 ] ) && is_zero( files[ 2 ] ) ),
			fn = function(){
				_this.$node.ltProp( 'editMode', false ); 
			};

			if( draft_need ){
				// if( _this.data.ltPropEditAlert ){
				// 	this.render_edit_alert( text_editor );
				// 	return true;
				// } else {
					editor_comp.get( 0 ).setData( 'draftMode', true );
					fn();
				// }
			} else {
				fn();
			}
		}
	},

	render_edit_alert : function( editor ){
		this.setData( 'editAlertRender', true );
		this.setData( 'alertShow', true );
		this.__promeditor = editor;
	},

	close_all_comments : function( arg ){
		var _this = this,
		ret;

		( arg || _this.data.ltPropComments ).every( function( item ){
			if( item.editmode ){
				var comment = $L( '#' + item.id, _this.$node ),
				editor = comment.find( 'lyte-texteditor' ).get( 0 );

				if( _this.data.ltPropEditAlert ){ 
					_this.__promcomment = comment;
					_this.render_edit_alert( editor );
					ret = true;
				} else {
					_this.call_cancel( editor, comment );
				}
			}

			if( _this.close_all_comments( item.reply || [] ) ){
				ret = true;
			}
			return !ret;
		}); 

		return ret;
	},

	call_cancel : function( editor, comment, name ){
		return this.execute( [ name || 'onCommentCancel', editor, this.get_comment_index( comment ) ].concat( this.get_files( editor ) ) );
	},

	get_scrolltop : function( wrapper, comment ){
		var sH = wrapper.scrollHeight,
		oH = wrapper.offsetHeight,
		oT = comment.offsetTop,
		elems = Array.from( wrapper.querySelectorAll( '.lyteNotePinnedComment' ) ),
		off = 0,
		max_scroll = sH - oH;

		elems.forEach( function( item ){
			off += item.offsetHeight;
		});

		return Math.min( oT - off - 10, max_scroll );
	},

	actions : {

		pinEnter : function( _this, evt ){
			var fn = function(){
				
				var index = Number( $L( _this ).addClass( 'lyteNotePinOrigin' ).attr( 'data-index' ).replace( 'pin_', '' ) ),
				obj = this.data.ltPropPinnedComments[ index ].pinnedBy,
				time = ( this.timeConversion( obj.pinnedTime, 'pin' ) || { display : "" } ).display,
				cb = "onTimeConversion";

				this.setData( 'pin',{
					message : this.data.ltPropText.pinnedBy.replace( "{{0}}", obj.name ),
					time : time
				});
				this.setData( 'pinShow', true );
			}.bind( this );
			
			if( this.data.pinShow ){
				this.__pintime = setTimeout( fn, 500 );
			} else {
				fn();
			}
		},

		pinned : function( evt, fake_comment, data ){
			var comment = $L( 'lyte-comment#' + data.id, this.$node ).get( 0 );

			if( $L( evt.target ).hasClass( 'lyteNoteUnpinIcon' ) ){
				return;
			}

			$L.fastdom.measure( function(){
				var wrapper = $L( this.$node ).children( '.lyteNoteCommentWrapper' ),
				cls_name = "lyteNotePinnedCommentClick",
				fn = function( _evt ){
					$L( _lyteUiUtils.getCurrentTarget( _evt ) ).removeClass( cls_name ).off( {
						animationend : fn,
						transitionend : fn	
					});
				};
				wrapper.scrollTo( { top : this.get_scrolltop( wrapper.get( 0 ), comment ) }, {
					duration : this.data.ltPropScrollDuration,
					onAfter : function(){
						$L( comment ).addClass( cls_name ).on( {
							animationend : fn,
							transitionend : fn	
						});
					}.bind( this )	
				});
			}.bind( this ));
		},

		keepedit : function(){
			this.setData( 'alertShow', false );
			this.__promeditor.focus();
			this.clear_alert();
		},

		continue : function(){
			this.setData( 'alertShow', false );
			
			var exe_arg = this.__executeArg,
			comment = this.__promcomment,
			editor = this.__promeditor;

			if( comment ){
				this.call_cancel( editor, comment );
			}

			if( exe_arg ){
				if( !comment ){
					this.execute( [ 'onMainCommentCancel', editor, this.$node ].concat( this.get_files( editor ) ) )
				}
				this.execute( Array.from( exe_arg ) );
			} else {
				this.$node.ltProp( 'editMode', true );
			}
			this.clear_alert();
		},

		enter : function( _this ){
			var $this = $L( _this );

			$this.attr( 'lt-prop-title', _this.scrollWidth > _this.offsetWidth ? $this.text() : '' );
		},

		thumbClick : function( index ){
			$L( this.$node ).children().get( -1 ).open( index + 1 );
			this.setup_file_data( this.__comment, index );
		},

		save : function( editor ){
			return this.execute( [ 'onMainCommentSave', editor, this.$node ].concat( this.get_files( editor ) ) );
		},

		cancel : function( editor ){
			return this.execute( [ 'onMainCommentCancel', editor, this.$node ].concat( this.get_files( editor ) ) )
		},

		other : function( editor, evt ){
			return this.execute( [ 'onButtonClick', editor, evt, this.$node ].concat( this.get_files( editor ) ) )
		},

		common_action : function( name ){

			switch( name ){
				case 'onPreviewClick' : {
					return this.preview_click.apply( this, arguments );
				}
				break;
				// case 'onCommentEdit' : {
				// 	if( this.close_all_comments() || this.make_main_draft() ){
				// 		this.__executeArg = arguments;
				// 		return;
				// 	}
				// }
				default : {
					return this.execute( Array.from( arguments ) );
				}
			}
		},

		update_comment : function( editor, comment ){
			return this.call_cancel( editor, comment, 'onCommentSave' );
		},

		cancel_comment : function(){
			return this.call_cancel.apply( this, arguments );
		},

		show_emoji : function( elem ){
			this.show_emoji( elem );
		},

		bg_switch : function( editor ){
			var colors = this.data.ltPropColors,
			$editor = $L( editor ),
			elem = $editor.parent().children( '.lyteNoteBgSwitcher' );

			if( colors ){
				var note = $editor.closest( 'lyte-note-editor' ).get( 0 ),
				_color = note.ltProp( 'background' ),
				index = this.find_index( colors, 'background', _color ),
				final = colors[ ( index + 1 ) % colors.length ];

				[ 'background', 'border' ].forEach( function( item ){
					note.ltProp( item, final[ item ] );
				});

			} else {
				var __classname = 'lyte_note_bgswitch_elem';

				$L( '.' + __classname, this.$node ).removeClass( __classname );
				elem.addClass( __classname );

				this.setData( 'bgSwitch', true );
			}
			return false;
		},

		show_smiley : function( editor ){
			this.show_emoji( $L( editor.parentNode.parentNode ).find( '.lyteNoteSmileyIcon' ).get( 0 ) );
			return false;
		},

		file_before_send : function(){
			return this.execute_file_method( arguments, 3, 'onBeforeSend' );
		},

		file_success : function(){
			return this.execute_file_method( arguments, 2, 'onSuccess' );
		},

		file_failure : function(){
			return this.execute_file_method( arguments, 2, 'onFailure' );
		},

		file_remove : function(){
			return this.execute_file_method( arguments, 2, 'onRemove' );
		},

		file_before_remove : function(){
			return this.execute_file_method( arguments, 2, 'onBeforeRemove' );
		},

		on_editor_paste : function(){
			return this.execute_file_method( arguments, 2, 'onEditorPaste' );
		},

		onAfterInput : function( name ){
			return this.execute_file_method( arguments, 3, name, true );
		},

		onWordChange : function( name ){
			return this.execute_file_method( arguments, 4, name, true );
		},

		onCursorChange : function( name ){
			return this.execute_file_method( arguments, 4, name, true );
		},

		hideHoverCard : function( evt ){
			this.setData( 'hovercardShow', false );
			$L( '.lyteNoteHoverOrigin', this.$node ).removeClass( 'lyteNoteHoverOrigin' );
			this.setData( 'hoverEmoji', {} );
		}
	},

	execute_file_method : function( args, index, name, __ignore ){

		var base64toFile = function( base64String, mimeType, fileName ){
			const base64Data = base64String.replace(/^data:.+;base64,/, '');
            const byteCharacters = atob(base64Data); // Decode Base64 string
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }

            const byteArray = new Uint8Array(byteNumbers);
            const blob = new Blob([byteArray], { type: mimeType });
			return new File([blob], fileName, { type: mimeType });
		}

		if( name == 'onEditorPaste' && this.data.ltPropHandlePastedImage ){
			let elem = args[ 0 ];

			if(elem.children.length === 1 && elem.children[ 0 ].tagName === 'IMG'){
				let image = elem.querySelector( 'img' );

				if( image.src.startsWith('data:image/') ){
					let file = base64toFile( image.src, 'image/jpeg', this.data.pastedFileName );
					$L(this.$node).find( 'lyte-fileupload' ).get( 0 ).addFiles( file );
					image.remove();
				}
			} 
		}
		var args = Array.from( args ),
		comment = $L( args[ index ] ).closest( 'lyte-comment', this.$node ).get( 0 );

		if( comment ){
			args.push( this.get_comment_index( comment ) );
		}

		!__ignore && args.unshift( name );

		if( this.getMethods( name ) ){
			this.executeMethod.apply( this, args );
		}
		return false;
	},

	show_emoji : function( elem ){
		if( this.data.popoverShow ){
			return;
		}

		var __classname = 'lyte_note_origin_elem';

		$L( '.' + __classname ).removeClass( __classname );
		$L( elem ).addClass( __classname );
		this.setData( 'popoverShow', true );
	},

	execute : function( __arg ){
		var name = __arg.shift();

		if( /commentsave/i.test( name ) ){
			if( this.should_prevent.apply( this, __arg ) ){
				return;
			}
		}

		return this.execute_file_method( __arg, 2, name );
	},

	should_prevent : function( editor, notecomp, success, uploading ){
		var html = editor.getHTML(),
		message;

		if( !html.replace( '<br>', '' ) ){
			message = 'Empty';
		}

		if( uploading.length ){
			message = 'Upload';
		}

		if( message ){
			var value = this.data[ 'ltProp' + message + 'InfoMessage' ];

			if( value ){
				this.setData( 'message', value );
				this.setData( 'messageShow', true );
				return 1;
			}
		}
	},

	detect_keywords : function( elem ){
		var keywords = this.data.ltPropKeywords || {},
		formats = this.data.ltPropDateFormats || [],
		format_len = formats.length;

		if( !format_len || !Object.keys( keywords ).length ){
			return;
		}

		var children = Array.from( elem.children ),
		cache = this.__word_cache || {},
		chars_to_check = /^[\.\,]/,
		chars_to_check_at_end = /[\.\,]$/,
		__replace_words = function( node ){
			var text = node.nodeValue,
			words = text.split( " " ),
			__len = words.length,
			is_modified;

			for( var i = 0; i < __len; i++ ){
				var __cur = words[ i ],
				exst_cache = cache[ __cur ];

				if( exst_cache ){
					words[ i ] = exst_cache;
					is_modified = true;
					continue;
				} else if( exst_cache == false ){
					continue;
				}

				if( __cur ){
					var to_replace = void 0,
					lower = __cur.toLowerCase();

					for( var key in keywords ){

						var key_lower = key.toLowerCase(),
						__index = lower.indexOf( key_lower );

						if( __index == 0 ){ 
							var matched_len = key_lower.length,
							rem_str = __cur.slice( matched_len );

							if( chars_to_check.test( rem_str ) || !rem_str ){
								is_modified = true;
								to_replace = {
									attr : {
										class : `${ keywords[ key ] } lyteNoteKeyWord`
									},
									text : __cur.slice( 0, matched_len ),
									remaining : rem_str
								};
								break;
							}
						}
					}

					if( !to_replace ){
						var perfect_word = __cur.replace( chars_to_check_at_end, "" );

						if( perfect_word ){
							for( var j = 0; j < format_len; j++ ){
								var cur_format = formats[ j ],
								__moment = $L.moment( perfect_word, cur_format, { i18n : true } );

								if( __moment.validate() ){
									is_modified = true;

									var matched_len = perfect_word.length,
									rem_str = __cur.slice( matched_len );

									to_replace = {
										attr : {
											"data-format" : cur_format,
											"data-timestamp" : __moment.getDObj().getTime(),
											"class" : "lyteNoteDateWord lyteNoteKeyWord"
										},
										text : perfect_word,
										remaining : rem_str
									};
								}
							}
						}
					}

					if( to_replace ){
						cache[ __cur ] = words[ i ] = to_replace;
					} else {
						cache[ __cur ] = false;
					}
				}
			}

			if( is_modified ){
				var parentNode = node.parentNode,
				__ref = node;

				for( var i = 0; i < __len; i++ ){
					let __cur = words[ i ],
					new_node,
					prev_node,
					extra_text = ( i + 1 ) != __len ? " " : ""; 
					
					if( typeof __cur == "object" ){
						prev_node = document.createElement( "span" );
						$L( prev_node ).attr( __cur.attr );
						prev_node.innerText = __cur.text;
						new_node = new Text( __cur.remaining + extra_text );
					} else {
						new_node = new Text( __cur + extra_text );
					}
					prev_node && __ref.after( __ref = prev_node );
					__ref.after( __ref = new_node );
				}
				node.remove();
				parentNode.normalize();
			}
		},
		__fn = function( nodes ){
			var len = nodes.length;

			for( var i = 0; i < len; i++ ){
				var __cur = nodes[ i ];

				if( __cur.nodeName == "#text" ){
					__replace_words( __cur );
				} else {
					__fn( Array.from( __cur.childNodes ) );
				}
			}
		};

		__fn( children )
	}
});


/**
 * @syntax nonYield
 * <lyte-notecomp lt-prop-comments = []></lyte-notecomp>
 */


 /**
  * @syntax Pinned comment yield
  * @attribute ltPropPinnedComments
  * <lyte-notecomp lt-prop-comments = []>
  *   <template is = "registerYield" yield-name = "lyte-pinned-note">
  *       <div class="notePinMessage"></div>
  *   </template>
  * </lyte-notecomp>
  */ 

 /**
  * @syntax Checkin yield
  * @attribute ltPropCheckIn=true
  * <lyte-notecomp lt-prop-comments = []>
  *   <template is = "registerYield" yield-name = "lyte-note-checkin">
  *        your content
  *   </template>
  * </lyte-notecomp>
  */ 

 /**
  * @syntax Reply header yield
  * @attribute ltPropReplyYield=true
  * <lyte-notecomp lt-prop-comments = []>
  *   <template is = "registerYield" yield-name = "lyte-reply-header">
  *        your content
  *   </template>
  * </lyte-notecomp>
  */

 /**
  * @syntax Reply footer yield
  * @attribute ltPropReplyYield=true
  * <lyte-notecomp lt-prop-comments = []>
  *   <template is = "registerYield" yield-name = "lyte-reply-footer">
  *        your content
  *   </template>
  * </lyte-notecomp>
  */ 

 /**
  * @syntax Comment title yield
  * @attribute ltPropTitleYield
  * <lyte-notecomp lt-prop-comments = []>
  *   <template is = "registerYield" yield-name = "lyte-comment-title">
  *        your content
  *   </template>
  * </lyte-notecomp>
  */ 